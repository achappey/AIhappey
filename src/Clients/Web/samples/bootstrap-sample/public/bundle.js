"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all2) => {
    for (var name21 in all2)
      __defProp(target, name21, { get: all2[name21], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // <define:__DEFAULT_MCP_SERVER_LIST_URLS__>
  var define_DEFAULT_MCP_SERVER_LIST_URLS_default;
  var init_define_DEFAULT_MCP_SERVER_LIST_URLS = __esm({
    "<define:__DEFAULT_MCP_SERVER_LIST_URLS__>"() {
      define_DEFAULT_MCP_SERVER_LIST_URLS_default = ["http://localhost:3001/mcp.json"];
    }
  });

  // <define:__MSAL_SCOPES__>
  var define_MSAL_SCOPES_default;
  var init_define_MSAL_SCOPES = __esm({
    "<define:__MSAL_SCOPES__>"() {
      define_MSAL_SCOPES_default = ["api://fakton.chat/AI.use"];
    }
  });

  // ../../node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../../node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var l = Symbol.for("react.element");
      var n = Symbol.for("react.portal");
      var p = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r = Symbol.for("react.profiler");
      var t = Symbol.for("react.provider");
      var u = Symbol.for("react.context");
      var v = Symbol.for("react.forward_ref");
      var w = Symbol.for("react.suspense");
      var x = Symbol.for("react.memo");
      var y = Symbol.for("react.lazy");
      var z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C = Object.assign;
      var D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null };
      var V = { transition: null };
      var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      exports.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      exports.Component = E;
      exports.Fragment = p;
      exports.Profiler = r;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      exports.act = X;
      exports.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      exports.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = M;
      exports.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      exports.isValidElement = O;
      exports.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      exports.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      exports.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      exports.unstable_act = X;
      exports.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      exports.useContext = function(a) {
        return U.current.useContext(a);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      exports.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      exports.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      exports.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      exports.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      exports.useRef = function(a) {
        return U.current.useRef(a);
      };
      exports.useState = function(a) {
        return U.current.useState(a);
      };
      exports.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.3.1";
    }
  });

  // ../../node_modules/react/index.js
  var require_react = __commonJS({
    "../../node_modules/react/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../../node_modules/react-dom/node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // ../../node_modules/react-dom/node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../../node_modules/react-dom/node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var aa = require_react();
      var ca = require_scheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign;
      var La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb;
      var nb = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      var Mb;
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re2(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re2, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {};
      var H = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true);
      var Vg = Og(false);
      var Wg = Uf(null);
      var Xg = null;
      var Yg = null;
      var Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {};
      var uh = Uf(th);
      var vh = Uf(th);
      var wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher;
      var Gh = ua.ReactCurrentBatchConfig;
      var Hh = 0;
      var M = null;
      var N = null;
      var O = null;
      var Ih = false;
      var Jh = false;
      var Kh = 0;
      var Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false };
      var Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false };
      var Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      };
      var Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner;
      var dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj;
      var Aj;
      var Bj;
      var Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false;
      var U = false;
      var Kj = "function" === typeof WeakSet ? WeakSet : Set;
      var V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null;
      var Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a, b, c);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f, b, c), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a, b, c);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a, b, c);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil;
      var mk = ua.ReactCurrentDispatcher;
      var nk = ua.ReactCurrentOwner;
      var ok3 = ua.ReactCurrentBatchConfig;
      var K = 0;
      var Q = null;
      var Y = null;
      var Z = 0;
      var fj = 0;
      var ej = Uf(0);
      var T = 0;
      var pk = null;
      var rh = 0;
      var qk = 0;
      var rk = 0;
      var sk = null;
      var tk = null;
      var fk = 0;
      var Gj = Infinity;
      var uk = null;
      var Oi = false;
      var Pi = null;
      var Ri = null;
      var vk = false;
      var wk = null;
      var xk = 0;
      var yk = 0;
      var zk = null;
      var Ak = -1;
      var Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok3.transition, d = C;
        try {
          if (ok3.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok3.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok3.transition;
        try {
          ok3.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok3.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok3.transition;
          ok3.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c, a, e);
          dc();
          K = h;
          C = g;
          ok3.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode, d);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok3.transition, c = C;
          try {
            ok3.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok3.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] };
      var tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      var vl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      exports.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      exports.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      exports.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a) {
        return Rk(a);
      };
      exports.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      exports.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      exports.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Qk;
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      exports.version = "18.3.1-next-f1338f8080-20240426";
    }
  });

  // ../../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/react-dom/client.js
  var require_client = __commonJS({
    "../../node_modules/react-dom/client.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var m = require_react_dom();
      if (true) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // ../../node_modules/react-router/node_modules/cookie/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/react-router/node_modules/cookie/dist/index.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = parse4;
      exports.serialize = serialize5;
      var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
      var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
      var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
      var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
      var __toString = Object.prototype.toString;
      var NullObject = /* @__PURE__ */ (() => {
        const C = function() {
        };
        C.prototype = /* @__PURE__ */ Object.create(null);
        return C;
      })();
      function parse4(str, options) {
        const obj = new NullObject();
        const len = str.length;
        if (len < 2)
          return obj;
        const dec = options?.decode || decode2;
        let index2 = 0;
        do {
          const eqIdx = str.indexOf("=", index2);
          if (eqIdx === -1)
            break;
          const colonIdx = str.indexOf(";", index2);
          const endIdx = colonIdx === -1 ? len : colonIdx;
          if (eqIdx > endIdx) {
            index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          const keyStartIdx = startIndex(str, index2, eqIdx);
          const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
          const key = str.slice(keyStartIdx, keyEndIdx);
          if (obj[key] === void 0) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
          }
          index2 = endIdx + 1;
        } while (index2 < len);
        return obj;
      }
      function startIndex(str, index2, max2) {
        do {
          const code4 = str.charCodeAt(index2);
          if (code4 !== 32 && code4 !== 9)
            return index2;
        } while (++index2 < max2);
        return max2;
      }
      function endIndex(str, index2, min2) {
        while (index2 > min2) {
          const code4 = str.charCodeAt(--index2);
          if (code4 !== 32 && code4 !== 9)
            return index2 + 1;
        }
        return min2;
      }
      function serialize5(name21, val, options) {
        const enc = options?.encode || encodeURIComponent;
        if (!cookieNameRegExp.test(name21)) {
          throw new TypeError(`argument name is invalid: ${name21}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`argument val is invalid: ${val}`);
        }
        let str = name21 + "=" + value;
        if (!options)
          return str;
        if (options.maxAge !== void 0) {
          if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
          }
          str += "; Max-Age=" + options.maxAge;
        }
        if (options.domain) {
          if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
          }
          str += "; Domain=" + options.domain;
        }
        if (options.path) {
          if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
          }
          str += "; Path=" + options.path;
        }
        if (options.expires) {
          if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
          }
          str += "; Expires=" + options.expires.toUTCString();
        }
        if (options.httpOnly) {
          str += "; HttpOnly";
        }
        if (options.secure) {
          str += "; Secure";
        }
        if (options.partitioned) {
          str += "; Partitioned";
        }
        if (options.priority) {
          const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError(`option priority is invalid: ${options.priority}`);
          }
        }
        if (options.sameSite) {
          const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
          switch (sameSite) {
            case true:
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
          }
        }
        return str;
      }
      function decode2(str) {
        if (str.indexOf("%") === -1)
          return str;
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }
      function isDate(val) {
        return __toString.call(val) === "[object Date]";
      }
    }
  });

  // ../../node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "../../node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var f = require_react();
      var k = Symbol.for("react.element");
      var l = Symbol.for("react.fragment");
      var m = Object.prototype.hasOwnProperty;
      var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      exports.Fragment = l;
      exports.jsx = q;
      exports.jsxs = q;
    }
  });

  // ../../node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "../../node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_react_jsx_runtime_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
  var require_use_sync_external_store_shim_production = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var React189 = require_react();
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is2;
      var useState41 = React189.useState;
      var useEffect42 = React189.useEffect;
      var useLayoutEffect7 = React189.useLayoutEffect;
      var useDebugValue2 = React189.useDebugValue;
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        var value = getSnapshot(), _useState = useState41({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect7(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect42(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React189.useSyncExternalStore ? React189.useSyncExternalStore : shim;
    }
  });

  // ../../node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_use_sync_external_store_shim_production();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js
  var require_with_selector_production = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var React189 = require_react();
      var shim = require_shim();
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is2;
      var useSyncExternalStore2 = shim.useSyncExternalStore;
      var useRef49 = React189.useRef;
      var useEffect42 = React189.useEffect;
      var useMemo32 = React189.useMemo;
      var useDebugValue2 = React189.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef49(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo32(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
        useEffect42(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
    }
  });

  // ../../node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_with_selector_production();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/uri-js/dist/es5/uri.all.js
  var require_uri_all = __commonJS({
    "../../node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
      })(exports, function(exports2) {
        "use strict";
        function merge2() {
          for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
            sets[_key] = arguments[_key];
          }
          if (sets.length > 1) {
            sets[0] = sets[0].slice(0, -1);
            var xl = sets.length - 1;
            for (var x = 1; x < xl; ++x) {
              sets[x] = sets[x].slice(1, -1);
            }
            sets[xl] = sets[xl].slice(1);
            return sets.join("");
          } else {
            return sets[0];
          }
        }
        function subexp(str) {
          return "(?:" + str + ")";
        }
        function typeOf2(o) {
          return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
          return str.toUpperCase();
        }
        function toArray(obj) {
          return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
        }
        function assign2(target, source) {
          var obj = target;
          if (source) {
            for (var key in source) {
              obj[key] = source[key];
            }
          }
          return obj;
        }
        function buildExps(isIRI2) {
          var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
          return {
            NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
            NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
            NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
            ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
            UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
            OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
            PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
            IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
            IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            //RFC 6874, with relaxed parsing rules
          };
        }
        var URI_PROTOCOL = buildExps(false);
        var IRI_PROTOCOL = buildExps(true);
        var slicedToArray = /* @__PURE__ */ function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var toConsumableArray = function(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
          } else {
            return Array.from(arr);
          }
        };
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter2 = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor2 = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error$1(type) {
          throw new RangeError(errors[type]);
        }
        function map3(array, fn) {
          var result = [];
          var length2 = array.length;
          while (length2--) {
            result[length2] = fn(array[length2]);
          }
          return result;
        }
        function mapDomain(string3, fn) {
          var parts = string3.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string3 = parts[1];
          }
          string3 = string3.replace(regexSeparators, ".");
          var labels = string3.split(".");
          var encoded = map3(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string3) {
          var output = [];
          var counter = 0;
          var length2 = string3.length;
          while (counter < length2) {
            var value = string3.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length2) {
              var extra = string3.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        var ucs2encode = function ucs2encode2(array) {
          return String.fromCodePoint.apply(String, toConsumableArray(array));
        };
        var basicToDigit = function basicToDigit2(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        };
        var digitToBasic = function digitToBasic2(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function adapt2(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor2(delta / damp) : delta >> 1;
          delta += floor2(delta / numPoints);
          for (
            ;
            /* no initialization */
            delta > baseMinusTMin * tMax >> 1;
            k += base
          ) {
            delta = floor2(delta / baseMinusTMin);
          }
          return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode2 = function decode3(input) {
          var output = [];
          var inputLength = input.length;
          var i = 0;
          var n = initialN;
          var bias = initialBias;
          var basic = input.lastIndexOf(delimiter2);
          if (basic < 0) {
            basic = 0;
          }
          for (var j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error$1("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (var index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
            var oldi = i;
            for (
              var w = 1, k = base;
              ;
              /* no condition */
              k += base
            ) {
              if (index2 >= inputLength) {
                error$1("invalid-input");
              }
              var digit = basicToDigit(input.charCodeAt(index2++));
              if (digit >= base || digit > floor2((maxInt - i) / w)) {
                error$1("overflow");
              }
              i += digit * w;
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              var baseMinusT = base - t;
              if (w > floor2(maxInt / baseMinusT)) {
                error$1("overflow");
              }
              w *= baseMinusT;
            }
            var out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor2(i / out) > maxInt - n) {
              error$1("overflow");
            }
            n += floor2(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return String.fromCodePoint.apply(String, output);
        };
        var encode = function encode2(input) {
          var output = [];
          input = ucs2decode(input);
          var inputLength = input.length;
          var n = initialN;
          var delta = 0;
          var bias = initialBias;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _currentValue2 = _step.value;
              if (_currentValue2 < 128) {
                output.push(stringFromCharCode(_currentValue2));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var basicLength = output.length;
          var handledCPCount = basicLength;
          if (basicLength) {
            output.push(delimiter2);
          }
          while (handledCPCount < inputLength) {
            var m = maxInt;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var currentValue = _step2.value;
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            var handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
              error$1("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _currentValue = _step3.value;
                if (_currentValue < n && ++delta > maxInt) {
                  error$1("overflow");
                }
                if (_currentValue == n) {
                  var q = delta;
                  for (
                    var k = base;
                    ;
                    /* no condition */
                    k += base
                  ) {
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                      break;
                    }
                    var qMinusT = q - t;
                    var baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = floor2(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q, 0)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        };
        var toUnicode = function toUnicode2(input) {
          return mapDomain(input, function(string3) {
            return regexPunycode.test(string3) ? decode2(string3.slice(4).toLowerCase()) : string3;
          });
        };
        var toASCII = function toASCII2(input) {
          return mapDomain(input, function(string3) {
            return regexNonASCII.test(string3) ? "xn--" + encode(string3) : string3;
          });
        };
        var punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "2.1.0",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode2,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        var SCHEMES = {};
        function pctEncChar(chr) {
          var c = chr.charCodeAt(0);
          var e = void 0;
          if (c < 16) e = "%0" + c.toString(16).toUpperCase();
          else if (c < 128) e = "%" + c.toString(16).toUpperCase();
          else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
          return e;
        }
        function pctDecChars(str) {
          var newStr = "";
          var i = 0;
          var il = str.length;
          while (i < il) {
            var c = parseInt(str.substr(i + 1, 2), 16);
            if (c < 128) {
              newStr += String.fromCharCode(c);
              i += 3;
            } else if (c >= 194 && c < 224) {
              if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
              } else {
                newStr += str.substr(i, 6);
              }
              i += 6;
            } else if (c >= 224) {
              if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
              } else {
                newStr += str.substr(i, 9);
              }
              i += 9;
            } else {
              newStr += str.substr(i, 3);
              i += 3;
            }
          }
          return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
          function decodeUnreserved2(str) {
            var decStr = pctDecChars(str);
            return !decStr.match(protocol.UNRESERVED) ? str : decStr;
          }
          if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
          if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
          return components;
        }
        function _stripLeadingZeros(str) {
          return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
          var matches = host.match(protocol.IPV4ADDRESS) || [];
          var _matches = slicedToArray(matches, 2), address = _matches[1];
          if (address) {
            return address.split(".").map(_stripLeadingZeros).join(".");
          } else {
            return host;
          }
        }
        function _normalizeIPv6(host, protocol) {
          var matches = host.match(protocol.IPV6ADDRESS) || [];
          var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
          if (address) {
            var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
            var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
            var lastFields = last.split(":").map(_stripLeadingZeros);
            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
            var fieldCount = isLastFieldIPv4Address ? 7 : 8;
            var lastFieldsStart = lastFields.length - fieldCount;
            var fields = Array(fieldCount);
            for (var x = 0; x < fieldCount; ++x) {
              fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
            }
            if (isLastFieldIPv4Address) {
              fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
            }
            var allZeroFields = fields.reduce(function(acc, field, index2) {
              if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index2) {
                  lastLongest.length++;
                } else {
                  acc.push({ index: index2, length: 1 });
                }
              }
              return acc;
            }, []);
            var longestZeroFields = allZeroFields.sort(function(a, b) {
              return b.length - a.length;
            })[0];
            var newHost = void 0;
            if (longestZeroFields && longestZeroFields.length > 1) {
              var newFirst = fields.slice(0, longestZeroFields.index);
              var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
              newHost = newFirst.join(":") + "::" + newLast.join(":");
            } else {
              newHost = fields.join(":");
            }
            if (zone) {
              newHost += "%" + zone;
            }
            return newHost;
          } else {
            return host;
          }
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
        var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
        function parse4(uriString) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var components = {};
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
          var matches = uriString.match(URI_PARSE);
          if (matches) {
            if (NO_MATCH_IS_UNDEFINED) {
              components.scheme = matches[1];
              components.userinfo = matches[3];
              components.host = matches[4];
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = matches[7];
              components.fragment = matches[8];
              if (isNaN(components.port)) {
                components.port = matches[5];
              }
            } else {
              components.scheme = matches[1] || void 0;
              components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
              components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
              components.port = parseInt(matches[5], 10);
              components.path = matches[6] || "";
              components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
              components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
              if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
              }
            }
            if (components.host) {
              components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
            }
            if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
              components.reference = "same-document";
            } else if (components.scheme === void 0) {
              components.reference = "relative";
            } else if (components.fragment === void 0) {
              components.reference = "absolute";
            } else {
              components.reference = "uri";
            }
            if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
              components.error = components.error || "URI is not a " + options.reference + " reference.";
            }
            var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
              if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                try {
                  components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                  components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
              }
              _normalizeComponentEncoding(components, URI_PROTOCOL);
            } else {
              _normalizeComponentEncoding(components, protocol);
            }
            if (schemeHandler && schemeHandler.parse) {
              schemeHandler.parse(components, options);
            }
          } else {
            components.error = components.error || "URI can not be parsed.";
          }
          return components;
        }
        function _recomposeAuthority(components, options) {
          var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          if (components.userinfo !== void 0) {
            uriTokens.push(components.userinfo);
            uriTokens.push("@");
          }
          if (components.host !== void 0) {
            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
              return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }));
          }
          if (typeof components.port === "number" || typeof components.port === "string") {
            uriTokens.push(":");
            uriTokens.push(String(components.port));
          }
          return uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//;
        var RDS2 = /^\/\.(\/|$)/;
        var RDS3 = /^\/\.\.(\/|$)/;
        var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
          var output = [];
          while (input.length) {
            if (input.match(RDS1)) {
              input = input.replace(RDS1, "");
            } else if (input.match(RDS2)) {
              input = input.replace(RDS2, "/");
            } else if (input.match(RDS3)) {
              input = input.replace(RDS3, "/");
              output.pop();
            } else if (input === "." || input === "..") {
              input = "";
            } else {
              var im = input.match(RDS5);
              if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
              } else {
                throw new Error("Unexpected dot segment condition");
              }
            }
          }
          return output.join("");
        }
        function serialize5(components) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
          var uriTokens = [];
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
          if (components.host) {
            if (protocol.IPV6ADDRESS.test(components.host)) {
            } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
              try {
                components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
            }
          }
          _normalizeComponentEncoding(components, protocol);
          if (options.reference !== "suffix" && components.scheme) {
            uriTokens.push(components.scheme);
            uriTokens.push(":");
          }
          var authority = _recomposeAuthority(components, options);
          if (authority !== void 0) {
            if (options.reference !== "suffix") {
              uriTokens.push("//");
            }
            uriTokens.push(authority);
            if (components.path && components.path.charAt(0) !== "/") {
              uriTokens.push("/");
            }
          }
          if (components.path !== void 0) {
            var s = components.path;
            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
              s = removeDotSegments(s);
            }
            if (authority === void 0) {
              s = s.replace(/^\/\//, "/%2F");
            }
            uriTokens.push(s);
          }
          if (components.query !== void 0) {
            uriTokens.push("?");
            uriTokens.push(components.query);
          }
          if (components.fragment !== void 0) {
            uriTokens.push("#");
            uriTokens.push(components.fragment);
          }
          return uriTokens.join("");
        }
        function resolveComponents(base2, relative) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var skipNormalization = arguments[3];
          var target = {};
          if (!skipNormalization) {
            base2 = parse4(serialize5(base2, options), options);
            relative = parse4(serialize5(relative, options), options);
          }
          options = options || {};
          if (!options.tolerant && relative.scheme) {
            target.scheme = relative.scheme;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
              target.userinfo = relative.userinfo;
              target.host = relative.host;
              target.port = relative.port;
              target.path = removeDotSegments(relative.path || "");
              target.query = relative.query;
            } else {
              if (!relative.path) {
                target.path = base2.path;
                if (relative.query !== void 0) {
                  target.query = relative.query;
                } else {
                  target.query = base2.query;
                }
              } else {
                if (relative.path.charAt(0) === "/") {
                  target.path = removeDotSegments(relative.path);
                } else {
                  if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                    target.path = "/" + relative.path;
                  } else if (!base2.path) {
                    target.path = relative.path;
                  } else {
                    target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                  }
                  target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
              }
              target.userinfo = base2.userinfo;
              target.host = base2.host;
              target.port = base2.port;
            }
            target.scheme = base2.scheme;
          }
          target.fragment = relative.fragment;
          return target;
        }
        function resolve(baseURI, relativeURI, options) {
          var schemelessOptions = assign2({ scheme: "null" }, options);
          return serialize5(resolveComponents(parse4(baseURI, schemelessOptions), parse4(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
        }
        function normalize3(uri, options) {
          if (typeof uri === "string") {
            uri = serialize5(parse4(uri, options), options);
          } else if (typeOf2(uri) === "object") {
            uri = parse4(serialize5(uri, options), options);
          }
          return uri;
        }
        function equal(uriA, uriB, options) {
          if (typeof uriA === "string") {
            uriA = serialize5(parse4(uriA, options), options);
          } else if (typeOf2(uriA) === "object") {
            uriA = serialize5(uriA, options);
          }
          if (typeof uriB === "string") {
            uriB = serialize5(parse4(uriB, options), options);
          } else if (typeOf2(uriB) === "object") {
            uriB = serialize5(uriB, options);
          }
          return uriA === uriB;
        }
        function escapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
        }
        function unescapeComponent(str, options) {
          return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
          scheme: "http",
          domainHost: true,
          parse: function parse5(components, options) {
            if (!components.host) {
              components.error = components.error || "HTTP URIs must have a host.";
            }
            return components;
          },
          serialize: function serialize6(components, options) {
            var secure = String(components.scheme).toLowerCase() === "https";
            if (components.port === (secure ? 443 : 80) || components.port === "") {
              components.port = void 0;
            }
            if (!components.path) {
              components.path = "/";
            }
            return components;
          }
        };
        var handler$1 = {
          scheme: "https",
          domainHost: handler.domainHost,
          parse: handler.parse,
          serialize: handler.serialize
        };
        function isSecure(wsComponents) {
          return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
        }
        var handler$2 = {
          scheme: "ws",
          domainHost: true,
          parse: function parse5(components, options) {
            var wsComponents = components;
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
          },
          serialize: function serialize6(wsComponents, options) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
              wsComponents.port = void 0;
            }
            if (typeof wsComponents.secure === "boolean") {
              wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
              wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
              var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
              wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
              wsComponents.query = query;
              wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
          }
        };
        var handler$3 = {
          scheme: "wss",
          domainHost: handler$2.domainHost,
          parse: handler$2.parse,
          serialize: handler$2.serialize
        };
        var O = {};
        var isIRI = true;
        var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
        var HEXDIG$$ = "[0-9A-Fa-f]";
        var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
        var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
        var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
        var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
        var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
        var UNRESERVED = new RegExp(UNRESERVED$$, "g");
        var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
        var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
        var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
        var NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(UNRESERVED) ? str : decStr;
        }
        var handler$4 = {
          scheme: "mailto",
          parse: function parse$$1(components, options) {
            var mailtoComponents = components;
            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
            mailtoComponents.path = void 0;
            if (mailtoComponents.query) {
              var unknownHeaders = false;
              var headers = {};
              var hfields = mailtoComponents.query.split("&");
              for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                  case "to":
                    var toAddrs = hfield[1].split(",");
                    for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                      to.push(toAddrs[_x]);
                    }
                    break;
                  case "subject":
                    mailtoComponents.subject = unescapeComponent(hfield[1], options);
                    break;
                  case "body":
                    mailtoComponents.body = unescapeComponent(hfield[1], options);
                    break;
                  default:
                    unknownHeaders = true;
                    headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                    break;
                }
              }
              if (unknownHeaders) mailtoComponents.headers = headers;
            }
            mailtoComponents.query = void 0;
            for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
              var addr = to[_x2].split("@");
              addr[0] = unescapeComponent(addr[0]);
              if (!options.unicodeSupport) {
                try {
                  addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                  mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
              } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
              }
              to[_x2] = addr.join("@");
            }
            return mailtoComponents;
          },
          serialize: function serialize$$1(mailtoComponents, options) {
            var components = mailtoComponents;
            var to = toArray(mailtoComponents.to);
            if (to) {
              for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain2 = toAddr.slice(atIdx + 1);
                try {
                  domain2 = !options.iri ? punycode.toASCII(unescapeComponent(domain2, options).toLowerCase()) : punycode.toUnicode(domain2);
                } catch (e) {
                  components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain2;
              }
              components.path = to.join(",");
            }
            var headers = mailtoComponents.headers = mailtoComponents.headers || {};
            if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
            if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
            var fields = [];
            for (var name21 in headers) {
              if (headers[name21] !== O[name21]) {
                fields.push(name21.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name21].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
              }
            }
            if (fields.length) {
              components.query = fields.join("&");
            }
            return components;
          }
        };
        var URN_PARSE = /^([^\:]+)\:(.*)/;
        var handler$5 = {
          scheme: "urn",
          parse: function parse$$1(components, options) {
            var matches = components.path && components.path.match(URN_PARSE);
            var urnComponents = components;
            if (matches) {
              var scheme = options.scheme || urnComponents.scheme || "urn";
              var nid = matches[1].toLowerCase();
              var nss = matches[2];
              var urnScheme = scheme + ":" + (options.nid || nid);
              var schemeHandler = SCHEMES[urnScheme];
              urnComponents.nid = nid;
              urnComponents.nss = nss;
              urnComponents.path = void 0;
              if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
              }
            } else {
              urnComponents.error = urnComponents.error || "URN can not be parsed.";
            }
            return urnComponents;
          },
          serialize: function serialize$$1(urnComponents, options) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = urnComponents.nid;
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) {
              urnComponents = schemeHandler.serialize(urnComponents, options);
            }
            var uriComponents = urnComponents;
            var nss = urnComponents.nss;
            uriComponents.path = (nid || options.nid) + ":" + nss;
            return uriComponents;
          }
        };
        var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
        var handler$6 = {
          scheme: "urn:uuid",
          parse: function parse5(urnComponents, options) {
            var uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
              uuidComponents.error = uuidComponents.error || "UUID is not valid.";
            }
            return uuidComponents;
          },
          serialize: function serialize6(uuidComponents, options) {
            var urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
            return urnComponents;
          }
        };
        SCHEMES[handler.scheme] = handler;
        SCHEMES[handler$1.scheme] = handler$1;
        SCHEMES[handler$2.scheme] = handler$2;
        SCHEMES[handler$3.scheme] = handler$3;
        SCHEMES[handler$4.scheme] = handler$4;
        SCHEMES[handler$5.scheme] = handler$5;
        SCHEMES[handler$6.scheme] = handler$6;
        exports2.SCHEMES = SCHEMES;
        exports2.pctEncChar = pctEncChar;
        exports2.pctDecChars = pctDecChars;
        exports2.parse = parse4;
        exports2.removeDotSegments = removeDotSegments;
        exports2.serialize = serialize5;
        exports2.resolveComponents = resolveComponents;
        exports2.resolve = resolve;
        exports2.normalize = normalize3;
        exports2.equal = equal;
        exports2.escapeComponent = escapeComponent;
        exports2.unescapeComponent = unescapeComponent;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "../../node_modules/fast-deep-equal/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function equal(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length2, i, keys2;
          if (Array.isArray(a)) {
            length2 = a.length;
            if (length2 != b.length) return false;
            for (i = length2; i-- !== 0; )
              if (!equal(a[i], b[i])) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
          keys2 = Object.keys(a);
          length2 = keys2.length;
          if (length2 !== Object.keys(b).length) return false;
          for (i = length2; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
          for (i = length2; i-- !== 0; ) {
            var key = keys2[i];
            if (!equal(a[key], b[key])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/ucs2length.js
  var require_ucs2length = __commonJS({
    "../../node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function ucs2length(str) {
        var length2 = 0, len = str.length, pos = 0, value;
        while (pos < len) {
          length2++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) == 56320) pos++;
          }
        }
        return length2;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/util.js
  var require_util = __commonJS({
    "../../node_modules/ajv/lib/compile/util.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = {
        copy: copy2,
        checkDataType,
        checkDataTypes,
        coerceToTypes,
        toHash,
        getProperty,
        escapeQuotes,
        equal: require_fast_deep_equal(),
        ucs2length: require_ucs2length(),
        varOccurences,
        varReplace,
        schemaHasRules,
        schemaHasRulesExcept,
        schemaUnknownRules,
        toQuotedString,
        getPathExpr,
        getPath,
        getData,
        unescapeFragment,
        unescapeJsonPointer,
        escapeFragment,
        escapeJsonPointer
      };
      function copy2(o, to) {
        to = to || {};
        for (var key in o) to[key] = o[key];
        return to;
      }
      function checkDataType(dataType, data2, strictNumbers, negate) {
        var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK2 = negate ? "!" : "", NOT = negate ? "" : "!";
        switch (dataType) {
          case "null":
            return data2 + EQUAL + "null";
          case "array":
            return OK2 + "Array.isArray(" + data2 + ")";
          case "object":
            return "(" + OK2 + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
          case "integer":
            return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
          case "number":
            return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK2 + "isFinite(" + data2 + ")" : "") + ")";
          default:
            return "typeof " + data2 + EQUAL + '"' + dataType + '"';
        }
      }
      function checkDataTypes(dataTypes, data2, strictNumbers) {
        switch (dataTypes.length) {
          case 1:
            return checkDataType(dataTypes[0], data2, strictNumbers, true);
          default:
            var code4 = "";
            var types = toHash(dataTypes);
            if (types.array && types.object) {
              code4 = types.null ? "(" : "(!" + data2 + " || ";
              code4 += "typeof " + data2 + ' !== "object")';
              delete types.null;
              delete types.array;
              delete types.object;
            }
            if (types.number) delete types.integer;
            for (var t in types)
              code4 += (code4 ? " && " : "") + checkDataType(t, data2, strictNumbers, true);
            return code4;
        }
      }
      var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(optionCoerceTypes, dataTypes) {
        if (Array.isArray(dataTypes)) {
          var types = [];
          for (var i = 0; i < dataTypes.length; i++) {
            var t = dataTypes[i];
            if (COERCE_TO_TYPES[t]) types[types.length] = t;
            else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
          }
          if (types.length) return types;
        } else if (COERCE_TO_TYPES[dataTypes]) {
          return [dataTypes];
        } else if (optionCoerceTypes === "array" && dataTypes === "array") {
          return ["array"];
        }
      }
      function toHash(arr) {
        var hash2 = {};
        for (var i = 0; i < arr.length; i++) hash2[arr[i]] = true;
        return hash2;
      }
      var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      var SINGLE_QUOTE = /'|\\/g;
      function getProperty(key) {
        return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
      }
      function escapeQuotes(str) {
        return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
      }
      function varOccurences(str, dataVar) {
        dataVar += "[^0-9]";
        var matches = str.match(new RegExp(dataVar, "g"));
        return matches ? matches.length : 0;
      }
      function varReplace(str, dataVar, expr) {
        dataVar += "([^0-9])";
        expr = expr.replace(/\$/g, "$$$$");
        return str.replace(new RegExp(dataVar, "g"), expr + "$1");
      }
      function schemaHasRules(schema, rules) {
        if (typeof schema == "boolean") return !schema;
        for (var key in schema) if (rules[key]) return true;
      }
      function schemaHasRulesExcept(schema, rules, exceptKeyword) {
        if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
        for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
      }
      function schemaUnknownRules(schema, rules) {
        if (typeof schema == "boolean") return;
        for (var key in schema) if (!rules[key]) return key;
      }
      function toQuotedString(str) {
        return "'" + escapeQuotes(str) + "'";
      }
      function getPathExpr(currentPath, expr, jsonPointers, isNumber2) {
        var path2 = jsonPointers ? "'/' + " + expr + (isNumber2 ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber2 ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
        return joinPaths2(currentPath, path2);
      }
      function getPath(currentPath, prop, jsonPointers) {
        var path2 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
        return joinPaths2(currentPath, path2);
      }
      var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, lvl, paths) {
        var up, jsonPointer, data2, matches;
        if ($data === "") return "rootData";
        if ($data[0] == "/") {
          if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
          jsonPointer = $data;
          data2 = "rootData";
        } else {
          matches = $data.match(RELATIVE_JSON_POINTER);
          if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
          up = +matches[1];
          jsonPointer = matches[2];
          if (jsonPointer == "#") {
            if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
            return paths[lvl - up];
          }
          if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
          data2 = "data" + (lvl - up || "");
          if (!jsonPointer) return data2;
        }
        var expr = data2;
        var segments = jsonPointer.split("/");
        for (var i = 0; i < segments.length; i++) {
          var segment = segments[i];
          if (segment) {
            data2 += getProperty(unescapeJsonPointer(segment));
            expr += " && " + data2;
          }
        }
        return expr;
      }
      function joinPaths2(a, b) {
        if (a == '""') return b;
        return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
      }
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      function escapeJsonPointer(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/schema_obj.js
  var require_schema_obj = __commonJS({
    "../../node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var util2 = require_util();
      module.exports = SchemaObject;
      function SchemaObject(obj) {
        util2.copy(obj, this);
      }
    }
  });

  // ../../node_modules/json-schema-traverse/index.js
  var require_json_schema_traverse = __commonJS({
    "../../node_modules/json-schema-traverse/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var traverse = module.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post2 = cb.post || function() {
        };
        _traverse(opts, pre, post2, schema, "", schema);
      };
      traverse.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true
      };
      traverse.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse.propsKeywords = {
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post2, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(opts, pre, post2, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
              }
            } else if (key in traverse.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post2, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
              _traverse(opts, pre, post2, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post2(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/resolve.js
  var require_resolve = __commonJS({
    "../../node_modules/ajv/lib/compile/resolve.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var URI = require_uri_all();
      var equal = require_fast_deep_equal();
      var util2 = require_util();
      var SchemaObject = require_schema_obj();
      var traverse = require_json_schema_traverse();
      module.exports = resolve;
      resolve.normalizeId = normalizeId;
      resolve.fullPath = getFullPath;
      resolve.url = resolveUrl;
      resolve.ids = resolveIds;
      resolve.inlineRef = inlineRef;
      resolve.schema = resolveSchema;
      function resolve(compile2, root5, ref) {
        var refVal = this._refs[ref];
        if (typeof refVal == "string") {
          if (this._refs[refVal]) refVal = this._refs[refVal];
          else return resolve.call(this, compile2, root5, refVal);
        }
        refVal = refVal || this._schemas[ref];
        if (refVal instanceof SchemaObject) {
          return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
        }
        var res = resolveSchema.call(this, root5, ref);
        var schema, v, baseId;
        if (res) {
          schema = res.schema;
          root5 = res.root;
          baseId = res.baseId;
        }
        if (schema instanceof SchemaObject) {
          v = schema.validate || compile2.call(this, schema.schema, root5, void 0, baseId);
        } else if (schema !== void 0) {
          v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile2.call(this, schema, root5, void 0, baseId);
        }
        return v;
      }
      function resolveSchema(root5, ref) {
        var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root5.schema));
        if (Object.keys(root5.schema).length === 0 || refPath !== baseId) {
          var id = normalizeId(refPath);
          var refVal = this._refs[id];
          if (typeof refVal == "string") {
            return resolveRecursive.call(this, root5, refVal, p);
          } else if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            root5 = refVal;
          } else {
            refVal = this._schemas[id];
            if (refVal instanceof SchemaObject) {
              if (!refVal.validate) this._compile(refVal);
              if (id == normalizeId(ref))
                return { schema: refVal, root: root5, baseId };
              root5 = refVal;
            } else {
              return;
            }
          }
          if (!root5.schema) return;
          baseId = getFullPath(this._getId(root5.schema));
        }
        return getJsonPointer.call(this, p, baseId, root5.schema, root5);
      }
      function resolveRecursive(root5, ref, parsedRef) {
        var res = resolveSchema.call(this, root5, ref);
        if (res) {
          var schema = res.schema;
          var baseId = res.baseId;
          root5 = res.root;
          var id = this._getId(schema);
          if (id) baseId = resolveUrl(baseId, id);
          return getJsonPointer.call(this, parsedRef, baseId, schema, root5);
        }
      }
      var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
      function getJsonPointer(parsedRef, baseId, schema, root5) {
        parsedRef.fragment = parsedRef.fragment || "";
        if (parsedRef.fragment.slice(0, 1) != "/") return;
        var parts = parsedRef.fragment.split("/");
        for (var i = 1; i < parts.length; i++) {
          var part = parts[i];
          if (part) {
            part = util2.unescapeFragment(part);
            schema = schema[part];
            if (schema === void 0) break;
            var id;
            if (!PREVENT_SCOPE_CHANGE[part]) {
              id = this._getId(schema);
              if (id) baseId = resolveUrl(baseId, id);
              if (schema.$ref) {
                var $ref = resolveUrl(baseId, schema.$ref);
                var res = resolveSchema.call(this, root5, $ref);
                if (res) {
                  schema = res.schema;
                  root5 = res.root;
                  baseId = res.baseId;
                }
              }
            }
          }
        }
        if (schema !== void 0 && schema !== root5.schema)
          return { schema, root: root5, baseId };
      }
      var SIMPLE_INLINED = util2.toHash([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum"
      ]);
      function inlineRef(schema, limit) {
        if (limit === false) return false;
        if (limit === void 0 || limit === true) return checkNoRef(schema);
        else if (limit) return countKeys(schema) <= limit;
      }
      function checkNoRef(schema) {
        var item;
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            item = schema[i];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return false;
            item = schema[key];
            if (typeof item == "object" && !checkNoRef(item)) return false;
          }
        }
        return true;
      }
      function countKeys(schema) {
        var count = 0, item;
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) {
            item = schema[i];
            if (typeof item == "object") count += countKeys(item);
            if (count == Infinity) return Infinity;
          }
        } else {
          for (var key in schema) {
            if (key == "$ref") return Infinity;
            if (SIMPLE_INLINED[key]) {
              count++;
            } else {
              item = schema[key];
              if (typeof item == "object") count += countKeys(item) + 1;
              if (count == Infinity) return Infinity;
            }
          }
        }
        return count;
      }
      function getFullPath(id, normalize3) {
        if (normalize3 !== false) id = normalizeId(id);
        var p = URI.parse(id);
        return _getFullPath(p);
      }
      function _getFullPath(p) {
        return URI.serialize(p).split("#")[0] + "#";
      }
      var TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id) {
        return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
      }
      function resolveUrl(baseId, id) {
        id = normalizeId(id);
        return URI.resolve(baseId, id);
      }
      function resolveIds(schema) {
        var schemaId = normalizeId(this._getId(schema));
        var baseIds = { "": schemaId };
        var fullPaths = { "": getFullPath(schemaId, false) };
        var localRefs = {};
        var self2 = this;
        traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
          if (jsonPtr === "") return;
          var id = self2._getId(sch);
          var baseId = baseIds[parentJsonPtr];
          var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
          if (keyIndex !== void 0)
            fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
          if (typeof id == "string") {
            id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
            var refVal = self2._refs[id];
            if (typeof refVal == "string") refVal = self2._refs[refVal];
            if (refVal && refVal.schema) {
              if (!equal(sch, refVal.schema))
                throw new Error('id "' + id + '" resolves to more than one schema');
            } else if (id != normalizeId(fullPath)) {
              if (id[0] == "#") {
                if (localRefs[id] && !equal(sch, localRefs[id]))
                  throw new Error('id "' + id + '" resolves to more than one schema');
                localRefs[id] = sch;
              } else {
                self2._refs[id] = fullPath;
              }
            }
          }
          baseIds[jsonPtr] = baseId;
          fullPaths[jsonPtr] = fullPath;
        });
        return localRefs;
      }
    }
  });

  // ../../node_modules/ajv/lib/compile/error_classes.js
  var require_error_classes = __commonJS({
    "../../node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var resolve = require_resolve();
      module.exports = {
        Validation: errorSubclass(ValidationError),
        MissingRef: errorSubclass(MissingRefError)
      };
      function ValidationError(errors) {
        this.message = "validation failed";
        this.errors = errors;
        this.ajv = this.validation = true;
      }
      MissingRefError.message = function(baseId, ref) {
        return "can't resolve reference " + ref + " from id " + baseId;
      };
      function MissingRefError(baseId, ref, message) {
        this.message = message || MissingRefError.message(baseId, ref);
        this.missingRef = resolve.url(baseId, ref);
        this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
      }
      function errorSubclass(Subclass) {
        Subclass.prototype = Object.create(Error.prototype);
        Subclass.prototype.constructor = Subclass;
        return Subclass;
      }
    }
  });

  // ../../node_modules/fast-json-stable-stringify/index.js
  var require_fast_json_stable_stringify = __commonJS({
    "../../node_modules/fast-json-stable-stringify/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function(data2, opts) {
        if (!opts) opts = {};
        if (typeof opts === "function") opts = { cmp: opts };
        var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
        var cmp = opts.cmp && /* @__PURE__ */ function(f) {
          return function(node3) {
            return function(a, b) {
              var aobj = { key: a, value: node3[a] };
              var bobj = { key: b, value: node3[b] };
              return f(aobj, bobj);
            };
          };
        }(opts.cmp);
        var seen = [];
        return function stringify4(node3) {
          if (node3 && node3.toJSON && typeof node3.toJSON === "function") {
            node3 = node3.toJSON();
          }
          if (node3 === void 0) return;
          if (typeof node3 == "number") return isFinite(node3) ? "" + node3 : "null";
          if (typeof node3 !== "object") return JSON.stringify(node3);
          var i, out;
          if (Array.isArray(node3)) {
            out = "[";
            for (i = 0; i < node3.length; i++) {
              if (i) out += ",";
              out += stringify4(node3[i]) || "null";
            }
            return out + "]";
          }
          if (node3 === null) return "null";
          if (seen.indexOf(node3) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          }
          var seenIndex = seen.push(node3) - 1;
          var keys2 = Object.keys(node3).sort(cmp && cmp(node3));
          out = "";
          for (i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            var value = stringify4(node3[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
          }
          seen.splice(seenIndex, 1);
          return "{" + out + "}";
        }(data2);
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/validate.js
  var require_validate = __commonJS({
    "../../node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_validate(it, $keyword, $ruleType) {
        var out = "";
        var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
        if (it.opts.strictKeywords) {
          var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
          if ($unknownKwd) {
            var $keywordsMsg = "unknown keyword: " + $unknownKwd;
            if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
            else throw new Error($keywordsMsg);
          }
        }
        if (it.isTop) {
          out += " var validate = ";
          if ($async) {
            it.async = true;
            out += "async ";
          }
          out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
          if ($id && (it.opts.sourceCode || it.opts.processCode)) {
            out += " " + ("/*# sourceURL=" + $id + " */") + " ";
          }
        }
        if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
          var $keyword = "false schema";
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
          var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = "data" + ($dataLvl || "");
          var $valid = "valid" + $lvl;
          if (it.schema === false) {
            if (it.isTop) {
              $breakOnError = true;
            } else {
              out += " var " + $valid + " = false; ";
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
              if (it.opts.messages !== false) {
                out += " , message: 'boolean schema is false' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            if (it.isTop) {
              if ($async) {
                out += " return data; ";
              } else {
                out += " validate.errors = null; return true; ";
              }
            } else {
              out += " var " + $valid + " = true; ";
            }
          }
          if (it.isTop) {
            out += " }; return validate; ";
          }
          return out;
        }
        if (it.isTop) {
          var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
          it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
          it.baseId = it.baseId || it.rootId;
          delete it.isTop;
          it.dataPathArr = [""];
          if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
            var $defaultMsg = "default is ignored in the schema root";
            if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
            else throw new Error($defaultMsg);
          }
          out += " var vErrors = null; ";
          out += " var errors = 0;     ";
          out += " if (rootData === undefined) rootData = data; ";
        } else {
          var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
          if ($id) it.baseId = it.resolve.url(it.baseId, $id);
          if ($async && !it.async) throw new Error("async schema in sync schema");
          out += " var errs_" + $lvl + " = errors;";
        }
        var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
        var $errorKeyword;
        var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
        if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
          if ($typeIsArray) {
            if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
          } else if ($typeSchema != "null") {
            $typeSchema = [$typeSchema, "null"];
            $typeIsArray = true;
          }
        }
        if ($typeIsArray && $typeSchema.length == 1) {
          $typeSchema = $typeSchema[0];
          $typeIsArray = false;
        }
        if (it.schema.$ref && $refKeywords) {
          if (it.opts.extendRefs == "fail") {
            throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
          } else if (it.opts.extendRefs !== true) {
            $refKeywords = false;
            it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
          }
        }
        if (it.schema.$comment && it.opts.$comment) {
          out += " " + it.RULES.all.$comment.code(it, "$comment");
        }
        if ($typeSchema) {
          if (it.opts.coerceTypes) {
            var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
          }
          var $rulesGroup = it.RULES.types[$typeSchema];
          if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
            var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
            out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
            if ($coerceToTypes) {
              var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
              out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
              if (it.opts.coerceTypes == "array") {
                out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
              }
              out += " if (" + $coerced + " !== undefined) ; ";
              var arr1 = $coerceToTypes;
              if (arr1) {
                var $type, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $type = arr1[$i += 1];
                  if ($type == "string") {
                    out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                  } else if ($type == "number" || $type == "integer") {
                    out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                    if ($type == "integer") {
                      out += " && !(" + $data + " % 1)";
                    }
                    out += ")) " + $coerced + " = +" + $data + "; ";
                  } else if ($type == "boolean") {
                    out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                  } else if ($type == "null") {
                    out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                  } else if (it.opts.coerceTypes == "array" && $type == "array") {
                    out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                  }
                }
              }
              out += " else {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } if (" + $coerced + " !== undefined) {  ";
              var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
              out += " " + $data + " = " + $coerced + "; ";
              if (!$dataLvl) {
                out += "if (" + $parentData + " !== undefined)";
              }
              out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
            } else {
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            }
            out += " } ";
          }
        }
        if (it.schema.$ref && !$refKeywords) {
          out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
          if ($breakOnError) {
            out += " } if (errors === ";
            if ($top) {
              out += "0";
            } else {
              out += "errs_" + $lvl;
            }
            out += ") { ";
            $closingBraces2 += "}";
          }
        } else {
          var arr2 = it.RULES;
          if (arr2) {
            var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $rulesGroup = arr2[i2 += 1];
              if ($shouldUseGroup($rulesGroup)) {
                if ($rulesGroup.type) {
                  out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
                }
                if (it.opts.useDefaults) {
                  if ($rulesGroup.type == "object" && it.schema.properties) {
                    var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                    var arr3 = $schemaKeys;
                    if (arr3) {
                      var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                      while (i3 < l3) {
                        $propertyKey = arr3[i3 += 1];
                        var $sch = $schema[$propertyKey];
                        if ($sch.default !== void 0) {
                          var $passData = $data + it.util.getProperty($propertyKey);
                          if (it.compositeRule) {
                            if (it.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it.opts.useDefaults == "shared") {
                              out += " " + it.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                    var arr4 = it.schema.items;
                    if (arr4) {
                      var $sch, $i = -1, l4 = arr4.length - 1;
                      while ($i < l4) {
                        $sch = arr4[$i += 1];
                        if ($sch.default !== void 0) {
                          var $passData = $data + "[" + $i + "]";
                          if (it.compositeRule) {
                            if (it.opts.strictDefaults) {
                              var $defaultMsg = "default is ignored for: " + $passData;
                              if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                              else throw new Error($defaultMsg);
                            }
                          } else {
                            out += " if (" + $passData + " === undefined ";
                            if (it.opts.useDefaults == "empty") {
                              out += " || " + $passData + " === null || " + $passData + " === '' ";
                            }
                            out += " ) " + $passData + " = ";
                            if (it.opts.useDefaults == "shared") {
                              out += " " + it.useDefault($sch.default) + " ";
                            } else {
                              out += " " + JSON.stringify($sch.default) + " ";
                            }
                            out += "; ";
                          }
                        }
                      }
                    }
                  }
                }
                var arr5 = $rulesGroup.rules;
                if (arr5) {
                  var $rule, i5 = -1, l5 = arr5.length - 1;
                  while (i5 < l5) {
                    $rule = arr5[i5 += 1];
                    if ($shouldUseRule($rule)) {
                      var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                      if ($code) {
                        out += " " + $code + " ";
                        if ($breakOnError) {
                          $closingBraces1 += "}";
                        }
                      }
                    }
                  }
                }
                if ($breakOnError) {
                  out += " " + $closingBraces1 + " ";
                  $closingBraces1 = "";
                }
                if ($rulesGroup.type) {
                  out += " } ";
                  if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                    out += " else { ";
                    var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it.createErrors !== false) {
                      out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: 'should be ";
                        if ($typeIsArray) {
                          out += "" + $typeSchema.join(",");
                        } else {
                          out += "" + $typeSchema;
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                      if (it.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    out += " } ";
                  }
                }
                if ($breakOnError) {
                  out += " if (errors === ";
                  if ($top) {
                    out += "0";
                  } else {
                    out += "errs_" + $lvl;
                  }
                  out += ") { ";
                  $closingBraces2 += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces2 + " ";
        }
        if ($top) {
          if ($async) {
            out += " if (errors === 0) return data;           ";
            out += " else throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; ";
            out += " return errors === 0;       ";
          }
          out += " }; return validate;";
        } else {
          out += " var " + $valid + " = errors === errs_" + $lvl + ";";
        }
        function $shouldUseGroup($rulesGroup2) {
          var rules = $rulesGroup2.rules;
          for (var i = 0; i < rules.length; i++)
            if ($shouldUseRule(rules[i])) return true;
        }
        function $shouldUseRule($rule2) {
          return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
        }
        function $ruleImplementsSomeKeyword($rule2) {
          var impl = $rule2.implements;
          for (var i = 0; i < impl.length; i++)
            if (it.schema[impl[i]] !== void 0) return true;
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/index.js
  var require_compile = __commonJS({
    "../../node_modules/ajv/lib/compile/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var resolve = require_resolve();
      var util2 = require_util();
      var errorClasses = require_error_classes();
      var stableStringify = require_fast_json_stable_stringify();
      var validateGenerator = require_validate();
      var ucs2length = util2.ucs2length;
      var equal = require_fast_deep_equal();
      var ValidationError = errorClasses.Validation;
      module.exports = compile2;
      function compile2(schema, root5, localRefs, baseId) {
        var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
        root5 = root5 || { schema, refVal, refs };
        var c = checkCompiling.call(this, schema, root5, baseId);
        var compilation = this._compilations[c.index];
        if (c.compiling) return compilation.callValidate = callValidate;
        var formats = this._formats;
        var RULES = this.RULES;
        try {
          var v = localCompile(schema, root5, localRefs, baseId);
          compilation.validate = v;
          var cv = compilation.callValidate;
          if (cv) {
            cv.schema = v.schema;
            cv.errors = null;
            cv.refs = v.refs;
            cv.refVal = v.refVal;
            cv.root = v.root;
            cv.$async = v.$async;
            if (opts.sourceCode) cv.source = v.source;
          }
          return v;
        } finally {
          endCompiling.call(this, schema, root5, baseId);
        }
        function callValidate() {
          var validate = compilation.validate;
          var result = validate.apply(this, arguments);
          callValidate.errors = validate.errors;
          return result;
        }
        function localCompile(_schema, _root, localRefs2, baseId2) {
          var isRoot = !_root || _root && _root.schema == _schema;
          if (_root.schema != root5.schema)
            return compile2.call(self2, _schema, _root, localRefs2, baseId2);
          var $async = _schema.$async === true;
          var sourceCode = validateGenerator({
            isTop: true,
            schema: _schema,
            isRoot,
            baseId: baseId2,
            root: _root,
            schemaPath: "",
            errSchemaPath: "#",
            errorPath: '""',
            MissingRefError: errorClasses.MissingRef,
            RULES,
            validate: validateGenerator,
            util: util2,
            resolve,
            resolveRef,
            usePattern,
            useDefault,
            useCustomRule,
            opts,
            formats,
            logger: self2.logger,
            self: self2
          });
          sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
          if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
          var validate;
          try {
            var makeValidate = new Function(
              "self",
              "RULES",
              "formats",
              "root",
              "refVal",
              "defaults",
              "customRules",
              "equal",
              "ucs2length",
              "ValidationError",
              sourceCode
            );
            validate = makeValidate(
              self2,
              RULES,
              formats,
              root5,
              refVal,
              defaults,
              customRules,
              equal,
              ucs2length,
              ValidationError
            );
            refVal[0] = validate;
          } catch (e) {
            self2.logger.error("Error compiling schema, function code:", sourceCode);
            throw e;
          }
          validate.schema = _schema;
          validate.errors = null;
          validate.refs = refs;
          validate.refVal = refVal;
          validate.root = isRoot ? validate : _root;
          if ($async) validate.$async = true;
          if (opts.sourceCode === true) {
            validate.source = {
              code: sourceCode,
              patterns,
              defaults
            };
          }
          return validate;
        }
        function resolveRef(baseId2, ref, isRoot) {
          ref = resolve.url(baseId2, ref);
          var refIndex = refs[ref];
          var _refVal, refCode;
          if (refIndex !== void 0) {
            _refVal = refVal[refIndex];
            refCode = "refVal[" + refIndex + "]";
            return resolvedRef(_refVal, refCode);
          }
          if (!isRoot && root5.refs) {
            var rootRefId = root5.refs[ref];
            if (rootRefId !== void 0) {
              _refVal = root5.refVal[rootRefId];
              refCode = addLocalRef(ref, _refVal);
              return resolvedRef(_refVal, refCode);
            }
          }
          refCode = addLocalRef(ref);
          var v2 = resolve.call(self2, localCompile, root5, ref);
          if (v2 === void 0) {
            var localSchema = localRefs && localRefs[ref];
            if (localSchema) {
              v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile2.call(self2, localSchema, root5, localRefs, baseId2);
            }
          }
          if (v2 === void 0) {
            removeLocalRef(ref);
          } else {
            replaceLocalRef(ref, v2);
            return resolvedRef(v2, refCode);
          }
        }
        function addLocalRef(ref, v2) {
          var refId = refVal.length;
          refVal[refId] = v2;
          refs[ref] = refId;
          return "refVal" + refId;
        }
        function removeLocalRef(ref) {
          delete refs[ref];
        }
        function replaceLocalRef(ref, v2) {
          var refId = refs[ref];
          refVal[refId] = v2;
        }
        function resolvedRef(refVal2, code4) {
          return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code: code4, schema: refVal2, inline: true } : { code: code4, $async: refVal2 && !!refVal2.$async };
        }
        function usePattern(regexStr) {
          var index2 = patternsHash[regexStr];
          if (index2 === void 0) {
            index2 = patternsHash[regexStr] = patterns.length;
            patterns[index2] = regexStr;
          }
          return "pattern" + index2;
        }
        function useDefault(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
              return "" + value;
            case "string":
              return util2.toQuotedString(value);
            case "object":
              if (value === null) return "null";
              var valueStr = stableStringify(value);
              var index2 = defaultsHash[valueStr];
              if (index2 === void 0) {
                index2 = defaultsHash[valueStr] = defaults.length;
                defaults[index2] = value;
              }
              return "default" + index2;
          }
        }
        function useCustomRule(rule, schema2, parentSchema, it) {
          if (self2._opts.validateSchema !== false) {
            var deps = rule.definition.dependencies;
            if (deps && !deps.every(function(keyword) {
              return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
            }))
              throw new Error("parent schema must have all required keywords: " + deps.join(","));
            var validateSchema = rule.definition.validateSchema;
            if (validateSchema) {
              var valid2 = validateSchema(schema2);
              if (!valid2) {
                var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
                if (self2._opts.validateSchema == "log") self2.logger.error(message);
                else throw new Error(message);
              }
            }
          }
          var compile3 = rule.definition.compile, inline2 = rule.definition.inline, macro = rule.definition.macro;
          var validate;
          if (compile3) {
            validate = compile3.call(self2, schema2, parentSchema, it);
          } else if (macro) {
            validate = macro.call(self2, schema2, parentSchema, it);
            if (opts.validateSchema !== false) self2.validateSchema(validate, true);
          } else if (inline2) {
            validate = inline2.call(self2, it, rule.keyword, schema2, parentSchema);
          } else {
            validate = rule.definition.validate;
            if (!validate) return;
          }
          if (validate === void 0)
            throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
          var index2 = customRules.length;
          customRules[index2] = validate;
          return {
            code: "customRule" + index2,
            validate
          };
        }
      }
      function checkCompiling(schema, root5, baseId) {
        var index2 = compIndex.call(this, schema, root5, baseId);
        if (index2 >= 0) return { index: index2, compiling: true };
        index2 = this._compilations.length;
        this._compilations[index2] = {
          schema,
          root: root5,
          baseId
        };
        return { index: index2, compiling: false };
      }
      function endCompiling(schema, root5, baseId) {
        var i = compIndex.call(this, schema, root5, baseId);
        if (i >= 0) this._compilations.splice(i, 1);
      }
      function compIndex(schema, root5, baseId) {
        for (var i = 0; i < this._compilations.length; i++) {
          var c = this._compilations[i];
          if (c.schema == schema && c.root == root5 && c.baseId == baseId) return i;
        }
        return -1;
      }
      function patternCode(i, patterns) {
        return "var pattern" + i + " = new RegExp(" + util2.toQuotedString(patterns[i]) + ");";
      }
      function defaultCode(i) {
        return "var default" + i + " = defaults[" + i + "];";
      }
      function refValCode(i, refVal) {
        return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
      }
      function customRuleCode(i) {
        return "var customRule" + i + " = customRules[" + i + "];";
      }
      function vars(arr, statement) {
        if (!arr.length) return "";
        var code4 = "";
        for (var i = 0; i < arr.length; i++)
          code4 += statement(i, arr);
        return code4;
      }
    }
  });

  // ../../node_modules/ajv/lib/cache.js
  var require_cache = __commonJS({
    "../../node_modules/ajv/lib/cache.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var Cache = module.exports = function Cache2() {
        this._cache = {};
      };
      Cache.prototype.put = function Cache_put(key, value) {
        this._cache[key] = value;
      };
      Cache.prototype.get = function Cache_get(key) {
        return this._cache[key];
      };
      Cache.prototype.del = function Cache_del(key) {
        delete this._cache[key];
      };
      Cache.prototype.clear = function Cache_clear() {
        this._cache = {};
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/formats.js
  var require_formats = __commonJS({
    "../../node_modules/ajv/lib/compile/formats.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var util2 = require_util();
      var DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
      var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
      var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
      var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
      var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
      var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
      var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
      var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
      module.exports = formats;
      function formats(mode) {
        mode = mode == "full" ? "full" : "fast";
        return util2.copy(formats[mode]);
      }
      formats.fast = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": URITEMPLATE,
        url: URL2,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: HOSTNAME,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: regex2,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: UUID,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      formats.full = {
        date,
        time,
        "date-time": date_time,
        uri,
        "uri-reference": URIREF,
        "uri-template": URITEMPLATE,
        url: URL2,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: HOSTNAME,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: regex2,
        uuid: UUID,
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        "relative-json-pointer": RELATIVE_JSON_POINTER
      };
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function date(str) {
        var matches = str.match(DATE2);
        if (!matches) return false;
        var year = +matches[1];
        var month = +matches[2];
        var day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
      }
      function time(str, full) {
        var matches = str.match(TIME);
        if (!matches) return false;
        var hour = matches[1];
        var minute = matches[2];
        var second = matches[3];
        var timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
      }
      var DATE_TIME_SEPARATOR = /t|\s/i;
      function date_time(str) {
        var dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
      }
      var NOT_URI_FRAGMENT = /\/|:/;
      function uri(str) {
        return NOT_URI_FRAGMENT.test(str) && URI.test(str);
      }
      var Z_ANCHOR = /[^\\]\\Z/;
      function regex2(str) {
        if (Z_ANCHOR.test(str)) return false;
        try {
          new RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      }
    }
  });

  // ../../node_modules/ajv/lib/dotjs/ref.js
  var require_ref = __commonJS({
    "../../node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_ref(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $async, $refCode;
        if ($schema == "#" || $schema == "#/") {
          if (it.isRoot) {
            $async = it.async;
            $refCode = "validate";
          } else {
            $async = it.root.schema.$async === true;
            $refCode = "root.refVal[0]";
          }
        } else {
          var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
          if ($refVal === void 0) {
            var $message = it.MissingRefError.message(it.baseId, $schema);
            if (it.opts.missingRefs == "fail") {
              it.logger.error($message);
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              if ($breakOnError) {
                out += " if (false) { ";
              }
            } else if (it.opts.missingRefs == "ignore") {
              it.logger.warn($message);
              if ($breakOnError) {
                out += " if (true) { ";
              }
            } else {
              throw new it.MissingRefError(it.baseId, $schema, $message);
            }
          } else if ($refVal.inline) {
            var $it = it.util.copy(it);
            $it.level++;
            var $nextValid = "valid" + $it.level;
            $it.schema = $refVal.schema;
            $it.schemaPath = "";
            $it.errSchemaPath = $schema;
            var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
            out += " " + $code + " ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
            }
          } else {
            $async = $refVal.$async === true || it.async && $refVal.$async !== false;
            $refCode = $refVal.code;
          }
        }
        if ($refCode) {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.opts.passContext) {
            out += " " + $refCode + ".call(this, ";
          } else {
            out += " " + $refCode + "( ";
          }
          out += " " + $data + ", (dataPath || '')";
          if (it.errorPath != '""') {
            out += " + " + it.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
          var __callValidate = out;
          out = $$outStack.pop();
          if ($async) {
            if (!it.async) throw new Error("async schema referenced by sync schema");
            if ($breakOnError) {
              out += " var " + $valid + "; ";
            }
            out += " try { await " + __callValidate + "; ";
            if ($breakOnError) {
              out += " " + $valid + " = true; ";
            }
            out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
            if ($breakOnError) {
              out += " " + $valid + " = false; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " if (" + $valid + ") { ";
            }
          } else {
            out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
            if ($breakOnError) {
              out += " else { ";
            }
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/allOf.js
  var require_allOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_allOf(it, $keyword, $ruleType) {
        var out = " ";
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $allSchemasEmpty = false;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($breakOnError) {
          if ($allSchemasEmpty) {
            out += " if (true) { ";
          } else {
            out += " " + $closingBraces.slice(0, -1) + " ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/anyOf.js
  var require_anyOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_anyOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $noEmptySchema = $schema.every(function($sch2) {
          return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
        });
        if ($noEmptySchema) {
          var $currentBaseId = $it.baseId;
          out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
              out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
              $closingBraces += "}";
            }
          }
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should match some schema in anyOf' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it.opts.allErrors) {
            out += " } ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/comment.js
  var require_comment = __commonJS({
    "../../node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_comment(it, $keyword, $ruleType) {
        var out = " ";
        var $schema = it.schema[$keyword];
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $comment = it.util.toQuotedString($schema);
        if (it.opts.$comment === true) {
          out += " console.log(" + $comment + ");";
        } else if (typeof it.opts.$comment == "function") {
          out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/const.js
  var require_const = __commonJS({
    "../../node_modules/ajv/lib/dotjs/const.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_const(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!$isData) {
          out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be equal to constant' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/contains.js
  var require_contains = __commonJS({
    "../../node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_contains(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($nonEmptySchema) {
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          out += " if (" + $nextValid + ") break; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $closingBraces + " if (!" + $nextValid + ") {";
        } else {
          out += " if (" + $data + ".length == 0) {";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should contain a valid item' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else { ";
        if ($nonEmptySchema) {
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        }
        if (it.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/dependencies.js
  var require_dependencies = __commonJS({
    "../../node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_dependencies(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
        for ($property in $schema) {
          if ($property == "__proto__") continue;
          var $sch = $schema[$property];
          var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
          $deps[$property] = $sch;
        }
        out += "var " + $errs + " = errors;";
        var $currentErrorPath = it.errorPath;
        out += "var missing" + $lvl + ";";
        for (var $property in $propertyDeps) {
          $deps = $propertyDeps[$property];
          if ($deps.length) {
            out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            }
            if ($breakOnError) {
              out += " && ( ";
              var arr1 = $deps;
              if (arr1) {
                var $propertyKey, $i = -1, l1 = arr1.length - 1;
                while ($i < l1) {
                  $propertyKey = arr1[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ")) {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
            } else {
              out += " ) { ";
              var arr2 = $deps;
              if (arr2) {
                var $propertyKey, i2 = -1, l2 = arr2.length - 1;
                while (i2 < l2) {
                  $propertyKey = arr2[i2 += 1];
                  var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should have ";
                      if ($deps.length == 1) {
                        out += "property " + it.util.escapeQuotes($deps[0]);
                      } else {
                        out += "properties " + it.util.escapeQuotes($deps.join(", "));
                      }
                      out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
            out += " }   ";
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
        var $currentBaseId = $it.baseId;
        for (var $property in $schemaDeps) {
          var $sch = $schemaDeps[$property];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
            if ($ownProperties) {
              out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
            }
            out += ") { ";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + it.util.getProperty($property);
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
        if ($breakOnError) {
          out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/enum.js
  var require_enum = __commonJS({
    "../../node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_enum(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
        if (!$isData) {
          out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
        }
        out += "var " + $valid + ";";
        if ($isData) {
          out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
        }
        out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be equal to one of the allowed values' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " }";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/format.js
  var require_format = __commonJS({
    "../../node_modules/ajv/lib/dotjs/format.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_format(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        if (it.opts.format === false) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
        if ($isData) {
          var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
          out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
          if (it.async) {
            out += " var async" + $lvl + " = " + $format + ".async; ";
          }
          out += " " + $format + " = " + $format + ".validate; } if (  ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
          }
          out += " (";
          if ($unknownFormats != "ignore") {
            out += " (" + $schemaValue + " && !" + $format + " ";
            if ($allowUnknown) {
              out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
            }
            out += ") || ";
          }
          out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
          if (it.async) {
            out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
          } else {
            out += " " + $format + "(" + $data + ") ";
          }
          out += " : " + $format + ".test(" + $data + "))))) {";
        } else {
          var $format = it.formats[$schema];
          if (!$format) {
            if ($unknownFormats == "ignore") {
              it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
              if ($breakOnError) {
                out += " if (true) { ";
              }
              return out;
            } else {
              throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
            }
          }
          var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
          var $formatType = $isObject && $format.type || "string";
          if ($isObject) {
            var $async = $format.async === true;
            $format = $format.validate;
          }
          if ($formatType != $ruleType) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          }
          if ($async) {
            if (!it.async) throw new Error("async format in sync schema");
            var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
            out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
          } else {
            out += " if (! ";
            var $formatRef = "formats" + it.util.getProperty($schema);
            if ($isObject) $formatRef += ".validate";
            if (typeof $format == "function") {
              out += " " + $formatRef + "(" + $data + ") ";
            } else {
              out += " " + $formatRef + ".test(" + $data + ") ";
            }
            out += ") { ";
          }
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match format "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/if.js
  var require_if = __commonJS({
    "../../node_modules/ajv/lib/dotjs/if.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_if(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
        if ($thenPresent || $elsePresent) {
          var $ifClause;
          $it.createErrors = false;
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          $it.createErrors = true;
          out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
          it.compositeRule = $it.compositeRule = $wasComposite;
          if ($thenPresent) {
            out += " if (" + $nextValid + ") {  ";
            $it.schema = it.schema["then"];
            $it.schemaPath = it.schemaPath + ".then";
            $it.errSchemaPath = it.errSchemaPath + "/then";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'then'; ";
            } else {
              $ifClause = "'then'";
            }
            out += " } ";
            if ($elsePresent) {
              out += " else { ";
            }
          } else {
            out += " if (!" + $nextValid + ") { ";
          }
          if ($elsePresent) {
            $it.schema = it.schema["else"];
            $it.schemaPath = it.schemaPath + ".else";
            $it.errSchemaPath = it.errSchemaPath + "/else";
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $nextValid + "; ";
            if ($thenPresent && $elsePresent) {
              $ifClause = "ifClause" + $lvl;
              out += " var " + $ifClause + " = 'else'; ";
            } else {
              $ifClause = "'else'";
            }
            out += " } ";
          }
          out += " if (!" + $valid + ") {   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          out += " }   ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/items.js
  var require_items = __commonJS({
    "../../node_modules/ajv/lib/dotjs/items.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_items(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if (Array.isArray($schema)) {
          var $additionalItems = it.schema.additionalItems;
          if ($additionalItems === false) {
            out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should NOT have more than " + $schema.length + " items' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } ";
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              $closingBraces += "}";
              out += " else { ";
            }
          }
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
                var $passData = $data + "[" + $i + "]";
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + "[" + $i + "]";
                $it.errSchemaPath = $errSchemaPath + "/" + $i;
                $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                $it.dataPathArr[$dataNxt] = $i;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
          if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
            $it.schema = $additionalItems;
            $it.schemaPath = it.schemaPath + ".additionalItems";
            $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
            var $passData = $data + "[" + $idx + "]";
            $it.dataPathArr[$dataNxt] = $idx;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limit.js
  var require_limit = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate__limit(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
        if (!($isData || typeof $schema == "number" || $schema === void 0)) {
          throw new Error($keyword + " must be number");
        }
        if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
          throw new Error($exclusiveKeyword + " must be number or boolean");
        }
        if ($isDataExcl) {
          var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
          out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
          $schemaValueExcl = "schemaExcl" + $lvl;
          out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
          var $errorKeyword = $exclusiveKeyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
          if ($schema === void 0) {
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaValueExcl;
            $isData = $isDataExcl;
          }
        } else {
          var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
          if ($exclIsNumber && $isData) {
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
          } else {
            if ($exclIsNumber && $schema === void 0) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $schemaValue = $schemaExcl;
              $notOp += "=";
            } else {
              if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
              if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
                $exclusive = true;
                $errorKeyword = $exclusiveKeyword;
                $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
                $notOp += "=";
              } else {
                $exclusive = false;
                $opStr += "=";
              }
            }
            var $opExpr = "'" + $opStr + "'";
            out += " if ( ";
            if ($isData) {
              out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
            }
            out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
          }
        }
        $errorKeyword = $errorKeyword || $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be " + $opStr + " ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitItems.js
  var require_limitItems = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate__limitItems(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxItems" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxItems") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitLength.js
  var require_limitLength = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate__limitLength(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxLength" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        if (it.opts.unicode === false) {
          out += " " + $data + ".length ";
        } else {
          out += " ucs2length(" + $data + ") ";
        }
        out += " " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be ";
            if ($keyword == "maxLength") {
              out += "longer";
            } else {
              out += "shorter";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " characters' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/_limitProperties.js
  var require_limitProperties = __commonJS({
    "../../node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        var $op = $keyword == "maxProperties" ? ">" : "<";
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
        var $errorKeyword = $keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have ";
            if ($keyword == "maxProperties") {
              out += "more";
            } else {
              out += "fewer";
            }
            out += " than ";
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + $schema;
            }
            out += " properties' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/multipleOf.js
  var require_multipleOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (!($isData || typeof $schema == "number")) {
          throw new Error($keyword + " must be number");
        }
        out += "var division" + $lvl + ";if (";
        if ($isData) {
          out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
        }
        out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
        if (it.opts.multipleOfPrecision) {
          out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
        } else {
          out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
        }
        out += " ) ";
        if ($isData) {
          out += "  )  ";
        }
        out += " ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be multiple of ";
            if ($isData) {
              out += "' + " + $schemaValue;
            } else {
              out += "" + $schemaValue + "'";
            }
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/not.js
  var require_not = __commonJS({
    "../../node_modules/ajv/lib/dotjs/not.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_not(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          out += " var " + $errs + " = errors;  ";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.createErrors = false;
          var $allErrorsOption;
          if ($it.opts.allErrors) {
            $allErrorsOption = $it.opts.allErrors;
            $it.opts.allErrors = false;
          }
          out += " " + it.validate($it) + " ";
          $it.createErrors = true;
          if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (" + $nextValid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
          if (it.opts.allErrors) {
            out += " } ";
          }
        } else {
          out += "  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT be valid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if ($breakOnError) {
            out += " if (false) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/oneOf.js
  var require_oneOf = __commonJS({
    "../../node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_oneOf(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
        out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              out += "  " + it.validate($it) + " ";
              $it.baseId = $currentBaseId;
            } else {
              out += " var " + $nextValid + " = true; ";
            }
            if ($i) {
              out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
              $closingBraces += "}";
            }
            out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match exactly one schema in oneOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
        if (it.opts.allErrors) {
          out += " } ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/pattern.js
  var require_pattern = __commonJS({
    "../../node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_pattern(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
        out += "if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " !" + $regexp + ".test(" + $data + ") ) {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
          if ($isData) {
            out += "" + $schemaValue;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "  } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match pattern "`;
            if ($isData) {
              out += "' + " + $schemaValue + " + '";
            } else {
              out += "" + it.util.escapeQuotes($schema);
            }
            out += `"' `;
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + it.util.toQuotedString($schema);
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += "} ";
        if ($breakOnError) {
          out += " else { ";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/properties.js
  var require_properties = __commonJS({
    "../../node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_properties(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
        var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        var $required = it.schema.required;
        if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
          var $requiredHash = it.util.toHash($required);
        }
        function notProto(p) {
          return p !== "__proto__";
        }
        out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined;";
        }
        if ($checkAdditional) {
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          if ($someProperties) {
            out += " var isAdditional" + $lvl + " = !(false ";
            if ($schemaKeys.length) {
              if ($schemaKeys.length > 8) {
                out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
              } else {
                var arr1 = $schemaKeys;
                if (arr1) {
                  var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                  while (i1 < l1) {
                    $propertyKey = arr1[i1 += 1];
                    out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                  }
                }
              }
            }
            if ($pPropertyKeys.length) {
              var arr2 = $pPropertyKeys;
              if (arr2) {
                var $pProperty, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $pProperty = arr2[$i += 1];
                  out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
                }
              }
            }
            out += " ); if (isAdditional" + $lvl + ") { ";
          }
          if ($removeAdditional == "all") {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            var $currentErrorPath = it.errorPath;
            var $additionalProperty = "' + " + $key + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            }
            if ($noAdditional) {
              if ($removeAdditional) {
                out += " delete " + $data + "[" + $key + "]; ";
              } else {
                out += " " + $nextValid + " = false; ";
                var $currErrSchemaPath = $errSchemaPath;
                $errSchemaPath = it.errSchemaPath + "/additionalProperties";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is an invalid additional property";
                    } else {
                      out += "should NOT have additional properties";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += " break; ";
                }
              }
            } else if ($additionalIsSchema) {
              if ($removeAdditional == "failing") {
                out += " var " + $errs + " = errors;  ";
                var $wasComposite = it.compositeRule;
                it.compositeRule = $it.compositeRule = true;
                $it.schema = $aProperties;
                $it.schemaPath = it.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
                it.compositeRule = $it.compositeRule = $wasComposite;
              } else {
                $it.schema = $aProperties;
                $it.schemaPath = it.schemaPath + ".additionalProperties";
                $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
                $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
              }
            }
            it.errorPath = $currentErrorPath;
          }
          if ($someProperties) {
            out += " } ";
          }
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
        var $useDefaults = it.opts.useDefaults && !it.compositeRule;
        if ($schemaKeys.length) {
          var arr3 = $schemaKeys;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $sch = $schema[$propertyKey];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + $prop;
                $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
                $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  $code = it.util.varReplace($code, $nextData, $passData);
                  var $useData = $passData;
                } else {
                  var $useData = $nextData;
                  out += " var " + $nextData + " = " + $passData + "; ";
                }
                if ($hasDefault) {
                  out += " " + $code + " ";
                } else {
                  if ($requiredHash && $requiredHash[$propertyKey]) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = false; ";
                    var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                    if (it.opts._errorDataPathProperty) {
                      it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                    }
                    $errSchemaPath = it.errSchemaPath + "/required";
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = "";
                    if (it.createErrors !== false) {
                      out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                      if (it.opts.messages !== false) {
                        out += " , message: '";
                        if (it.opts._errorDataPathProperty) {
                          out += "is a required property";
                        } else {
                          out += "should have required property \\'" + $missingProperty + "\\'";
                        }
                        out += "' ";
                      }
                      if (it.opts.verbose) {
                        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                      }
                      out += " } ";
                    } else {
                      out += " {} ";
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) {
                      if (it.async) {
                        out += " throw new ValidationError([" + __err + "]); ";
                      } else {
                        out += " validate.errors = [" + __err + "]; return false; ";
                      }
                    } else {
                      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                    }
                    $errSchemaPath = $currErrSchemaPath;
                    it.errorPath = $currentErrorPath;
                    out += " } else { ";
                  } else {
                    if ($breakOnError) {
                      out += " if ( " + $useData + " === undefined ";
                      if ($ownProperties) {
                        out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += ") { " + $nextValid + " = true; } else { ";
                    } else {
                      out += " if (" + $useData + " !== undefined ";
                      if ($ownProperties) {
                        out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                      }
                      out += " ) { ";
                    }
                  }
                  out += " " + $code + " } ";
                }
              }
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr4 = $pPropertyKeys;
          if (arr4) {
            var $pProperty, i4 = -1, l4 = arr4.length - 1;
            while (i4 < l4) {
              $pProperty = arr4[i4 += 1];
              var $sch = $pProperties[$pProperty];
              if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
                $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
                if ($ownProperties) {
                  out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
                } else {
                  out += " for (var " + $key + " in " + $data + ") { ";
                }
                out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
                $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
                var $passData = $data + "[" + $key + "]";
                $it.dataPathArr[$dataNxt] = $key;
                var $code = it.validate($it);
                $it.baseId = $currentBaseId;
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
                } else {
                  out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
                }
                if ($breakOnError) {
                  out += " if (!" + $nextValid + ") break; ";
                }
                out += " } ";
                if ($breakOnError) {
                  out += " else " + $nextValid + " = true; ";
                }
                out += " }  ";
                if ($breakOnError) {
                  out += " if (" + $nextValid + ") { ";
                  $closingBraces += "}";
                }
              }
            }
          }
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/propertyNames.js
  var require_propertyNames = __commonJS({
    "../../node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $errs = "errs__" + $lvl;
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        out += "var " + $errs + " = errors;";
        if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
          $it.schema = $schema;
          $it.schemaPath = $schemaPath;
          $it.errSchemaPath = $errSchemaPath;
          var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
          if ($ownProperties) {
            out += " var " + $dataProperties + " = undefined; ";
          }
          if ($ownProperties) {
            out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
          } else {
            out += " for (var " + $key + " in " + $data + ") { ";
          }
          out += " var startErrs" + $lvl + " = errors; ";
          var $passData = $key;
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
          if ($breakOnError) {
            out += " break; ";
          }
          out += " } }";
        }
        if ($breakOnError) {
          out += " " + $closingBraces + " if (" + $errs + " == errors) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/required.js
  var require_required = __commonJS({
    "../../node_modules/ajv/lib/dotjs/required.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_required(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $vSchema = "schema" + $lvl;
        if (!$isData) {
          if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
            var $required = [];
            var arr1 = $schema;
            if (arr1) {
              var $property, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $property = arr1[i1 += 1];
                var $propertySch = it.schema.properties[$property];
                if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                  $required[$required.length] = $property;
                }
              }
            }
          } else {
            var $required = $schema;
          }
        }
        if ($isData || $required.length) {
          var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
          if ($breakOnError) {
            out += " var missing" + $lvl + "; ";
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
              }
              out += " var " + $valid + " = true; ";
              if ($isData) {
                out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
              if ($ownProperties) {
                out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += "; if (!" + $valid + ") break; } ";
              if ($isData) {
                out += "  }  ";
              }
              out += "  if (!" + $valid + ") {   ";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            } else {
              out += " if ( ";
              var arr2 = $required;
              if (arr2) {
                var $propertyKey, $i = -1, l2 = arr2.length - 1;
                while ($i < l2) {
                  $propertyKey = arr2[$i += 1];
                  if ($i) {
                    out += " || ";
                  }
                  var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                  out += " ( ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
                }
              }
              out += ") {  ";
              var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
              }
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              out += " } else { ";
            }
          } else {
            if ($loopRequired) {
              if (!$isData) {
                out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
              }
              var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
              }
              if ($isData) {
                out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
              }
              out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
              if ($isData) {
                out += "  }  ";
              }
            } else {
              var arr3 = $required;
              if (arr3) {
                var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") {  var err =   ";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
                }
              }
            }
          }
          it.errorPath = $currentErrorPath;
        } else if ($breakOnError) {
          out += " if (true) {";
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/uniqueItems.js
  var require_uniqueItems = __commonJS({
    "../../node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        if (($schema || $isData) && it.opts.uniqueItems !== false) {
          if ($isData) {
            out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
          }
          out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
          var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
          if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
            out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
          } else {
            out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
            var $method = "checkDataType" + ($typeIsArray ? "s" : "");
            out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
            if ($typeIsArray) {
              out += ` if (typeof item == 'string') item = '"' + item; `;
            }
            out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
          }
          out += " } ";
          if ($isData) {
            out += "  }  ";
          }
          out += " if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
            }
            if (it.opts.verbose) {
              out += " , schema:  ";
              if ($isData) {
                out += "validate.schema" + $schemaPath;
              } else {
                out += "" + $schema;
              }
              out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        } else {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/dotjs/index.js
  var require_dotjs = __commonJS({
    "../../node_modules/ajv/lib/dotjs/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = {
        "$ref": require_ref(),
        allOf: require_allOf(),
        anyOf: require_anyOf(),
        "$comment": require_comment(),
        const: require_const(),
        contains: require_contains(),
        dependencies: require_dependencies(),
        "enum": require_enum(),
        format: require_format(),
        "if": require_if(),
        items: require_items(),
        maximum: require_limit(),
        minimum: require_limit(),
        maxItems: require_limitItems(),
        minItems: require_limitItems(),
        maxLength: require_limitLength(),
        minLength: require_limitLength(),
        maxProperties: require_limitProperties(),
        minProperties: require_limitProperties(),
        multipleOf: require_multipleOf(),
        not: require_not(),
        oneOf: require_oneOf(),
        pattern: require_pattern(),
        properties: require_properties(),
        propertyNames: require_propertyNames(),
        required: require_required(),
        uniqueItems: require_uniqueItems(),
        validate: require_validate()
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/rules.js
  var require_rules = __commonJS({
    "../../node_modules/ajv/lib/compile/rules.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var ruleModules = require_dotjs();
      var toHash = require_util().toHash;
      module.exports = function rules() {
        var RULES = [
          {
            type: "number",
            rules: [
              { "maximum": ["exclusiveMaximum"] },
              { "minimum": ["exclusiveMinimum"] },
              "multipleOf",
              "format"
            ]
          },
          {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"]
          },
          {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
          },
          {
            type: "object",
            rules: [
              "maxProperties",
              "minProperties",
              "required",
              "dependencies",
              "propertyNames",
              { "properties": ["additionalProperties", "patternProperties"] }
            ]
          },
          { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
        ];
        var ALL = ["type", "$comment"];
        var KEYWORDS = [
          "$schema",
          "$id",
          "id",
          "$data",
          "$async",
          "title",
          "description",
          "default",
          "definitions",
          "examples",
          "readOnly",
          "writeOnly",
          "contentMediaType",
          "contentEncoding",
          "additionalItems",
          "then",
          "else"
        ];
        var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
        RULES.all = toHash(ALL);
        RULES.types = toHash(TYPES);
        RULES.forEach(function(group) {
          group.rules = group.rules.map(function(keyword) {
            var implKeywords;
            if (typeof keyword == "object") {
              var key = Object.keys(keyword)[0];
              implKeywords = keyword[key];
              keyword = key;
              implKeywords.forEach(function(k) {
                ALL.push(k);
                RULES.all[k] = true;
              });
            }
            ALL.push(keyword);
            var rule = RULES.all[keyword] = {
              keyword,
              code: ruleModules[keyword],
              implements: implKeywords
            };
            return rule;
          });
          RULES.all.$comment = {
            keyword: "$comment",
            code: ruleModules.$comment
          };
          if (group.type) RULES.types[group.type] = group;
        });
        RULES.keywords = toHash(ALL.concat(KEYWORDS));
        RULES.custom = {};
        return RULES;
      };
    }
  });

  // ../../node_modules/ajv/lib/data.js
  var require_data = __commonJS({
    "../../node_modules/ajv/lib/data.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var KEYWORDS = [
        "multipleOf",
        "maximum",
        "exclusiveMaximum",
        "minimum",
        "exclusiveMinimum",
        "maxLength",
        "minLength",
        "pattern",
        "additionalItems",
        "maxItems",
        "minItems",
        "uniqueItems",
        "maxProperties",
        "minProperties",
        "required",
        "additionalProperties",
        "enum",
        "format",
        "const"
      ];
      module.exports = function(metaSchema, keywordsJsonPointers) {
        for (var i = 0; i < keywordsJsonPointers.length; i++) {
          metaSchema = JSON.parse(JSON.stringify(metaSchema));
          var segments = keywordsJsonPointers[i].split("/");
          var keywords = metaSchema;
          var j;
          for (j = 1; j < segments.length; j++)
            keywords = keywords[segments[j]];
          for (j = 0; j < KEYWORDS.length; j++) {
            var key = KEYWORDS[j];
            var schema = keywords[key];
            if (schema) {
              keywords[key] = {
                anyOf: [
                  schema,
                  { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
          }
        }
        return metaSchema;
      };
    }
  });

  // ../../node_modules/ajv/lib/compile/async.js
  var require_async = __commonJS({
    "../../node_modules/ajv/lib/compile/async.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var MissingRefError = require_error_classes().MissingRef;
      module.exports = compileAsync;
      function compileAsync(schema, meta, callback) {
        var self2 = this;
        if (typeof this._opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        if (typeof meta == "function") {
          callback = meta;
          meta = void 0;
        }
        var p = loadMetaSchemaOf(schema).then(function() {
          var schemaObj = self2._addSchema(schema, void 0, meta);
          return schemaObj.validate || _compileAsync(schemaObj);
        });
        if (callback) {
          p.then(
            function(v) {
              callback(null, v);
            },
            callback
          );
        }
        return p;
        function loadMetaSchemaOf(sch) {
          var $schema = sch.$schema;
          return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
        }
        function _compileAsync(schemaObj) {
          try {
            return self2._compile(schemaObj);
          } catch (e) {
            if (e instanceof MissingRefError) return loadMissingSchema(e);
            throw e;
          }
          function loadMissingSchema(e) {
            var ref = e.missingSchema;
            if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
            var schemaPromise = self2._loadingSchemas[ref];
            if (!schemaPromise) {
              schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
              schemaPromise.then(removePromise, removePromise);
            }
            return schemaPromise.then(function(sch) {
              if (!added(ref)) {
                return loadMetaSchemaOf(sch).then(function() {
                  if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
                });
              }
            }).then(function() {
              return _compileAsync(schemaObj);
            });
            function removePromise() {
              delete self2._loadingSchemas[ref];
            }
            function added(ref2) {
              return self2._refs[ref2] || self2._schemas[ref2];
            }
          }
        }
      }
    }
  });

  // ../../node_modules/ajv/lib/dotjs/custom.js
  var require_custom = __commonJS({
    "../../node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      module.exports = function generate_custom(it, $keyword, $ruleType) {
        var out = " ";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        var $errs = "errs__" + $lvl;
        var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
        if ($isData) {
          out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
          $schemaValue = "schema" + $lvl;
        } else {
          $schemaValue = $schema;
        }
        var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
        var $compile, $inline, $macro, $ruleValidate, $validateCode;
        if ($isData && $rDef.$data) {
          $validateCode = "keywordValidate" + $lvl;
          var $validateSchema = $rDef.validateSchema;
          out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
        } else {
          $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
          if (!$ruleValidate) return;
          $schemaValue = "validate.schema" + $schemaPath;
          $validateCode = $ruleValidate.code;
          $compile = $rDef.compile;
          $inline = $rDef.inline;
          $macro = $rDef.macro;
        }
        var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
        if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
        if (!($inline || $macro)) {
          out += "" + $ruleErrs + " = null;";
        }
        out += "var " + $errs + " = errors;var " + $valid + ";";
        if ($isData && $rDef.$data) {
          $closingBraces += "}";
          out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
          if ($validateSchema) {
            $closingBraces += "}";
            out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
          }
        }
        if ($inline) {
          if ($rDef.statements) {
            out += " " + $ruleValidate.validate + " ";
          } else {
            out += " " + $valid + " = " + $ruleValidate.validate + "; ";
          }
        } else if ($macro) {
          var $it = it.util.copy(it);
          var $closingBraces = "";
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $ruleValidate.validate;
          $it.schemaPath = "";
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += " " + $code;
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          out += "  " + $validateCode + ".call( ";
          if (it.opts.passContext) {
            out += "this";
          } else {
            out += "self";
          }
          if ($compile || $rDef.schema === false) {
            out += " , " + $data + " ";
          } else {
            out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
          }
          out += " , (dataPath || '')";
          if (it.errorPath != '""') {
            out += " + " + it.errorPath;
          }
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
          var def_callRuleValidate = out;
          out = $$outStack.pop();
          if ($rDef.errors === false) {
            out += " " + $valid + " = ";
            if ($asyncKeyword) {
              out += "await ";
            }
            out += "" + def_callRuleValidate + "; ";
          } else {
            if ($asyncKeyword) {
              $ruleErrs = "customErrors" + $lvl;
              out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
            } else {
              out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
            }
          }
        }
        if ($rDef.modifying) {
          out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
        }
        out += "" + $closingBraces;
        if ($rDef.valid) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          out += " if ( ";
          if ($rDef.valid === void 0) {
            out += " !";
            if ($macro) {
              out += "" + $nextValid;
            } else {
              out += "" + $valid;
            }
          } else {
            out += " " + !$rDef.valid + " ";
          }
          out += ") { ";
          $errorKeyword = $rule.keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          var def_customError = out;
          out = $$outStack.pop();
          if ($inline) {
            if ($rDef.errors) {
              if ($rDef.errors != "full") {
                out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } ";
              }
            } else {
              if ($rDef.errors === false) {
                out += " " + def_customError + " ";
              } else {
                out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
                if (it.opts.verbose) {
                  out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
                }
                out += " } } ";
              }
            }
          } else if ($macro) {
            out += "   var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
              if (it.opts.messages !== false) {
                out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError(vErrors); ";
              } else {
                out += " validate.errors = vErrors; return false; ";
              }
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } else { " + def_customError + " } ";
            }
          }
          out += " } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
        return out;
      };
    }
  });

  // ../../node_modules/ajv/lib/refs/json-schema-draft-07.json
  var require_json_schema_draft_07 = __commonJS({
    "../../node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [
              { $ref: "#/definitions/nonNegativeInteger" },
              { default: 0 }
            ]
          },
          simpleTypes: {
            enum: [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/schemaArray" }
            ],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [
                { $ref: "#" },
                { $ref: "#/definitions/stringArray" }
              ]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });

  // ../../node_modules/ajv/lib/definition_schema.js
  var require_definition_schema = __commonJS({
    "../../node_modules/ajv/lib/definition_schema.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var metaSchema = require_json_schema_draft_07();
      module.exports = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {
          simpleTypes: metaSchema.definitions.simpleTypes
        },
        type: "object",
        dependencies: {
          schema: ["validate"],
          $data: ["validate"],
          statements: ["inline"],
          valid: { not: { required: ["macro"] } }
        },
        properties: {
          type: metaSchema.properties.type,
          schema: { type: "boolean" },
          statements: { type: "boolean" },
          dependencies: {
            type: "array",
            items: { type: "string" }
          },
          metaSchema: { type: "object" },
          modifying: { type: "boolean" },
          valid: { type: "boolean" },
          $data: { type: "boolean" },
          async: { type: "boolean" },
          errors: {
            anyOf: [
              { type: "boolean" },
              { const: "full" }
            ]
          }
        }
      };
    }
  });

  // ../../node_modules/ajv/lib/keyword.js
  var require_keyword = __commonJS({
    "../../node_modules/ajv/lib/keyword.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
      var customRuleCode = require_custom();
      var definitionSchema = require_definition_schema();
      module.exports = {
        add: addKeyword,
        get: getKeyword,
        remove: removeKeyword,
        validate: validateKeyword
      };
      function addKeyword(keyword, definition3) {
        var RULES = this.RULES;
        if (RULES.keywords[keyword])
          throw new Error("Keyword " + keyword + " is already defined");
        if (!IDENTIFIER.test(keyword))
          throw new Error("Keyword " + keyword + " is not a valid identifier");
        if (definition3) {
          this.validateKeyword(definition3, true);
          var dataType = definition3.type;
          if (Array.isArray(dataType)) {
            for (var i = 0; i < dataType.length; i++)
              _addRule(keyword, dataType[i], definition3);
          } else {
            _addRule(keyword, dataType, definition3);
          }
          var metaSchema = definition3.metaSchema;
          if (metaSchema) {
            if (definition3.$data && this._opts.$data) {
              metaSchema = {
                anyOf: [
                  metaSchema,
                  { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
                ]
              };
            }
            definition3.validateSchema = this.compile(metaSchema, true);
          }
        }
        RULES.keywords[keyword] = RULES.all[keyword] = true;
        function _addRule(keyword2, dataType2, definition4) {
          var ruleGroup;
          for (var i2 = 0; i2 < RULES.length; i2++) {
            var rg = RULES[i2];
            if (rg.type == dataType2) {
              ruleGroup = rg;
              break;
            }
          }
          if (!ruleGroup) {
            ruleGroup = { type: dataType2, rules: [] };
            RULES.push(ruleGroup);
          }
          var rule = {
            keyword: keyword2,
            definition: definition4,
            custom: true,
            code: customRuleCode,
            implements: definition4.implements
          };
          ruleGroup.rules.push(rule);
          RULES.custom[keyword2] = rule;
        }
        return this;
      }
      function getKeyword(keyword) {
        var rule = this.RULES.custom[keyword];
        return rule ? rule.definition : this.RULES.keywords[keyword] || false;
      }
      function removeKeyword(keyword) {
        var RULES = this.RULES;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        delete RULES.custom[keyword];
        for (var i = 0; i < RULES.length; i++) {
          var rules = RULES[i].rules;
          for (var j = 0; j < rules.length; j++) {
            if (rules[j].keyword == keyword) {
              rules.splice(j, 1);
              break;
            }
          }
        }
        return this;
      }
      function validateKeyword(definition3, throwError) {
        validateKeyword.errors = null;
        var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
        if (v(definition3)) return true;
        validateKeyword.errors = v.errors;
        if (throwError)
          throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
        else
          return false;
      }
    }
  });

  // ../../node_modules/ajv/lib/refs/data.json
  var require_data2 = __commonJS({
    "../../node_modules/ajv/lib/refs/data.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON Schema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
          $data: {
            type: "string",
            anyOf: [
              { format: "relative-json-pointer" },
              { format: "json-pointer" }
            ]
          }
        },
        additionalProperties: false
      };
    }
  });

  // ../../node_modules/ajv/lib/ajv.js
  var require_ajv = __commonJS({
    "../../node_modules/ajv/lib/ajv.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var compileSchema = require_compile();
      var resolve = require_resolve();
      var Cache = require_cache();
      var SchemaObject = require_schema_obj();
      var stableStringify = require_fast_json_stable_stringify();
      var formats = require_formats();
      var rules = require_rules();
      var $dataMetaSchema = require_data();
      var util2 = require_util();
      module.exports = Ajv2;
      Ajv2.prototype.validate = validate;
      Ajv2.prototype.compile = compile2;
      Ajv2.prototype.addSchema = addSchema;
      Ajv2.prototype.addMetaSchema = addMetaSchema;
      Ajv2.prototype.validateSchema = validateSchema;
      Ajv2.prototype.getSchema = getSchema;
      Ajv2.prototype.removeSchema = removeSchema;
      Ajv2.prototype.addFormat = addFormat2;
      Ajv2.prototype.errorsText = errorsText;
      Ajv2.prototype._addSchema = _addSchema;
      Ajv2.prototype._compile = _compile;
      Ajv2.prototype.compileAsync = require_async();
      var customKeyword = require_keyword();
      Ajv2.prototype.addKeyword = customKeyword.add;
      Ajv2.prototype.getKeyword = customKeyword.get;
      Ajv2.prototype.removeKeyword = customKeyword.remove;
      Ajv2.prototype.validateKeyword = customKeyword.validate;
      var errorClasses = require_error_classes();
      Ajv2.ValidationError = errorClasses.Validation;
      Ajv2.MissingRefError = errorClasses.MissingRef;
      Ajv2.$dataMetaSchema = $dataMetaSchema;
      var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
      var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
      var META_SUPPORT_DATA = ["/properties"];
      function Ajv2(opts) {
        if (!(this instanceof Ajv2)) return new Ajv2(opts);
        opts = this._opts = util2.copy(opts) || {};
        setLogger(this);
        this._schemas = {};
        this._refs = {};
        this._fragments = {};
        this._formats = formats(opts.format);
        this._cache = opts.cache || new Cache();
        this._loadingSchemas = {};
        this._compilations = [];
        this.RULES = rules();
        this._getId = chooseGetId(opts);
        opts.loopRequired = opts.loopRequired || Infinity;
        if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
        if (opts.serialize === void 0) opts.serialize = stableStringify;
        this._metaOpts = getMetaSchemaOptions(this);
        if (opts.formats) addInitialFormats(this);
        if (opts.keywords) addInitialKeywords(this);
        addDefaultMetaSchema(this);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
        addInitialSchemas(this);
      }
      function validate(schemaKeyRef, data2) {
        var v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
        } else {
          var schemaObj = this._addSchema(schemaKeyRef);
          v = schemaObj.validate || this._compile(schemaObj);
        }
        var valid2 = v(data2);
        if (v.$async !== true) this.errors = v.errors;
        return valid2;
      }
      function compile2(schema, _meta) {
        var schemaObj = this._addSchema(schema, void 0, _meta);
        return schemaObj.validate || this._compile(schemaObj);
      }
      function addSchema(schema, key, _skipValidation, _meta) {
        if (Array.isArray(schema)) {
          for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
          return this;
        }
        var id = this._getId(schema);
        if (id !== void 0 && typeof id != "string")
          throw new Error("schema id must be string");
        key = resolve.normalizeId(key || id);
        checkUnique(this, key);
        this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
        return this;
      }
      function addMetaSchema(schema, key, skipValidation) {
        this.addSchema(schema, key, skipValidation, true);
        return this;
      }
      function validateSchema(schema, throwOrLogError) {
        var $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        var valid2 = this.validate($schema, schema);
        if (!valid2 && throwOrLogError) {
          var message = "schema is invalid: " + this.errorsText();
          if (this._opts.validateSchema == "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid2;
      }
      function defaultMeta(self2) {
        var meta = self2._opts.meta;
        self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
        return self2._opts.defaultMeta;
      }
      function getSchema(keyRef) {
        var schemaObj = _getSchemaObj(this, keyRef);
        switch (typeof schemaObj) {
          case "object":
            return schemaObj.validate || this._compile(schemaObj);
          case "string":
            return this.getSchema(schemaObj);
          case "undefined":
            return _getSchemaFragment(this, keyRef);
        }
      }
      function _getSchemaFragment(self2, ref) {
        var res = resolve.schema.call(self2, { schema: {} }, ref);
        if (res) {
          var schema = res.schema, root5 = res.root, baseId = res.baseId;
          var v = compileSchema.call(self2, schema, root5, void 0, baseId);
          self2._fragments[ref] = new SchemaObject({
            ref,
            fragment: true,
            schema,
            root: root5,
            baseId,
            validate: v
          });
          return v;
        }
      }
      function _getSchemaObj(self2, keyRef) {
        keyRef = resolve.normalizeId(keyRef);
        return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
      }
      function removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          _removeAllSchemas(this, this._schemas, schemaKeyRef);
          _removeAllSchemas(this, this._refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            _removeAllSchemas(this, this._schemas);
            _removeAllSchemas(this, this._refs);
            this._cache.clear();
            return this;
          case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            if (schemaObj) this._cache.del(schemaObj.cacheKey);
            delete this._schemas[schemaKeyRef];
            delete this._refs[schemaKeyRef];
            return this;
          case "object":
            var serialize5 = this._opts.serialize;
            var cacheKey = serialize5 ? serialize5(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            if (id) {
              id = resolve.normalizeId(id);
              delete this._schemas[id];
              delete this._refs[id];
            }
        }
        return this;
      }
      function _removeAllSchemas(self2, schemas, regex2) {
        for (var keyRef in schemas) {
          var schemaObj = schemas[keyRef];
          if (!schemaObj.meta && (!regex2 || regex2.test(keyRef))) {
            self2._cache.del(schemaObj.cacheKey);
            delete schemas[keyRef];
          }
        }
      }
      function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
        if (typeof schema != "object" && typeof schema != "boolean")
          throw new Error("schema should be object or boolean");
        var serialize5 = this._opts.serialize;
        var cacheKey = serialize5 ? serialize5(schema) : schema;
        var cached = this._cache.get(cacheKey);
        if (cached) return cached;
        shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
        var id = resolve.normalizeId(this._getId(schema));
        if (id && shouldAddSchema) checkUnique(this, id);
        var willValidate = this._opts.validateSchema !== false && !skipValidation;
        var recursiveMeta;
        if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
          this.validateSchema(schema, true);
        var localRefs = resolve.ids.call(this, schema);
        var schemaObj = new SchemaObject({
          id,
          schema,
          localRefs,
          cacheKey,
          meta
        });
        if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
        this._cache.put(cacheKey, schemaObj);
        if (willValidate && recursiveMeta) this.validateSchema(schema, true);
        return schemaObj;
      }
      function _compile(schemaObj, root5) {
        if (schemaObj.compiling) {
          schemaObj.validate = callValidate;
          callValidate.schema = schemaObj.schema;
          callValidate.errors = null;
          callValidate.root = root5 ? root5 : callValidate;
          if (schemaObj.schema.$async === true)
            callValidate.$async = true;
          return callValidate;
        }
        schemaObj.compiling = true;
        var currentOpts;
        if (schemaObj.meta) {
          currentOpts = this._opts;
          this._opts = this._metaOpts;
        }
        var v;
        try {
          v = compileSchema.call(this, schemaObj.schema, root5, schemaObj.localRefs);
        } catch (e) {
          delete schemaObj.validate;
          throw e;
        } finally {
          schemaObj.compiling = false;
          if (schemaObj.meta) this._opts = currentOpts;
        }
        schemaObj.validate = v;
        schemaObj.refs = v.refs;
        schemaObj.refVal = v.refVal;
        schemaObj.root = v.root;
        return v;
        function callValidate() {
          var _validate = schemaObj.validate;
          var result = _validate.apply(this, arguments);
          callValidate.errors = _validate.errors;
          return result;
        }
      }
      function chooseGetId(opts) {
        switch (opts.schemaId) {
          case "auto":
            return _get$IdOrId;
          case "id":
            return _getId;
          default:
            return _get$Id;
        }
      }
      function _getId(schema) {
        if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
        return schema.id;
      }
      function _get$Id(schema) {
        if (schema.id) this.logger.warn("schema id ignored", schema.id);
        return schema.$id;
      }
      function _get$IdOrId(schema) {
        if (schema.$id && schema.id && schema.$id != schema.id)
          throw new Error("schema $id is different from id");
        return schema.$id || schema.id;
      }
      function errorsText(errors, options) {
        errors = errors || this.errors;
        if (!errors) return "No errors";
        options = options || {};
        var separator = options.separator === void 0 ? ", " : options.separator;
        var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
        var text9 = "";
        for (var i = 0; i < errors.length; i++) {
          var e = errors[i];
          if (e) text9 += dataVar + e.dataPath + " " + e.message + separator;
        }
        return text9.slice(0, -separator.length);
      }
      function addFormat2(name21, format) {
        if (typeof format == "string") format = new RegExp(format);
        this._formats[name21] = format;
        return this;
      }
      function addDefaultMetaSchema(self2) {
        var $dataSchema;
        if (self2._opts.$data) {
          $dataSchema = require_data2();
          self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
        }
        if (self2._opts.meta === false) return;
        var metaSchema = require_json_schema_draft_07();
        if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
        self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
        self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      function addInitialSchemas(self2) {
        var optsSchemas = self2._opts.schemas;
        if (!optsSchemas) return;
        if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
        else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
      }
      function addInitialFormats(self2) {
        for (var name21 in self2._opts.formats) {
          var format = self2._opts.formats[name21];
          self2.addFormat(name21, format);
        }
      }
      function addInitialKeywords(self2) {
        for (var name21 in self2._opts.keywords) {
          var keyword = self2._opts.keywords[name21];
          self2.addKeyword(name21, keyword);
        }
      }
      function checkUnique(self2, id) {
        if (self2._schemas[id] || self2._refs[id])
          throw new Error('schema with key or id "' + id + '" already exists');
      }
      function getMetaSchemaOptions(self2) {
        var metaOpts = util2.copy(self2._opts);
        for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
          delete metaOpts[META_IGNORE_OPTIONS[i]];
        return metaOpts;
      }
      function setLogger(self2) {
        var logger = self2._opts.logger;
        if (logger === false) {
          self2.logger = { log: noop5, warn: noop5, error: noop5 };
        } else {
          if (logger === void 0) logger = console;
          if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
            throw new Error("logger must implement log, warn and error methods");
          self2.logger = logger;
        }
      }
      function noop5() {
      }
    }
  });

  // ../../node_modules/inline-style-parser/index.js
  var require_inline_style_parser = __commonJS({
    "../../node_modules/inline-style-parser/index.js"(exports, module) {
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
      var NEWLINE_REGEX = /\n/g;
      var WHITESPACE_REGEX = /^\s*/;
      var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
      var COLON_REGEX = /^:\s*/;
      var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
      var SEMICOLON_REGEX = /^[;\s]*/;
      var TRIM_REGEX = /^\s+|\s+$/g;
      var NEWLINE = "\n";
      var FORWARD_SLASH = "/";
      var ASTERISK = "*";
      var EMPTY_STRING = "";
      var TYPE_COMMENT = "comment";
      var TYPE_DECLARATION = "declaration";
      module.exports = function(style, options) {
        if (typeof style !== "string") {
          throw new TypeError("First argument must be a string");
        }
        if (!style) return [];
        options = options || {};
        var lineno = 1;
        var column2 = 1;
        function updatePosition(str) {
          var lines = str.match(NEWLINE_REGEX);
          if (lines) lineno += lines.length;
          var i = str.lastIndexOf(NEWLINE);
          column2 = ~i ? str.length - i : column2 + str.length;
        }
        function position4() {
          var start2 = { line: lineno, column: column2 };
          return function(node3) {
            node3.position = new Position(start2);
            whitespace3();
            return node3;
          };
        }
        function Position(start2) {
          this.start = start2;
          this.end = { line: lineno, column: column2 };
          this.source = options.source;
        }
        Position.prototype.content = style;
        var errorsList = [];
        function error(msg) {
          var err = new Error(
            options.source + ":" + lineno + ":" + column2 + ": " + msg
          );
          err.reason = msg;
          err.filename = options.source;
          err.line = lineno;
          err.column = column2;
          err.source = style;
          if (options.silent) {
            errorsList.push(err);
          } else {
            throw err;
          }
        }
        function match2(re2) {
          var m = re2.exec(style);
          if (!m) return;
          var str = m[0];
          updatePosition(str);
          style = style.slice(str.length);
          return m;
        }
        function whitespace3() {
          match2(WHITESPACE_REGEX);
        }
        function comments(rules) {
          var c;
          rules = rules || [];
          while (c = comment3()) {
            if (c !== false) {
              rules.push(c);
            }
          }
          return rules;
        }
        function comment3() {
          var pos = position4();
          if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
          var i = 2;
          while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
            ++i;
          }
          i += 2;
          if (EMPTY_STRING === style.charAt(i - 1)) {
            return error("End of comment missing");
          }
          var str = style.slice(2, i - 2);
          column2 += 2;
          updatePosition(str);
          style = style.slice(i);
          column2 += 2;
          return pos({
            type: TYPE_COMMENT,
            comment: str
          });
        }
        function declaration2() {
          var pos = position4();
          var prop = match2(PROPERTY_REGEX);
          if (!prop) return;
          comment3();
          if (!match2(COLON_REGEX)) return error("property missing ':'");
          var val = match2(VALUE_REGEX);
          var ret = pos({
            type: TYPE_DECLARATION,
            property: trim2(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
            value: val ? trim2(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
          });
          match2(SEMICOLON_REGEX);
          return ret;
        }
        function declarations() {
          var decls = [];
          comments(decls);
          var decl;
          while (decl = declaration2()) {
            if (decl !== false) {
              decls.push(decl);
              comments(decls);
            }
          }
          return decls;
        }
        whitespace3();
        return declarations();
      };
      function trim2(str) {
        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
      }
    }
  });

  // ../../node_modules/style-to-object/cjs/index.js
  var require_cjs = __commonJS({
    "../../node_modules/style-to-object/cjs/index.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = StyleToObject;
      var inline_style_parser_1 = __importDefault(require_inline_style_parser());
      function StyleToObject(style, iterator) {
        var styleObject = null;
        if (!style || typeof style !== "string") {
          return styleObject;
        }
        var declarations = (0, inline_style_parser_1.default)(style);
        var hasIterator = typeof iterator === "function";
        declarations.forEach(function(declaration2) {
          if (declaration2.type !== "declaration") {
            return;
          }
          var property = declaration2.property, value = declaration2.value;
          if (hasIterator) {
            iterator(property, value, declaration2);
          } else if (value) {
            styleObject = styleObject || {};
            styleObject[property] = value;
          }
        });
        return styleObject;
      }
    }
  });

  // ../../node_modules/style-to-js/cjs/utilities.js
  var require_utilities = __commonJS({
    "../../node_modules/style-to-js/cjs/utilities.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.camelCase = void 0;
      var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
      var HYPHEN_REGEX = /-([a-z])/g;
      var NO_HYPHEN_REGEX = /^[^-]+$/;
      var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
      var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
      var skipCamelCase = function(property) {
        return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
      };
      var capitalize = function(match2, character2) {
        return character2.toUpperCase();
      };
      var trimHyphen = function(match2, prefix2) {
        return "".concat(prefix2, "-");
      };
      var camelCase = function(property, options) {
        if (options === void 0) {
          options = {};
        }
        if (skipCamelCase(property)) {
          return property;
        }
        property = property.toLowerCase();
        if (options.reactCompat) {
          property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
        } else {
          property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
        }
        return property.replace(HYPHEN_REGEX, capitalize);
      };
      exports.camelCase = camelCase;
    }
  });

  // ../../node_modules/style-to-js/cjs/index.js
  var require_cjs2 = __commonJS({
    "../../node_modules/style-to-js/cjs/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      var style_to_object_1 = __importDefault(require_cjs());
      var utilities_1 = require_utilities();
      function StyleToJS(style, options) {
        var output = {};
        if (!style || typeof style !== "string") {
          return output;
        }
        (0, style_to_object_1.default)(style, function(property, value) {
          if (property && value) {
            output[(0, utilities_1.camelCase)(property, options)] = value;
          }
        });
        return output;
      }
      StyleToJS.default = StyleToJS;
      module.exports = StyleToJS;
    }
  });

  // ../../node_modules/extend/index.js
  var require_extend = __commonJS({
    "../../node_modules/extend/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var hasOwn = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;
      var isArray = function isArray2(arr) {
        if (typeof Array.isArray === "function") {
          return Array.isArray(arr);
        }
        return toStr.call(arr) === "[object Array]";
      };
      var isPlainObject2 = function isPlainObject3(obj) {
        if (!obj || toStr.call(obj) !== "[object Object]") {
          return false;
        }
        var hasOwnConstructor = hasOwn.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        var key;
        for (key in obj) {
        }
        return typeof key === "undefined" || hasOwn.call(obj, key);
      };
      var setProperty = function setProperty2(target, options) {
        if (defineProperty && options.name === "__proto__") {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      };
      var getProperty = function getProperty2(obj, name21) {
        if (name21 === "__proto__") {
          if (!hasOwn.call(obj, name21)) {
            return void 0;
          } else if (gOPD) {
            return gOPD(obj, name21).value;
          }
        }
        return obj[name21];
      };
      module.exports = function extend2() {
        var options, name21, src, copy2, copyIsArray, clone;
        var target = arguments[0];
        var i = 1;
        var length2 = arguments.length;
        var deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (target == null || typeof target !== "object" && typeof target !== "function") {
          target = {};
        }
        for (; i < length2; ++i) {
          options = arguments[i];
          if (options != null) {
            for (name21 in options) {
              src = getProperty(target, name21);
              copy2 = getProperty(options, name21);
              if (target !== copy2) {
                if (deep && copy2 && (isPlainObject2(copy2) || (copyIsArray = isArray(copy2)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray(src) ? src : [];
                  } else {
                    clone = src && isPlainObject2(src) ? src : {};
                  }
                  setProperty(target, { name: name21, newValue: extend2(deep, clone, copy2) });
                } else if (typeof copy2 !== "undefined") {
                  setProperty(target, { name: name21, newValue: copy2 });
                }
              }
            }
          }
        }
        return target;
      };
    }
  });

  // ../../node_modules/react-is/cjs/react-is.production.min.js
  var require_react_is_production_min = __commonJS({
    "../../node_modules/react-is/cjs/react-is.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var b = 60103;
      var c = 60106;
      var d = 60107;
      var e = 60108;
      var f = 60114;
      var g = 60109;
      var h = 60110;
      var k = 60112;
      var l = 60113;
      var m = 60120;
      var n = 60115;
      var p = 60116;
      var q = 60121;
      var r = 60122;
      var u = 60117;
      var v = 60129;
      var w = 60131;
      if ("function" === typeof Symbol && Symbol.for) {
        x = Symbol.for;
        b = x("react.element");
        c = x("react.portal");
        d = x("react.fragment");
        e = x("react.strict_mode");
        f = x("react.profiler");
        g = x("react.provider");
        h = x("react.context");
        k = x("react.forward_ref");
        l = x("react.suspense");
        m = x("react.suspense_list");
        n = x("react.memo");
        p = x("react.lazy");
        q = x("react.block");
        r = x("react.server.block");
        u = x("react.fundamental");
        v = x("react.debug_trace_mode");
        w = x("react.legacy_hidden");
      }
      var x;
      function y(a) {
        if ("object" === typeof a && null !== a) {
          var t = a.$$typeof;
          switch (t) {
            case b:
              switch (a = a.type, a) {
                case d:
                case f:
                case e:
                case l:
                case m:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case h:
                    case k:
                    case p:
                    case n:
                    case g:
                      return a;
                    default:
                      return t;
                  }
              }
            case c:
              return t;
          }
        }
      }
      var z = g;
      var A = b;
      var B = k;
      var C = d;
      var D = p;
      var E = n;
      var F = c;
      var G = f;
      var H = e;
      var I = l;
      exports.ContextConsumer = h;
      exports.ContextProvider = z;
      exports.Element = A;
      exports.ForwardRef = B;
      exports.Fragment = C;
      exports.Lazy = D;
      exports.Memo = E;
      exports.Portal = F;
      exports.Profiler = G;
      exports.StrictMode = H;
      exports.Suspense = I;
      exports.isAsyncMode = function() {
        return false;
      };
      exports.isConcurrentMode = function() {
        return false;
      };
      exports.isContextConsumer = function(a) {
        return y(a) === h;
      };
      exports.isContextProvider = function(a) {
        return y(a) === g;
      };
      exports.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === b;
      };
      exports.isForwardRef = function(a) {
        return y(a) === k;
      };
      exports.isFragment = function(a) {
        return y(a) === d;
      };
      exports.isLazy = function(a) {
        return y(a) === p;
      };
      exports.isMemo = function(a) {
        return y(a) === n;
      };
      exports.isPortal = function(a) {
        return y(a) === c;
      };
      exports.isProfiler = function(a) {
        return y(a) === f;
      };
      exports.isStrictMode = function(a) {
        return y(a) === e;
      };
      exports.isSuspense = function(a) {
        return y(a) === l;
      };
      exports.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === d || a === f || a === v || a === e || a === l || a === m || a === w || "object" === typeof a && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === u || a.$$typeof === q || a[0] === r) ? true : false;
      };
      exports.typeOf = y;
    }
  });

  // ../../node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "../../node_modules/react-is/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_react_is_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min2 = __commonJS({
    "../../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      function f(a, b) {
        var c = a.length;
        a.push(b);
        a: for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
          else break a;
        }
      }
      function h(a) {
        return 0 === a.length ? null : a[0];
      }
      function k(a) {
        if (0 === a.length) return null;
        var b = a[0], c = a.pop();
        if (c !== b) {
          a[0] = c;
          a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
            else break a;
          }
        }
        return b;
      }
      function g(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      var r = [];
      var t = [];
      var u = 1;
      var v = null;
      var y = 3;
      var z = false;
      var A = false;
      var B = false;
      var D = "function" === typeof setTimeout ? setTimeout : null;
      var E = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a) {
        for (var b = h(t); null !== b; ) {
          if (null === b.callback) k(t);
          else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
          else break;
          b = h(t);
        }
      }
      function H(a) {
        B = false;
        G(a);
        if (!A) if (null !== h(r)) A = true, I(J);
        else {
          var b = h(t);
          null !== b && K(H, b.startTime - a);
        }
      }
      function J(a, b) {
        A = false;
        B && (B = false, E(L), L = -1);
        z = true;
        var c = y;
        try {
          G(b);
          for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
            var d = v.callback;
            if ("function" === typeof d) {
              v.callback = null;
              y = v.priorityLevel;
              var e = d(v.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? v.callback = e : v === h(r) && k(r);
              G(b);
            } else k(r);
            v = h(r);
          }
          if (null !== v) var w = true;
          else {
            var m = h(t);
            null !== m && K(H, m.startTime - b);
            w = false;
          }
          return w;
        } finally {
          v = null, y = c, z = false;
        }
      }
      var N = false;
      var O = null;
      var L = -1;
      var P = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P ? false : true;
      }
      function R() {
        if (null !== O) {
          var a = exports.unstable_now();
          Q = a;
          var b = true;
          try {
            b = O(true, a);
          } finally {
            b ? S() : (N = false, O = null);
          }
        } else N = false;
      }
      var S;
      if ("function" === typeof F) S = function() {
        F(R);
      };
      else if ("undefined" !== typeof MessageChannel) {
        T = new MessageChannel(), U = T.port2;
        T.port1.onmessage = R;
        S = function() {
          U.postMessage(null);
        };
      } else S = function() {
        D(R, 0);
      };
      var T;
      var U;
      function I(a) {
        O = a;
        N || (N = true, S());
      }
      function K(a, b) {
        L = D(function() {
          a(exports.unstable_now());
        }, b);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A || z || (A = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h(r);
      };
      exports.unstable_next = function(a) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y;
        }
        var c = y;
        y = b;
        try {
          return a();
        } finally {
          y = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = y;
        y = a;
        try {
          return b();
        } finally {
          y = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
        return a;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a) {
        var b = y;
        return function() {
          var c = y;
          y = b;
          try {
            return a.apply(this, arguments);
          } finally {
            y = c;
          }
        };
      };
    }
  });

  // ../../node_modules/scheduler/index.js
  var require_scheduler2 = __commonJS({
    "../../node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      if (true) {
        module.exports = require_scheduler_production_min2();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../node_modules/lodash.debounce/index.js
  var require_lodash = __commonJS({
    "../../node_modules/lodash.debounce/index.js"(exports, module) {
      init_define_DEFAULT_MCP_SERVER_LIST_URLS();
      init_define_MSAL_SCOPES();
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root5 = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now2 = function() {
        return root5.Date.now();
      };
      function debounce3(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isObject3(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = debounce3;
    }
  });

  // src/main.tsx
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_client2 = __toESM(require_client());

  // ../../node_modules/react-router/dist/development/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/react-router/dist/development/chunk-DQRVZFIR.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React3 = __toESM(require_react(), 1);
  var React = __toESM(require_react(), 1);
  var React2 = __toESM(require_react(), 1);
  var React10 = __toESM(require_react(), 1);
  var React9 = __toESM(require_react(), 1);
  var React4 = __toESM(require_react(), 1);
  var React8 = __toESM(require_react(), 1);
  var React7 = __toESM(require_react(), 1);
  var React5 = __toESM(require_react(), 1);
  var React6 = __toESM(require_react(), 1);
  var React11 = __toESM(require_react(), 1);
  var React12 = __toESM(require_react(), 1);
  var React13 = __toESM(require_react(), 1);
  var import_cookie = __toESM(require_dist(), 1);
  var import_meta = {};
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var PopStateEventType = "popstate";
  function createBrowserHistory(options = {}) {
    function createBrowserLocation(window2, globalHistory) {
      let { pathname, search: search2, hash: hash2 } = window2.location;
      return createLocation(
        "",
        { pathname, search: search2, hash: hash2 },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createBrowserHref(window2, to) {
      return typeof to === "string" ? to : createPath(to);
    }
    return getUrlBasedHistory(
      createBrowserLocation,
      createBrowserHref,
      null,
      options
    );
  }
  function invariant(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined") console.warn(message);
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substring(2, 10);
  }
  function getHistoryState(location, index2) {
    return {
      usr: location.state,
      key: location.key,
      idx: index2
    };
  }
  function createLocation(current, to, state = null, key) {
    let location = {
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: "",
      ...typeof to === "string" ? parsePath(to) : to,
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
    };
    return location;
  }
  function createPath({
    pathname = "/",
    search: search2 = "",
    hash: hash2 = ""
  }) {
    if (search2 && search2 !== "?")
      pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
    if (hash2 && hash2 !== "#")
      pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
    return pathname;
  }
  function parsePath(path2) {
    let parsedPath = {};
    if (path2) {
      let hashIndex = path2.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path2.substring(hashIndex);
        path2 = path2.substring(0, hashIndex);
      }
      let searchIndex = path2.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path2.substring(searchIndex);
        path2 = path2.substring(0, searchIndex);
      }
      if (path2) {
        parsedPath.pathname = path2;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
    let { window: window2 = document.defaultView, v5Compat = false } = options;
    let globalHistory = window2.history;
    let action = "POP";
    let listener = null;
    let index2 = getIndex();
    if (index2 == null) {
      index2 = 0;
      globalHistory.replaceState({ ...globalHistory.state, idx: index2 }, "");
    }
    function getIndex() {
      let state = globalHistory.state || { idx: null };
      return state.idx;
    }
    function handlePop() {
      action = "POP";
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index2;
      index2 = nextIndex;
      if (listener) {
        listener({ action, location: history.location, delta });
      }
    }
    function push2(to, state) {
      action = "PUSH";
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index2 = getIndex() + 1;
      let historyState = getHistoryState(location, index2);
      let url = history.createHref(location);
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        if (error instanceof DOMException && error.name === "DataCloneError") {
          throw error;
        }
        window2.location.assign(url);
      }
      if (v5Compat && listener) {
        listener({ action, location: history.location, delta: 1 });
      }
    }
    function replace22(to, state) {
      action = "REPLACE";
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index2 = getIndex();
      let historyState = getHistoryState(location, index2);
      let url = history.createHref(location);
      globalHistory.replaceState(historyState, "", url);
      if (v5Compat && listener) {
        listener({ action, location: history.location, delta: 0 });
      }
    }
    function createURL(to) {
      return createBrowserURLImpl(to);
    }
    let history = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener = null;
        };
      },
      createHref(to) {
        return createHref2(window2, to);
      },
      createURL,
      encodeLocation(to) {
        let url = createURL(to);
        return {
          pathname: url.pathname,
          search: url.search,
          hash: url.hash
        };
      },
      push: push2,
      replace: replace22,
      go(n) {
        return globalHistory.go(n);
      }
    };
    return history;
  }
  function createBrowserURLImpl(to, isAbsolute = false) {
    let base = "http://localhost";
    if (typeof window !== "undefined") {
      base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    }
    invariant(base, "No window.location.(origin|href) available to create URL");
    let href2 = typeof to === "string" ? to : createPath(to);
    href2 = href2.replace(/ $/, "%20");
    if (!isAbsolute && href2.startsWith("//")) {
      href2 = base + href2;
    }
    return new URL(href2, base);
  }
  var _map;
  var unstable_RouterContextProvider = class {
    constructor(init) {
      __privateAdd(this, _map, /* @__PURE__ */ new Map());
      if (init) {
        for (let [context, value] of init) {
          this.set(context, value);
        }
      }
    }
    get(context) {
      if (__privateGet(this, _map).has(context)) {
        return __privateGet(this, _map).get(context);
      }
      if (context.defaultValue !== void 0) {
        return context.defaultValue;
      }
      throw new Error("No value found for context");
    }
    set(context, value) {
      __privateGet(this, _map).set(context, value);
    }
  };
  _map = /* @__PURE__ */ new WeakMap();
  var unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([
    "lazy",
    "caseSensitive",
    "path",
    "id",
    "index",
    "children"
  ]);
  function isUnsupportedLazyRouteObjectKey(key) {
    return unsupportedLazyRouteObjectKeys.has(
      key
    );
  }
  var unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([
    "lazy",
    "caseSensitive",
    "path",
    "id",
    "index",
    "unstable_middleware",
    "children"
  ]);
  function isUnsupportedLazyRouteFunctionKey(key) {
    return unsupportedLazyRouteFunctionKeys.has(
      key
    );
  }
  function isIndexRoute(route) {
    return route.index === true;
  }
  function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
    return routes.map((route, index2) => {
      let treePath = [...parentPath, String(index2)];
      let id = typeof route.id === "string" ? route.id : treePath.join("-");
      invariant(
        route.index !== true || !route.children,
        `Cannot specify children on an index route`
      );
      invariant(
        !manifest[id],
        `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
      );
      if (isIndexRoute(route)) {
        let indexRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id
        };
        manifest[id] = indexRoute;
        return indexRoute;
      } else {
        let pathOrLayoutRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id,
          children: void 0
        };
        manifest[id] = pathOrLayoutRoute;
        if (route.children) {
          pathOrLayoutRoute.children = convertRoutesToDataRoutes(
            route.children,
            mapRouteProperties2,
            treePath,
            manifest
          );
        }
        return pathOrLayoutRoute;
      }
    });
  }
  function matchRoutes(routes, locationArg, basename2 = "/") {
    return matchRoutesImpl(routes, locationArg, basename2, false);
  }
  function matchRoutesImpl(routes, locationArg, basename2, allowPartial) {
    let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location.pathname || "/", basename2);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;
    for (let i = 0; matches == null && i < branches.length; ++i) {
      let decoded = decodePath(pathname);
      matches = matchRouteBranch(
        branches[i],
        decoded,
        allowPartial
      );
    }
    return matches;
  }
  function convertRouteMatchToUiMatch(match2, loaderData) {
    let { route, pathname, params } = match2;
    return {
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
    };
  }
  function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
    let flattenRoute = (route, index2, relativePath) => {
      let meta = {
        relativePath: relativePath === void 0 ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index2,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(
          meta.relativePath.startsWith(parentPath),
          `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
        );
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path2 = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          `Index routes must not have child routes. Please remove all child routes from route path "${path2}".`
        );
        flattenRoutes(route.children, branches, routesMeta, path2);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path: path2,
        score: computeScore(path2, route.index),
        routesMeta
      });
    };
    routes.forEach((route, index2) => {
      if (route.path === "" || !route.path?.includes("?")) {
        flattenRoute(route, index2);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index2, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path2) {
    let segments = path2.split("/");
    if (segments.length === 0) return [];
    let [first, ...rest] = segments;
    let isOptional = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(
      ...restExploded.map(
        (subpath) => subpath === "" ? required : [required, subpath].join("/")
      )
    );
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map(
      (exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded
    );
  }
  function rankRouteBranches(branches) {
    branches.sort(
      (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
        a.routesMeta.map((meta) => meta.childrenIndex),
        b.routesMeta.map((meta) => meta.childrenIndex)
      )
    );
  }
  var paramRe = /^:[\w-]+$/;
  var dynamicSegmentValue = 3;
  var indexRouteValue = 2;
  var emptySegmentValue = 1;
  var staticSegmentValue = 10;
  var splatPenalty = -2;
  var isSplat = (s) => s === "*";
  function computeScore(path2, index2) {
    let segments = path2.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index2) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s) => !isSplat(s)).reduce(
      (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
      initialScore
    );
  }
  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname, allowPartial = false) {
    let { routesMeta } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];
    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      let end = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match2 = matchPath(
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
        remainingPathname
      );
      let route = meta.route;
      if (!match2 && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
        match2 = matchPath(
          {
            path: meta.relativePath,
            caseSensitive: meta.caseSensitive,
            end: false
          },
          remainingPathname
        );
      }
      if (!match2) {
        return null;
      }
      Object.assign(matchedParams, match2.params);
      matches.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match2.pathname]),
        pathnameBase: normalizePathname(
          joinPaths([matchedPathname, match2.pathnameBase])
        ),
        route
      });
      if (match2.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
      }
    }
    return matches;
  }
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = { path: pattern, caseSensitive: false, end: true };
    }
    let [matcher, compiledParams] = compilePath(
      pattern.path,
      pattern.caseSensitive,
      pattern.end
    );
    let match2 = pathname.match(matcher);
    if (!match2) return null;
    let matchedPathname = match2[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match2.slice(1);
    let params = compiledParams.reduce(
      (memo22, { paramName, isOptional }, index2) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index2];
        if (isOptional && !value) {
          memo22[paramName] = void 0;
        } else {
          memo22[paramName] = (value || "").replace(/%2F/g, "/");
        }
        return memo22;
      },
      {}
    );
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }
  function compilePath(path2, caseSensitive = false, end = true) {
    warning(
      path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"),
      `Route path "${path2}" will be treated as if it were "${path2.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path2.replace(/\*$/, "/*")}".`
    );
    let params = [];
    let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
      /\/:([\w-]+)(\?)?/g,
      (_, paramName, isOptional) => {
        params.push({ paramName, isOptional: isOptional != null });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      }
    );
    if (path2.endsWith("*")) {
      params.push({ paramName: "*" });
      regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end) {
      regexpSource += "\\/*$";
    } else if (path2 !== "" && path2 !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else {
    }
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, params];
  }
  function decodePath(value) {
    try {
      return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
    } catch (error) {
      warning(
        false,
        `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
      );
      return value;
    }
  }
  function stripBasename(pathname, basename2) {
    if (basename2 === "/") return pathname;
    if (!pathname.toLowerCase().startsWith(basename2.toLowerCase())) {
      return null;
    }
    let startIndex = basename2.endsWith("/") ? basename2.length - 1 : basename2.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to, fromPathname = "/") {
    let {
      pathname: toPathname,
      search: search2 = "",
      hash: hash2 = ""
    } = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search2),
      hash: normalizeHash(hash2)
    };
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1) segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char2, field, dest, path2) {
    return `Cannot include a '${char2}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
      path2
    )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
  }
  function getPathContributingMatches(matches) {
    return matches.filter(
      (match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0
    );
  }
  function getResolveToMatches(matches) {
    let pathMatches = getPathContributingMatches(matches);
    return pathMatches.map(
      (match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase
    );
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
    let to;
    if (typeof toArg === "string") {
      to = parsePath(toArg);
    } else {
      to = { ...toArg };
      invariant(
        !to.pathname || !to.pathname.includes("?"),
        getInvalidPathError("?", "pathname", "search", to)
      );
      invariant(
        !to.pathname || !to.pathname.includes("#"),
        getInvalidPathError("#", "pathname", "hash", to)
      );
      invariant(
        !to.search || !to.search.includes("#"),
        getInvalidPathError("#", "search", "hash", to)
      );
    }
    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from2;
    if (toPathname == null) {
      from2 = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to.pathname = toSegments.join("/");
      }
      from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path2 = resolvePath(to, from2);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path2.pathname += "/";
    }
    return path2;
  }
  var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
  var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  var normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
  var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
  var ErrorResponseImpl = class {
    constructor(status, statusText, data2, internal = false) {
      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;
      if (data2 instanceof Error) {
        this.data = data2.toString();
        this.error = data2;
      } else {
        this.data = data2;
      }
    }
  };
  function isRouteErrorResponse(error) {
    return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
  }
  var validMutationMethodsArr = [
    "POST",
    "PUT",
    "PATCH",
    "DELETE"
  ];
  var validMutationMethods = new Set(
    validMutationMethodsArr
  );
  var validRequestMethodsArr = [
    "GET",
    ...validMutationMethodsArr
  ];
  var validRequestMethods = new Set(validRequestMethodsArr);
  var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
  var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
  var IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
  };
  var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var defaultMapRouteProperties = (route) => ({
    hasErrorBoundary: Boolean(route.hasErrorBoundary)
  });
  var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
  var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
  function createRouter(init) {
    const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
    const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
    invariant(
      init.routes.length > 0,
      "You must provide a non-empty routes array to createRouter"
    );
    let hydrationRouteProperties2 = init.hydrationRouteProperties || [];
    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
    let manifest = {};
    let dataRoutes = convertRoutesToDataRoutes(
      init.routes,
      mapRouteProperties2,
      void 0,
      manifest
    );
    let inFlightDataRoutes;
    let basename2 = init.basename || "/";
    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;
    let future = {
      unstable_middleware: false,
      ...init.future
    };
    let unlistenHistory = null;
    let subscribers = /* @__PURE__ */ new Set();
    let savedScrollPositions2 = null;
    let getScrollRestorationKey2 = null;
    let getScrollPosition = null;
    let initialScrollRestored = init.hydrationData != null;
    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename2);
    let initialMatchesIsFOW = false;
    let initialErrors = null;
    let initialized;
    if (initialMatches == null && !init.patchRoutesOnNavigation) {
      let error = getInternalRouterError(404, {
        pathname: init.history.location.pathname
      });
      let { matches, route } = getShortCircuitMatches(dataRoutes);
      initialized = true;
      initialMatches = matches;
      initialErrors = { [route.id]: error };
    } else {
      if (initialMatches && !init.hydrationData) {
        let fogOfWar = checkFogOfWar(
          initialMatches,
          dataRoutes,
          init.history.location.pathname
        );
        if (fogOfWar.active) {
          initialMatches = null;
        }
      }
      if (!initialMatches) {
        initialized = false;
        initialMatches = [];
        let fogOfWar = checkFogOfWar(
          null,
          dataRoutes,
          init.history.location.pathname
        );
        if (fogOfWar.active && fogOfWar.matches) {
          initialMatchesIsFOW = true;
          initialMatches = fogOfWar.matches;
        }
      } else if (initialMatches.some((m) => m.route.lazy)) {
        initialized = false;
      } else if (!initialMatches.some((m) => m.route.loader)) {
        initialized = true;
      } else {
        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
        let errors = init.hydrationData ? init.hydrationData.errors : null;
        if (errors) {
          let idx = initialMatches.findIndex(
            (m) => errors[m.route.id] !== void 0
          );
          initialized = initialMatches.slice(0, idx + 1).every(
            (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
          );
        } else {
          initialized = initialMatches.every(
            (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)
          );
        }
      }
    }
    let router2;
    let state = {
      historyAction: init.history.action,
      location: init.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      // Don't restore on initial updateState() if we were SSR'd
      restoreScrollPosition: init.hydrationData != null ? false : null,
      preventScrollReset: false,
      revalidation: "idle",
      loaderData: init.hydrationData && init.hydrationData.loaderData || {},
      actionData: init.hydrationData && init.hydrationData.actionData || null,
      errors: init.hydrationData && init.hydrationData.errors || initialErrors,
      fetchers: /* @__PURE__ */ new Map(),
      blockers: /* @__PURE__ */ new Map()
    };
    let pendingAction = "POP";
    let pendingPreventScrollReset = false;
    let pendingNavigationController;
    let pendingViewTransitionEnabled = false;
    let appliedViewTransitions = /* @__PURE__ */ new Map();
    let removePageHideEventListener = null;
    let isUninterruptedRevalidation = false;
    let isRevalidationRequired = false;
    let cancelledFetcherLoads = /* @__PURE__ */ new Set();
    let fetchControllers = /* @__PURE__ */ new Map();
    let incrementingLoadId = 0;
    let pendingNavigationLoadId = -1;
    let fetchReloadIds = /* @__PURE__ */ new Map();
    let fetchRedirectIds = /* @__PURE__ */ new Set();
    let fetchLoadMatches = /* @__PURE__ */ new Map();
    let activeFetchers = /* @__PURE__ */ new Map();
    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
    let blockerFunctions = /* @__PURE__ */ new Map();
    let unblockBlockerHistoryUpdate = void 0;
    let pendingRevalidationDfd = null;
    function initialize() {
      unlistenHistory = init.history.listen(
        ({ action: historyAction, location, delta }) => {
          if (unblockBlockerHistoryUpdate) {
            unblockBlockerHistoryUpdate();
            unblockBlockerHistoryUpdate = void 0;
            return;
          }
          warning(
            blockerFunctions.size === 0 || delta != null,
            "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
          );
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            let nextHistoryUpdatePromise = new Promise((resolve) => {
              unblockBlockerHistoryUpdate = resolve;
            });
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                });
                nextHistoryUpdatePromise.then(() => init.history.go(delta));
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({ blockers });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        }
      );
      if (isBrowser2) {
        restoreAppliedTransitions(routerWindow, appliedViewTransitions);
        let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
        routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
        removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
      }
      if (!state.initialized) {
        startNavigation("POP", state.location, {
          initialHydration: true
        });
      }
      return router2;
    }
    function dispose() {
      if (unlistenHistory) {
        unlistenHistory();
      }
      if (removePageHideEventListener) {
        removePageHideEventListener();
      }
      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_, key) => deleteFetcher(key));
      state.blockers.forEach((_, key) => deleteBlocker(key));
    }
    function subscribe(fn) {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }
    function updateState(newState, opts = {}) {
      state = {
        ...state,
        ...newState
      };
      let unmountedFetchers = [];
      let mountedFetchers = [];
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (fetchersQueuedForDeletion.has(key)) {
            unmountedFetchers.push(key);
          } else {
            mountedFetchers.push(key);
          }
        }
      });
      fetchersQueuedForDeletion.forEach((key) => {
        if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
          unmountedFetchers.push(key);
        }
      });
      [...subscribers].forEach(
        (subscriber) => subscriber(state, {
          deletedFetchers: unmountedFetchers,
          viewTransitionOpts: opts.viewTransitionOpts,
          flushSync: opts.flushSync === true
        })
      );
      unmountedFetchers.forEach((key) => deleteFetcher(key));
      mountedFetchers.forEach((key) => state.fetchers.delete(key));
    }
    function completeNavigation(location, newState, { flushSync } = {}) {
      let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location.state?._isRedirect !== true;
      let actionData;
      if (newState.actionData) {
        if (Object.keys(newState.actionData).length > 0) {
          actionData = newState.actionData;
        } else {
          actionData = null;
        }
      } else if (isActionReload) {
        actionData = state.actionData;
      } else {
        actionData = null;
      }
      let loaderData = newState.loaderData ? mergeLoaderData(
        state.loaderData,
        newState.loaderData,
        newState.matches || [],
        newState.errors
      ) : state.loaderData;
      let blockers = state.blockers;
      if (blockers.size > 0) {
        blockers = new Map(blockers);
        blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
      }
      let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;
      if (inFlightDataRoutes) {
        dataRoutes = inFlightDataRoutes;
        inFlightDataRoutes = void 0;
      }
      if (isUninterruptedRevalidation) {
      } else if (pendingAction === "POP") {
      } else if (pendingAction === "PUSH") {
        init.history.push(location, location.state);
      } else if (pendingAction === "REPLACE") {
        init.history.replace(location, location.state);
      }
      let viewTransitionOpts;
      if (pendingAction === "POP") {
        let priorPaths = appliedViewTransitions.get(state.location.pathname);
        if (priorPaths && priorPaths.has(location.pathname)) {
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location
          };
        } else if (appliedViewTransitions.has(location.pathname)) {
          viewTransitionOpts = {
            currentLocation: location,
            nextLocation: state.location
          };
        }
      } else if (pendingViewTransitionEnabled) {
        let toPaths = appliedViewTransitions.get(state.location.pathname);
        if (toPaths) {
          toPaths.add(location.pathname);
        } else {
          toPaths = /* @__PURE__ */ new Set([location.pathname]);
          appliedViewTransitions.set(state.location.pathname, toPaths);
        }
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      }
      updateState(
        {
          ...newState,
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(
            location,
            newState.matches || state.matches
          ),
          preventScrollReset,
          blockers
        },
        {
          viewTransitionOpts,
          flushSync: flushSync === true
        }
      );
      pendingAction = "POP";
      pendingPreventScrollReset = false;
      pendingViewTransitionEnabled = false;
      isUninterruptedRevalidation = false;
      isRevalidationRequired = false;
      pendingRevalidationDfd?.resolve();
      pendingRevalidationDfd = null;
    }
    async function navigate(to, opts) {
      if (typeof to === "number") {
        init.history.go(to);
        return;
      }
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename2,
        to,
        opts?.fromRouteId,
        opts?.relative
      );
      let { path: path2, submission, error } = normalizeNavigateOptions(
        false,
        normalizedPath,
        opts
      );
      let currentLocation = state.location;
      let nextLocation = createLocation(state.location, path2, opts && opts.state);
      nextLocation = {
        ...nextLocation,
        ...init.history.encodeLocation(nextLocation)
      };
      let userReplace = opts && opts.replace != null ? opts.replace : void 0;
      let historyAction = "PUSH";
      if (userReplace === true) {
        historyAction = "REPLACE";
      } else if (userReplace === false) {
      } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
        historyAction = "REPLACE";
      }
      let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
      let flushSync = (opts && opts.flushSync) === true;
      let blockerKey = shouldBlockNavigation({
        currentLocation,
        nextLocation,
        historyAction
      });
      if (blockerKey) {
        updateBlocker(blockerKey, {
          state: "blocked",
          location: nextLocation,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: nextLocation
            });
            navigate(to, opts);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({ blockers });
          }
        });
        return;
      }
      await startNavigation(historyAction, nextLocation, {
        submission,
        // Send through the formData serialization error if we have one so we can
        // render at the right error boundary after we match routes
        pendingError: error,
        preventScrollReset,
        replace: opts && opts.replace,
        enableViewTransition: opts && opts.viewTransition,
        flushSync
      });
    }
    function revalidate() {
      if (!pendingRevalidationDfd) {
        pendingRevalidationDfd = createDeferred();
      }
      interruptActiveLoads();
      updateState({ revalidation: "loading" });
      let promise = pendingRevalidationDfd.promise;
      if (state.navigation.state === "submitting") {
        return promise;
      }
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: true
        });
        return promise;
      }
      startNavigation(
        pendingAction || state.historyAction,
        state.navigation.location,
        {
          overrideNavigation: state.navigation,
          // Proxy through any rending view transition
          enableViewTransition: pendingViewTransitionEnabled === true
        }
      );
      return promise;
    }
    async function startNavigation(historyAction, location, opts) {
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
      saveScrollPosition(state.location, state.matches);
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
      pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let loadingNavigation = opts && opts.overrideNavigation;
      let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
        // `matchRoutes()` has already been called if we're in here via `router.initialize()`
        state.matches
      ) : matchRoutes(routesToUse, location, basename2);
      let flushSync = (opts && opts.flushSync) === true;
      if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
        completeNavigation(location, { matches }, { flushSync });
        return;
      }
      let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        let { error, notFoundMatches, route } = handleNavigational404(
          location.pathname
        );
        completeNavigation(
          location,
          {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          },
          { flushSync }
        );
        return;
      }
      pendingNavigationController = new AbortController();
      let request = createClientSideRequest(
        init.history,
        location,
        pendingNavigationController.signal,
        opts && opts.submission
      );
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let pendingActionResult;
      if (opts && opts.pendingError) {
        pendingActionResult = [
          findNearestBoundary(matches).route.id,
          { type: "error", error: opts.pendingError }
        ];
      } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
        let actionResult = await handleAction(
          request,
          location,
          opts.submission,
          matches,
          scopedContext,
          fogOfWar.active,
          opts && opts.initialHydration === true,
          { replace: opts.replace, flushSync }
        );
        if (actionResult.shortCircuited) {
          return;
        }
        if (actionResult.pendingActionResult) {
          let [routeId, result] = actionResult.pendingActionResult;
          if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
            pendingNavigationController = null;
            completeNavigation(location, {
              matches: actionResult.matches,
              loaderData: {},
              errors: {
                [routeId]: result.error
              }
            });
            return;
          }
        }
        matches = actionResult.matches || matches;
        pendingActionResult = actionResult.pendingActionResult;
        loadingNavigation = getLoadingNavigation(location, opts.submission);
        flushSync = false;
        fogOfWar.active = false;
        request = createClientSideRequest(
          init.history,
          request.url,
          request.signal
        );
      }
      let {
        shortCircuited,
        matches: updatedMatches,
        loaderData,
        errors
      } = await handleLoaders(
        request,
        location,
        matches,
        scopedContext,
        fogOfWar.active,
        loadingNavigation,
        opts && opts.submission,
        opts && opts.fetcherSubmission,
        opts && opts.replace,
        opts && opts.initialHydration === true,
        flushSync,
        pendingActionResult
      );
      if (shortCircuited) {
        return;
      }
      pendingNavigationController = null;
      completeNavigation(location, {
        matches: updatedMatches || matches,
        ...getActionDataForCommit(pendingActionResult),
        loaderData,
        errors
      });
    }
    async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {
      interruptActiveLoads();
      let navigation = getSubmittingNavigation(location, submission);
      updateState({ navigation }, { flushSync: opts.flushSync === true });
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches,
          location.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            pendingActionResult: [
              boundaryId,
              {
                type: "error",
                error: discoverResult.error
              }
            ]
          };
        } else if (!discoverResult.matches) {
          let { notFoundMatches, error, route } = handleNavigational404(
            location.pathname
          );
          return {
            matches: notFoundMatches,
            pendingActionResult: [
              route.id,
              {
                type: "error",
                error
              }
            ]
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let result;
      let actionMatch = getTargetMatch(matches, location);
      if (!actionMatch.route.action && !actionMatch.route.lazy) {
        result = {
          type: "error",
          error: getInternalRouterError(405, {
            method: request.method,
            pathname: location.pathname,
            routeId: actionMatch.route.id
          })
        };
      } else {
        let dsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          request,
          matches,
          actionMatch,
          initialHydration ? [] : hydrationRouteProperties2,
          scopedContext
        );
        let results = await callDataStrategy(
          request,
          dsMatches,
          scopedContext,
          null
        );
        result = results[actionMatch.route.id];
        if (!result) {
          for (let match2 of matches) {
            if (results[match2.route.id]) {
              result = results[match2.route.id];
              break;
            }
          }
        }
        if (request.signal.aborted) {
          return { shortCircuited: true };
        }
      }
      if (isRedirectResult(result)) {
        let replace22;
        if (opts && opts.replace != null) {
          replace22 = opts.replace;
        } else {
          let location2 = normalizeRedirectLocation(
            result.response.headers.get("Location"),
            new URL(request.url),
            basename2
          );
          replace22 = location2 === state.location.pathname + state.location.search;
        }
        await startRedirectNavigation(request, result, true, {
          submission,
          replace: replace22
        });
        return { shortCircuited: true };
      }
      if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
        if ((opts && opts.replace) !== true) {
          pendingAction = "PUSH";
        }
        return {
          matches,
          pendingActionResult: [
            boundaryMatch.route.id,
            result,
            actionMatch.route.id
          ]
        };
      }
      return {
        matches,
        pendingActionResult: [actionMatch.route.id, result]
      };
    }
    async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace22, initialHydration, flushSync, pendingActionResult) {
      let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
      let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
      let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
      if (isFogOfWar) {
        if (shouldUpdateNavigationState) {
          let actionData = getUpdatedActionData(pendingActionResult);
          updateState(
            {
              navigation: loadingNavigation,
              ...actionData !== void 0 ? { actionData } : {}
            },
            {
              flushSync
            }
          );
        }
        let discoverResult = await discoverRoutes(
          matches,
          location.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            loaderData: {},
            errors: {
              [boundaryId]: discoverResult.error
            }
          };
        } else if (!discoverResult.matches) {
          let { error, notFoundMatches, route } = handleNavigational404(
            location.pathname
          );
          return {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
        request,
        scopedContext,
        mapRouteProperties2,
        manifest,
        init.history,
        state,
        matches,
        activeSubmission,
        location,
        initialHydration ? [] : hydrationRouteProperties2,
        initialHydration === true,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename2,
        init.patchRoutesOnNavigation != null,
        pendingActionResult
      );
      pendingNavigationLoadId = ++incrementingLoadId;
      if (!init.dataStrategy && !dsMatches.some((m) => m.shouldLoad) && revalidatingFetchers.length === 0) {
        let updatedFetchers2 = markFetchRedirectsDone();
        completeNavigation(
          location,
          {
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
            ...getActionDataForCommit(pendingActionResult),
            ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
          },
          { flushSync }
        );
        return { shortCircuited: true };
      }
      if (shouldUpdateNavigationState) {
        let updates = {};
        if (!isFogOfWar) {
          updates.navigation = loadingNavigation;
          let actionData = getUpdatedActionData(pendingActionResult);
          if (actionData !== void 0) {
            updates.actionData = actionData;
          }
        }
        if (revalidatingFetchers.length > 0) {
          updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
        }
        updateState(updates, { flushSync });
      }
      revalidatingFetchers.forEach((rf) => {
        abortFetcher(rf.key);
        if (rf.controller) {
          fetchControllers.set(rf.key, rf.controller);
        }
      });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
      if (pendingNavigationController) {
        pendingNavigationController.signal.addEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        dsMatches,
        revalidatingFetchers,
        request,
        scopedContext
      );
      if (request.signal.aborted) {
        return { shortCircuited: true };
      }
      if (pendingNavigationController) {
        pendingNavigationController.signal.removeEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace22
        });
        return { shortCircuited: true };
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace22
        });
        return { shortCircuited: true };
      }
      let { loaderData, errors } = processLoaderData(
        state,
        matches,
        loaderResults,
        pendingActionResult,
        revalidatingFetchers,
        fetcherResults
      );
      if (initialHydration && state.errors) {
        errors = { ...state.errors, ...errors };
      }
      let updatedFetchers = markFetchRedirectsDone();
      let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
      let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
      return {
        matches,
        loaderData,
        errors,
        ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
      };
    }
    function getUpdatedActionData(pendingActionResult) {
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        return {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          return null;
        } else {
          return state.actionData;
        }
      }
    }
    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
      revalidatingFetchers.forEach((rf) => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          fetcher ? fetcher.data : void 0
        );
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      return new Map(state.fetchers);
    }
    async function fetch2(key, routeId, href2, opts) {
      abortFetcher(key);
      let flushSync = (opts && opts.flushSync) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename2,
        href2,
        routeId,
        opts?.relative
      );
      let matches = matchRoutes(routesToUse, normalizedPath, basename2);
      let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: normalizedPath }),
          { flushSync }
        );
        return;
      }
      let { path: path2, submission, error } = normalizeNavigateOptions(
        true,
        normalizedPath,
        opts
      );
      if (error) {
        setFetcherError(key, routeId, error, { flushSync });
        return;
      }
      let match2 = getTargetMatch(matches, path2);
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let preventScrollReset = (opts && opts.preventScrollReset) === true;
      if (submission && isMutationMethod(submission.formMethod)) {
        await handleFetcherAction(
          key,
          routeId,
          path2,
          match2,
          matches,
          scopedContext,
          fogOfWar.active,
          flushSync,
          preventScrollReset,
          submission
        );
        return;
      }
      fetchLoadMatches.set(key, { routeId, path: path2 });
      await handleFetcherLoader(
        key,
        routeId,
        path2,
        match2,
        matches,
        scopedContext,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission
      );
    }
    async function handleFetcherAction(key, routeId, path2, match2, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      interruptActiveLoads();
      fetchLoadMatches.delete(key);
      function detectAndHandle405Error(m) {
        if (!m.route.action && !m.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path2,
            routeId
          });
          setFetcherError(key, routeId, error, { flushSync });
          return true;
        }
        return false;
      }
      if (!isFogOfWar && detectAndHandle405Error(match2)) {
        return;
      }
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
        flushSync
      });
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path2,
        abortController.signal,
        submission
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          requestMatches,
          path2,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path2 }),
            { flushSync }
          );
          return;
        } else {
          requestMatches = discoverResult.matches;
          match2 = getTargetMatch(requestMatches, path2);
          if (detectAndHandle405Error(match2)) {
            return;
          }
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let fetchMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        requestMatches,
        match2,
        hydrationRouteProperties2,
        scopedContext
      );
      let actionResults = await callDataStrategy(
        fetchRequest,
        fetchMatches,
        scopedContext,
        key
      );
      let actionResult = actionResults[match2.route.id];
      if (fetchRequest.signal.aborted) {
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
      } else {
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key);
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            updateFetcherState(key, getLoadingFetcher(submission));
            return startRedirectNavigation(fetchRequest, actionResult, false, {
              fetcherSubmission: submission,
              preventScrollReset
            });
          }
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
      }
      let nextLocation = state.navigation.location || state.location;
      let revalidationRequest = createClientSideRequest(
        init.history,
        nextLocation,
        abortController.signal
      );
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename2) : state.matches;
      invariant(matches, "Didn't find any matches after fetcher action");
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);
      let loadFetcher = getLoadingFetcher(submission, actionResult.data);
      state.fetchers.set(key, loadFetcher);
      let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
        revalidationRequest,
        scopedContext,
        mapRouteProperties2,
        manifest,
        init.history,
        state,
        matches,
        submission,
        nextLocation,
        hydrationRouteProperties2,
        false,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename2,
        init.patchRoutesOnNavigation != null,
        [match2.route.id, actionResult]
      );
      revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
        let staleKey = rf.key;
        let existingFetcher2 = state.fetchers.get(staleKey);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          existingFetcher2 ? existingFetcher2.data : void 0
        );
        state.fetchers.set(staleKey, revalidatingFetcher);
        abortFetcher(staleKey);
        if (rf.controller) {
          fetchControllers.set(staleKey, rf.controller);
        }
      });
      updateState({ fetchers: new Map(state.fetchers) });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
      abortController.signal.addEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        dsMatches,
        revalidatingFetchers,
        revalidationRequest,
        scopedContext
      );
      if (abortController.signal.aborted) {
        return;
      }
      abortController.signal.removeEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
      if (state.fetchers.has(key)) {
        let doneFetcher = getDoneFetcher(actionResult.data);
        state.fetchers.set(key, doneFetcher);
      }
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      let { loaderData, errors } = processLoaderData(
        state,
        matches,
        loaderResults,
        void 0,
        revalidatingFetchers,
        fetcherResults
      );
      abortStaleFetchLoads(loadId);
      if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
        invariant(pendingAction, "Expected pending action");
        pendingNavigationController && pendingNavigationController.abort();
        completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
        });
      } else {
        updateState({
          errors,
          loaderData: mergeLoaderData(
            state.loaderData,
            loaderData,
            matches,
            errors
          ),
          fetchers: new Map(state.fetchers)
        });
        isRevalidationRequired = false;
      }
    }
    async function handleFetcherLoader(key, routeId, path2, match2, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(
        key,
        getLoadingFetcher(
          submission,
          existingFetcher ? existingFetcher.data : void 0
        ),
        { flushSync }
      );
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path2,
        abortController.signal
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches,
          path2,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path2 }),
            { flushSync }
          );
          return;
        } else {
          matches = discoverResult.matches;
          match2 = getTargetMatch(matches, path2);
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let dsMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        matches,
        match2,
        hydrationRouteProperties2,
        scopedContext
      );
      let results = await callDataStrategy(
        fetchRequest,
        dsMatches,
        scopedContext,
        key
      );
      let result = results[match2.route.id];
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      if (fetchRequest.signal.aborted) {
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
      if (isRedirectResult(result)) {
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          await startRedirectNavigation(fetchRequest, result, false, {
            preventScrollReset
          });
          return;
        }
      }
      if (isErrorResult(result)) {
        setFetcherError(key, routeId, result.error);
        return;
      }
      updateFetcherState(key, getDoneFetcher(result.data));
    }
    async function startRedirectNavigation(request, redirect2, isNavigation, {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace: replace22
    } = {}) {
      if (redirect2.response.headers.has("X-Remix-Revalidate")) {
        isRevalidationRequired = true;
      }
      let location = redirect2.response.headers.get("Location");
      invariant(location, "Expected a Location header on the redirect Response");
      location = normalizeRedirectLocation(
        location,
        new URL(request.url),
        basename2
      );
      let redirectLocation = createLocation(state.location, location, {
        _isRedirect: true
      });
      if (isBrowser2) {
        let isDocumentReload = false;
        if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
          isDocumentReload = true;
        } else if (ABSOLUTE_URL_REGEX.test(location)) {
          const url = createBrowserURLImpl(location, true);
          isDocumentReload = // Hard reload if it's an absolute URL to a new origin
          url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
          stripBasename(url.pathname, basename2) == null;
        }
        if (isDocumentReload) {
          if (replace22) {
            routerWindow.location.replace(location);
          } else {
            routerWindow.location.assign(location);
          }
          return;
        }
      }
      pendingNavigationController = null;
      let redirectNavigationType = replace22 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH";
      let { formMethod, formAction, formEncType } = state.navigation;
      if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
        submission = getSubmissionFromNavigation(state.navigation);
      }
      let activeSubmission = submission || fetcherSubmission;
      if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
        await startNavigation(redirectNavigationType, redirectLocation, {
          submission: {
            ...activeSubmission,
            formAction: location
          },
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      } else {
        let overrideNavigation = getLoadingNavigation(
          redirectLocation,
          submission
        );
        await startNavigation(redirectNavigationType, redirectLocation, {
          overrideNavigation,
          // Send fetcher submissions through for shouldRevalidate
          fetcherSubmission,
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      }
    }
    async function callDataStrategy(request, matches, scopedContext, fetcherKey) {
      let results;
      let dataResults = {};
      try {
        results = await callDataStrategyImpl(
          dataStrategyImpl,
          request,
          matches,
          fetcherKey,
          scopedContext,
          false
        );
      } catch (e) {
        matches.filter((m) => m.shouldLoad).forEach((m) => {
          dataResults[m.route.id] = {
            type: "error",
            error: e
          };
        });
        return dataResults;
      }
      if (request.signal.aborted) {
        return dataResults;
      }
      for (let [routeId, result] of Object.entries(results)) {
        if (isRedirectDataStrategyResult(result)) {
          let response = result.result;
          dataResults[routeId] = {
            type: "redirect",
            response: normalizeRelativeRoutingRedirectResponse(
              response,
              request,
              routeId,
              matches,
              basename2
            )
          };
        } else {
          dataResults[routeId] = await convertDataStrategyResultToDataResult(
            result
          );
        }
      }
      return dataResults;
    }
    async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {
      let loaderResultsPromise = callDataStrategy(
        request,
        matches,
        scopedContext,
        null
      );
      let fetcherResultsPromise = Promise.all(
        fetchersToLoad.map(async (f) => {
          if (f.matches && f.match && f.request && f.controller) {
            let results = await callDataStrategy(
              f.request,
              f.matches,
              scopedContext,
              f.key
            );
            let result = results[f.match.route.id];
            return { [f.key]: result };
          } else {
            return Promise.resolve({
              [f.key]: {
                type: "error",
                error: getInternalRouterError(404, {
                  pathname: f.path
                })
              }
            });
          }
        })
      );
      let loaderResults = await loaderResultsPromise;
      let fetcherResults = (await fetcherResultsPromise).reduce(
        (acc, r) => Object.assign(acc, r),
        {}
      );
      return {
        loaderResults,
        fetcherResults
      };
    }
    function interruptActiveLoads() {
      isRevalidationRequired = true;
      fetchLoadMatches.forEach((_, key) => {
        if (fetchControllers.has(key)) {
          cancelledFetcherLoads.add(key);
        }
        abortFetcher(key);
      });
    }
    function updateFetcherState(key, fetcher, opts = {}) {
      state.fetchers.set(key, fetcher);
      updateState(
        { fetchers: new Map(state.fetchers) },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function setFetcherError(key, routeId, error, opts = {}) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState(
        {
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function getFetcher(key) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      if (fetchersQueuedForDeletion.has(key)) {
        fetchersQueuedForDeletion.delete(key);
      }
      return state.fetchers.get(key) || IDLE_FETCHER;
    }
    function deleteFetcher(key) {
      let fetcher = state.fetchers.get(key);
      if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
        abortFetcher(key);
      }
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      fetchersQueuedForDeletion.delete(key);
      cancelledFetcherLoads.delete(key);
      state.fetchers.delete(key);
    }
    function queueFetcherForDeletion(key) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        fetchersQueuedForDeletion.add(key);
      } else {
        activeFetchers.set(key, count);
      }
      updateState({ fetchers: new Map(state.fetchers) });
    }
    function abortFetcher(key) {
      let controller = fetchControllers.get(key);
      if (controller) {
        controller.abort();
        fetchControllers.delete(key);
      }
    }
    function markFetchersDone(keys2) {
      for (let key of keys2) {
        let fetcher = getFetcher(key);
        let doneFetcher = getDoneFetcher(fetcher.data);
        state.fetchers.set(key, doneFetcher);
      }
    }
    function markFetchRedirectsDone() {
      let doneKeys = [];
      let updatedFetchers = false;
      for (let key of fetchRedirectIds) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          fetchRedirectIds.delete(key);
          doneKeys.push(key);
          updatedFetchers = true;
        }
      }
      markFetchersDone(doneKeys);
      return updatedFetchers;
    }
    function abortStaleFetchLoads(landedId) {
      let yeetedKeys = [];
      for (let [key, id] of fetchReloadIds) {
        if (id < landedId) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, `Expected fetcher: ${key}`);
          if (fetcher.state === "loading") {
            abortFetcher(key);
            fetchReloadIds.delete(key);
            yeetedKeys.push(key);
          }
        }
      }
      markFetchersDone(yeetedKeys);
      return yeetedKeys.length > 0;
    }
    function getBlocker(key, fn) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      if (blockerFunctions.get(key) !== fn) {
        blockerFunctions.set(key, fn);
      }
      return blocker;
    }
    function deleteBlocker(key) {
      state.blockers.delete(key);
      blockerFunctions.delete(key);
    }
    function updateBlocker(key, newBlocker) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      invariant(
        blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
        `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
      );
      let blockers = new Map(state.blockers);
      blockers.set(key, newBlocker);
      updateState({ blockers });
    }
    function shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    }) {
      if (blockerFunctions.size === 0) {
        return;
      }
      if (blockerFunctions.size > 1) {
        warning(false, "A router only supports one blocker at a time");
      }
      let entries = Array.from(blockerFunctions.entries());
      let [blockerKey, blockerFunction] = entries[entries.length - 1];
      let blocker = state.blockers.get(blockerKey);
      if (blocker && blocker.state === "proceeding") {
        return;
      }
      if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
        return blockerKey;
      }
    }
    function handleNavigational404(pathname) {
      let error = getInternalRouterError(404, { pathname });
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let { matches, route } = getShortCircuitMatches(routesToUse);
      return { notFoundMatches: matches, route, error };
    }
    function enableScrollRestoration(positions, getPosition, getKey) {
      savedScrollPositions2 = positions;
      getScrollPosition = getPosition;
      getScrollRestorationKey2 = getKey || null;
      if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
        initialScrollRestored = true;
        let y = getSavedScrollPosition(state.location, state.matches);
        if (y != null) {
          updateState({ restoreScrollPosition: y });
        }
      }
      return () => {
        savedScrollPositions2 = null;
        getScrollPosition = null;
        getScrollRestorationKey2 = null;
      };
    }
    function getScrollKey(location, matches) {
      if (getScrollRestorationKey2) {
        let key = getScrollRestorationKey2(
          location,
          matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
        );
        return key || location.key;
      }
      return location.key;
    }
    function saveScrollPosition(location, matches) {
      if (savedScrollPositions2 && getScrollPosition) {
        let key = getScrollKey(location, matches);
        savedScrollPositions2[key] = getScrollPosition();
      }
    }
    function getSavedScrollPosition(location, matches) {
      if (savedScrollPositions2) {
        let key = getScrollKey(location, matches);
        let y = savedScrollPositions2[key];
        if (typeof y === "number") {
          return y;
        }
      }
      return null;
    }
    function checkFogOfWar(matches, routesToUse, pathname) {
      if (init.patchRoutesOnNavigation) {
        if (!matches) {
          let fogMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename2,
            true
          );
          return { active: true, matches: fogMatches || [] };
        } else {
          if (Object.keys(matches[0].params).length > 0) {
            let partialMatches = matchRoutesImpl(
              routesToUse,
              pathname,
              basename2,
              true
            );
            return { active: true, matches: partialMatches };
          }
        }
      }
      return { active: false, matches: null };
    }
    async function discoverRoutes(matches, pathname, signal, fetcherKey) {
      if (!init.patchRoutesOnNavigation) {
        return { type: "success", matches };
      }
      let partialMatches = matches;
      while (true) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let localManifest = manifest;
        try {
          await init.patchRoutesOnNavigation({
            signal,
            path: pathname,
            matches: partialMatches,
            fetcherKey,
            patch: (routeId, children2) => {
              if (signal.aborted) return;
              patchRoutesImpl(
                routeId,
                children2,
                routesToUse,
                localManifest,
                mapRouteProperties2
              );
            }
          });
        } catch (e) {
          return { type: "error", error: e, partialMatches };
        } finally {
          if (isNonHMR && !signal.aborted) {
            dataRoutes = [...dataRoutes];
          }
        }
        if (signal.aborted) {
          return { type: "aborted" };
        }
        let newMatches = matchRoutes(routesToUse, pathname, basename2);
        if (newMatches) {
          return { type: "success", matches: newMatches };
        }
        let newPartialMatches = matchRoutesImpl(
          routesToUse,
          pathname,
          basename2,
          true
        );
        if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
          (m, i) => m.route.id === newPartialMatches[i].route.id
        )) {
          return { type: "success", matches: null };
        }
        partialMatches = newPartialMatches;
      }
    }
    function _internalSetRoutes(newRoutes) {
      manifest = {};
      inFlightDataRoutes = convertRoutesToDataRoutes(
        newRoutes,
        mapRouteProperties2,
        void 0,
        manifest
      );
    }
    function patchRoutes(routeId, children2) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      patchRoutesImpl(
        routeId,
        children2,
        routesToUse,
        manifest,
        mapRouteProperties2
      );
      if (isNonHMR) {
        dataRoutes = [...dataRoutes];
        updateState({});
      }
    }
    router2 = {
      get basename() {
        return basename2;
      },
      get future() {
        return future;
      },
      get state() {
        return state;
      },
      get routes() {
        return dataRoutes;
      },
      get window() {
        return routerWindow;
      },
      initialize,
      subscribe,
      enableScrollRestoration,
      navigate,
      fetch: fetch2,
      revalidate,
      // Passthrough to history-aware createHref used by useHref so we get proper
      // hash-aware URLs in DOM paths
      createHref: (to) => init.history.createHref(to),
      encodeLocation: (to) => init.history.encodeLocation(to),
      getFetcher,
      deleteFetcher: queueFetcherForDeletion,
      dispose,
      getBlocker,
      deleteBlocker,
      patchRoutes,
      _internalFetchControllers: fetchControllers,
      // TODO: Remove setRoutes, it's temporary to avoid dealing with
      // updating the tree while validating the update algorithm.
      _internalSetRoutes
    };
    return router2;
  }
  function isSubmissionNavigation(opts) {
    return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
  }
  function normalizeTo(location, matches, basename2, to, fromRouteId, relative) {
    let contextualMatches;
    let activeRouteMatch;
    if (fromRouteId) {
      contextualMatches = [];
      for (let match2 of matches) {
        contextualMatches.push(match2);
        if (match2.route.id === fromRouteId) {
          activeRouteMatch = match2;
          break;
        }
      }
    } else {
      contextualMatches = matches;
      activeRouteMatch = matches[matches.length - 1];
    }
    let path2 = resolveTo(
      to ? to : ".",
      getResolveToMatches(contextualMatches),
      stripBasename(location.pathname, basename2) || location.pathname,
      relative === "path"
    );
    if (to == null) {
      path2.search = location.search;
      path2.hash = location.hash;
    }
    if ((to == null || to === "" || to === ".") && activeRouteMatch) {
      let nakedIndex = hasNakedIndexQuery(path2.search);
      if (activeRouteMatch.route.index && !nakedIndex) {
        path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index";
      } else if (!activeRouteMatch.route.index && nakedIndex) {
        let params = new URLSearchParams(path2.search);
        let indexValues = params.getAll("index");
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path2.search = qs ? `?${qs}` : "";
      }
    }
    if (basename2 !== "/") {
      path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
    }
    return createPath(path2);
  }
  function normalizeNavigateOptions(isFetcher, path2, opts) {
    if (!opts || !isSubmissionNavigation(opts)) {
      return { path: path2 };
    }
    if (opts.formMethod && !isValidMethod(opts.formMethod)) {
      return {
        path: path2,
        error: getInternalRouterError(405, { method: opts.formMethod })
      };
    }
    let getInvalidBodyError = () => ({
      path: path2,
      error: getInternalRouterError(400, { type: "invalid-body" })
    });
    let rawFormMethod = opts.formMethod || "get";
    let formMethod = rawFormMethod.toUpperCase();
    let formAction = stripHashFromPath(path2);
    if (opts.body !== void 0) {
      if (opts.formEncType === "text/plain") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        let text9 = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
          // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
          Array.from(opts.body.entries()).reduce(
            (acc, [name21, value]) => `${acc}${name21}=${value}
`,
            ""
          )
        ) : String(opts.body);
        return {
          path: path2,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: void 0,
            text: text9
          }
        };
      } else if (opts.formEncType === "application/json") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        try {
          let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
          return {
            path: path2,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json,
              text: void 0
            }
          };
        } catch (e) {
          return getInvalidBodyError();
        }
      }
    }
    invariant(
      typeof FormData === "function",
      "FormData is not available in this environment"
    );
    let searchParams;
    let formData;
    if (opts.formData) {
      searchParams = convertFormDataToSearchParams(opts.formData);
      formData = opts.formData;
    } else if (opts.body instanceof FormData) {
      searchParams = convertFormDataToSearchParams(opts.body);
      formData = opts.body;
    } else if (opts.body instanceof URLSearchParams) {
      searchParams = opts.body;
      formData = convertSearchParamsToFormData(searchParams);
    } else if (opts.body == null) {
      searchParams = new URLSearchParams();
      formData = new FormData();
    } else {
      try {
        searchParams = new URLSearchParams(opts.body);
        formData = convertSearchParamsToFormData(searchParams);
      } catch (e) {
        return getInvalidBodyError();
      }
    }
    let submission = {
      formMethod,
      formAction,
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData,
      json: void 0,
      text: void 0
    };
    if (isMutationMethod(submission.formMethod)) {
      return { path: path2, submission };
    }
    let parsedPath = parsePath(path2);
    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }
    parsedPath.search = `?${searchParams}`;
    return { path: createPath(parsedPath), submission };
  }
  function getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename2, hasPatchRoutesOnNavigation, pendingActionResult) {
    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
    let currentUrl = history.createURL(state.location);
    let nextUrl = history.createURL(location);
    let maxIdx;
    if (initialHydration && state.errors) {
      let boundaryId = Object.keys(state.errors)[0];
      maxIdx = matches.findIndex((m) => m.route.id === boundaryId);
    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
      let boundaryId = pendingActionResult[0];
      maxIdx = matches.findIndex((m) => m.route.id === boundaryId) - 1;
    }
    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
    let baseShouldRevalidateArgs = {
      currentUrl,
      currentParams: state.matches[0]?.params || {},
      nextUrl,
      nextParams: matches[0].params,
      ...submission,
      actionResult,
      actionStatus
    };
    let dsMatches = matches.map((match2, index2) => {
      let { route } = match2;
      let forceShouldLoad = null;
      if (maxIdx != null && index2 > maxIdx) {
        forceShouldLoad = false;
      } else if (route.lazy) {
        forceShouldLoad = true;
      } else if (route.loader == null) {
        forceShouldLoad = false;
      } else if (initialHydration) {
        forceShouldLoad = shouldLoadRouteOnHydration(
          route,
          state.loaderData,
          state.errors
        );
      } else if (isNewLoader(state.loaderData, state.matches[index2], match2)) {
        forceShouldLoad = true;
      }
      if (forceShouldLoad !== null) {
        return getDataStrategyMatch(
          mapRouteProperties2,
          manifest,
          request,
          match2,
          lazyRoutePropertiesToSkip,
          scopedContext,
          forceShouldLoad
        );
      }
      let defaultShouldRevalidate = shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index2], match2)
      );
      let shouldRevalidateArgs = {
        ...baseShouldRevalidateArgs,
        defaultShouldRevalidate
      };
      let shouldLoad = shouldRevalidateLoader(match2, shouldRevalidateArgs);
      return getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request,
        match2,
        lazyRoutePropertiesToSkip,
        scopedContext,
        shouldLoad,
        shouldRevalidateArgs
      );
    });
    let revalidatingFetchers = [];
    fetchLoadMatches.forEach((f, key) => {
      if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
        return;
      }
      let fetcher = state.fetchers.get(key);
      let isMidInitialLoad = fetcher && fetcher.state !== "idle" && fetcher.data === void 0;
      let fetcherMatches = matchRoutes(routesToUse, f.path, basename2);
      if (!fetcherMatches) {
        if (hasPatchRoutesOnNavigation && isMidInitialLoad) {
          return;
        }
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: null,
          match: null,
          request: null,
          controller: null
        });
        return;
      }
      if (fetchRedirectIds.has(key)) {
        return;
      }
      let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
      let fetchController = new AbortController();
      let fetchRequest = createClientSideRequest(
        history,
        f.path,
        fetchController.signal
      );
      let fetcherDsMatches = null;
      if (cancelledFetcherLoads.has(key)) {
        cancelledFetcherLoads.delete(key);
        fetcherDsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          fetcherMatches,
          fetcherMatch,
          lazyRoutePropertiesToSkip,
          scopedContext
        );
      } else if (isMidInitialLoad) {
        if (isRevalidationRequired) {
          fetcherDsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            fetchRequest,
            fetcherMatches,
            fetcherMatch,
            lazyRoutePropertiesToSkip,
            scopedContext
          );
        }
      } else {
        let shouldRevalidateArgs = {
          ...baseShouldRevalidateArgs,
          defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
        };
        if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {
          fetcherDsMatches = getTargetedDataStrategyMatches(
            mapRouteProperties2,
            manifest,
            fetchRequest,
            fetcherMatches,
            fetcherMatch,
            lazyRoutePropertiesToSkip,
            scopedContext,
            shouldRevalidateArgs
          );
        }
      }
      if (fetcherDsMatches) {
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: fetcherDsMatches,
          match: fetcherMatch,
          request: fetchRequest,
          controller: fetchController
        });
      }
    });
    return { dsMatches, revalidatingFetchers };
  }
  function shouldLoadRouteOnHydration(route, loaderData, errors) {
    if (route.lazy) {
      return true;
    }
    if (!route.loader) {
      return false;
    }
    let hasData = loaderData != null && route.id in loaderData;
    let hasError = errors != null && errors[route.id] !== void 0;
    if (!hasData && hasError) {
      return false;
    }
    if (typeof route.loader === "function" && route.loader.hydrate === true) {
      return true;
    }
    return !hasData && !hasError;
  }
  function isNewLoader(currentLoaderData, currentMatch, match2) {
    let isNew = (
      // [a] -> [a, b]
      !currentMatch || // [a, b] -> [a, c]
      match2.route.id !== currentMatch.route.id
    );
    let isMissingData = !currentLoaderData.hasOwnProperty(match2.route.id);
    return isNew || isMissingData;
  }
  function isNewRouteInstance(currentMatch, match2) {
    let currentPath = currentMatch.route.path;
    return (
      // param change for this match, /users/123 -> /users/456
      currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
    );
  }
  function shouldRevalidateLoader(loaderMatch, arg) {
    if (loaderMatch.route.shouldRevalidate) {
      let routeChoice = loaderMatch.route.shouldRevalidate(arg);
      if (typeof routeChoice === "boolean") {
        return routeChoice;
      }
    }
    return arg.defaultShouldRevalidate;
  }
  function patchRoutesImpl(routeId, children2, routesToUse, manifest, mapRouteProperties2) {
    let childrenToPatch;
    if (routeId) {
      let route = manifest[routeId];
      invariant(
        route,
        `No route found to patch children into: routeId = ${routeId}`
      );
      if (!route.children) {
        route.children = [];
      }
      childrenToPatch = route.children;
    } else {
      childrenToPatch = routesToUse;
    }
    let uniqueChildren = children2.filter(
      (newRoute) => !childrenToPatch.some(
        (existingRoute) => isSameRoute(newRoute, existingRoute)
      )
    );
    let newRoutes = convertRoutesToDataRoutes(
      uniqueChildren,
      mapRouteProperties2,
      [routeId || "_", "patch", String(childrenToPatch?.length || "0")],
      manifest
    );
    childrenToPatch.push(...newRoutes);
  }
  function isSameRoute(newRoute, existingRoute) {
    if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
      return true;
    }
    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
      return false;
    }
    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
      return true;
    }
    return newRoute.children.every(
      (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))
    );
  }
  var lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();
  var loadLazyRouteProperty = ({
    key,
    route,
    manifest,
    mapRouteProperties: mapRouteProperties2
  }) => {
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== "object") {
      return;
    }
    let lazyFn = routeToUpdate.lazy[key];
    if (!lazyFn) {
      return;
    }
    let cache2 = lazyRoutePropertyCache.get(routeToUpdate);
    if (!cache2) {
      cache2 = {};
      lazyRoutePropertyCache.set(routeToUpdate, cache2);
    }
    let cachedPromise = cache2[key];
    if (cachedPromise) {
      return cachedPromise;
    }
    let propertyPromise = (async () => {
      let isUnsupported = isUnsupportedLazyRouteObjectKey(key);
      let staticRouteValue = routeToUpdate[key];
      let isStaticallyDefined = staticRouteValue !== void 0 && key !== "hasErrorBoundary";
      if (isUnsupported) {
        warning(
          !isUnsupported,
          "Route property " + key + " is not a supported lazy route property. This property will be ignored."
        );
        cache2[key] = Promise.resolve();
      } else if (isStaticallyDefined) {
        warning(
          false,
          `Route "${routeToUpdate.id}" has a static property "${key}" defined. The lazy property will be ignored.`
        );
      } else {
        let value = await lazyFn();
        if (value != null) {
          Object.assign(routeToUpdate, { [key]: value });
          Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));
        }
      }
      if (typeof routeToUpdate.lazy === "object") {
        routeToUpdate.lazy[key] = void 0;
        if (Object.values(routeToUpdate.lazy).every((value) => value === void 0)) {
          routeToUpdate.lazy = void 0;
        }
      }
    })();
    cache2[key] = propertyPromise;
    return propertyPromise;
  };
  var lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();
  function loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    if (!route.lazy) {
      return {
        lazyRoutePromise: void 0,
        lazyHandlerPromise: void 0
      };
    }
    if (typeof route.lazy === "function") {
      let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);
      if (cachedPromise) {
        return {
          lazyRoutePromise: cachedPromise,
          lazyHandlerPromise: cachedPromise
        };
      }
      let lazyRoutePromise2 = (async () => {
        invariant(
          typeof route.lazy === "function",
          "No lazy route function found"
        );
        let lazyRoute = await route.lazy();
        let routeUpdates = {};
        for (let lazyRouteProperty in lazyRoute) {
          let lazyValue = lazyRoute[lazyRouteProperty];
          if (lazyValue === void 0) {
            continue;
          }
          let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);
          let staticRouteValue = routeToUpdate[lazyRouteProperty];
          let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
          // on the route updates
          lazyRouteProperty !== "hasErrorBoundary";
          if (isUnsupported) {
            warning(
              !isUnsupported,
              "Route property " + lazyRouteProperty + " is not a supported property to be returned from a lazy route function. This property will be ignored."
            );
          } else if (isStaticallyDefined) {
            warning(
              !isStaticallyDefined,
              `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
            );
          } else {
            routeUpdates[lazyRouteProperty] = lazyValue;
          }
        }
        Object.assign(routeToUpdate, routeUpdates);
        Object.assign(routeToUpdate, {
          // To keep things framework agnostic, we use the provided `mapRouteProperties`
          // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
          // since the logic will differ between frameworks.
          ...mapRouteProperties2(routeToUpdate),
          lazy: void 0
        });
      })();
      lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);
      lazyRoutePromise2.catch(() => {
      });
      return {
        lazyRoutePromise: lazyRoutePromise2,
        lazyHandlerPromise: lazyRoutePromise2
      };
    }
    let lazyKeys = Object.keys(route.lazy);
    let lazyPropertyPromises = [];
    let lazyHandlerPromise = void 0;
    for (let key of lazyKeys) {
      if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {
        continue;
      }
      let promise = loadLazyRouteProperty({
        key,
        route,
        manifest,
        mapRouteProperties: mapRouteProperties2
      });
      if (promise) {
        lazyPropertyPromises.push(promise);
        if (key === type) {
          lazyHandlerPromise = promise;
        }
      }
    }
    let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {
    }) : void 0;
    lazyRoutePromise?.catch(() => {
    });
    lazyHandlerPromise?.catch(() => {
    });
    return {
      lazyRoutePromise,
      lazyHandlerPromise
    };
  }
  async function defaultDataStrategy(args) {
    let matchesToLoad = args.matches.filter((m) => m.shouldLoad);
    let keyedResults = {};
    let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
    results.forEach((result, i) => {
      keyedResults[matchesToLoad[i].route.id] = result;
    });
    return keyedResults;
  }
  async function defaultDataStrategyWithMiddleware(args) {
    if (!args.matches.some((m) => m.route.unstable_middleware)) {
      return defaultDataStrategy(args);
    }
    return runMiddlewarePipeline(
      args,
      false,
      () => defaultDataStrategy(args),
      (error, routeId) => ({ [routeId]: { type: "error", result: error } })
    );
  }
  async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {
    let { matches, request, params, context } = args;
    let middlewareState = {
      handlerResult: void 0
    };
    try {
      let tuples = matches.flatMap(
        (m) => m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) => [m.route.id, fn]) : []
      );
      let result = await callRouteMiddleware(
        { request, params, context },
        tuples,
        propagateResult,
        middlewareState,
        handler
      );
      return propagateResult ? result : middlewareState.handlerResult;
    } catch (e) {
      if (!middlewareState.middlewareError) {
        throw e;
      }
      let result = await errorHandler(
        middlewareState.middlewareError.error,
        middlewareState.middlewareError.routeId
      );
      if (propagateResult || !middlewareState.handlerResult) {
        return result;
      }
      return Object.assign(middlewareState.handlerResult, result);
    }
  }
  async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {
    let { request } = args;
    if (request.signal.aborted) {
      if (request.signal.reason) {
        throw request.signal.reason;
      }
      throw new Error(
        `Request aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
      );
    }
    let tuple = middlewares[idx];
    if (!tuple) {
      middlewareState.handlerResult = await handler();
      return middlewareState.handlerResult;
    }
    let [routeId, middleware2] = tuple;
    let nextCalled = false;
    let nextResult = void 0;
    let next2 = async () => {
      if (nextCalled) {
        throw new Error("You may only call `next()` once per middleware");
      }
      nextCalled = true;
      let result = await callRouteMiddleware(
        args,
        middlewares,
        propagateResult,
        middlewareState,
        handler,
        idx + 1
      );
      if (propagateResult) {
        nextResult = result;
        return nextResult;
      }
    };
    try {
      let result = await middleware2(
        {
          request: args.request,
          params: args.params,
          context: args.context
        },
        next2
      );
      if (nextCalled) {
        if (result === void 0) {
          return nextResult;
        } else {
          return result;
        }
      } else {
        return next2();
      }
    } catch (error) {
      if (!middlewareState.middlewareError) {
        middlewareState.middlewareError = { routeId, error };
      } else if (middlewareState.middlewareError.error !== error) {
        middlewareState.middlewareError = { routeId, error };
      }
      throw error;
    }
  }
  function getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match2, lazyRoutePropertiesToSkip) {
    let lazyMiddlewarePromise = loadLazyRouteProperty({
      key: "unstable_middleware",
      route: match2.route,
      manifest,
      mapRouteProperties: mapRouteProperties2
    });
    let lazyRoutePromises = loadLazyRoute(
      match2.route,
      isMutationMethod(request.method) ? "action" : "loader",
      manifest,
      mapRouteProperties2,
      lazyRoutePropertiesToSkip
    );
    return {
      middleware: lazyMiddlewarePromise,
      route: lazyRoutePromises.lazyRoutePromise,
      handler: lazyRoutePromises.lazyHandlerPromise
    };
  }
  function getDataStrategyMatch(mapRouteProperties2, manifest, request, match2, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {
    let isUsingNewApi = false;
    let _lazyPromises = getDataStrategyMatchLazyPromises(
      mapRouteProperties2,
      manifest,
      request,
      match2,
      lazyRoutePropertiesToSkip
    );
    return {
      ...match2,
      _lazyPromises,
      shouldLoad,
      unstable_shouldRevalidateArgs,
      unstable_shouldCallHandler(defaultShouldRevalidate) {
        isUsingNewApi = true;
        if (!unstable_shouldRevalidateArgs) {
          return shouldLoad;
        }
        if (typeof defaultShouldRevalidate === "boolean") {
          return shouldRevalidateLoader(match2, {
            ...unstable_shouldRevalidateArgs,
            defaultShouldRevalidate
          });
        }
        return shouldRevalidateLoader(match2, unstable_shouldRevalidateArgs);
      },
      resolve(handlerOverride) {
        if (isUsingNewApi || shouldLoad || handlerOverride && request.method === "GET" && (match2.route.lazy || match2.route.loader)) {
          return callLoaderOrAction({
            request,
            match: match2,
            lazyHandlerPromise: _lazyPromises?.handler,
            lazyRoutePromise: _lazyPromises?.route,
            handlerOverride,
            scopedContext
          });
        }
        return Promise.resolve({ type: "data", result: void 0 });
      }
    };
  }
  function getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {
    return matches.map((match2) => {
      if (match2.route.id !== targetMatch.route.id) {
        return {
          ...match2,
          shouldLoad: false,
          unstable_shouldRevalidateArgs: shouldRevalidateArgs,
          unstable_shouldCallHandler: () => false,
          _lazyPromises: getDataStrategyMatchLazyPromises(
            mapRouteProperties2,
            manifest,
            request,
            match2,
            lazyRoutePropertiesToSkip
          ),
          resolve: () => Promise.resolve({ type: "data", result: void 0 })
        };
      }
      return getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request,
        match2,
        lazyRoutePropertiesToSkip,
        scopedContext,
        true,
        shouldRevalidateArgs
      );
    });
  }
  async function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {
    if (matches.some((m) => m._lazyPromises?.middleware)) {
      await Promise.all(matches.map((m) => m._lazyPromises?.middleware));
    }
    let dataStrategyArgs = {
      request,
      params: matches[0].params,
      context: scopedContext,
      matches
    };
    let unstable_runClientMiddleware = isStaticHandler ? () => {
      throw new Error(
        "You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`"
      );
    } : (cb) => {
      let typedDataStrategyArgs = dataStrategyArgs;
      return runMiddlewarePipeline(
        typedDataStrategyArgs,
        false,
        () => cb({
          ...typedDataStrategyArgs,
          fetcherKey,
          unstable_runClientMiddleware: () => {
            throw new Error(
              "Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler"
            );
          }
        }),
        (error, routeId) => ({
          [routeId]: { type: "error", result: error }
        })
      );
    };
    let results = await dataStrategyImpl({
      ...dataStrategyArgs,
      fetcherKey,
      unstable_runClientMiddleware
    });
    try {
      await Promise.all(
        matches.flatMap((m) => [m._lazyPromises?.handler, m._lazyPromises?.route])
      );
    } catch (e) {
    }
    return results;
  }
  async function callLoaderOrAction({
    request,
    match: match2,
    lazyHandlerPromise,
    lazyRoutePromise,
    handlerOverride,
    scopedContext
  }) {
    let result;
    let onReject;
    let isAction = isMutationMethod(request.method);
    let type = isAction ? "action" : "loader";
    let runHandler = (handler) => {
      let reject;
      let abortPromise = new Promise((_, r) => reject = r);
      onReject = () => reject();
      request.signal.addEventListener("abort", onReject);
      let actualHandler = (ctx) => {
        if (typeof handler !== "function") {
          return Promise.reject(
            new Error(
              `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match2.route.id}]`
            )
          );
        }
        return handler(
          {
            request,
            params: match2.params,
            context: scopedContext
          },
          ...ctx !== void 0 ? [ctx] : []
        );
      };
      let handlerPromise = (async () => {
        try {
          let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
          return { type: "data", result: val };
        } catch (e) {
          return { type: "error", result: e };
        }
      })();
      return Promise.race([handlerPromise, abortPromise]);
    };
    try {
      let handler = isAction ? match2.route.action : match2.route.loader;
      if (lazyHandlerPromise || lazyRoutePromise) {
        if (handler) {
          let handlerError;
          let [value] = await Promise.all([
            // If the handler throws, don't let it immediately bubble out,
            // since we need to let the lazy() execution finish so we know if this
            // route has a boundary that can handle the error
            runHandler(handler).catch((e) => {
              handlerError = e;
            }),
            // Ensure all lazy route promises are resolved before continuing
            lazyHandlerPromise,
            lazyRoutePromise
          ]);
          if (handlerError !== void 0) {
            throw handlerError;
          }
          result = value;
        } else {
          await lazyHandlerPromise;
          let handler2 = isAction ? match2.route.action : match2.route.loader;
          if (handler2) {
            [result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);
          } else if (type === "action") {
            let url = new URL(request.url);
            let pathname = url.pathname + url.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match2.route.id
            });
          } else {
            return { type: "data", result: void 0 };
          }
        }
      } else if (!handler) {
        let url = new URL(request.url);
        let pathname = url.pathname + url.search;
        throw getInternalRouterError(404, {
          pathname
        });
      } else {
        result = await runHandler(handler);
      }
    } catch (e) {
      return { type: "error", result: e };
    } finally {
      if (onReject) {
        request.signal.removeEventListener("abort", onReject);
      }
    }
    return result;
  }
  async function convertDataStrategyResultToDataResult(dataStrategyResult) {
    let { result, type } = dataStrategyResult;
    if (isResponse(result)) {
      let data2;
      try {
        let contentType = result.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          if (result.body == null) {
            data2 = null;
          } else {
            data2 = await result.json();
          }
        } else {
          data2 = await result.text();
        }
      } catch (e) {
        return { type: "error", error: e };
      }
      if (type === "error") {
        return {
          type: "error",
          error: new ErrorResponseImpl(result.status, result.statusText, data2),
          statusCode: result.status,
          headers: result.headers
        };
      }
      return {
        type: "data",
        data: data2,
        statusCode: result.status,
        headers: result.headers
      };
    }
    if (type === "error") {
      if (isDataWithResponseInit(result)) {
        if (result.data instanceof Error) {
          return {
            type: "error",
            error: result.data,
            statusCode: result.init?.status,
            headers: result.init?.headers ? new Headers(result.init.headers) : void 0
          };
        }
        return {
          type: "error",
          error: new ErrorResponseImpl(
            result.init?.status || 500,
            void 0,
            result.data
          ),
          statusCode: isRouteErrorResponse(result) ? result.status : void 0,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: "error",
        error: result,
        statusCode: isRouteErrorResponse(result) ? result.status : void 0
      };
    }
    if (isDataWithResponseInit(result)) {
      return {
        type: "data",
        data: result.data,
        statusCode: result.init?.status,
        headers: result.init?.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return { type: "data", data: result };
  }
  function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename2) {
    let location = response.headers.get("Location");
    invariant(
      location,
      "Redirects returned/thrown from loaders/actions must have a Location header"
    );
    if (!ABSOLUTE_URL_REGEX.test(location)) {
      let trimmedMatches = matches.slice(
        0,
        matches.findIndex((m) => m.route.id === routeId) + 1
      );
      location = normalizeTo(
        new URL(request.url),
        trimmedMatches,
        basename2,
        location
      );
      response.headers.set("Location", location);
    }
    return response;
  }
  function normalizeRedirectLocation(location, currentUrl, basename2) {
    if (ABSOLUTE_URL_REGEX.test(location)) {
      let normalizedLocation = location;
      let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
      let isSameBasename = stripBasename(url.pathname, basename2) != null;
      if (url.origin === currentUrl.origin && isSameBasename) {
        return url.pathname + url.search + url.hash;
      }
    }
    return location;
  }
  function createClientSideRequest(history, location, signal, submission) {
    let url = history.createURL(stripHashFromPath(location)).toString();
    let init = { signal };
    if (submission && isMutationMethod(submission.formMethod)) {
      let { formMethod, formEncType } = submission;
      init.method = formMethod.toUpperCase();
      if (formEncType === "application/json") {
        init.headers = new Headers({ "Content-Type": formEncType });
        init.body = JSON.stringify(submission.json);
      } else if (formEncType === "text/plain") {
        init.body = submission.text;
      } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
        init.body = convertFormDataToSearchParams(submission.formData);
      } else {
        init.body = submission.formData;
      }
    }
    return new Request(url, init);
  }
  function convertFormDataToSearchParams(formData) {
    let searchParams = new URLSearchParams();
    for (let [key, value] of formData.entries()) {
      searchParams.append(key, typeof value === "string" ? value : value.name);
    }
    return searchParams;
  }
  function convertSearchParamsToFormData(searchParams) {
    let formData = new FormData();
    for (let [key, value] of searchParams.entries()) {
      formData.append(key, value);
    }
    return formData;
  }
  function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
    let loaderData = {};
    let errors = null;
    let statusCode;
    let foundError = false;
    let loaderHeaders = {};
    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
    matches.forEach((match2) => {
      if (!(match2.route.id in results)) {
        return;
      }
      let id = match2.route.id;
      let result = results[id];
      invariant(
        !isRedirectResult(result),
        "Cannot handle redirect results in processLoaderData"
      );
      if (isErrorResult(result)) {
        let error = result.error;
        if (pendingError !== void 0) {
          error = pendingError;
          pendingError = void 0;
        }
        errors = errors || {};
        if (skipLoaderErrorBubbling) {
          errors[id] = error;
        } else {
          let boundaryMatch = findNearestBoundary(matches, id);
          if (errors[boundaryMatch.route.id] == null) {
            errors[boundaryMatch.route.id] = error;
          }
        }
        if (!isStaticHandler) {
          loaderData[id] = ResetLoaderDataSymbol;
        }
        if (!foundError) {
          foundError = true;
          statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      } else {
        loaderData[id] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      }
    });
    if (pendingError !== void 0 && pendingActionResult) {
      errors = { [pendingActionResult[0]]: pendingError };
      if (pendingActionResult[2]) {
        loaderData[pendingActionResult[2]] = void 0;
      }
    }
    return {
      loaderData,
      errors,
      statusCode: statusCode || 200,
      loaderHeaders
    };
  }
  function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
    let { loaderData, errors } = processRouteLoaderData(
      matches,
      results,
      pendingActionResult
    );
    revalidatingFetchers.filter((f) => !f.matches || f.matches.some((m) => m.shouldLoad)).forEach((rf) => {
      let { key, match: match2, controller } = rf;
      let result = fetcherResults[key];
      invariant(result, "Did not find corresponding fetcher result");
      if (controller && controller.signal.aborted) {
        return;
      } else if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(state.matches, match2?.route.id);
        if (!(errors && errors[boundaryMatch.route.id])) {
          errors = {
            ...errors,
            [boundaryMatch.route.id]: result.error
          };
        }
        state.fetchers.delete(key);
      } else if (isRedirectResult(result)) {
        invariant(false, "Unhandled fetcher revalidation redirect");
      } else {
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
      }
    });
    return { loaderData, errors };
  }
  function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
      merged[k] = v;
      return merged;
    }, {});
    for (let match2 of matches) {
      let id = match2.route.id;
      if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match2.route.loader) {
        mergedLoaderData[id] = loaderData[id];
      }
      if (errors && errors.hasOwnProperty(id)) {
        break;
      }
    }
    return mergedLoaderData;
  }
  function getActionDataForCommit(pendingActionResult) {
    if (!pendingActionResult) {
      return {};
    }
    return isErrorResult(pendingActionResult[1]) ? {
      // Clear out prior actionData on errors
      actionData: {}
    } : {
      actionData: {
        [pendingActionResult[0]]: pendingActionResult[1].data
      }
    };
  }
  function findNearestBoundary(matches, routeId) {
    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];
    return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];
  }
  function getShortCircuitMatches(routes) {
    let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === "/") || {
      id: `__shim-error-route__`
    };
    return {
      matches: [
        {
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }
      ],
      route
    };
  }
  function getInternalRouterError(status, {
    pathname,
    routeId,
    method,
    type,
    message
  } = {}) {
    let statusText = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";
    if (status === 400) {
      statusText = "Bad Request";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (type === "invalid-body") {
        errorMessage = "Unable to encode submission body";
      }
    } else if (status === 403) {
      statusText = "Forbidden";
      errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
    } else if (status === 404) {
      statusText = "Not Found";
      errorMessage = `No route matches URL "${pathname}"`;
    } else if (status === 405) {
      statusText = "Method Not Allowed";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (method) {
        errorMessage = `Invalid request method "${method.toUpperCase()}"`;
      }
    }
    return new ErrorResponseImpl(
      status || 500,
      statusText,
      new Error(errorMessage),
      true
    );
  }
  function findRedirect(results) {
    let entries = Object.entries(results);
    for (let i = entries.length - 1; i >= 0; i--) {
      let [key, result] = entries[i];
      if (isRedirectResult(result)) {
        return { key, result };
      }
    }
  }
  function stripHashFromPath(path2) {
    let parsedPath = typeof path2 === "string" ? parsePath(path2) : path2;
    return createPath({ ...parsedPath, hash: "" });
  }
  function isHashChangeOnly(a, b) {
    if (a.pathname !== b.pathname || a.search !== b.search) {
      return false;
    }
    if (a.hash === "") {
      return b.hash !== "";
    } else if (a.hash === b.hash) {
      return true;
    } else if (b.hash !== "") {
      return true;
    }
    return false;
  }
  function isRedirectDataStrategyResult(result) {
    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
  }
  function isErrorResult(result) {
    return result.type === "error";
  }
  function isRedirectResult(result) {
    return (result && result.type) === "redirect";
  }
  function isDataWithResponseInit(value) {
    return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
  }
  function isResponse(value) {
    return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
  }
  function isValidMethod(method) {
    return validRequestMethods.has(method.toUpperCase());
  }
  function isMutationMethod(method) {
    return validMutationMethods.has(method.toUpperCase());
  }
  function hasNakedIndexQuery(search2) {
    return new URLSearchParams(search2).getAll("index").some((v) => v === "");
  }
  function getTargetMatch(matches, location) {
    let search2 = typeof location === "string" ? parsePath(location).search : location.search;
    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search2 || "")) {
      return matches[matches.length - 1];
    }
    let pathMatches = getPathContributingMatches(matches);
    return pathMatches[pathMatches.length - 1];
  }
  function getSubmissionFromNavigation(navigation) {
    let { formMethod, formAction, formEncType, text: text9, formData, json } = navigation;
    if (!formMethod || !formAction || !formEncType) {
      return;
    }
    if (text9 != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: void 0,
        text: text9
      };
    } else if (formData != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData,
        json: void 0,
        text: void 0
      };
    } else if (json !== void 0) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json,
        text: void 0
      };
    }
  }
  function getLoadingNavigation(location, submission) {
    if (submission) {
      let navigation = {
        state: "loading",
        location,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    } else {
      let navigation = {
        state: "loading",
        location,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
      };
      return navigation;
    }
  }
  function getSubmittingNavigation(location, submission) {
    let navigation = {
      state: "submitting",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  }
  function getLoadingFetcher(submission, data2) {
    if (submission) {
      let fetcher = {
        state: "loading",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: data2
      };
      return fetcher;
    } else {
      let fetcher = {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
  }
  function getSubmittingFetcher(submission, existingFetcher) {
    let fetcher = {
      state: "submitting",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: existingFetcher ? existingFetcher.data : void 0
    };
    return fetcher;
  }
  function getDoneFetcher(data2) {
    let fetcher = {
      state: "idle",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
  function restoreAppliedTransitions(_window, transitions) {
    try {
      let sessionPositions = _window.sessionStorage.getItem(
        TRANSITIONS_STORAGE_KEY
      );
      if (sessionPositions) {
        let json = JSON.parse(sessionPositions);
        for (let [k, v] of Object.entries(json || {})) {
          if (v && Array.isArray(v)) {
            transitions.set(k, new Set(v || []));
          }
        }
      }
    } catch (e) {
    }
  }
  function persistAppliedTransitions(_window, transitions) {
    if (transitions.size > 0) {
      let json = {};
      for (let [k, v] of transitions) {
        json[k] = [...v];
      }
      try {
        _window.sessionStorage.setItem(
          TRANSITIONS_STORAGE_KEY,
          JSON.stringify(json)
        );
      } catch (error) {
        warning(
          false,
          `Failed to save applied view transitions in sessionStorage (${error}).`
        );
      }
    }
  }
  function createDeferred() {
    let resolve;
    let reject;
    let promise = new Promise((res, rej) => {
      resolve = async (val) => {
        res(val);
        try {
          await promise;
        } catch (e) {
        }
      };
      reject = async (error) => {
        rej(error);
        try {
          await promise;
        } catch (e) {
        }
      };
    });
    return {
      promise,
      //@ts-ignore
      resolve,
      //@ts-ignore
      reject
    };
  }
  var DataRouterContext = React.createContext(null);
  DataRouterContext.displayName = "DataRouter";
  var DataRouterStateContext = React.createContext(null);
  DataRouterStateContext.displayName = "DataRouterState";
  var ViewTransitionContext = React.createContext({
    isTransitioning: false
  });
  ViewTransitionContext.displayName = "ViewTransition";
  var FetchersContext = React.createContext(
    /* @__PURE__ */ new Map()
  );
  FetchersContext.displayName = "Fetchers";
  var AwaitContext = React.createContext(null);
  AwaitContext.displayName = "Await";
  var NavigationContext = React.createContext(
    null
  );
  NavigationContext.displayName = "Navigation";
  var LocationContext = React.createContext(
    null
  );
  LocationContext.displayName = "Location";
  var RouteContext = React.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  RouteContext.displayName = "Route";
  var RouteErrorContext = React.createContext(null);
  RouteErrorContext.displayName = "RouteError";
  var ENABLE_DEV_WARNINGS = true;
  function useHref(to, { relative } = {}) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useHref() may be used only in the context of a <Router> component.`
    );
    let { basename: basename2, navigator: navigator2 } = React2.useContext(NavigationContext);
    let { hash: hash2, pathname, search: search2 } = useResolvedPath(to, { relative });
    let joinedPathname = pathname;
    if (basename2 !== "/") {
      joinedPathname = pathname === "/" ? basename2 : joinPaths([basename2, pathname]);
    }
    return navigator2.createHref({ pathname: joinedPathname, search: search2, hash: hash2 });
  }
  function useInRouterContext() {
    return React2.useContext(LocationContext) != null;
  }
  function useLocation() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useLocation() may be used only in the context of a <Router> component.`
    );
    return React2.useContext(LocationContext).location;
  }
  var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
  function useIsomorphicLayoutEffect(cb) {
    let isStatic = React2.useContext(NavigationContext).static;
    if (!isStatic) {
      React2.useLayoutEffect(cb);
    }
  }
  function useNavigate() {
    let { isDataRoute } = React2.useContext(RouteContext);
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useNavigate() may be used only in the context of a <Router> component.`
    );
    let dataRouterContext = React2.useContext(DataRouterContext);
    let { basename: basename2, navigator: navigator2 } = React2.useContext(NavigationContext);
    let { matches } = React2.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
    let activeRef = React2.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React2.useCallback(
      (to, options = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path2 = resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          options.relative === "path"
        );
        if (dataRouterContext == null && basename2 !== "/") {
          path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(
          path2,
          options.state,
          options
        );
      },
      [
        basename2,
        navigator2,
        routePathnamesJson,
        locationPathname,
        dataRouterContext
      ]
    );
    return navigate;
  }
  var OutletContext = React2.createContext(null);
  function useResolvedPath(to, { relative } = {}) {
    let { matches } = React2.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
    return React2.useMemo(
      () => resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        relative === "path"
      ),
      [to, routePathnamesJson, locationPathname, relative]
    );
  }
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useRoutes() may be used only in the context of a <Router> component.`
    );
    let { navigator: navigator2 } = React2.useContext(NavigationContext);
    let { matches: parentMatches } = React2.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;
    if (ENABLE_DEV_WARNINGS) {
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(
        parentPathname,
        !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
        `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
      );
    }
    let locationFromContext = useLocation();
    let location;
    if (locationArg) {
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      invariant(
        parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
        `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
      );
      location = parsedLocationArg;
    } else {
      location = locationFromContext;
    }
    let pathname = location.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches = matchRoutes(routes, { pathname: remainingPathname });
    if (ENABLE_DEV_WARNINGS) {
      warning(
        parentRoute || matches != null,
        `No routes matched location "${location.pathname}${location.search}${location.hash}" `
      );
      warning(
        matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
        `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
      );
    }
    let renderedMatches = _renderMatches(
      matches && matches.map(
        (match2) => Object.assign({}, match2, {
          params: Object.assign({}, parentParams, match2.params),
          pathname: joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
          ]),
          pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
          ])
        })
      ),
      parentMatches,
      dataRouterState,
      future
    );
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ React2.createElement(
        LocationContext.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              ...location
            },
            navigationType: "POP"
            /* Pop */
          }
        },
        renderedMatches
      );
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
    let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
    let devInfo = null;
    if (ENABLE_DEV_WARNINGS) {
      console.error(
        "Error handled by React Router default ErrorBoundary:",
        error
      );
      devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React2.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
    }
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React2.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ React2.createElement("pre", { style: preStyles }, stack) : null, devInfo);
  }
  var defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);
  var RenderErrorBoundary = class extends React2.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    static getDerivedStateFromProps(props, state) {
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error !== void 0 ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error(
        "React Router caught the following error during render",
        error,
        errorInfo
      );
    }
    render() {
      return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(
        RouteErrorContext.Provider,
        {
          value: this.state.error,
          children: this.props.component
        }
      )) : this.props.children;
    }
  };
  function RenderedRoute({ routeContext, match: match2, children: children2 }) {
    let dataRouterContext = React2.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
    }
    return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children2);
  }
  function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
    if (matches == null) {
      if (!dataRouterState) {
        return null;
      }
      if (dataRouterState.errors) {
        matches = dataRouterState.matches;
      } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;
    let errors = dataRouterState?.errors;
    if (errors != null) {
      let errorIndex = renderedMatches.findIndex(
        (m) => m.route.id && errors?.[m.route.id] !== void 0
      );
      invariant(
        errorIndex >= 0,
        `Could not find a matching route for errors on route IDs: ${Object.keys(
          errors
        ).join(",")}`
      );
      renderedMatches = renderedMatches.slice(
        0,
        Math.min(renderedMatches.length, errorIndex + 1)
      );
    }
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState) {
      for (let i = 0; i < renderedMatches.length; i++) {
        let match2 = renderedMatches[i];
        if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
          fallbackIndex = i;
        }
        if (match2.route.id) {
          let { loaderData, errors: errors2 } = dataRouterState;
          let needsToRunLoader = match2.route.loader && !loaderData.hasOwnProperty(match2.route.id) && (!errors2 || errors2[match2.route.id] === void 0);
          if (match2.route.lazy || needsToRunLoader) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match2, index2) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match2.route.id ? errors[match2.route.id] : void 0;
        errorElement = match2.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index2 === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index2) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
      let getChildren = () => {
        let children2;
        if (error) {
          children2 = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children2 = hydrateFallbackElement;
        } else if (match2.route.Component) {
          children2 = /* @__PURE__ */ React2.createElement(match2.route.Component, null);
        } else if (match2.route.element) {
          children2 = match2.route.element;
        } else {
          children2 = outlet;
        }
        return /* @__PURE__ */ React2.createElement(
          RenderedRoute,
          {
            match: match2,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children: children2
          }
        );
      };
      return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ React2.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true }
        }
      ) : getChildren();
    }, null);
  }
  function getDataRouterConsoleError(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext(hookName) {
    let ctx = React2.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError(hookName));
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React2.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError(hookName));
    return state;
  }
  function useRouteContext(hookName) {
    let route = React2.useContext(RouteContext);
    invariant(route, getDataRouterConsoleError(hookName));
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext(hookName);
    let thisRoute = route.matches[route.matches.length - 1];
    invariant(
      thisRoute.route.id,
      `${hookName} can only be used on routes that contain a unique "id"`
    );
    return thisRoute.route.id;
  }
  function useRouteId() {
    return useCurrentRouteId(
      "useRouteId"
      /* UseRouteId */
    );
  }
  function useNavigation() {
    let state = useDataRouterState(
      "useNavigation"
      /* UseNavigation */
    );
    return state.navigation;
  }
  function useMatches() {
    let { matches, loaderData } = useDataRouterState(
      "useMatches"
      /* UseMatches */
    );
    return React2.useMemo(
      () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
      [matches, loaderData]
    );
  }
  function useRouteError() {
    let error = React2.useContext(RouteErrorContext);
    let state = useDataRouterState(
      "useRouteError"
      /* UseRouteError */
    );
    let routeId = useCurrentRouteId(
      "useRouteError"
      /* UseRouteError */
    );
    if (error !== void 0) {
      return error;
    }
    return state.errors?.[routeId];
  }
  function useNavigateStable() {
    let { router: router2 } = useDataRouterContext(
      "useNavigate"
      /* UseNavigateStable */
    );
    let id = useCurrentRouteId(
      "useNavigate"
      /* UseNavigateStable */
    );
    let activeRef = React2.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React2.useCallback(
      async (to, options = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to === "number") {
          router2.navigate(to);
        } else {
          await router2.navigate(to, { fromRouteId: id, ...options });
        }
      },
      [router2, id]
    );
    return navigate;
  }
  var alreadyWarned = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned[key]) {
      alreadyWarned[key] = true;
      warning(false, message);
    }
  }
  var alreadyWarned2 = {};
  function warnOnce(condition, message) {
    if (!condition && !alreadyWarned2[message]) {
      alreadyWarned2[message] = true;
      console.warn(message);
    }
  }
  function mapRouteProperties(route) {
    let updates = {
      // Note: this check also occurs in createRoutesFromChildren so update
      // there if you change this -- please and thank you!
      hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
    };
    if (route.Component) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.element) {
          warning(
            false,
            "You should not include both `Component` and `element` on your route - `Component` will be used."
          );
        }
      }
      Object.assign(updates, {
        element: React3.createElement(route.Component),
        Component: void 0
      });
    }
    if (route.HydrateFallback) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.hydrateFallbackElement) {
          warning(
            false,
            "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
          );
        }
      }
      Object.assign(updates, {
        hydrateFallbackElement: React3.createElement(route.HydrateFallback),
        HydrateFallback: void 0
      });
    }
    if (route.ErrorBoundary) {
      if (ENABLE_DEV_WARNINGS) {
        if (route.errorElement) {
          warning(
            false,
            "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
          );
        }
      }
      Object.assign(updates, {
        errorElement: React3.createElement(route.ErrorBoundary),
        ErrorBoundary: void 0
      });
    }
    return updates;
  }
  var hydrationRouteProperties = [
    "HydrateFallback",
    "hydrateFallbackElement"
  ];
  var Deferred = class {
    constructor() {
      this.status = "pending";
      this.promise = new Promise((resolve, reject) => {
        this.resolve = (value) => {
          if (this.status === "pending") {
            this.status = "resolved";
            resolve(value);
          }
        };
        this.reject = (reason) => {
          if (this.status === "pending") {
            this.status = "rejected";
            reject(reason);
          }
        };
      });
    }
  };
  function RouterProvider({
    router: router2,
    flushSync: reactDomFlushSyncImpl
  }) {
    let [state, setStateImpl] = React3.useState(router2.state);
    let [pendingState, setPendingState] = React3.useState();
    let [vtContext, setVtContext] = React3.useState({
      isTransitioning: false
    });
    let [renderDfd, setRenderDfd] = React3.useState();
    let [transition3, setTransition] = React3.useState();
    let [interruption, setInterruption] = React3.useState();
    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());
    let setState = React3.useCallback(
      (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
        newState.fetchers.forEach((fetcher, key) => {
          if (fetcher.data !== void 0) {
            fetcherData.current.set(key, fetcher.data);
          }
        });
        deletedFetchers.forEach((key) => fetcherData.current.delete(key));
        warnOnce(
          flushSync === false || reactDomFlushSyncImpl != null,
          'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
        );
        let isViewTransitionAvailable = router2.window != null && router2.window.document != null && typeof router2.window.document.startViewTransition === "function";
        warnOnce(
          viewTransitionOpts == null || isViewTransitionAvailable,
          "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
        );
        if (!viewTransitionOpts || !isViewTransitionAvailable) {
          if (reactDomFlushSyncImpl && flushSync) {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          } else {
            React3.startTransition(() => setStateImpl(newState));
          }
          return;
        }
        if (reactDomFlushSyncImpl && flushSync) {
          reactDomFlushSyncImpl(() => {
            if (transition3) {
              renderDfd && renderDfd.resolve();
              transition3.skipTransition();
            }
            setVtContext({
              isTransitioning: true,
              flushSync: true,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          });
          let t = router2.window.document.startViewTransition(() => {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          });
          t.finished.finally(() => {
            reactDomFlushSyncImpl(() => {
              setRenderDfd(void 0);
              setTransition(void 0);
              setPendingState(void 0);
              setVtContext({ isTransitioning: false });
            });
          });
          reactDomFlushSyncImpl(() => setTransition(t));
          return;
        }
        if (transition3) {
          renderDfd && renderDfd.resolve();
          transition3.skipTransition();
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        } else {
          setPendingState(newState);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        }
      },
      [router2.window, reactDomFlushSyncImpl, transition3, renderDfd]
    );
    React3.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
    React3.useEffect(() => {
      if (vtContext.isTransitioning && !vtContext.flushSync) {
        setRenderDfd(new Deferred());
      }
    }, [vtContext]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && router2.window) {
        let newState = pendingState;
        let renderPromise = renderDfd.promise;
        let transition22 = router2.window.document.startViewTransition(async () => {
          React3.startTransition(() => setStateImpl(newState));
          await renderPromise;
        });
        transition22.finished.finally(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({ isTransitioning: false });
        });
        setTransition(transition22);
      }
    }, [pendingState, renderDfd, router2.window]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
        renderDfd.resolve();
      }
    }, [renderDfd, transition3, state.location, pendingState]);
    React3.useEffect(() => {
      if (!vtContext.isTransitioning && interruption) {
        setPendingState(interruption.state);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: interruption.currentLocation,
          nextLocation: interruption.nextLocation
        });
        setInterruption(void 0);
      }
    }, [vtContext.isTransitioning, interruption]);
    let navigator2 = React3.useMemo(() => {
      return {
        createHref: router2.createHref,
        encodeLocation: router2.encodeLocation,
        go: (n) => router2.navigate(n),
        push: (to, state2, opts) => router2.navigate(to, {
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        }),
        replace: (to, state2, opts) => router2.navigate(to, {
          replace: true,
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        })
      };
    }, [router2]);
    let basename2 = router2.basename || "/";
    let dataRouterContext = React3.useMemo(
      () => ({
        router: router2,
        navigator: navigator2,
        static: false,
        basename: basename2
      }),
      [router2, navigator2, basename2]
    );
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(
      Router,
      {
        basename: basename2,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2
      },
      /* @__PURE__ */ React3.createElement(
        MemoizedDataRoutes,
        {
          routes: router2.routes,
          future: router2.future,
          state
        }
      )
    ))))), null);
  }
  var MemoizedDataRoutes = React3.memo(DataRoutes);
  function DataRoutes({
    routes,
    future,
    state
  }) {
    return useRoutesImpl(routes, void 0, state, future);
  }
  function Router({
    basename: basenameProp = "/",
    children: children2 = null,
    location: locationProp,
    navigationType = "POP",
    navigator: navigator2,
    static: staticProp = false
  }) {
    invariant(
      !useInRouterContext(),
      `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
    );
    let basename2 = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React3.useMemo(
      () => ({
        basename: basename2,
        navigator: navigator2,
        static: staticProp,
        future: {}
      }),
      [basename2, navigator2, staticProp]
    );
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search: search2 = "",
      hash: hash2 = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = React3.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename2);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search: search2,
          hash: hash2,
          state,
          key
        },
        navigationType
      };
    }, [basename2, pathname, search2, hash2, state, key, navigationType]);
    warning(
      locationContext != null,
      `<Router basename="${basename2}"> is not able to match the URL "${pathname}${search2}${hash2}" because it does not start with the basename, so the <Router> won't render anything.`
    );
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children: children2, value: locationContext }));
  }
  var defaultMethod = "get";
  var defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object2) {
    return object2 != null && typeof object2.tagName === "string";
  }
  function isButtonElement(object2) {
    return isHtmlElement(object2) && object2.tagName.toLowerCase() === "button";
  }
  function isFormElement(object2) {
    return isHtmlElement(object2) && object2.tagName.toLowerCase() === "form";
  }
  function isInputElement(object2) {
    return isHtmlElement(object2) && object2.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event);
  }
  var _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(
          document.createElement("form"),
          // @ts-expect-error if FormData supports the submitter parameter, this will throw
          0
        );
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }
  var supportedFormEncTypes = /* @__PURE__ */ new Set([
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  ]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      warning(
        false,
        `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
      );
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename2) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      let attr = target.getAttribute("action");
      action = attr ? stripBasename(attr, basename2) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(
          `Cannot submit a <button> or <input type="submit"> without a <form>`
        );
      }
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? stripBasename(attr, basename2) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(form, target);
      if (!isFormDataSubmitterSupported()) {
        let { name: name21, type, value } = target;
        if (type === "image") {
          let prefix2 = name21 ? `${name21}.` : "";
          formData.append(`${prefix2}x`, "0");
          formData.append(`${prefix2}y`, "0");
        } else if (name21) {
          formData.append(name21, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error(
        `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
      );
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }
    if (formData && encType === "text/plain") {
      body = formData;
      formData = void 0;
    }
    return { action, method: method.toLowerCase(), encType, formData, body };
  }
  function invariant2(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  async function loadRouteModule(route, routeModulesCache) {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        route.module
      );
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error) {
      console.error(
        `Error loading route module \`${route.module}\`, reloading page...`
      );
      console.error(error);
      if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
      import_meta.hot) {
        throw error;
      }
      window.location.reload();
      return new Promise(() => {
      });
    }
  }
  function isPageLinkDescriptor(object2) {
    return object2 != null && typeof object2.page === "string";
  }
  function isHtmlLinkDescriptor(object2) {
    if (object2 == null) {
      return false;
    }
    if (object2.href == null) {
      return object2.rel === "preload" && typeof object2.imageSrcSet === "string" && typeof object2.imageSizes === "string";
    }
    return typeof object2.rel === "string" && typeof object2.href === "string";
  }
  async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
    let links = await Promise.all(
      matches.map(async (match2) => {
        let route = manifest.routes[match2.route.id];
        if (route) {
          let mod = await loadRouteModule(route, routeModules);
          return mod.links ? mod.links() : [];
        }
        return [];
      })
    );
    return dedupeLinkDescriptors(
      links.flat(1).filter(isHtmlLinkDescriptor).filter((link3) => link3.rel === "stylesheet" || link3.rel === "preload").map(
        (link3) => link3.rel === "stylesheet" ? { ...link3, rel: "prefetch", as: "style" } : { ...link3, rel: "prefetch" }
      )
    );
  }
  function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
    let isNew = (match2, index2) => {
      if (!currentMatches[index2]) return true;
      return match2.route.id !== currentMatches[index2].route.id;
    };
    let matchPathChanged = (match2, index2) => {
      return (
        // param change, /users/123 -> /users/456
        currentMatches[index2].pathname !== match2.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentMatches[index2].route.path?.endsWith("*") && currentMatches[index2].params["*"] !== match2.params["*"]
      );
    };
    if (mode === "assets") {
      return nextMatches.filter(
        (match2, index2) => isNew(match2, index2) || matchPathChanged(match2, index2)
      );
    }
    if (mode === "data") {
      return nextMatches.filter((match2, index2) => {
        let manifestRoute = manifest.routes[match2.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return false;
        }
        if (isNew(match2, index2) || matchPathChanged(match2, index2)) {
          return true;
        }
        if (match2.route.shouldRevalidate) {
          let routeChoice = match2.route.shouldRevalidate({
            currentUrl: new URL(
              location.pathname + location.search + location.hash,
              window.origin
            ),
            currentParams: currentMatches[0]?.params || {},
            nextUrl: new URL(page, window.origin),
            nextParams: match2.params,
            defaultShouldRevalidate: true
          });
          if (typeof routeChoice === "boolean") {
            return routeChoice;
          }
        }
        return true;
      });
    }
    return [];
  }
  function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
    return dedupeHrefs(
      matches.map((match2) => {
        let route = manifest.routes[match2.route.id];
        if (!route) return [];
        let hrefs = [route.module];
        if (route.clientActionModule) {
          hrefs = hrefs.concat(route.clientActionModule);
        }
        if (route.clientLoaderModule) {
          hrefs = hrefs.concat(route.clientLoaderModule);
        }
        if (includeHydrateFallback && route.hydrateFallbackModule) {
          hrefs = hrefs.concat(route.hydrateFallbackModule);
        }
        if (route.imports) {
          hrefs = hrefs.concat(route.imports);
        }
        return hrefs;
      }).flat(1)
    );
  }
  function dedupeHrefs(hrefs) {
    return [...new Set(hrefs)];
  }
  function sortKeys(obj) {
    let sorted = {};
    let keys2 = Object.keys(obj).sort();
    for (let key of keys2) {
      sorted[key] = obj[key];
    }
    return sorted;
  }
  function dedupeLinkDescriptors(descriptors, preloads) {
    let set = /* @__PURE__ */ new Set();
    let preloadsSet = new Set(preloads);
    return descriptors.reduce((deduped, descriptor) => {
      let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
      if (alreadyModulePreload) {
        return deduped;
      }
      let key = JSON.stringify(sortKeys(descriptor));
      if (!set.has(key)) {
        set.add(key);
        deduped.push({ key, link: descriptor });
      }
      return deduped;
    }, []);
  }
  var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
  var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
  var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);
  function singleFetchUrl(reqUrl, basename2) {
    let url = typeof reqUrl === "string" ? new URL(
      reqUrl,
      // This can be called during the SSR flow via PrefetchPageLinksImpl so
      // don't assume window is available
      typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
    ) : reqUrl;
    if (url.pathname === "/") {
      url.pathname = "_root.data";
    } else if (basename2 && stripBasename(url.pathname, basename2) === "/") {
      url.pathname = `${basename2.replace(/\/$/, "")}/_root.data`;
    } else {
      url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
    }
    return url;
  }
  function useDataRouterContext2() {
    let context = React9.useContext(DataRouterContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterContext.Provider> element"
    );
    return context;
  }
  function useDataRouterStateContext() {
    let context = React9.useContext(DataRouterStateContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterStateContext.Provider> element"
    );
    return context;
  }
  var FrameworkContext = React9.createContext(void 0);
  FrameworkContext.displayName = "FrameworkContext";
  function useFrameworkContext() {
    let context = React9.useContext(FrameworkContext);
    invariant2(
      context,
      "You must render this element inside a <HydratedRouter> element"
    );
    return context;
  }
  function usePrefetchBehavior(prefetch, theirElementProps) {
    let frameworkContext = React9.useContext(FrameworkContext);
    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);
    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);
    let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
    let ref = React9.useRef(null);
    React9.useEffect(() => {
      if (prefetch === "render") {
        setShouldPrefetch(true);
      }
      if (prefetch === "viewport") {
        let callback = (entries) => {
          entries.forEach((entry) => {
            setShouldPrefetch(entry.isIntersecting);
          });
        };
        let observer = new IntersectionObserver(callback, { threshold: 0.5 });
        if (ref.current) observer.observe(ref.current);
        return () => {
          observer.disconnect();
        };
      }
    }, [prefetch]);
    React9.useEffect(() => {
      if (maybePrefetch) {
        let id = setTimeout(() => {
          setShouldPrefetch(true);
        }, 100);
        return () => {
          clearTimeout(id);
        };
      }
    }, [maybePrefetch]);
    let setIntent = () => {
      setMaybePrefetch(true);
    };
    let cancelIntent = () => {
      setMaybePrefetch(false);
      setShouldPrefetch(false);
    };
    if (!frameworkContext) {
      return [false, ref, {}];
    }
    if (prefetch !== "intent") {
      return [shouldPrefetch, ref, {}];
    }
    return [
      shouldPrefetch,
      ref,
      {
        onFocus: composeEventHandlers(onFocus, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }
    ];
  }
  function composeEventHandlers(theirHandler, ourHandler) {
    return (event) => {
      theirHandler && theirHandler(event);
      if (!event.defaultPrevented) {
        ourHandler(event);
      }
    };
  }
  function PrefetchPageLinks({
    page,
    ...dataLinkProps
  }) {
    let { router: router2 } = useDataRouterContext2();
    let matches = React9.useMemo(
      () => matchRoutes(router2.routes, page, router2.basename),
      [router2.routes, page, router2.basename]
    );
    if (!matches) {
      return null;
    }
    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });
  }
  function useKeyedPrefetchLinks(matches) {
    let { manifest, routeModules } = useFrameworkContext();
    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);
    React9.useEffect(() => {
      let interrupted = false;
      void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
        (links) => {
          if (!interrupted) {
            setKeyedPrefetchLinks(links);
          }
        }
      );
      return () => {
        interrupted = true;
      };
    }, [matches, manifest, routeModules]);
    return keyedPrefetchLinks;
  }
  function PrefetchPageLinksImpl({
    page,
    matches: nextMatches,
    ...linkProps
  }) {
    let location = useLocation();
    let { manifest, routeModules } = useFrameworkContext();
    let { basename: basename2 } = useDataRouterContext2();
    let { loaderData, matches } = useDataRouterStateContext();
    let newMatchesForData = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "data"
      ),
      [page, nextMatches, matches, manifest, location]
    );
    let newMatchesForAssets = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches,
        manifest,
        location,
        "assets"
      ),
      [page, nextMatches, matches, manifest, location]
    );
    let dataHrefs = React9.useMemo(() => {
      if (page === location.pathname + location.search + location.hash) {
        return [];
      }
      let routesParams = /* @__PURE__ */ new Set();
      let foundOptOutRoute = false;
      nextMatches.forEach((m) => {
        let manifestRoute = manifest.routes[m.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return;
        }
        if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
          foundOptOutRoute = true;
        } else if (manifestRoute.hasClientLoader) {
          foundOptOutRoute = true;
        } else {
          routesParams.add(m.route.id);
        }
      });
      if (routesParams.size === 0) {
        return [];
      }
      let url = singleFetchUrl(page, basename2);
      if (foundOptOutRoute && routesParams.size > 0) {
        url.searchParams.set(
          "_routes",
          nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
        );
      }
      return [url.pathname + url.search];
    }, [
      basename2,
      loaderData,
      location,
      manifest,
      newMatchesForData,
      nextMatches,
      page,
      routeModules
    ]);
    let moduleHrefs = React9.useMemo(
      () => getModuleLinkHrefs(newMatchesForAssets, manifest),
      [newMatchesForAssets, manifest]
    );
    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link: link3 }) => (
      // these don't spread `linkProps` because they are full link descriptors
      // already with their own props
      /* @__PURE__ */ React9.createElement("link", { key, ...link3 })
    )));
  }
  function mergeRefs(...refs) {
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  try {
    if (isBrowser) {
      window.__reactRouterVersion = "7.6.1";
    }
  } catch (e) {
  }
  function createBrowserRouter(routes, opts) {
    return createRouter({
      basename: opts?.basename,
      unstable_getContext: opts?.unstable_getContext,
      future: opts?.future,
      history: createBrowserHistory({ window: opts?.window }),
      hydrationData: opts?.hydrationData || parseHydrationData(),
      routes,
      mapRouteProperties,
      hydrationRouteProperties,
      dataStrategy: opts?.dataStrategy,
      patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
      window: opts?.window
    }).initialize();
  }
  function parseHydrationData() {
    let state = window?.__staticRouterHydrationData;
    if (state && state.errors) {
      state = {
        ...state,
        errors: deserializeErrors(state.errors)
      };
    }
    return state;
  }
  function deserializeErrors(errors) {
    if (!errors) return null;
    let entries = Object.entries(errors);
    let serialized = {};
    for (let [key, val] of entries) {
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new ErrorResponseImpl(
          val.status,
          val.statusText,
          val.data,
          val.internal === true
        );
      } else if (val && val.__type === "Error") {
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              let error = new ErrorConstructor(val.message);
              error.stack = "";
              serialized[key] = error;
            } catch (e) {
            }
          }
        }
        if (serialized[key] == null) {
          let error = new Error(val.message);
          error.stack = "";
          serialized[key] = error;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }
  function HistoryRouter({
    basename: basename2,
    children: children2,
    history
  }) {
    let [state, setStateImpl] = React10.useState({
      action: history.action,
      location: history.location
    });
    let setState = React10.useCallback(
      (newState) => {
        React10.startTransition(() => setStateImpl(newState));
      },
      [setStateImpl]
    );
    React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /* @__PURE__ */ React10.createElement(
      Router,
      {
        basename: basename2,
        children: children2,
        location: state.location,
        navigationType: state.action,
        navigator: history
      }
    );
  }
  HistoryRouter.displayName = "unstable_HistoryRouter";
  var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var Link = React10.forwardRef(
    function LinkWithRef({
      onClick,
      discover = "render",
      prefetch = "none",
      relative,
      reloadDocument,
      replace: replace22,
      state,
      target,
      to,
      preventScrollReset,
      viewTransition,
      ...rest
    }, forwardedRef) {
      let { basename: basename2 } = React10.useContext(NavigationContext);
      let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
      let absoluteHref;
      let isExternal = false;
      if (typeof to === "string" && isAbsolute) {
        absoluteHref = to;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
            let path2 = stripBasename(targetUrl.pathname, basename2);
            if (targetUrl.origin === currentUrl.origin && path2 != null) {
              to = path2 + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e) {
            warning(
              false,
              `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
            );
          }
        }
      }
      let href2 = useHref(to, { relative });
      let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
        prefetch,
        rest
      );
      let internalOnClick = useLinkClickHandler(to, {
        replace: replace22,
        state,
        target,
        preventScrollReset,
        relative,
        viewTransition
      });
      function handleClick(event) {
        if (onClick) onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      let link3 = (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ React10.createElement(
          "a",
          {
            ...rest,
            ...prefetchHandlers,
            href: absoluteHref || href2,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref: mergeRefs(forwardedRef, prefetchRef),
            target,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }
        )
      );
      return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link3, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href2 })) : link3;
    }
  );
  Link.displayName = "Link";
  var NavLink = React10.forwardRef(
    function NavLinkWithRef({
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      viewTransition,
      children: children2,
      ...rest
    }, ref) {
      let path2 = useResolvedPath(to, { relative: rest.relative });
      let location = useLocation();
      let routerState = React10.useContext(DataRouterStateContext);
      let { navigator: navigator2, basename: basename2 } = React10.useContext(NavigationContext);
      let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useViewTransitionState(path2) && viewTransition === true;
      let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path2).pathname : path2.pathname;
      let locationPathname = location.pathname;
      let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      if (!caseSensitive) {
        locationPathname = locationPathname.toLowerCase();
        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
        toPathname = toPathname.toLowerCase();
      }
      if (nextLocationPathname && basename2) {
        nextLocationPathname = stripBasename(nextLocationPathname, basename2) || nextLocationPathname;
      }
      const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
      let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
      let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
      let renderProps = {
        isActive,
        isPending,
        isTransitioning
      };
      let ariaCurrent = isActive ? ariaCurrentProp : void 0;
      let className;
      if (typeof classNameProp === "function") {
        className = classNameProp(renderProps);
      } else {
        className = [
          classNameProp,
          isActive ? "active" : null,
          isPending ? "pending" : null,
          isTransitioning ? "transitioning" : null
        ].filter(Boolean).join(" ");
      }
      let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
      return /* @__PURE__ */ React10.createElement(
        Link,
        {
          ...rest,
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to,
          viewTransition
        },
        typeof children2 === "function" ? children2(renderProps) : children2
      );
    }
  );
  NavLink.displayName = "NavLink";
  var Form = React10.forwardRef(
    ({
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace22,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition,
      ...props
    }, forwardedRef) => {
      let submit = useSubmit();
      let formAction = useFormAction(action, { relative });
      let formMethod = method.toLowerCase() === "get" ? "get" : "post";
      let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
      let submitHandler = (event) => {
        onSubmit && onSubmit(event);
        if (event.defaultPrevented) return;
        event.preventDefault();
        let submitter = event.nativeEvent.submitter;
        let submitMethod = submitter?.getAttribute("formmethod") || method;
        submit(submitter || event.currentTarget, {
          fetcherKey,
          method: submitMethod,
          navigate,
          replace: replace22,
          state,
          relative,
          preventScrollReset,
          viewTransition
        });
      };
      return /* @__PURE__ */ React10.createElement(
        "form",
        {
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          onSubmit: reloadDocument ? onSubmit : submitHandler,
          ...props,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      );
    }
  );
  Form.displayName = "Form";
  function ScrollRestoration({
    getKey,
    storageKey,
    ...props
  }) {
    let remixContext = React10.useContext(FrameworkContext);
    let { basename: basename2 } = React10.useContext(NavigationContext);
    let location = useLocation();
    let matches = useMatches();
    useScrollRestoration({ getKey, storageKey });
    let ssrKey = React10.useMemo(
      () => {
        if (!remixContext || !getKey) return null;
        let userKey = getScrollRestorationKey(
          location,
          matches,
          basename2,
          getKey
        );
        return userKey !== location.key ? userKey : null;
      },
      // Nah, we only need this the first time for the SSR render
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    if (!remixContext || remixContext.isSpaMode) {
      return null;
    }
    let restoreScroll = ((storageKey2, restoreKey) => {
      if (!window.history.state || !window.history.state.key) {
        let key = Math.random().toString(32).slice(2);
        window.history.replaceState({ key }, "");
      }
      try {
        let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
        let storedY = positions[restoreKey || window.history.state.key];
        if (typeof storedY === "number") {
          window.scrollTo(0, storedY);
        }
      } catch (error) {
        console.error(error);
        sessionStorage.removeItem(storageKey2);
      }
    }).toString();
    return /* @__PURE__ */ React10.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          )}, ${JSON.stringify(ssrKey)})`
        }
      }
    );
  }
  ScrollRestoration.displayName = "ScrollRestoration";
  function getDataRouterConsoleError2(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext3(hookName) {
    let ctx = React10.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError2(hookName));
    return ctx;
  }
  function useDataRouterState2(hookName) {
    let state = React10.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError2(hookName));
    return state;
  }
  function useLinkClickHandler(to, {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = {}) {
    let navigate = useNavigate();
    let location = useLocation();
    let path2 = useResolvedPath(to, { relative });
    return React10.useCallback(
      (event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace22 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
          navigate(to, {
            replace: replace22,
            state,
            preventScrollReset,
            relative,
            viewTransition
          });
        }
      },
      [
        location,
        navigate,
        path2,
        replaceProp,
        state,
        target,
        to,
        preventScrollReset,
        relative,
        viewTransition
      ]
    );
  }
  var fetcherId = 0;
  var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
  function useSubmit() {
    let { router: router2 } = useDataRouterContext3(
      "useSubmit"
      /* UseSubmit */
    );
    let { basename: basename2 } = React10.useContext(NavigationContext);
    let currentRouteId = useRouteId();
    return React10.useCallback(
      async (target, options = {}) => {
        let { action, method, encType, formData, body } = getFormSubmissionInfo(
          target,
          basename2
        );
        if (options.navigate === false) {
          let key = options.fetcherKey || getUniqueFetcherId();
          await router2.fetch(key, currentRouteId, options.action || action, {
            preventScrollReset: options.preventScrollReset,
            formData,
            body,
            formMethod: options.method || method,
            formEncType: options.encType || encType,
            flushSync: options.flushSync
          });
        } else {
          await router2.navigate(options.action || action, {
            preventScrollReset: options.preventScrollReset,
            formData,
            body,
            formMethod: options.method || method,
            formEncType: options.encType || encType,
            replace: options.replace,
            state: options.state,
            fromRouteId: currentRouteId,
            flushSync: options.flushSync,
            viewTransition: options.viewTransition
          });
        }
      },
      [router2, basename2, currentRouteId]
    );
  }
  function useFormAction(action, { relative } = {}) {
    let { basename: basename2 } = React10.useContext(NavigationContext);
    let routeContext = React10.useContext(RouteContext);
    invariant(routeContext, "useFormAction must be used inside a RouteContext");
    let [match2] = routeContext.matches.slice(-1);
    let path2 = { ...useResolvedPath(action ? action : ".", { relative }) };
    let location = useLocation();
    if (action == null) {
      path2.search = location.search;
      let params = new URLSearchParams(path2.search);
      let indexValues = params.getAll("index");
      let hasNakedIndexParam = indexValues.some((v) => v === "");
      if (hasNakedIndexParam) {
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path2.search = qs ? `?${qs}` : "";
      }
    }
    if ((!action || action === ".") && match2.route.index) {
      path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index";
    }
    if (basename2 !== "/") {
      path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
    }
    return createPath(path2);
  }
  var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  var savedScrollPositions = {};
  function getScrollRestorationKey(location, matches, basename2, getKey) {
    let key = null;
    if (getKey) {
      if (basename2 !== "/") {
        key = getKey(
          {
            ...location,
            pathname: stripBasename(location.pathname, basename2) || location.pathname
          },
          matches
        );
      } else {
        key = getKey(location, matches);
      }
    }
    if (key == null) {
      key = location.key;
    }
    return key;
  }
  function useScrollRestoration({
    getKey,
    storageKey
  } = {}) {
    let { router: router2 } = useDataRouterContext3(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { basename: basename2 } = React10.useContext(NavigationContext);
    let location = useLocation();
    let matches = useMatches();
    let navigation = useNavigation();
    React10.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);
    usePageHide(
      React10.useCallback(() => {
        if (navigation.state === "idle") {
          let key = getScrollRestorationKey(location, matches, basename2, getKey);
          savedScrollPositions[key] = window.scrollY;
        }
        try {
          sessionStorage.setItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY,
            JSON.stringify(savedScrollPositions)
          );
        } catch (error) {
          warning(
            false,
            `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
          );
        }
        window.history.scrollRestoration = "auto";
      }, [navigation.state, getKey, basename2, location, matches, storageKey])
    );
    if (typeof document !== "undefined") {
      React10.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          );
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
        }
      }, [storageKey]);
      React10.useLayoutEffect(() => {
        let disableScrollRestoration = router2?.enableScrollRestoration(
          savedScrollPositions,
          () => window.scrollY,
          getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename2, getKey) : void 0
        );
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router2, basename2, getKey]);
      React10.useLayoutEffect(() => {
        if (restoreScrollPosition === false) {
          return;
        }
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }
        if (location.hash) {
          let el = document.getElementById(
            decodeURIComponent(location.hash.slice(1))
          );
          if (el) {
            el.scrollIntoView();
            return;
          }
        }
        if (preventScrollReset === true) {
          return;
        }
        window.scrollTo(0, 0);
      }, [location, restoreScrollPosition, preventScrollReset]);
    }
  }
  function usePageHide(callback, options) {
    let { capture } = options || {};
    React10.useEffect(() => {
      let opts = capture != null ? { capture } : void 0;
      window.addEventListener("pagehide", callback, opts);
      return () => {
        window.removeEventListener("pagehide", callback, opts);
      };
    }, [callback, capture]);
  }
  function useViewTransitionState(to, opts = {}) {
    let vtContext = React10.useContext(ViewTransitionContext);
    invariant(
      vtContext != null,
      "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
    );
    let { basename: basename2 } = useDataRouterContext3(
      "useViewTransitionState"
      /* useViewTransitionState */
    );
    let path2 = useResolvedPath(to, { relative: opts.relative });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename2) || vtContext.currentLocation.pathname;
    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename2) || vtContext.nextLocation.pathname;
    return matchPath(path2.pathname, nextPath) != null || matchPath(path2.pathname, currentPath) != null;
  }
  var SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([
    ...NO_BODY_STATUS_CODES,
    304
  ]);

  // src/App.tsx
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-core/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-core/dist/CoreRoot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react = __toESM(require_react());
  var ThemeContext = (0, import_react.createContext)(void 0);
  var useTheme = () => {
    const ctx = (0, import_react.useContext)(ThemeContext);
    if (!ctx)
      throw new Error("No ThemeProvider found");
    return ctx;
  };

  // ../../packages/aihappey-core/dist/components/chat/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-core/dist/components/chat/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-core/dist/components/chat/ChatProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var import_react7 = __toESM(require_react());

  // ../../packages/aihappey-ai/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-ai/dist/store.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/ai/dist/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ai-sdk/provider/dist/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var marker = "vercel.ai.error";
  var symbol = Symbol.for(marker);
  var _a;
  var _AISDKError = class _AISDKError2 extends Error {
    /**
     * Creates an AI SDK Error.
     *
     * @param {Object} params - The parameters for creating the error.
     * @param {string} params.name - The name of the error.
     * @param {string} params.message - The error message.
     * @param {unknown} [params.cause] - The underlying cause of the error.
     */
    constructor({
      name: name143,
      message,
      cause
    }) {
      super(message);
      this[_a] = true;
      this.name = name143;
      this.cause = cause;
    }
    /**
     * Checks if the given error is an AI SDK Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
     */
    static isInstance(error) {
      return _AISDKError2.hasMarker(error, marker);
    }
    static hasMarker(error, marker153) {
      const markerSymbol = Symbol.for(marker153);
      return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
  };
  _a = symbol;
  var AISDKError = _AISDKError;
  var name = "AI_APICallError";
  var marker2 = `vercel.ai.error.${name}`;
  var symbol2 = Symbol.for(marker2);
  var _a2;
  _a2 = symbol2;
  var name2 = "AI_EmptyResponseBodyError";
  var marker3 = `vercel.ai.error.${name2}`;
  var symbol3 = Symbol.for(marker3);
  var _a3;
  _a3 = symbol3;
  function getErrorMessage(error) {
    if (error == null) {
      return "unknown error";
    }
    if (typeof error === "string") {
      return error;
    }
    if (error instanceof Error) {
      return error.message;
    }
    return JSON.stringify(error);
  }
  var name3 = "AI_InvalidArgumentError";
  var marker4 = `vercel.ai.error.${name3}`;
  var symbol4 = Symbol.for(marker4);
  var _a4;
  var InvalidArgumentError = class extends AISDKError {
    constructor({
      message,
      cause,
      argument
    }) {
      super({ name: name3, message, cause });
      this[_a4] = true;
      this.argument = argument;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker4);
    }
  };
  _a4 = symbol4;
  var name4 = "AI_InvalidPromptError";
  var marker5 = `vercel.ai.error.${name4}`;
  var symbol5 = Symbol.for(marker5);
  var _a5;
  _a5 = symbol5;
  var name5 = "AI_InvalidResponseDataError";
  var marker6 = `vercel.ai.error.${name5}`;
  var symbol6 = Symbol.for(marker6);
  var _a6;
  _a6 = symbol6;
  var name6 = "AI_JSONParseError";
  var marker7 = `vercel.ai.error.${name6}`;
  var symbol7 = Symbol.for(marker7);
  var _a7;
  var JSONParseError = class extends AISDKError {
    constructor({ text: text9, cause }) {
      super({
        name: name6,
        message: `JSON parsing failed: Text: ${text9}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a7] = true;
      this.text = text9;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker7);
    }
  };
  _a7 = symbol7;
  var name7 = "AI_LoadAPIKeyError";
  var marker8 = `vercel.ai.error.${name7}`;
  var symbol8 = Symbol.for(marker8);
  var _a8;
  _a8 = symbol8;
  var name8 = "AI_LoadSettingError";
  var marker9 = `vercel.ai.error.${name8}`;
  var symbol9 = Symbol.for(marker9);
  var _a9;
  _a9 = symbol9;
  var name9 = "AI_NoContentGeneratedError";
  var marker10 = `vercel.ai.error.${name9}`;
  var symbol10 = Symbol.for(marker10);
  var _a10;
  _a10 = symbol10;
  var name10 = "AI_NoSuchModelError";
  var marker11 = `vercel.ai.error.${name10}`;
  var symbol11 = Symbol.for(marker11);
  var _a11;
  _a11 = symbol11;
  var name11 = "AI_TooManyEmbeddingValuesForCallError";
  var marker12 = `vercel.ai.error.${name11}`;
  var symbol12 = Symbol.for(marker12);
  var _a12;
  _a12 = symbol12;
  var name12 = "AI_TypeValidationError";
  var marker13 = `vercel.ai.error.${name12}`;
  var symbol13 = Symbol.for(marker13);
  var _a13;
  var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
    constructor({ value, cause }) {
      super({
        name: name12,
        message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a13] = true;
      this.value = value;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker13);
    }
    /**
     * Wraps an error into a TypeValidationError.
     * If the cause is already a TypeValidationError with the same value, it returns the cause.
     * Otherwise, it creates a new TypeValidationError.
     *
     * @param {Object} params - The parameters for wrapping the error.
     * @param {unknown} params.value - The value that failed validation.
     * @param {unknown} params.cause - The original error or cause of the validation failure.
     * @returns {TypeValidationError} A TypeValidationError instance.
     */
    static wrap({
      value,
      cause
    }) {
      return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
    }
  };
  _a13 = symbol13;
  var TypeValidationError = _TypeValidationError;
  var name13 = "AI_UnsupportedFunctionalityError";
  var marker14 = `vercel.ai.error.${name13}`;
  var symbol14 = Symbol.for(marker14);
  var _a14;
  _a14 = symbol14;

  // ../../node_modules/zod-to-json-schema/dist/esm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/Options.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
  var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  var getDefaultOptions = (options) => typeof options === "string" ? {
    ...defaultOptions,
    name: options
  } : {
    ...defaultOptions,
    ...options
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/Refs.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(Object.entries(_options.definitions).map(([name21, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name21],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ]))
    };
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/errorMessages.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages)
      return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parseDef.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/selectParser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/external.js
  var external_exports = {};
  __export(external_exports, {
    BRAND: () => BRAND,
    DIRTY: () => DIRTY,
    EMPTY_PATH: () => EMPTY_PATH,
    INVALID: () => INVALID,
    NEVER: () => NEVER,
    OK: () => OK,
    ParseStatus: () => ParseStatus,
    Schema: () => ZodType,
    ZodAny: () => ZodAny,
    ZodArray: () => ZodArray,
    ZodBigInt: () => ZodBigInt,
    ZodBoolean: () => ZodBoolean,
    ZodBranded: () => ZodBranded,
    ZodCatch: () => ZodCatch,
    ZodDate: () => ZodDate,
    ZodDefault: () => ZodDefault,
    ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
    ZodEffects: () => ZodEffects,
    ZodEnum: () => ZodEnum,
    ZodError: () => ZodError,
    ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
    ZodFunction: () => ZodFunction,
    ZodIntersection: () => ZodIntersection,
    ZodIssueCode: () => ZodIssueCode,
    ZodLazy: () => ZodLazy,
    ZodLiteral: () => ZodLiteral,
    ZodMap: () => ZodMap,
    ZodNaN: () => ZodNaN,
    ZodNativeEnum: () => ZodNativeEnum,
    ZodNever: () => ZodNever,
    ZodNull: () => ZodNull,
    ZodNullable: () => ZodNullable,
    ZodNumber: () => ZodNumber,
    ZodObject: () => ZodObject,
    ZodOptional: () => ZodOptional,
    ZodParsedType: () => ZodParsedType,
    ZodPipeline: () => ZodPipeline,
    ZodPromise: () => ZodPromise,
    ZodReadonly: () => ZodReadonly,
    ZodRecord: () => ZodRecord,
    ZodSchema: () => ZodType,
    ZodSet: () => ZodSet,
    ZodString: () => ZodString,
    ZodSymbol: () => ZodSymbol,
    ZodTransformer: () => ZodEffects,
    ZodTuple: () => ZodTuple,
    ZodType: () => ZodType,
    ZodUndefined: () => ZodUndefined,
    ZodUnion: () => ZodUnion,
    ZodUnknown: () => ZodUnknown,
    ZodVoid: () => ZodVoid,
    addIssueToContext: () => addIssueToContext,
    any: () => anyType,
    array: () => arrayType,
    bigint: () => bigIntType,
    boolean: () => booleanType,
    coerce: () => coerce,
    custom: () => custom,
    date: () => dateType,
    datetimeRegex: () => datetimeRegex,
    defaultErrorMap: () => en_default,
    discriminatedUnion: () => discriminatedUnionType,
    effect: () => effectsType,
    enum: () => enumType,
    function: () => functionType,
    getErrorMap: () => getErrorMap,
    getParsedType: () => getParsedType,
    instanceof: () => instanceOfType,
    intersection: () => intersectionType,
    isAborted: () => isAborted,
    isAsync: () => isAsync,
    isDirty: () => isDirty,
    isValid: () => isValid,
    late: () => late,
    lazy: () => lazyType,
    literal: () => literalType,
    makeIssue: () => makeIssue,
    map: () => mapType,
    nan: () => nanType,
    nativeEnum: () => nativeEnumType,
    never: () => neverType,
    null: () => nullType,
    nullable: () => nullableType,
    number: () => numberType,
    object: () => objectType,
    objectUtil: () => objectUtil,
    oboolean: () => oboolean,
    onumber: () => onumber,
    optional: () => optionalType,
    ostring: () => ostring,
    pipeline: () => pipelineType,
    preprocess: () => preprocessType,
    promise: () => promiseType,
    quotelessJson: () => quotelessJson,
    record: () => recordType,
    set: () => setType,
    setErrorMap: () => setErrorMap,
    strictObject: () => strictObjectType,
    string: () => stringType,
    symbol: () => symbolType,
    transformer: () => effectsType,
    tuple: () => tupleType,
    undefined: () => undefinedType,
    union: () => unionType,
    unknown: () => unknownType,
    util: () => util,
    void: () => voidType
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/errors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/locales/en.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/ZodError.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/helpers/util.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
      const keys2 = [];
      for (const key in object2) {
        if (Object.prototype.hasOwnProperty.call(object2, key)) {
          keys2.push(key);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data2) => {
    const t = typeof data2;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data2)) {
          return ZodParsedType.array;
        }
        if (data2 === null) {
          return ZodParsedType.null;
        }
        if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data2 instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data2 instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data2 instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  // ../../node_modules/zod/dist/esm/v3/ZodError.js
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class _ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };

  // ../../node_modules/zod/dist/esm/v3/locales/en.js
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var en_default = errorMap;

  // ../../node_modules/zod/dist/esm/v3/errors.js
  var overrideErrorMap = en_default;
  function setErrorMap(map3) {
    overrideErrorMap = map3;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }

  // ../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var makeIssue = (params) => {
    const { data: data2, path: path2, errorMaps, issueData } = params;
    const fullPath = [...path2, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map3 of maps) {
      errorMessage = map3(fullIssue, { data: data2, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default ? void 0 : en_default
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

  // ../../node_modules/zod/dist/esm/v3/helpers/typeAliases.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));

  // ../../node_modules/zod/dist/esm/v3/types.js
  var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _ZodEnum_cache;
  var _ZodNativeEnum_cache;
  var ParseInputLazyPath = class {
    constructor(parent, value, path2, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path2;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data2, params) {
      const result = this.safeParse(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data2, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data2) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data: data2, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data: data2, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data2, params) {
      const result = await this.safeParseAsync(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data2, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data2) => {
            if (!data2) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data2) => this["~validate"](data2)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform3) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform: transform3 }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex2 = `${regex2}(${opts.join("|")})`;
    return new RegExp(`^${regex2}$`);
  }
  function isValidIP(ip, version5) {
    if ((version5 === "v4" || !version5) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version5 === "v6" || !version5) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version5) {
    if ((version5 === "v4" || !version5) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version5 === "v6" || !version5) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex2 = datetimeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex2 = dateRegex;
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex2 = timeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex2, validation, message) {
      return this.refinement((data2) => regex2.test(data2), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex2, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex2,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxLength() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max2 = null;
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        } else if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return Number.isFinite(min2) && Number.isFinite(max2);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2 != null ? new Date(min2) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util.objectKeys(shape);
      this._cached = { shape, keys: keys2 };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new _ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element4 of elements2) {
          if (element4.status === "aborted")
            return INVALID;
          if (element4.status === "dirty")
            status.dirty();
          parsedSet.add(element4.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize2, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize2, message: errorUtil.toString(message) }
      });
    }
    size(size3, message) {
      return this.min(size3, message).max(size3, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data2) => {
        return this._def.type.parseAsync(data2, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess2 },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data2 = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data2 = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data2 = ctx.data;
      return this._def.type._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data2) => {
        if (isValid(data2)) {
          data2.value = Object.freeze(data2.value);
        }
        return data2;
      };
      return isAsync(result) ? result.then((data2) => freeze(data2)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data2) {
    const p = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data2, ctx) => {
        const r = check(data2);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data2);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data2);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data2) => data2 instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/any.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseAnyDef() {
    return {};
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/array.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseArrayDef(def, refs) {
    const res = {
      type: "array"
    };
    if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
      res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseBigintDef(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseBooleanDef() {
    return {
      type: "boolean"
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/date.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser(def, refs);
    }
  }
  var integerDateParser = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
          break;
      }
    }
    return res;
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/default.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseDefaultDef(_def, refs) {
    return {
      ...parseDef(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseEnumDef(def) {
    return {
      type: "string",
      enum: Array.from(def.values)
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef(def, refs) {
    const allOf = [
      parseDef(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var emojiRegex2 = void 0;
  var zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex2 === void 0) {
        emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex2;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  function parseStringDef(def, refs) {
    const res = {
      type: "string"
    };
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat(res, "date", check.message, refs);
            break;
          case "time":
            addFormat(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "base64url":
            addPattern(res, zodPatterns.base64url, check.message, refs);
            break;
          case "jwt":
            addPattern(res, zodPatterns.jwt, check.message, refs);
            break;
          case "cidr": {
            if (check.version !== "v6") {
              addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
            }
            if (check.version !== "v4") {
              addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern(res, zodPatterns.emoji(), check.message, refs);
            break;
          case "ulid": {
            addPattern(res, zodPatterns.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern(res, zodPatterns.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern(res, zodPatterns.nanoid, check.message, refs);
          }
          case "toLowerCase":
          case "toUpperCase":
          case "trim":
            break;
          default:
            /* @__PURE__ */ ((_) => {
            })(check);
        }
      }
    }
    return res;
  }
  function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
  }
  var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
  function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
      if (!ALPHA_NUMERIC.has(source[i])) {
        result += "\\";
      }
      result += source[i];
    }
    return result;
  }
  function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x) => x.format)) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      setResponseValueAndErrors(schema, "format", value, message, refs);
    }
  }
  function addPattern(schema, regex2, message, refs) {
    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: stringifyRegExpWithFlags(regex2, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex2, refs), message, refs);
    }
  }
  function stringifyRegExpWithFlags(regex2, refs) {
    if (!refs.applyRegexFlags || !regex2.flags) {
      return regex2.source;
    }
    const flags = {
      i: regex2.flags.includes("i"),
      m: regex2.flags.includes("m"),
      s: regex2.flags.includes("s")
      // `.` matches newlines
    };
    const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
      if (isEscaped) {
        pattern += source[i];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source[i].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source[i];
              pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
              inCharRange = false;
            } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
              pattern += source[i];
              inCharRange = true;
            } else {
              pattern += `${source[i]}${source[i].toUpperCase()}`;
            }
            continue;
          }
        } else if (source[i].match(/[a-z]/)) {
          pattern += `[${source[i]}${source[i].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source[i] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source[i] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source[i] === ".") {
        pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
        continue;
      }
      pattern += source[i];
      if (source[i] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source[i] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source[i] === "[") {
        inCharGroup = true;
      }
    }
    try {
      new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex2.source;
    }
    return pattern;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js
  function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
      console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          }) ?? {}
        }), {}),
        additionalProperties: refs.rejectedAdditionalProperties
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      }) ?? refs.allowedAdditionalProperties
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
      const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
      const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    }
    return schema;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js
  function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef(def, refs);
    }
    const keys2 = parseDef(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || {};
    const values = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys2, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseNativeEnumDef(def) {
    const object2 = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object2[object2[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object2[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/never.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseNeverDef() {
    return {
      not: {}
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/null.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseNullDef(refs) {
    return refs.target === "openApi3" ? {
      enum: ["null"],
      nullable: true
    } : {
      type: "null"
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/union.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
      return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce((acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null)
              return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          }, [])
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ], [])
      };
    }
    return asAnyOf(def, refs);
  }
  var asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
    return anyOf.length ? { anyOf } : void 0;
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
  function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3") {
        return {
          type: primitiveMappings[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [
          primitiveMappings[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath]
      });
      if (base2 && "$ref" in base2)
        return { allOf: [base2], nullable: true };
      return base2 && { ...base2, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/number.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseNumberDef(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/object.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
      type: "object",
      properties: {}
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
      let propDef = shape[propName];
      if (propDef === void 0 || propDef._def === void 0) {
        continue;
      }
      let propOptional = safeIsOptional(propDef);
      if (propOptional && forceOptionalIntoNullable) {
        if (propDef instanceof ZodOptional) {
          propDef = propDef._def.innerType;
        }
        if (!propDef.isNullable()) {
          propDef = propDef.nullable();
        }
        propOptional = false;
      }
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0) {
        continue;
      }
      result.properties[propName] = parsedDef;
      if (!propOptional) {
        required.push(propName);
      }
    }
    if (required.length) {
      result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
      result.additionalProperties = additionalProperties;
    }
    return result;
  }
  function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
      return parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
    }
    switch (def.unknownKeys) {
      case "passthrough":
        return refs.allowedAdditionalProperties;
      case "strict":
        return refs.rejectedAdditionalProperties;
      case "strip":
        return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
  }
  function safeIsOptional(schema) {
    try {
      return schema.isOptional();
    } catch {
      return true;
    }
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var parseOptionalDef = (def, refs) => {
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
      return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/set.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseTupleDef(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: parseDef(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseUndefinedDef() {
    return {
      not: {}
    };
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseUnknownDef() {
    return {};
  }

  // ../../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/selectParser.js
  var selectParser = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString:
        return parseStringDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNumber:
        return parseNumberDef(def, refs);
      case ZodFirstPartyTypeKind.ZodObject:
        return parseObjectDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBigInt:
        return parseBigintDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBoolean:
        return parseBooleanDef();
      case ZodFirstPartyTypeKind.ZodDate:
        return parseDateDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUndefined:
        return parseUndefinedDef();
      case ZodFirstPartyTypeKind.ZodNull:
        return parseNullDef(refs);
      case ZodFirstPartyTypeKind.ZodArray:
        return parseArrayDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return parseUnionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodIntersection:
        return parseIntersectionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodTuple:
        return parseTupleDef(def, refs);
      case ZodFirstPartyTypeKind.ZodRecord:
        return parseRecordDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLiteral:
        return parseLiteralDef(def, refs);
      case ZodFirstPartyTypeKind.ZodEnum:
        return parseEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNativeEnum:
        return parseNativeEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNullable:
        return parseNullableDef(def, refs);
      case ZodFirstPartyTypeKind.ZodOptional:
        return parseOptionalDef(def, refs);
      case ZodFirstPartyTypeKind.ZodMap:
        return parseMapDef(def, refs);
      case ZodFirstPartyTypeKind.ZodSet:
        return parseSetDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLazy:
        return () => def.getter()._def;
      case ZodFirstPartyTypeKind.ZodPromise:
        return parsePromiseDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNaN:
      case ZodFirstPartyTypeKind.ZodNever:
        return parseNeverDef();
      case ZodFirstPartyTypeKind.ZodEffects:
        return parseEffectsDef(def, refs);
      case ZodFirstPartyTypeKind.ZodAny:
        return parseAnyDef();
      case ZodFirstPartyTypeKind.ZodUnknown:
        return parseUnknownDef();
      case ZodFirstPartyTypeKind.ZodDefault:
        return parseDefaultDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBranded:
        return parseBrandedDef(def, refs);
      case ZodFirstPartyTypeKind.ZodReadonly:
        return parseReadonlyDef(def, refs);
      case ZodFirstPartyTypeKind.ZodCatch:
        return parseCatchDef(def, refs);
      case ZodFirstPartyTypeKind.ZodPipeline:
        return parsePipelineDef(def, refs);
      case ZodFirstPartyTypeKind.ZodFunction:
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)(typeName);
    }
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parseDef.js
  function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
      addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
      const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
      newItem.jsonSchema = jsonSchema2;
      return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
  }
  var get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      case "relative":
        return { $ref: getRelativePath(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index2) => refs.currentPath[index2] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  var getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
      if (pathA[i] !== pathB[i])
        break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
  };
  var addMeta = (def, refs, jsonSchema2) => {
    if (def.description) {
      jsonSchema2.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema2.markdownDescription = def.description;
      }
    }
    return jsonSchema2;
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/parseTypes.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name23, schema2]) => ({
      ...acc,
      [name23]: parseDef(schema2._def, {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name23]
      }, true) ?? {}
    }), {}) : void 0;
    const name21 = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
    const main = parseDef(schema._def, name21 === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name21]
    }, false) ?? {};
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const combined = name21 === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name21
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name21]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
      console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
  };

  // ../../node_modules/zod-to-json-schema/dist/esm/index.js
  var esm_default = zodToJsonSchema;

  // ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs
  function createEventSourceParserStream() {
    let buffer = "";
    let event = void 0;
    let data2 = [];
    let lastEventId = void 0;
    let retry = void 0;
    function parseLine(line2, controller) {
      if (line2 === "") {
        dispatchEvent(controller);
        return;
      }
      if (line2.startsWith(":")) {
        return;
      }
      const colonIndex = line2.indexOf(":");
      if (colonIndex === -1) {
        handleField(line2, "");
        return;
      }
      const field = line2.slice(0, colonIndex);
      const valueStart = colonIndex + 1;
      const value = valueStart < line2.length && line2[valueStart] === " " ? line2.slice(valueStart + 1) : line2.slice(valueStart);
      handleField(field, value);
    }
    function dispatchEvent(controller) {
      if (data2.length > 0) {
        controller.enqueue({
          event,
          data: data2.join("\n"),
          id: lastEventId,
          retry
        });
        data2 = [];
        event = void 0;
        retry = void 0;
      }
    }
    function handleField(field, value) {
      switch (field) {
        case "event":
          event = value;
          break;
        case "data":
          data2.push(value);
          break;
        case "id":
          lastEventId = value;
          break;
        case "retry":
          const parsedRetry = parseInt(value, 10);
          if (!isNaN(parsedRetry)) {
            retry = parsedRetry;
          }
          break;
      }
    }
    return new TransformStream({
      transform(chunk, controller) {
        const { lines, incompleteLine } = splitLines(buffer, chunk);
        buffer = incompleteLine;
        for (let i = 0; i < lines.length; i++) {
          parseLine(lines[i], controller);
        }
      },
      flush(controller) {
        parseLine(buffer, controller);
        dispatchEvent(controller);
      }
    });
  }
  function splitLines(buffer, chunk) {
    const lines = [];
    let currentLine = buffer;
    for (let i = 0; i < chunk.length; ) {
      const char2 = chunk[i++];
      if (char2 === "\n") {
        lines.push(currentLine);
        currentLine = "";
      } else if (char2 === "\r") {
        lines.push(currentLine);
        currentLine = "";
        if (chunk[i] === "\n") {
          i++;
        }
      } else {
        currentLine += char2;
      }
    }
    return { lines, incompleteLine: currentLine };
  }
  var createIdGenerator = ({
    prefix: prefix2,
    size: size3 = 16,
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    separator = "-"
  } = {}) => {
    const generator = () => {
      const alphabetLength = alphabet.length;
      const chars = new Array(size3);
      for (let i = 0; i < size3; i++) {
        chars[i] = alphabet[Math.random() * alphabetLength | 0];
      }
      return chars.join("");
    };
    if (prefix2 == null) {
      return generator;
    }
    if (alphabet.includes(separator)) {
      throw new InvalidArgumentError({
        argument: "separator",
        message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
      });
    }
    return () => `${prefix2}${separator}${generator()}`;
  };
  var generateId = createIdGenerator();
  var suspectProtoRx = /"__proto__"\s*:/;
  var suspectConstructorRx = /"constructor"\s*:/;
  function _parse(text9) {
    const obj = JSON.parse(text9);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (suspectProtoRx.test(text9) === false && suspectConstructorRx.test(text9) === false) {
      return obj;
    }
    return filter(obj);
  }
  function filter(obj) {
    let next2 = [obj];
    while (next2.length) {
      const nodes = next2;
      next2 = [];
      for (const node3 of nodes) {
        if (Object.prototype.hasOwnProperty.call(node3, "__proto__")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        if (Object.prototype.hasOwnProperty.call(node3, "constructor") && Object.prototype.hasOwnProperty.call(node3.constructor, "prototype")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        for (const key in node3) {
          const value = node3[key];
          if (value && typeof value === "object") {
            next2.push(value);
          }
        }
      }
    }
    return obj;
  }
  function secureJsonParse(text9) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text9);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  var validatorSymbol = Symbol.for("vercel.ai.validator");
  function validator(validate) {
    return { [validatorSymbol]: true, validate };
  }
  function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
  }
  function asValidator(value) {
    return isValidator(value) ? value : standardSchemaValidator(value);
  }
  function standardSchemaValidator(standardSchema) {
    return validator(async (value) => {
      const result = await standardSchema["~standard"].validate(value);
      return result.issues == null ? { success: true, value: result.value } : {
        success: false,
        error: new TypeValidationError({
          value,
          cause: result.issues
        })
      };
    });
  }
  async function validateTypes({
    value,
    schema
  }) {
    const result = await safeValidateTypes({ value, schema });
    if (!result.success) {
      throw TypeValidationError.wrap({ value, cause: result.error });
    }
    return result.value;
  }
  async function safeValidateTypes({
    value,
    schema
  }) {
    const validator2 = asValidator(schema);
    try {
      if (validator2.validate == null) {
        return { success: true, value, rawValue: value };
      }
      const result = await validator2.validate(value);
      if (result.success) {
        return { success: true, value: result.value, rawValue: value };
      }
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: result.error }),
        rawValue: value
      };
    } catch (error) {
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: error }),
        rawValue: value
      };
    }
  }
  async function safeParseJSON({
    text: text9,
    schema
  }) {
    try {
      const value = secureJsonParse(text9);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      return await safeValidateTypes({ value, schema });
    } catch (error) {
      return {
        success: false,
        error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text: text9, cause: error }),
        rawValue: void 0
      };
    }
  }
  function parseJsonEventStream({
    stream,
    schema
  }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(
      new TransformStream({
        async transform({ data: data2 }, controller) {
          if (data2 === "[DONE]") {
            return;
          }
          controller.enqueue(await safeParseJSON({ text: data2, schema }));
        }
      })
    );
  }
  function zodSchema(zodSchema2, options) {
    var _a17;
    const useReferences = (_a17 = options == null ? void 0 : options.useReferences) != null ? _a17 : false;
    return jsonSchema(
      esm_default(zodSchema2, {
        $refStrategy: useReferences ? "root" : "none",
        target: "jsonSchema7"
        // note: openai mode breaks various gemini conversions
      }),
      {
        validate: (value) => {
          const result = zodSchema2.safeParse(value);
          return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
        }
      }
    );
  }
  var schemaSymbol = Symbol.for("vercel.ai.schema");
  function jsonSchema(jsonSchema2, {
    validate
  } = {}) {
    return {
      [schemaSymbol]: true,
      _type: void 0,
      // should never be used directly
      [validatorSymbol]: true,
      jsonSchema: jsonSchema2,
      validate
    };
  }
  function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
  }
  function asSchema(schema) {
    return schema == null ? jsonSchema({
      properties: {},
      additionalProperties: false
    }) : isSchema(schema) ? schema : zodSchema(schema);
  }
  var { btoa: btoa2, atob: atob2 } = globalThis;

  // ../../node_modules/ai/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all2) => {
    for (var name172 in all2)
      __defProp2(target, name172, { get: all2[name172], enumerable: true });
  };
  var name14 = "AI_InvalidArgumentError";
  var marker15 = `vercel.ai.error.${name14}`;
  var symbol15 = Symbol.for(marker15);
  var _a15;
  _a15 = symbol15;
  var name22 = "AI_InvalidStreamPartError";
  var marker22 = `vercel.ai.error.${name22}`;
  var symbol22 = Symbol.for(marker22);
  var _a22;
  _a22 = symbol22;
  var name32 = "AI_InvalidToolArgumentsError";
  var marker32 = `vercel.ai.error.${name32}`;
  var symbol32 = Symbol.for(marker32);
  var _a32;
  _a32 = symbol32;
  var name42 = "AI_MCPClientError";
  var marker42 = `vercel.ai.error.${name42}`;
  var symbol42 = Symbol.for(marker42);
  var _a42;
  _a42 = symbol42;
  var name52 = "AI_NoImageGeneratedError";
  var marker52 = `vercel.ai.error.${name52}`;
  var symbol52 = Symbol.for(marker52);
  var _a52;
  _a52 = symbol52;
  var name62 = "AI_NoObjectGeneratedError";
  var marker62 = `vercel.ai.error.${name62}`;
  var symbol62 = Symbol.for(marker62);
  var _a62;
  var NoObjectGeneratedError = class extends AISDKError {
    constructor({
      message = "No object generated.",
      cause,
      text: text22,
      response,
      usage,
      finishReason
    }) {
      super({ name: name62, message, cause });
      this[_a62] = true;
      this.text = text22;
      this.response = response;
      this.usage = usage;
      this.finishReason = finishReason;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker62);
    }
  };
  _a62 = symbol62;
  var name72 = "AI_NoOutputSpecifiedError";
  var marker72 = `vercel.ai.error.${name72}`;
  var symbol72 = Symbol.for(marker72);
  var _a72;
  _a72 = symbol72;
  var name82 = "AI_NoSuchToolError";
  var marker82 = `vercel.ai.error.${name82}`;
  var symbol82 = Symbol.for(marker82);
  var _a82;
  _a82 = symbol82;
  var name92 = "AI_ToolCallRepairError";
  var marker92 = `vercel.ai.error.${name92}`;
  var symbol92 = Symbol.for(marker92);
  var _a92;
  _a92 = symbol92;
  var name102 = "AI_ToolExecutionError";
  var marker102 = `vercel.ai.error.${name102}`;
  var symbol102 = Symbol.for(marker102);
  var _a102;
  _a102 = symbol102;
  var name112 = "AI_InvalidDataContentError";
  var marker112 = `vercel.ai.error.${name112}`;
  var symbol112 = Symbol.for(marker112);
  var _a112;
  _a112 = symbol112;
  var name122 = "AI_InvalidMessageRoleError";
  var marker122 = `vercel.ai.error.${name122}`;
  var symbol122 = Symbol.for(marker122);
  var _a122;
  _a122 = symbol122;
  var name132 = "AI_MessageConversionError";
  var marker132 = `vercel.ai.error.${name132}`;
  var symbol132 = Symbol.for(marker132);
  var _a132;
  _a132 = symbol132;
  var name142 = "AI_DownloadError";
  var marker142 = `vercel.ai.error.${name142}`;
  var symbol142 = Symbol.for(marker142);
  var _a142;
  _a142 = symbol142;
  var name15 = "AI_RetryError";
  var marker152 = `vercel.ai.error.${name15}`;
  var symbol152 = Symbol.for(marker152);
  var _a152;
  _a152 = symbol152;
  var uiMessageStreamPartSchema = external_exports.union([
    external_exports.object({
      type: external_exports.literal("text"),
      text: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("error"),
      errorText: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("tool-call-streaming-start"),
      toolCallId: external_exports.string(),
      toolName: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("tool-call-delta"),
      toolCallId: external_exports.string(),
      argsTextDelta: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.literal("tool-call"),
      toolCallId: external_exports.string(),
      toolName: external_exports.string(),
      args: external_exports.unknown()
    }),
    external_exports.object({
      type: external_exports.literal("tool-result"),
      toolCallId: external_exports.string(),
      result: external_exports.unknown(),
      providerMetadata: external_exports.any().optional()
    }),
    external_exports.object({
      type: external_exports.literal("reasoning"),
      text: external_exports.string(),
      providerMetadata: external_exports.record(external_exports.any()).optional()
    }),
    external_exports.object({
      type: external_exports.literal("source"),
      sourceType: external_exports.literal("url"),
      id: external_exports.string(),
      url: external_exports.string(),
      title: external_exports.string().optional(),
      providerMetadata: external_exports.any().optional()
      // Use z.any() for generic metadata
    }),
    external_exports.object({
      type: external_exports.literal("file"),
      url: external_exports.string(),
      mediaType: external_exports.string()
    }),
    external_exports.object({
      type: external_exports.string().startsWith("data-"),
      id: external_exports.string().optional(),
      data: external_exports.unknown()
    }),
    external_exports.object({
      type: external_exports.literal("metadata"),
      value: external_exports.object({ metadata: external_exports.unknown() })
    }),
    external_exports.object({
      type: external_exports.literal("start-step"),
      metadata: external_exports.unknown().optional()
    }),
    external_exports.object({
      type: external_exports.literal("finish-step"),
      metadata: external_exports.unknown().optional()
    }),
    external_exports.object({
      type: external_exports.literal("start"),
      messageId: external_exports.string().optional(),
      metadata: external_exports.unknown().optional()
    }),
    external_exports.object({
      type: external_exports.literal("finish"),
      metadata: external_exports.unknown().optional()
    }),
    external_exports.object({
      type: external_exports.literal("reasoning-part-finish")
    })
  ]);
  async function consumeStream({
    stream,
    onError
  }) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done } = await reader.read();
        if (done)
          break;
      }
    } catch (error) {
      onError == null ? void 0 : onError(error);
    } finally {
      reader.releaseLock();
    }
  }
  function mergeObjects(base, overrides) {
    if (base === void 0 && overrides === void 0) {
      return void 0;
    }
    if (base === void 0) {
      return overrides;
    }
    if (overrides === void 0) {
      return base;
    }
    const result = { ...base };
    for (const key in overrides) {
      if (Object.prototype.hasOwnProperty.call(overrides, key)) {
        const overridesValue = overrides[key];
        if (overridesValue === void 0)
          continue;
        const baseValue = key in base ? base[key] : void 0;
        const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
        const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
        if (isSourceObject && isTargetObject) {
          result[key] = mergeObjects(
            baseValue,
            overridesValue
          );
        } else {
          result[key] = overridesValue;
        }
      }
    }
    return result;
  }
  function fixJson(input) {
    const stack = ["ROOT"];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char2, i, swapState) {
      {
        switch (char2) {
          case '"': {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_STRING");
            break;
          }
          case "f":
          case "t":
          case "n": {
            lastValidIndex = i;
            literalStart = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_LITERAL");
            break;
          }
          case "-": {
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "{": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_OBJECT_START");
            break;
          }
          case "[": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_ARRAY_START");
            break;
          }
        }
      }
    }
    function processAfterObjectValue(char2, i) {
      switch (char2) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_OBJECT_AFTER_COMMA");
          break;
        }
        case "}": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    function processAfterArrayValue(char2, i) {
      switch (char2) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_ARRAY_AFTER_COMMA");
          break;
        }
        case "]": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    for (let i = 0; i < input.length; i++) {
      const char2 = input[i];
      const currentState = stack[stack.length - 1];
      switch (currentState) {
        case "ROOT":
          processValueStart(char2, i, "FINISH");
          break;
        case "INSIDE_OBJECT_START": {
          switch (char2) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
            case "}": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_COMMA": {
          switch (char2) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_KEY": {
          switch (char2) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_AFTER_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_KEY": {
          switch (char2) {
            case ":": {
              stack.pop();
              stack.push("INSIDE_OBJECT_BEFORE_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_BEFORE_VALUE": {
          processValueStart(char2, i, "INSIDE_OBJECT_AFTER_VALUE");
          break;
        }
        case "INSIDE_OBJECT_AFTER_VALUE": {
          processAfterObjectValue(char2, i);
          break;
        }
        case "INSIDE_STRING": {
          switch (char2) {
            case '"': {
              stack.pop();
              lastValidIndex = i;
              break;
            }
            case "\\": {
              stack.push("INSIDE_STRING_ESCAPE");
              break;
            }
            default: {
              lastValidIndex = i;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_START": {
          switch (char2) {
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              processValueStart(char2, i, "INSIDE_ARRAY_AFTER_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_VALUE": {
          switch (char2) {
            case ",": {
              stack.pop();
              stack.push("INSIDE_ARRAY_AFTER_COMMA");
              break;
            }
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_COMMA": {
          processValueStart(char2, i, "INSIDE_ARRAY_AFTER_VALUE");
          break;
        }
        case "INSIDE_STRING_ESCAPE": {
          stack.pop();
          lastValidIndex = i;
          break;
        }
        case "INSIDE_NUMBER": {
          switch (char2) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9": {
              lastValidIndex = i;
              break;
            }
            case "e":
            case "E":
            case "-":
            case ".": {
              break;
            }
            case ",": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char2, i);
              }
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char2, i);
              }
              break;
            }
            case "}": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char2, i);
              }
              break;
            }
            case "]": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char2, i);
              }
              break;
            }
            default: {
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, i + 1);
          if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char2, i);
            } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char2, i);
            }
          } else {
            lastValidIndex = i;
          }
          break;
        }
      }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for (let i = stack.length - 1; i >= 0; i--) {
      const state = stack[i];
      switch (state) {
        case "INSIDE_STRING": {
          result += '"';
          break;
        }
        case "INSIDE_OBJECT_KEY":
        case "INSIDE_OBJECT_AFTER_KEY":
        case "INSIDE_OBJECT_AFTER_COMMA":
        case "INSIDE_OBJECT_START":
        case "INSIDE_OBJECT_BEFORE_VALUE":
        case "INSIDE_OBJECT_AFTER_VALUE": {
          result += "}";
          break;
        }
        case "INSIDE_ARRAY_START":
        case "INSIDE_ARRAY_AFTER_COMMA":
        case "INSIDE_ARRAY_AFTER_VALUE": {
          result += "]";
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, input.length);
          if ("true".startsWith(partialLiteral)) {
            result += "true".slice(partialLiteral.length);
          } else if ("false".startsWith(partialLiteral)) {
            result += "false".slice(partialLiteral.length);
          } else if ("null".startsWith(partialLiteral)) {
            result += "null".slice(partialLiteral.length);
          }
        }
      }
    }
    return result;
  }
  async function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
      return { value: void 0, state: "undefined-input" };
    }
    let result = await safeParseJSON({ text: jsonText });
    if (result.success) {
      return { value: result.value, state: "successful-parse" };
    }
    result = await safeParseJSON({ text: fixJson(jsonText) });
    if (result.success) {
      return { value: result.value, state: "repaired-parse" };
    }
    return { value: void 0, state: "failed-parse" };
  }
  function extractMaxToolInvocationStep(toolInvocations) {
    return toolInvocations == null ? void 0 : toolInvocations.reduce((max2, toolInvocation) => {
      var _a17;
      return Math.max(max2, (_a17 = toolInvocation.step) != null ? _a17 : 0);
    }, 0);
  }
  function getToolInvocations(message) {
    return message.parts.filter(
      (part) => part.type === "tool-invocation"
    ).map((part) => part.toolInvocation);
  }
  function createStreamingUIMessageState({
    lastMessage,
    newMessageId = "no-id"
  } = {}) {
    var _a17;
    const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === "assistant";
    const step = isContinuation ? 1 + ((_a17 = extractMaxToolInvocationStep(getToolInvocations(lastMessage))) != null ? _a17 : 0) : 0;
    const message = isContinuation ? structuredClone(lastMessage) : {
      id: newMessageId,
      metadata: {},
      role: "assistant",
      parts: []
    };
    return {
      message,
      activeTextPart: void 0,
      activeReasoningPart: void 0,
      partialToolCalls: {},
      step
    };
  }
  function processUIMessageStream({
    stream,
    onToolCall,
    messageMetadataSchema,
    runUpdateMessageJob
  }) {
    return stream.pipeThrough(
      new TransformStream({
        async transform(part, controller) {
          await runUpdateMessageJob(async ({ state, write }) => {
            function updateToolInvocationPart(toolCallId, invocation) {
              const part2 = state.message.parts.find(
                (part3) => part3.type === "tool-invocation" && part3.toolInvocation.toolCallId === toolCallId
              );
              if (part2 != null) {
                part2.toolInvocation = invocation;
              } else {
                state.message.parts.push({
                  type: "tool-invocation",
                  toolInvocation: invocation
                });
              }
            }
            async function updateMessageMetadata(metadata) {
              if (metadata != null) {
                const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
                if (messageMetadataSchema != null) {
                  await validateTypes({
                    value: mergedMetadata,
                    schema: messageMetadataSchema
                  });
                }
                state.message.metadata = mergedMetadata;
              }
            }
            switch (part.type) {
              case "text": {
                if (state.activeTextPart == null) {
                  state.activeTextPart = {
                    type: "text",
                    text: part.text
                  };
                  state.message.parts.push(state.activeTextPart);
                } else {
                  state.activeTextPart.text += part.text;
                }
                write();
                break;
              }
              case "reasoning": {
                if (state.activeReasoningPart == null) {
                  state.activeReasoningPart = {
                    type: "reasoning",
                    text: part.text,
                    providerMetadata: part.providerMetadata
                  };
                  state.message.parts.push(state.activeReasoningPart);
                } else {
                  state.activeReasoningPart.text += part.text;
                  state.activeReasoningPart.providerMetadata = part.providerMetadata;
                }
                write();
                break;
              }
              case "reasoning-part-finish": {
                if (state.activeReasoningPart != null) {
                  state.activeReasoningPart = void 0;
                }
                break;
              }
              case "file": {
                state.message.parts.push({
                  type: "file",
                  mediaType: part.mediaType,
                  url: part.url
                });
                write();
                break;
              }
              case "source": {
                state.message.parts.push({
                  type: "source",
                  source: {
                    sourceType: "url",
                    id: part.id,
                    url: part.url,
                    title: part.title,
                    providerMetadata: part.providerMetadata
                  }
                });
                write();
                break;
              }
              case "tool-call-streaming-start": {
                const toolInvocations = getToolInvocations(state.message);
                state.partialToolCalls[part.toolCallId] = {
                  text: "",
                  step: state.step,
                  toolName: part.toolName,
                  index: toolInvocations.length
                };
                updateToolInvocationPart(part.toolCallId, {
                  state: "partial-call",
                  step: state.step,
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  args: void 0
                });
                write();
                break;
              }
              case "tool-call-delta": {
                const partialToolCall = state.partialToolCalls[part.toolCallId];
                partialToolCall.text += part.argsTextDelta;
                const { value: partialArgs } = await parsePartialJson(
                  partialToolCall.text
                );
                updateToolInvocationPart(part.toolCallId, {
                  state: "partial-call",
                  step: partialToolCall.step,
                  toolCallId: part.toolCallId,
                  toolName: partialToolCall.toolName,
                  args: partialArgs
                });
                write();
                break;
              }
              case "tool-call": {
                updateToolInvocationPart(part.toolCallId, {
                  state: "call",
                  step: state.step,
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  args: part.args
                });
                write();
                if (onToolCall) {
                  const result = await onToolCall({
                    toolCall: part
                  });
                  if (result != null) {
                    updateToolInvocationPart(part.toolCallId, {
                      state: "result",
                      step: state.step,
                      toolCallId: part.toolCallId,
                      toolName: part.toolName,
                      args: part.args,
                      result
                    });
                    write();
                  }
                }
                break;
              }
              case "tool-result": {
                const toolInvocations = getToolInvocations(state.message);
                if (toolInvocations == null) {
                  throw new Error("tool_result must be preceded by a tool_call");
                }
                const toolInvocationIndex = toolInvocations.findIndex(
                  (invocation) => invocation.toolCallId === part.toolCallId
                );
                if (toolInvocationIndex === -1) {
                  throw new Error(
                    "tool_result must be preceded by a tool_call with the same toolCallId"
                  );
                }
                updateToolInvocationPart(part.toolCallId, {
                  ...toolInvocations[toolInvocationIndex],
                  state: "result",
                  result: part.result
                });
                write();
                break;
              }
              case "start-step": {
                state.message.parts.push({ type: "step-start" });
                await updateMessageMetadata(part.metadata);
                write();
                break;
              }
              case "finish-step": {
                state.step += 1;
                state.activeTextPart = void 0;
                state.activeReasoningPart = void 0;
                await updateMessageMetadata(part.metadata);
                if (part.metadata != null) {
                  write();
                }
                break;
              }
              case "start": {
                if (part.messageId != null) {
                  state.message.id = part.messageId;
                }
                await updateMessageMetadata(part.metadata);
                if (part.messageId != null || part.metadata != null) {
                  write();
                }
                break;
              }
              case "finish": {
                await updateMessageMetadata(part.metadata);
                if (part.metadata != null) {
                  write();
                }
                break;
              }
              case "metadata": {
                await updateMessageMetadata(part.metadata);
                if (part.metadata != null) {
                  write();
                }
                break;
              }
              case "error": {
                throw new Error(part.errorText);
              }
              default: {
                if (part.type.startsWith("data-")) {
                  const existingPart = part.id != null ? state.message.parts.find(
                    (partArg) => part.type === partArg.type && part.id === partArg.id
                  ) : void 0;
                  if (existingPart != null) {
                    existingPart.value = mergeObjects(
                      existingPart.data,
                      part.data
                    );
                  } else {
                    state.message.parts.push({
                      type: part.type,
                      id: part.id,
                      value: part.data
                    });
                  }
                  write();
                }
              }
            }
            controller.enqueue(part);
          });
        }
      })
    );
  }
  function transformTextToUiMessageStream({
    stream
  }) {
    return stream.pipeThrough(
      new TransformStream({
        start(controller) {
          controller.enqueue({ type: "start" });
          controller.enqueue({ type: "start-step" });
        },
        async transform(part, controller) {
          controller.enqueue({ type: "text", text: part });
        },
        async flush(controller) {
          controller.enqueue({ type: "finish-step" });
          controller.enqueue({ type: "finish" });
        }
      })
    );
  }
  var getOriginalFetch = () => fetch;
  async function fetchUIMessageStream({
    api,
    body,
    streamProtocol = "ui-message",
    credentials,
    headers,
    abortController,
    fetch: fetch2 = getOriginalFetch(),
    requestType = "generate"
  }) {
    var _a17, _b, _c;
    const response = requestType === "resume" ? await fetch2(`${api}?chatId=${body.id}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      signal: (_a17 = abortController == null ? void 0 : abortController()) == null ? void 0 : _a17.signal,
      credentials
    }) : await fetch2(api, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      signal: (_b = abortController == null ? void 0 : abortController()) == null ? void 0 : _b.signal,
      credentials
    });
    if (!response.ok) {
      throw new Error(
        (_c = await response.text()) != null ? _c : "Failed to fetch the chat response."
      );
    }
    if (!response.body) {
      throw new Error("The response body is empty.");
    }
    return streamProtocol === "text" ? transformTextToUiMessageStream({
      stream: response.body.pipeThrough(new TextDecoderStream())
    }) : parseJsonEventStream({
      stream: response.body,
      schema: uiMessageStreamPartSchema
    }).pipeThrough(
      new TransformStream({
        async transform(part, controller) {
          if (!part.success) {
            throw part.error;
          }
          controller.enqueue(part.value);
        }
      })
    );
  }
  var SerialJobExecutor = class {
    constructor() {
      this.queue = [];
      this.isProcessing = false;
    }
    async processQueue() {
      if (this.isProcessing) {
        return;
      }
      this.isProcessing = true;
      while (this.queue.length > 0) {
        await this.queue[0]();
        this.queue.shift();
      }
      this.isProcessing = false;
    }
    async run(job) {
      return new Promise((resolve, reject) => {
        this.queue.push(async () => {
          try {
            await job();
            resolve();
          } catch (error) {
            reject(error);
          }
        });
        void this.processQueue();
      });
    }
  };
  function shouldResubmitMessages({
    originalMaxToolInvocationStep,
    originalMessageCount,
    maxSteps: maxSteps2,
    messages
  }) {
    var _a17;
    const lastMessage = messages[messages.length - 1];
    return (
      // check if the feature is enabled:
      maxSteps2 > 1 && // ensure there is a last message:
      lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):
      (messages.length > originalMessageCount || extractMaxToolInvocationStep(getToolInvocations(lastMessage)) !== originalMaxToolInvocationStep) && // check that next step is possible:
      isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:
      ((_a17 = extractMaxToolInvocationStep(getToolInvocations(lastMessage))) != null ? _a17 : 0) < maxSteps2
    );
  }
  function isAssistantMessageWithCompletedToolCalls(message) {
    if (message.role !== "assistant") {
      return false;
    }
    const lastStepStartIndex = message.parts.reduce((lastIndex2, part, index2) => {
      return part.type === "step-start" ? index2 : lastIndex2;
    }, -1);
    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part) => part.type === "tool-invocation");
    return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => "result" in part.toolInvocation);
  }
  function updateToolCallResult({
    messages,
    toolCallId,
    toolResult: result
  }) {
    const lastMessage = messages[messages.length - 1];
    const invocationPart = lastMessage.parts.find(
      (part) => part.type === "tool-invocation" && part.toolInvocation.toolCallId === toolCallId
    );
    if (invocationPart == null) {
      return;
    }
    invocationPart.toolInvocation = {
      ...invocationPart.toolInvocation,
      state: "result",
      result
    };
  }
  var ChatStore = class {
    constructor({
      chats = {},
      generateId: generateId3,
      messageMetadataSchema,
      transport,
      maxSteps: maxSteps2 = 1
    }) {
      this.chats = new Map(
        Object.entries(chats).map(([id, state]) => [
          id,
          {
            messages: [...state.messages],
            status: "ready",
            activeResponse: void 0,
            error: void 0,
            jobExecutor: new SerialJobExecutor()
          }
        ])
      );
      this.maxSteps = maxSteps2;
      this.transport = transport;
      this.subscribers = /* @__PURE__ */ new Set();
      this.generateId = generateId3 != null ? generateId3 : generateId;
      this.messageMetadataSchema = messageMetadataSchema;
    }
    hasChat(id) {
      return this.chats.has(id);
    }
    addChat(id, messages) {
      this.chats.set(id, {
        messages,
        status: "ready",
        jobExecutor: new SerialJobExecutor()
      });
    }
    getChats() {
      return Array.from(this.chats.entries());
    }
    get chatCount() {
      return this.chats.size;
    }
    getStatus(id) {
      return this.getChat(id).status;
    }
    setStatus({
      id,
      status,
      error
    }) {
      const chat = this.getChat(id);
      if (chat.status === status)
        return;
      chat.status = status;
      chat.error = error;
      this.emit({ type: "chat-status-changed", chatId: id, error });
    }
    getError(id) {
      return this.getChat(id).error;
    }
    getMessages(id) {
      return this.getChat(id).messages;
    }
    getLastMessage(id) {
      const chat = this.getChat(id);
      return chat.messages[chat.messages.length - 1];
    }
    subscribe(subscriber) {
      this.subscribers.add(subscriber);
      return () => this.subscribers.delete(subscriber);
    }
    setMessages({
      id,
      messages
    }) {
      this.getChat(id).messages = [...messages];
      this.emit({ type: "chat-messages-changed", chatId: id });
    }
    removeAssistantResponse(id) {
      const chat = this.getChat(id);
      const lastMessage = chat.messages[chat.messages.length - 1];
      if (lastMessage == null) {
        throw new Error("Cannot remove assistant response from empty chat");
      }
      if (lastMessage.role !== "assistant") {
        throw new Error("Last message is not an assistant message");
      }
      this.setMessages({ id, messages: chat.messages.slice(0, -1) });
    }
    async submitMessage({
      chatId,
      message,
      headers,
      body,
      onError,
      onToolCall,
      onFinish
    }) {
      var _a17;
      const chat = this.getChat(chatId);
      const currentMessages = chat.messages;
      await this.triggerRequest({
        chatId,
        messages: currentMessages.concat({
          ...message,
          id: (_a17 = message.id) != null ? _a17 : this.generateId()
        }),
        headers,
        body,
        requestType: "generate",
        onError,
        onToolCall,
        onFinish
      });
    }
    async resubmitLastUserMessage({
      chatId,
      headers,
      body,
      onError,
      onToolCall,
      onFinish
    }) {
      const messages = this.getChat(chatId).messages;
      const messagesToSubmit = messages[messages.length - 1].role === "assistant" ? messages.slice(0, -1) : messages;
      if (messagesToSubmit.length === 0) {
        return;
      }
      return this.triggerRequest({
        chatId,
        requestType: "generate",
        messages: messagesToSubmit,
        headers,
        body,
        onError,
        onToolCall,
        onFinish
      });
    }
    async resumeStream({
      chatId,
      headers,
      body,
      onError,
      onToolCall,
      onFinish
    }) {
      const chat = this.getChat(chatId);
      const currentMessages = chat.messages;
      return this.triggerRequest({
        chatId,
        messages: currentMessages,
        requestType: "resume",
        headers,
        body,
        onError,
        onToolCall,
        onFinish
      });
    }
    async addToolResult({
      chatId,
      toolCallId,
      result
    }) {
      const chat = this.getChat(chatId);
      chat.jobExecutor.run(async () => {
        const currentMessages = chat.messages;
        updateToolCallResult({
          messages: currentMessages,
          toolCallId,
          toolResult: result
        });
        this.setMessages({ id: chatId, messages: currentMessages });
        if (chat.status === "submitted" || chat.status === "streaming") {
          return;
        }
        const lastMessage = currentMessages[currentMessages.length - 1];
        if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {
          await this.triggerRequest({
            messages: currentMessages,
            requestType: "generate",
            chatId
          });
        }
      });
    }
    async stopStream({ chatId }) {
      var _a17;
      const chat = this.getChat(chatId);
      if (chat.status !== "streaming" && chat.status !== "submitted")
        return;
      if ((_a17 = chat.activeResponse) == null ? void 0 : _a17.abortController) {
        chat.activeResponse.abortController.abort();
        chat.activeResponse.abortController = void 0;
      }
    }
    emit(event) {
      for (const subscriber of this.subscribers) {
        subscriber.onChatChanged(event);
      }
    }
    getChat(id) {
      if (!this.hasChat(id)) {
        throw new Error(`chat '${id}' not found`);
      }
      return this.chats.get(id);
    }
    async triggerRequest({
      chatId,
      messages: chatMessages,
      requestType,
      headers,
      body,
      onError,
      onToolCall,
      onFinish
    }) {
      const self2 = this;
      const chat = this.getChat(chatId);
      this.setMessages({ id: chatId, messages: chatMessages });
      this.setStatus({ id: chatId, status: "submitted", error: void 0 });
      const messageCount = chatMessages.length;
      const maxStep = extractMaxToolInvocationStep(
        getToolInvocations(chatMessages[chatMessages.length - 1])
      );
      try {
        const activeResponse = {
          state: createStreamingUIMessageState({
            lastMessage: chatMessages[chatMessages.length - 1],
            newMessageId: self2.generateId()
          }),
          abortController: new AbortController()
        };
        chat.activeResponse = activeResponse;
        const stream = await self2.transport.submitMessages({
          chatId,
          messages: chatMessages,
          body,
          headers,
          abortController: activeResponse.abortController,
          requestType
        });
        const runUpdateMessageJob = (job) => (
          // serialize the job execution to avoid race conditions:
          chat.jobExecutor.run(
            () => job({
              state: activeResponse.state,
              write: () => {
                self2.setStatus({ id: chatId, status: "streaming" });
                const replaceLastMessage = activeResponse.state.message.id === chatMessages[chatMessages.length - 1].id;
                const newMessages = [
                  ...replaceLastMessage ? chatMessages.slice(0, chatMessages.length - 1) : chatMessages,
                  activeResponse.state.message
                ];
                self2.setMessages({
                  id: chatId,
                  messages: newMessages
                });
              }
            })
          )
        );
        await consumeStream({
          stream: processUIMessageStream({
            stream,
            onToolCall,
            messageMetadataSchema: self2.messageMetadataSchema,
            runUpdateMessageJob
          }),
          onError: (error) => {
            throw error;
          }
        });
        onFinish == null ? void 0 : onFinish({ message: activeResponse.state.message });
        this.setStatus({ id: chatId, status: "ready" });
      } catch (err) {
        if (err.name === "AbortError") {
          this.setStatus({ id: chatId, status: "ready" });
          return null;
        }
        if (onError && err instanceof Error) {
          onError(err);
        }
        this.setStatus({ id: chatId, status: "error", error: err });
      } finally {
        chat.activeResponse = void 0;
      }
      const currentMessages = self2.getMessages(chatId);
      if (shouldResubmitMessages({
        originalMaxToolInvocationStep: maxStep,
        originalMessageCount: messageCount,
        maxSteps: self2.maxSteps,
        messages: currentMessages
      })) {
        await self2.triggerRequest({
          chatId,
          requestType,
          onError,
          onToolCall,
          onFinish,
          headers,
          body,
          messages: currentMessages
        });
      }
    }
  };
  var DefaultChatTransport = class {
    constructor({
      api,
      credentials,
      headers,
      body,
      streamProtocol,
      fetch: fetch2,
      prepareRequestBody
    }) {
      this.api = api;
      this.credentials = credentials;
      this.headers = headers;
      this.body = body;
      this.streamProtocol = streamProtocol;
      this.fetch = fetch2;
      this.prepareRequestBody = prepareRequestBody;
    }
    submitMessages({
      chatId,
      messages,
      abortController,
      body,
      headers,
      requestType
    }) {
      var _a17, _b;
      return fetchUIMessageStream({
        api: this.api,
        headers: {
          ...this.headers,
          ...headers
        },
        body: (_b = (_a17 = this.prepareRequestBody) == null ? void 0 : _a17.call(this, {
          id: chatId,
          // TODO change to chatId
          messages,
          ...this.body,
          ...body
        })) != null ? _b : {
          id: chatId,
          // TODO change to chatId
          messages,
          ...this.body,
          ...body
        },
        streamProtocol: this.streamProtocol,
        credentials: this.credentials,
        abortController: () => abortController,
        fetch: this.fetch,
        requestType
      });
    }
  };
  async function convertFileListToFileUIParts(files) {
    if (files == null) {
      return [];
    }
    if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {
      throw new Error("FileList is not supported in the current environment");
    }
    return Promise.all(
      Array.from(files).map(async (file) => {
        const { name: name172, type } = file;
        const dataUrl = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (readerEvent) => {
            var _a17;
            resolve((_a17 = readerEvent.target) == null ? void 0 : _a17.result);
          };
          reader.onerror = (error) => reject(error);
          reader.readAsDataURL(file);
        });
        return {
          type: "file",
          mediaType: type,
          filename: name172,
          url: dataUrl
        };
      })
    );
  }
  function defaultChatStore({
    api,
    fetch: fetch2,
    streamProtocol = "ui-message",
    credentials,
    headers,
    body,
    prepareRequestBody,
    generateId: generateId3 = generateId,
    messageMetadataSchema,
    maxSteps: maxSteps2 = 1,
    chats
  }) {
    return new ChatStore({
      transport: new DefaultChatTransport({
        api,
        fetch: fetch2,
        streamProtocol,
        credentials,
        headers,
        body,
        prepareRequestBody
      }),
      generateId: generateId3,
      messageMetadataSchema,
      maxSteps: maxSteps2,
      chats
    });
  }
  var JsonToSseTransformStream = class extends TransformStream {
    constructor() {
      super({
        transform(part, controller) {
          controller.enqueue(`data: ${JSON.stringify(part)}

`);
        },
        flush(controller) {
          controller.enqueue("data: [DONE]\n\n");
        }
      });
    }
  };
  var dataContentSchema = external_exports.union([
    external_exports.string(),
    external_exports.instanceof(Uint8Array),
    external_exports.instanceof(ArrayBuffer),
    external_exports.custom(
      // Buffer might not be available in some environments such as CloudFlare:
      (value) => {
        var _a17, _b;
        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;
      },
      { message: "Must be a Buffer" }
    )
  ]);
  var jsonValueSchema = external_exports.lazy(
    () => external_exports.union([
      external_exports.null(),
      external_exports.string(),
      external_exports.number(),
      external_exports.boolean(),
      external_exports.record(external_exports.string(), jsonValueSchema),
      external_exports.array(jsonValueSchema)
    ])
  );
  var providerMetadataSchema = external_exports.record(
    external_exports.string(),
    external_exports.record(external_exports.string(), jsonValueSchema)
  );
  var toolResultContentSchema = external_exports.array(
    external_exports.union([
      external_exports.object({ type: external_exports.literal("text"), text: external_exports.string() }),
      external_exports.object({
        type: external_exports.literal("image"),
        data: external_exports.string(),
        mediaType: external_exports.string().optional()
      })
    ])
  );
  var textPartSchema = external_exports.object({
    type: external_exports.literal("text"),
    text: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var imagePartSchema = external_exports.object({
    type: external_exports.literal("image"),
    image: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
    mediaType: external_exports.string().optional(),
    providerOptions: providerMetadataSchema.optional()
  });
  var filePartSchema = external_exports.object({
    type: external_exports.literal("file"),
    data: external_exports.union([dataContentSchema, external_exports.instanceof(URL)]),
    filename: external_exports.string().optional(),
    mediaType: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var reasoningPartSchema = external_exports.object({
    type: external_exports.literal("reasoning"),
    text: external_exports.string(),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolCallPartSchema = external_exports.object({
    type: external_exports.literal("tool-call"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    args: external_exports.unknown(),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolResultPartSchema = external_exports.object({
    type: external_exports.literal("tool-result"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    result: external_exports.unknown(),
    content: toolResultContentSchema.optional(),
    isError: external_exports.boolean().optional(),
    providerOptions: providerMetadataSchema.optional()
  });
  var systemModelMessageSchema = external_exports.object(
    {
      role: external_exports.literal("system"),
      content: external_exports.string(),
      providerOptions: providerMetadataSchema.optional()
    }
  );
  var userModelMessageSchema = external_exports.object({
    role: external_exports.literal("user"),
    content: external_exports.union([
      external_exports.string(),
      external_exports.array(external_exports.union([textPartSchema, imagePartSchema, filePartSchema]))
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var assistantModelMessageSchema = external_exports.object({
    role: external_exports.literal("assistant"),
    content: external_exports.union([
      external_exports.string(),
      external_exports.array(
        external_exports.union([
          textPartSchema,
          filePartSchema,
          reasoningPartSchema,
          toolCallPartSchema
        ])
      )
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolModelMessageSchema = external_exports.object({
    role: external_exports.literal("tool"),
    content: external_exports.array(toolResultPartSchema),
    providerOptions: providerMetadataSchema.optional()
  });
  var modelMessageSchema = external_exports.union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
  ]);
  var originalGenerateId = createIdGenerator({ prefix: "aiobj", size: 24 });
  var originalGenerateId2 = createIdGenerator({ prefix: "aiobj", size: 24 });
  var originalGenerateId3 = createIdGenerator({
    prefix: "aitxt",
    size: 24
  });
  var output_exports = {};
  __export2(output_exports, {
    object: () => object,
    text: () => text
  });
  var text = () => ({
    type: "text",
    responseFormat: { type: "text" },
    async parsePartial({ text: text22 }) {
      return { partial: text22 };
    },
    async parseOutput({ text: text22 }) {
      return text22;
    }
  });
  var object = ({
    schema: inputSchema
  }) => {
    const schema = asSchema(inputSchema);
    return {
      type: "object",
      responseFormat: {
        type: "json",
        schema: schema.jsonSchema
      },
      async parsePartial({ text: text22 }) {
        const result = await parsePartialJson(text22);
        switch (result.state) {
          case "failed-parse":
          case "undefined-input":
            return void 0;
          case "repaired-parse":
          case "successful-parse":
            return {
              // Note: currently no validation of partial results:
              partial: result.value
            };
          default: {
            const _exhaustiveCheck = result.state;
            throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
          }
        }
      },
      async parseOutput({ text: text22 }, context) {
        const parseResult = await safeParseJSON({ text: text22 });
        if (!parseResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: could not parse the response.",
            cause: parseResult.error,
            text: text22,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        const validationResult = await safeValidateTypes({
          value: parseResult.value,
          schema
        });
        if (!validationResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text22,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        return validationResult.value;
      }
    };
  };
  var originalGenerateId4 = createIdGenerator({
    prefix: "aitxt",
    size: 24
  });
  var name16 = "AI_NoSuchProviderError";
  var marker16 = `vercel.ai.error.${name16}`;
  var symbol16 = Symbol.for(marker16);
  var _a16;
  _a16 = symbol16;
  var ClientOrServerImplementationSchema = external_exports.object({
    name: external_exports.string(),
    version: external_exports.string()
  }).passthrough();
  var BaseParamsSchema = external_exports.object({
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var ResultSchema = BaseParamsSchema;
  var RequestSchema = external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseParamsSchema)
  });
  var ServerCapabilitiesSchema = external_exports.object({
    experimental: external_exports.optional(external_exports.object({}).passthrough()),
    logging: external_exports.optional(external_exports.object({}).passthrough()),
    prompts: external_exports.optional(
      external_exports.object({
        listChanged: external_exports.optional(external_exports.boolean())
      }).passthrough()
    ),
    resources: external_exports.optional(
      external_exports.object({
        subscribe: external_exports.optional(external_exports.boolean()),
        listChanged: external_exports.optional(external_exports.boolean())
      }).passthrough()
    ),
    tools: external_exports.optional(
      external_exports.object({
        listChanged: external_exports.optional(external_exports.boolean())
      }).passthrough()
    )
  }).passthrough();
  var InitializeResultSchema = ResultSchema.extend({
    protocolVersion: external_exports.string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ClientOrServerImplementationSchema,
    instructions: external_exports.optional(external_exports.string())
  });
  var PaginatedResultSchema = ResultSchema.extend({
    nextCursor: external_exports.optional(external_exports.string())
  });
  var ToolSchema = external_exports.object({
    name: external_exports.string(),
    description: external_exports.optional(external_exports.string()),
    inputSchema: external_exports.object({
      type: external_exports.literal("object"),
      properties: external_exports.optional(external_exports.object({}).passthrough())
    }).passthrough()
  }).passthrough();
  var ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: external_exports.array(ToolSchema)
  });
  var TextContentSchema = external_exports.object({
    type: external_exports.literal("text"),
    text: external_exports.string()
  }).passthrough();
  var ImageContentSchema = external_exports.object({
    type: external_exports.literal("image"),
    data: external_exports.string().base64(),
    mimeType: external_exports.string()
  }).passthrough();
  var ResourceContentsSchema = external_exports.object({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string())
  }).passthrough();
  var TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: external_exports.string()
  });
  var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: external_exports.string().base64()
  });
  var EmbeddedResourceSchema = external_exports.object({
    type: external_exports.literal("resource"),
    resource: external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema])
  }).passthrough();
  var CallToolResultSchema = ResultSchema.extend({
    content: external_exports.array(
      external_exports.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
    ),
    isError: external_exports.boolean().default(false).optional()
  }).or(
    ResultSchema.extend({
      toolResult: external_exports.unknown()
    })
  );
  var JSONRPC_VERSION = "2.0";
  var JSONRPCRequestSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([external_exports.string(), external_exports.number().int()])
  }).merge(RequestSchema).strict();
  var JSONRPCResponseSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([external_exports.string(), external_exports.number().int()]),
    result: ResultSchema
  }).strict();
  var JSONRPCErrorSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([external_exports.string(), external_exports.number().int()]),
    error: external_exports.object({
      code: external_exports.number().int(),
      message: external_exports.string(),
      data: external_exports.optional(external_exports.unknown())
    })
  }).strict();
  var JSONRPCNotificationSchema = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION)
  }).merge(
    external_exports.object({
      method: external_exports.string(),
      params: external_exports.optional(BaseParamsSchema)
    })
  ).strict();
  var JSONRPCMessageSchema = external_exports.union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
  ]);

  // ../../packages/aihappey-ai/dist/store.js
  var LS_KEY = "aihappey_ai_chats_v1";
  function loadChats() {
    try {
      return JSON.parse(localStorage.getItem(LS_KEY) ?? "{}");
    } catch {
      return {};
    }
  }
  var createAiChatStore = (config) => {
    const store2 = defaultChatStore({
      api: config?.api ?? "/api/chat",
      maxSteps: 15,
      chats: loadChats(),
      fetch: async (input, init) => {
        let headers = { ...config?.headers || {} };
        if (config?.getAccessToken) {
          const token2 = await config.getAccessToken();
          headers["Authorization"] = `Bearer ${token2}`;
        }
        if (init?.headers) {
          headers = { ...headers, ...init.headers };
        }
        return (config?.fetch || fetch)(input, { ...init, headers });
      }
      // model is not a valid option for defaultChatStore, so it is ignored here
    });
    const save = () => {
      const chatsObj = Object.fromEntries(store2.getChats().map(([id, chat]) => [id, { messages: chat.messages }]));
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(chatsObj));
      } catch {
      }
    };
    store2.subscribe({
      onChatChanged: (e) => {
        if (e.type === "chat-messages-changed")
          save();
      }
    });
    return store2;
  };

  // ../../packages/aihappey-ai/dist/useAiChat.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ai-sdk/react/dist/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react2 = __toESM(require_react(), 1);
  var import_react3 = __toESM(require_react(), 1);
  var import_react4 = __toESM(require_react(), 1);
  function useChat({
    id,
    initialInput = "",
    onToolCall,
    onFinish,
    onError,
    generateId: generateId2 = generateId,
    experimental_throttle: throttleWaitMs,
    chatStore: chatStoreArg
  } = {}) {
    const [hookId] = (0, import_react2.useState)(generateId2);
    const chatId = id != null ? id : hookId;
    const chatStore = (0, import_react2.useRef)(
      chatStoreArg != null ? chatStoreArg : defaultChatStore({
        api: "/api/chat",
        generateId: generateId2
      })
    );
    if (!chatStore.current.hasChat(chatId)) {
      chatStore.current.addChat(chatId, []);
    }
    const subscribe = (0, import_react2.useCallback)(
      ({
        onStoreChange,
        eventType
      }) => {
        return chatStore.current.subscribe({
          onChatChanged: (event) => {
            if (event.chatId !== chatId || event.type !== eventType) {
              return;
            }
            onStoreChange();
          }
        });
      },
      [chatStore, chatId]
    );
    const addToolResult = (0, import_react2.useCallback)(
      (options) => chatStore.current.addToolResult({ chatId, ...options }),
      [chatStore, chatId]
    );
    const stopStream = (0, import_react2.useCallback)(() => {
      chatStore.current.stopStream({ chatId });
    }, [chatStore, chatId]);
    const error = (0, import_react2.useSyncExternalStore)(
      (callback) => subscribe({
        onStoreChange: callback,
        eventType: "chat-status-changed"
      }),
      () => chatStore.current.getError(chatId),
      () => chatStore.current.getError(chatId)
    );
    const status = (0, import_react2.useSyncExternalStore)(
      (callback) => subscribe({
        onStoreChange: callback,
        eventType: "chat-status-changed"
      }),
      () => chatStore.current.getStatus(chatId),
      () => chatStore.current.getStatus(chatId)
    );
    const messages = (0, import_react2.useSyncExternalStore)(
      (callback) => {
        return subscribe({
          onStoreChange: callback,
          eventType: "chat-messages-changed"
        });
      },
      () => chatStore.current.getMessages(chatId),
      () => chatStore.current.getMessages(chatId)
    );
    const append2 = (0, import_react2.useCallback)(
      (message, { headers, body } = {}) => chatStore.current.submitMessage({
        chatId,
        message,
        headers,
        body,
        onError,
        onToolCall,
        onFinish
      }),
      [chatStore, chatId, onError, onToolCall, onFinish]
    );
    const reload = (0, import_react2.useCallback)(
      async ({ headers, body } = {}) => chatStore.current.resubmitLastUserMessage({
        chatId,
        headers,
        body,
        onError,
        onToolCall,
        onFinish
      }),
      [chatStore, chatId, onError, onToolCall, onFinish]
    );
    const stop = (0, import_react2.useCallback)(() => stopStream(), [stopStream]);
    const experimental_resume = (0, import_react2.useCallback)(
      async () => chatStore.current.resumeStream({
        chatId,
        onError,
        onToolCall,
        onFinish
      }),
      [chatStore, chatId, onError, onToolCall, onFinish]
    );
    const setMessages = (0, import_react2.useCallback)(
      (messagesParam) => {
        if (typeof messagesParam === "function") {
          messagesParam = messagesParam(messages);
        }
        chatStore.current.setMessages({
          id: chatId,
          messages: messagesParam
        });
      },
      [chatId, messages]
    );
    const [input, setInput] = (0, import_react2.useState)(initialInput);
    const handleSubmit = (0, import_react2.useCallback)(
      async (event, options = {}) => {
        var _a17;
        (_a17 = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a17.call(event);
        const fileParts = Array.isArray(options == null ? void 0 : options.files) ? options.files : await convertFileListToFileUIParts(options == null ? void 0 : options.files);
        if (!input && fileParts.length === 0)
          return;
        append2(
          {
            id: generateId2(),
            role: "user",
            metadata: void 0,
            parts: [...fileParts, { type: "text", text: input }]
          },
          {
            headers: options.headers,
            body: options.body
          }
        );
        setInput("");
      },
      [input, generateId2, append2]
    );
    const handleInputChange = (e) => {
      setInput(e.target.value);
    };
    return {
      messages,
      id: chatId,
      setMessages,
      error,
      append: append2,
      reload,
      stop,
      experimental_resume,
      input,
      setInput,
      handleInputChange,
      handleSubmit,
      status,
      addToolResult
    };
  }

  // ../../packages/aihappey-core/dist/components/chat/ChatContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react6 = __toESM(require_react());
  var ChatContext = (0, import_react6.createContext)(void 0);
  var useChatContext = () => {
    const ctx = (0, import_react6.useContext)(ChatContext);
    if (!ctx)
      throw new Error("useChatContext must be used within ChatProvider");
    return ctx;
  };

  // ../../packages/aihappey-core/dist/components/chat/ChatProvider.js
  var ChatProvider = ({ config, children: children2 }) => {
    const chatStoreRef = (0, import_react7.useRef)();
    if (!chatStoreRef.current) {
      chatStoreRef.current = createAiChatStore(config);
    }
    const value = (0, import_react7.useMemo)(() => ({
      chatStore: chatStoreRef.current,
      config
    }), [config]);
    return (0, import_jsx_runtime.jsx)(ChatContext.Provider, { value, children: children2 });
  };

  // ../../packages/aihappey-core/dist/components/chat/useConversations.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-state/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-state/dist/createAppStore.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zustand/esm/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zustand/esm/vanilla.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_meta2 = {};
  var createStoreImpl = (createState2) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace4) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace4 != null ? replace4 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState = state = createState2(setState, getState, api);
    return api;
  };
  var createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;

  // ../../node_modules/zustand/esm/index.mjs
  var import_react8 = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var import_meta3 = {};
  var { useDebugValue } = import_react8.default;
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  var didWarnAboutEqualityFn = false;
  var identity = (arg) => arg;
  function useStore(api, selector = identity, equalityFn) {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice2 = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue(slice2);
    return slice2;
  }
  var createImpl = (createState2) => {
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && typeof createState2 !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
    const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create = (createState2) => createState2 ? createImpl(createState2) : createImpl;

  // ../../packages/aihappey-state/dist/slices/serversSlice.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var createServersSlice = (set, get, store2) => ({
    servers: {},
    selected: [],
    selectedServers: [],
    addServer: (name21, cfg) => set((s) => ({
      servers: { ...s.servers, [name21]: cfg }
    })),
    removeServer: (name21) => set((s) => {
      const { [name21]: _, ...rest } = s.servers;
      const filtered = s.selected.filter((n) => n !== name21);
      return {
        servers: rest,
        selected: filtered,
        selectedServers: filtered
      };
    }),
    selectServers: (names) => set(() => ({
      selected: names,
      selectedServers: names
    })),
    resetServers: () => set(() => ({
      servers: {},
      selected: [],
      selectedServers: []
    }))
  });

  // ../../packages/aihappey-state/dist/slices/chatSlice.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var now = () => (/* @__PURE__ */ new Date()).toISOString();
  var createChatSlice = (set, get, store2) => ({
    conversations: [],
    selectedConversationId: null,
    createConversation: (name21) => {
      const conv = {
        id: crypto.randomUUID(),
        name: name21,
        messages: [],
        createdAt: now(),
        updatedAt: now()
      };
      set((s) => ({
        conversations: [conv, ...s.conversations]
      }));
      return conv;
    },
    updateConversationName: (id, name21) => set((s) => ({
      conversations: s.conversations.map((c) => c.id === id ? { ...c, name: name21, updatedAt: now() } : c)
    })),
    addMessage: (cid, msg) => set((s) => ({
      conversations: s.conversations.map((c) => c.id === cid ? { ...c, messages: [...c.messages, msg], updatedAt: now() } : c)
    })),
    updateMessage: (cid, mid, up) => set((s) => ({
      conversations: s.conversations.map((c) => c.id === cid ? {
        ...c,
        messages: c.messages.map((m) => m.id === mid ? { ...m, ...up } : m),
        updatedAt: now()
      } : c)
    })),
    removeConversation: (id) => set((s) => ({
      conversations: s.conversations.filter((c) => c.id !== id)
    })),
    selectConversation: (id) => set(() => ({
      selectedConversationId: id
    })),
    getConversation: (id) => get().conversations.find((c) => c.id === id)
  });

  // ../../packages/aihappey-state/dist/slices/mcpSlice.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-mcp/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-mcp/dist/connect.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var LATEST_PROTOCOL_VERSION = "2025-03-26";
  var SUPPORTED_PROTOCOL_VERSIONS = [
    LATEST_PROTOCOL_VERSION,
    "2024-11-05",
    "2024-10-07"
  ];
  var JSONRPC_VERSION2 = "2.0";
  var ProgressTokenSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);
  var CursorSchema = external_exports.string();
  var RequestMetaSchema = external_exports.object({
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */
    progressToken: external_exports.optional(ProgressTokenSchema)
  }).passthrough();
  var BaseRequestParamsSchema = external_exports.object({
    _meta: external_exports.optional(RequestMetaSchema)
  }).passthrough();
  var RequestSchema2 = external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseRequestParamsSchema)
  });
  var BaseNotificationParamsSchema = external_exports.object({
    /**
     * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var NotificationSchema = external_exports.object({
    method: external_exports.string(),
    params: external_exports.optional(BaseNotificationParamsSchema)
  });
  var ResultSchema2 = external_exports.object({
    /**
     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
     */
    _meta: external_exports.optional(external_exports.object({}).passthrough())
  }).passthrough();
  var RequestIdSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);
  var JSONRPCRequestSchema2 = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION2),
    id: RequestIdSchema
  }).merge(RequestSchema2).strict();
  var isJSONRPCRequest = (value) => JSONRPCRequestSchema2.safeParse(value).success;
  var JSONRPCNotificationSchema2 = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION2)
  }).merge(NotificationSchema).strict();
  var isJSONRPCNotification = (value) => JSONRPCNotificationSchema2.safeParse(value).success;
  var JSONRPCResponseSchema2 = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION2),
    id: RequestIdSchema,
    result: ResultSchema2
  }).strict();
  var isJSONRPCResponse = (value) => JSONRPCResponseSchema2.safeParse(value).success;
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  })(ErrorCode || (ErrorCode = {}));
  var JSONRPCErrorSchema2 = external_exports.object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION2),
    id: RequestIdSchema,
    error: external_exports.object({
      /**
       * The error type that occurred.
       */
      code: external_exports.number().int(),
      /**
       * A short description of the error. The message SHOULD be limited to a concise single sentence.
       */
      message: external_exports.string(),
      /**
       * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
       */
      data: external_exports.optional(external_exports.unknown())
    })
  }).strict();
  var isJSONRPCError = (value) => JSONRPCErrorSchema2.safeParse(value).success;
  var JSONRPCMessageSchema2 = external_exports.union([
    JSONRPCRequestSchema2,
    JSONRPCNotificationSchema2,
    JSONRPCResponseSchema2,
    JSONRPCErrorSchema2
  ]);
  var EmptyResultSchema = ResultSchema2.strict();
  var CancelledNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The ID of the request to cancel.
       *
       * This MUST correspond to the ID of a request previously issued in the same direction.
       */
      requestId: RequestIdSchema,
      /**
       * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
       */
      reason: external_exports.string().optional()
    })
  });
  var ImplementationSchema = external_exports.object({
    name: external_exports.string(),
    version: external_exports.string()
  }).passthrough();
  var ClientCapabilitiesSchema = external_exports.object({
    /**
     * Experimental, non-standard capabilities that the client supports.
     */
    experimental: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the client supports sampling from an LLM.
     */
    sampling: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the client supports listing roots.
     */
    roots: external_exports.optional(external_exports.object({
      /**
       * Whether the client supports issuing notifications for changes to the roots list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
       */
      protocolVersion: external_exports.string(),
      capabilities: ClientCapabilitiesSchema,
      clientInfo: ImplementationSchema
    })
  });
  var ServerCapabilitiesSchema2 = external_exports.object({
    /**
     * Experimental, non-standard capabilities that the server supports.
     */
    experimental: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending log messages to the client.
     */
    logging: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server supports sending completions to the client.
     */
    completions: external_exports.optional(external_exports.object({}).passthrough()),
    /**
     * Present if the server offers any prompt templates.
     */
    prompts: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the prompt list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any resources to read.
     */
    resources: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports clients subscribing to resource updates.
       */
      subscribe: external_exports.optional(external_exports.boolean()),
      /**
       * Whether this server supports issuing notifications for changes to the resource list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough()),
    /**
     * Present if the server offers any tools to call.
     */
    tools: external_exports.optional(external_exports.object({
      /**
       * Whether this server supports issuing notifications for changes to the tool list.
       */
      listChanged: external_exports.optional(external_exports.boolean())
    }).passthrough())
  }).passthrough();
  var InitializeResultSchema2 = ResultSchema2.extend({
    /**
     * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
     */
    protocolVersion: external_exports.string(),
    capabilities: ServerCapabilitiesSchema2,
    serverInfo: ImplementationSchema,
    /**
     * Instructions describing how to use the server and its features.
     *
     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
     */
    instructions: external_exports.optional(external_exports.string())
  });
  var InitializedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/initialized")
  });
  var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
  var PingRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("ping")
  });
  var ProgressSchema = external_exports.object({
    /**
     * The progress thus far. This should increase every time progress is made, even if the total is unknown.
     */
    progress: external_exports.number(),
    /**
     * Total number of items to process (or total progress required), if known.
     */
    total: external_exports.optional(external_exports.number()),
    /**
     * An optional message describing the current progress.
     */
    message: external_exports.optional(external_exports.string())
  }).passthrough();
  var ProgressNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
      /**
       * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
       */
      progressToken: ProgressTokenSchema
    })
  });
  var PaginatedRequestSchema = RequestSchema2.extend({
    params: BaseRequestParamsSchema.extend({
      /**
       * An opaque token representing the current pagination position.
       * If provided, the server should return results starting after this cursor.
       */
      cursor: external_exports.optional(CursorSchema)
    }).optional()
  });
  var PaginatedResultSchema2 = ResultSchema2.extend({
    /**
     * An opaque token representing the pagination position after the last returned result.
     * If present, there may be more results available.
     */
    nextCursor: external_exports.optional(CursorSchema)
  });
  var ResourceContentsSchema2 = external_exports.object({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string())
  }).passthrough();
  var TextResourceContentsSchema2 = ResourceContentsSchema2.extend({
    /**
     * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
     */
    text: external_exports.string()
  });
  var BlobResourceContentsSchema2 = ResourceContentsSchema2.extend({
    /**
     * A base64-encoded string representing the binary data of the item.
     */
    blob: external_exports.string().base64()
  });
  var ResourceSchema = external_exports.object({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * A human-readable name for this resource.
     *
     * This can be used by clients to populate UI elements.
     */
    name: external_exports.string(),
    /**
     * A description of what this resource represents.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string())
  }).passthrough();
  var ResourceTemplateSchema = external_exports.object({
    /**
     * A URI template (according to RFC 6570) that can be used to construct resource URIs.
     */
    uriTemplate: external_exports.string(),
    /**
     * A human-readable name for the type of resource this template refers to.
     *
     * This can be used by clients to populate UI elements.
     */
    name: external_exports.string(),
    /**
     * A description of what this template is for.
     *
     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
     */
    mimeType: external_exports.optional(external_exports.string())
  }).passthrough();
  var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("resources/list")
  });
  var ListResourcesResultSchema = PaginatedResultSchema2.extend({
    resources: external_exports.array(ResourceSchema)
  });
  var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("resources/templates/list")
  });
  var ListResourceTemplatesResultSchema = PaginatedResultSchema2.extend({
    resourceTemplates: external_exports.array(ResourceTemplateSchema)
  });
  var ReadResourceRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: external_exports.string()
    })
  });
  var ReadResourceResultSchema = ResultSchema2.extend({
    contents: external_exports.array(external_exports.union([TextResourceContentsSchema2, BlobResourceContentsSchema2]))
  });
  var ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/resources/list_changed")
  });
  var SubscribeRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
       */
      uri: external_exports.string()
    })
  });
  var UnsubscribeRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The URI of the resource to unsubscribe from.
       */
      uri: external_exports.string()
    })
  });
  var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
       */
      uri: external_exports.string()
    })
  });
  var PromptArgumentSchema = external_exports.object({
    /**
     * The name of the argument.
     */
    name: external_exports.string(),
    /**
     * A human-readable description of the argument.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * Whether this argument must be provided.
     */
    required: external_exports.optional(external_exports.boolean())
  }).passthrough();
  var PromptSchema = external_exports.object({
    /**
     * The name of the prompt or prompt template.
     */
    name: external_exports.string(),
    /**
     * An optional description of what this prompt provides
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * A list of arguments to use for templating the prompt.
     */
    arguments: external_exports.optional(external_exports.array(PromptArgumentSchema))
  }).passthrough();
  var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("prompts/list")
  });
  var ListPromptsResultSchema = PaginatedResultSchema2.extend({
    prompts: external_exports.array(PromptSchema)
  });
  var GetPromptRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The name of the prompt or prompt template.
       */
      name: external_exports.string(),
      /**
       * Arguments to use for templating the prompt.
       */
      arguments: external_exports.optional(external_exports.record(external_exports.string()))
    })
  });
  var TextContentSchema2 = external_exports.object({
    type: external_exports.literal("text"),
    /**
     * The text content of the message.
     */
    text: external_exports.string()
  }).passthrough();
  var ImageContentSchema2 = external_exports.object({
    type: external_exports.literal("image"),
    /**
     * The base64-encoded image data.
     */
    data: external_exports.string().base64(),
    /**
     * The MIME type of the image. Different providers may support different image types.
     */
    mimeType: external_exports.string()
  }).passthrough();
  var AudioContentSchema = external_exports.object({
    type: external_exports.literal("audio"),
    /**
     * The base64-encoded audio data.
     */
    data: external_exports.string().base64(),
    /**
     * The MIME type of the audio. Different providers may support different audio types.
     */
    mimeType: external_exports.string()
  }).passthrough();
  var EmbeddedResourceSchema2 = external_exports.object({
    type: external_exports.literal("resource"),
    resource: external_exports.union([TextResourceContentsSchema2, BlobResourceContentsSchema2])
  }).passthrough();
  var PromptMessageSchema = external_exports.object({
    role: external_exports.enum(["user", "assistant"]),
    content: external_exports.union([
      TextContentSchema2,
      ImageContentSchema2,
      AudioContentSchema,
      EmbeddedResourceSchema2
    ])
  }).passthrough();
  var GetPromptResultSchema = ResultSchema2.extend({
    /**
     * An optional description for the prompt.
     */
    description: external_exports.optional(external_exports.string()),
    messages: external_exports.array(PromptMessageSchema)
  });
  var PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/prompts/list_changed")
  });
  var ToolAnnotationsSchema = external_exports.object({
    /**
     * A human-readable title for the tool.
     */
    title: external_exports.optional(external_exports.string()),
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */
    readOnlyHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: true
     */
    destructiveHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on the its environment.
     *
     * (This property is meaningful only when `readOnlyHint == false`)
     *
     * Default: false
     */
    idempotentHint: external_exports.optional(external_exports.boolean()),
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */
    openWorldHint: external_exports.optional(external_exports.boolean())
  }).passthrough();
  var ToolSchema2 = external_exports.object({
    /**
     * The name of the tool.
     */
    name: external_exports.string(),
    /**
     * A human-readable description of the tool.
     */
    description: external_exports.optional(external_exports.string()),
    /**
     * A JSON Schema object defining the expected parameters for the tool.
     */
    inputSchema: external_exports.object({
      type: external_exports.literal("object"),
      properties: external_exports.optional(external_exports.object({}).passthrough()),
      required: external_exports.optional(external_exports.array(external_exports.string()))
    }).passthrough(),
    /**
     * An optional JSON Schema object defining the structure of the tool's output returned in
     * the structuredContent field of a CallToolResult.
     */
    outputSchema: external_exports.optional(external_exports.object({
      type: external_exports.literal("object"),
      properties: external_exports.optional(external_exports.object({}).passthrough()),
      required: external_exports.optional(external_exports.array(external_exports.string()))
    }).passthrough()),
    /**
     * Optional additional tool information.
     */
    annotations: external_exports.optional(ToolAnnotationsSchema)
  }).passthrough();
  var ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: external_exports.literal("tools/list")
  });
  var ListToolsResultSchema2 = PaginatedResultSchema2.extend({
    tools: external_exports.array(ToolSchema2)
  });
  var CallToolResultSchema2 = ResultSchema2.extend({
    /**
     * A list of content objects that represent the result of the tool call.
     *
     * If the Tool does not define an outputSchema, this field MUST be present in the result.
     * For backwards compatibility, this field is always present, but it may be empty.
     */
    content: external_exports.array(external_exports.union([
      TextContentSchema2,
      ImageContentSchema2,
      AudioContentSchema,
      EmbeddedResourceSchema2
    ])).default([]),
    /**
     * An object containing structured tool output.
     *
     * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
     */
    structuredContent: external_exports.object({}).passthrough().optional(),
    /**
     * Whether the tool call ended in an error.
     *
     * If not set, this is assumed to be false (the call was successful).
     *
     * Any errors that originate from the tool SHOULD be reported inside the result
     * object, with `isError` set to true, _not_ as an MCP protocol-level error
     * response. Otherwise, the LLM would not be able to see that an error occurred
     * and self-correct.
     *
     * However, any errors in _finding_ the tool, an error indicating that the
     * server does not support tool calls, or any other exceptional conditions,
     * should be reported as an MCP error response.
     */
    isError: external_exports.optional(external_exports.boolean())
  });
  var CompatibilityCallToolResultSchema = CallToolResultSchema2.or(ResultSchema2.extend({
    toolResult: external_exports.unknown()
  }));
  var CallToolRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
      name: external_exports.string(),
      arguments: external_exports.optional(external_exports.record(external_exports.unknown()))
    })
  });
  var ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/tools/list_changed")
  });
  var LoggingLevelSchema = external_exports.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
  ]);
  var SetLevelRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
      /**
       * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
       */
      level: LoggingLevelSchema
    })
  });
  var LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
      /**
       * The severity of this log message.
       */
      level: LoggingLevelSchema,
      /**
       * An optional name of the logger issuing this message.
       */
      logger: external_exports.optional(external_exports.string()),
      /**
       * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
       */
      data: external_exports.unknown()
    })
  });
  var ModelHintSchema = external_exports.object({
    /**
     * A hint for a model name.
     */
    name: external_exports.string().optional()
  }).passthrough();
  var ModelPreferencesSchema = external_exports.object({
    /**
     * Optional hints to use for model selection.
     */
    hints: external_exports.optional(external_exports.array(ModelHintSchema)),
    /**
     * How much to prioritize cost when selecting a model.
     */
    costPriority: external_exports.optional(external_exports.number().min(0).max(1)),
    /**
     * How much to prioritize sampling speed (latency) when selecting a model.
     */
    speedPriority: external_exports.optional(external_exports.number().min(0).max(1)),
    /**
     * How much to prioritize intelligence and capabilities when selecting a model.
     */
    intelligencePriority: external_exports.optional(external_exports.number().min(0).max(1))
  }).passthrough();
  var SamplingMessageSchema = external_exports.object({
    role: external_exports.enum(["user", "assistant"]),
    content: external_exports.union([TextContentSchema2, ImageContentSchema2, AudioContentSchema])
  }).passthrough();
  var CreateMessageRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
      messages: external_exports.array(SamplingMessageSchema),
      /**
       * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
       */
      systemPrompt: external_exports.optional(external_exports.string()),
      /**
       * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
       */
      includeContext: external_exports.optional(external_exports.enum(["none", "thisServer", "allServers"])),
      temperature: external_exports.optional(external_exports.number()),
      /**
       * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
       */
      maxTokens: external_exports.number().int(),
      stopSequences: external_exports.optional(external_exports.array(external_exports.string())),
      /**
       * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
       */
      metadata: external_exports.optional(external_exports.object({}).passthrough()),
      /**
       * The server's preferences for which model to select.
       */
      modelPreferences: external_exports.optional(ModelPreferencesSchema)
    })
  });
  var CreateMessageResultSchema = ResultSchema2.extend({
    /**
     * The name of the model that generated the message.
     */
    model: external_exports.string(),
    /**
     * The reason why sampling stopped.
     */
    stopReason: external_exports.optional(external_exports.enum(["endTurn", "stopSequence", "maxTokens"]).or(external_exports.string())),
    role: external_exports.enum(["user", "assistant"]),
    content: external_exports.discriminatedUnion("type", [
      TextContentSchema2,
      ImageContentSchema2,
      AudioContentSchema
    ])
  });
  var ResourceReferenceSchema = external_exports.object({
    type: external_exports.literal("ref/resource"),
    /**
     * The URI or URI template of the resource.
     */
    uri: external_exports.string()
  }).passthrough();
  var PromptReferenceSchema = external_exports.object({
    type: external_exports.literal("ref/prompt"),
    /**
     * The name of the prompt or prompt template
     */
    name: external_exports.string()
  }).passthrough();
  var CompleteRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
      ref: external_exports.union([PromptReferenceSchema, ResourceReferenceSchema]),
      /**
       * The argument's information
       */
      argument: external_exports.object({
        /**
         * The name of the argument
         */
        name: external_exports.string(),
        /**
         * The value of the argument to use for completion matching.
         */
        value: external_exports.string()
      }).passthrough()
    })
  });
  var CompleteResultSchema = ResultSchema2.extend({
    completion: external_exports.object({
      /**
       * An array of completion values. Must not exceed 100 items.
       */
      values: external_exports.array(external_exports.string()).max(100),
      /**
       * The total number of completion options available. This can exceed the number of values actually sent in the response.
       */
      total: external_exports.optional(external_exports.number().int()),
      /**
       * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
       */
      hasMore: external_exports.optional(external_exports.boolean())
    }).passthrough()
  });
  var RootSchema = external_exports.object({
    /**
     * The URI identifying the root. This *must* start with file:// for now.
     */
    uri: external_exports.string().startsWith("file://"),
    /**
     * An optional name for the root.
     */
    name: external_exports.optional(external_exports.string())
  }).passthrough();
  var ListRootsRequestSchema = RequestSchema2.extend({
    method: external_exports.literal("roots/list")
  });
  var ListRootsResultSchema = ResultSchema2.extend({
    roots: external_exports.array(RootSchema)
  });
  var RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: external_exports.literal("notifications/roots/list_changed")
  });
  var ClientRequestSchema = external_exports.union([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema
  ]);
  var ClientNotificationSchema = external_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema
  ]);
  var ClientResultSchema = external_exports.union([
    EmptyResultSchema,
    CreateMessageResultSchema,
    ListRootsResultSchema
  ]);
  var ServerRequestSchema = external_exports.union([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ListRootsRequestSchema
  ]);
  var ServerNotificationSchema = external_exports.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema
  ]);
  var ServerResultSchema = external_exports.union([
    EmptyResultSchema,
    InitializeResultSchema2,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema2,
    ListToolsResultSchema2
  ]);
  var McpError = class extends Error {
    constructor(code4, message, data2) {
      super(`MCP error ${code4}: ${message}`);
      this.code = code4;
      this.data = data2;
      this.name = "McpError";
    }
  };

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
  var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
  var Protocol = class {
    constructor(_options) {
      this._options = _options;
      this._requestMessageId = 0;
      this._requestHandlers = /* @__PURE__ */ new Map();
      this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
      this._notificationHandlers = /* @__PURE__ */ new Map();
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers = /* @__PURE__ */ new Map();
      this._timeoutInfo = /* @__PURE__ */ new Map();
      this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
        const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
        controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
      });
      this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
        this._onprogress(notification);
      });
      this.setRequestHandler(
        PingRequestSchema,
        // Automatic pong by default.
        (_request) => ({})
      );
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
      this._timeoutInfo.set(messageId, {
        timeoutId: setTimeout(onTimeout, timeout),
        startTime: Date.now(),
        timeout,
        maxTotalTimeout,
        resetTimeoutOnProgress,
        onTimeout
      });
    }
    _resetTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (!info)
        return false;
      const totalElapsed = Date.now() - info.startTime;
      if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
        this._timeoutInfo.delete(messageId);
        throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });
      }
      clearTimeout(info.timeoutId);
      info.timeoutId = setTimeout(info.onTimeout, info.timeout);
      return true;
    }
    _cleanupTimeout(messageId) {
      const info = this._timeoutInfo.get(messageId);
      if (info) {
        clearTimeout(info.timeoutId);
        this._timeoutInfo.delete(messageId);
      }
    }
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    async connect(transport) {
      this._transport = transport;
      this._transport.onclose = () => {
        this._onclose();
      };
      this._transport.onerror = (error) => {
        this._onerror(error);
      };
      this._transport.onmessage = (message, extra) => {
        if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
          this._onresponse(message);
        } else if (isJSONRPCRequest(message)) {
          this._onrequest(message, extra);
        } else if (isJSONRPCNotification(message)) {
          this._onnotification(message);
        } else {
          this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
        }
      };
      await this._transport.start();
    }
    _onclose() {
      var _a17;
      const responseHandlers = this._responseHandlers;
      this._responseHandlers = /* @__PURE__ */ new Map();
      this._progressHandlers.clear();
      this._transport = void 0;
      (_a17 = this.onclose) === null || _a17 === void 0 ? void 0 : _a17.call(this);
      const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
      for (const handler of responseHandlers.values()) {
        handler(error);
      }
    }
    _onerror(error) {
      var _a17;
      (_a17 = this.onerror) === null || _a17 === void 0 ? void 0 : _a17.call(this, error);
    }
    _onnotification(notification) {
      var _a17;
      const handler = (_a17 = this._notificationHandlers.get(notification.method)) !== null && _a17 !== void 0 ? _a17 : this.fallbackNotificationHandler;
      if (handler === void 0) {
        return;
      }
      Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
      var _a17, _b, _c, _d;
      const handler = (_a17 = this._requestHandlers.get(request.method)) !== null && _a17 !== void 0 ? _a17 : this.fallbackRequestHandler;
      if (handler === void 0) {
        (_b = this._transport) === null || _b === void 0 ? void 0 : _b.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: ErrorCode.MethodNotFound,
            message: "Method not found"
          }
        }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
        return;
      }
      const abortController = new AbortController();
      this._requestHandlerAbortControllers.set(request.id, abortController);
      const fullExtra = {
        signal: abortController.signal,
        sessionId: (_c = this._transport) === null || _c === void 0 ? void 0 : _c.sessionId,
        _meta: (_d = request.params) === null || _d === void 0 ? void 0 : _d._meta,
        sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
        sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),
        authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
        requestId: request.id
      };
      Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
        var _a18;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a18 = this._transport) === null || _a18 === void 0 ? void 0 : _a18.send({
          result,
          jsonrpc: "2.0",
          id: request.id
        });
      }, (error) => {
        var _a18, _b2;
        if (abortController.signal.aborted) {
          return;
        }
        return (_a18 = this._transport) === null || _a18 === void 0 ? void 0 : _a18.send({
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
            message: (_b2 = error.message) !== null && _b2 !== void 0 ? _b2 : "Internal error"
          }
        });
      }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
        this._requestHandlerAbortControllers.delete(request.id);
      });
    }
    _onprogress(notification) {
      const { progressToken, ...params } = notification.params;
      const messageId = Number(progressToken);
      const handler = this._progressHandlers.get(messageId);
      if (!handler) {
        this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
        return;
      }
      const responseHandler = this._responseHandlers.get(messageId);
      const timeoutInfo = this._timeoutInfo.get(messageId);
      if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
        try {
          this._resetTimeout(messageId);
        } catch (error) {
          responseHandler(error);
          return;
        }
      }
      handler(params);
    }
    _onresponse(response) {
      const messageId = Number(response.id);
      const handler = this._responseHandlers.get(messageId);
      if (handler === void 0) {
        this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
        return;
      }
      this._responseHandlers.delete(messageId);
      this._progressHandlers.delete(messageId);
      this._cleanupTimeout(messageId);
      if (isJSONRPCResponse(response)) {
        handler(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        handler(error);
      }
    }
    get transport() {
      return this._transport;
    }
    /**
     * Closes the connection.
     */
    async close() {
      var _a17;
      await ((_a17 = this._transport) === null || _a17 === void 0 ? void 0 : _a17.close());
    }
    /**
     * Sends a request and wait for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */
    request(request, resultSchema, options) {
      const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
      return new Promise((resolve, reject) => {
        var _a17, _b, _c, _d, _e;
        if (!this._transport) {
          reject(new Error("Not connected"));
          return;
        }
        if (((_a17 = this._options) === null || _a17 === void 0 ? void 0 : _a17.enforceStrictCapabilities) === true) {
          this.assertCapabilityForMethod(request.method);
        }
        (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
        const messageId = this._requestMessageId++;
        const jsonrpcRequest = {
          ...request,
          jsonrpc: "2.0",
          id: messageId
        };
        if (options === null || options === void 0 ? void 0 : options.onprogress) {
          this._progressHandlers.set(messageId, options.onprogress);
          jsonrpcRequest.params = {
            ...request.params,
            _meta: { progressToken: messageId }
          };
        }
        const cancel = (reason) => {
          var _a18;
          this._responseHandlers.delete(messageId);
          this._progressHandlers.delete(messageId);
          this._cleanupTimeout(messageId);
          (_a18 = this._transport) === null || _a18 === void 0 ? void 0 : _a18.send({
            jsonrpc: "2.0",
            method: "notifications/cancelled",
            params: {
              requestId: messageId,
              reason: String(reason)
            }
          }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
          reject(reason);
        };
        this._responseHandlers.set(messageId, (response) => {
          var _a18;
          if ((_a18 = options === null || options === void 0 ? void 0 : options.signal) === null || _a18 === void 0 ? void 0 : _a18.aborted) {
            return;
          }
          if (response instanceof Error) {
            return reject(response);
          }
          try {
            const result = resultSchema.parse(response.result);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        });
        (_c = options === null || options === void 0 ? void 0 : options.signal) === null || _c === void 0 ? void 0 : _c.addEventListener("abort", () => {
          var _a18;
          cancel((_a18 = options === null || options === void 0 ? void 0 : options.signal) === null || _a18 === void 0 ? void 0 : _a18.reason);
        });
        const timeout = (_d = options === null || options === void 0 ? void 0 : options.timeout) !== null && _d !== void 0 ? _d : DEFAULT_REQUEST_TIMEOUT_MSEC;
        const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
        this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_e = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _e !== void 0 ? _e : false);
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      });
    }
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */
    async notification(notification, options) {
      if (!this._transport) {
        throw new Error("Not connected");
      }
      this.assertNotificationCapability(notification.method);
      const jsonrpcNotification = {
        ...notification,
        jsonrpc: "2.0"
      };
      await this._transport.send(jsonrpcNotification, options);
    }
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */
    setRequestHandler(requestSchema, handler) {
      const method = requestSchema.shape.method.value;
      this.assertRequestHandlerCapability(method);
      this._requestHandlers.set(method, (request, extra) => {
        return Promise.resolve(handler(requestSchema.parse(request), extra));
      });
    }
    /**
     * Removes the request handler for the given method.
     */
    removeRequestHandler(method) {
      this._requestHandlers.delete(method);
    }
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */
    assertCanSetRequestHandler(method) {
      if (this._requestHandlers.has(method)) {
        throw new Error(`A request handler for ${method} already exists, which would be overridden`);
      }
    }
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */
    setNotificationHandler(notificationSchema, handler) {
      this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    /**
     * Removes the notification handler for the given method.
     */
    removeNotificationHandler(method) {
      this._notificationHandlers.delete(method);
    }
  };
  function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value]) => {
      if (value && typeof value === "object") {
        acc[key] = acc[key] ? { ...acc[key], ...value } : value;
      } else {
        acc[key] = value;
      }
      return acc;
    }, { ...base });
  }

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
  var import_ajv = __toESM(require_ajv(), 1);
  var Client = class extends Protocol {
    /**
     * Initializes this client with the given name and version information.
     */
    constructor(_clientInfo, options) {
      var _a17;
      super(options);
      this._clientInfo = _clientInfo;
      this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
      this._capabilities = (_a17 = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a17 !== void 0 ? _a17 : {};
      this._ajv = new import_ajv.default();
    }
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    assertCapability(capability, method) {
      var _a17;
      if (!((_a17 = this._serverCapabilities) === null || _a17 === void 0 ? void 0 : _a17[capability])) {
        throw new Error(`Server does not support ${capability} (required for ${method})`);
      }
    }
    async connect(transport, options) {
      await super.connect(transport);
      if (transport.sessionId !== void 0) {
        return;
      }
      try {
        const result = await this.request({
          method: "initialize",
          params: {
            protocolVersion: LATEST_PROTOCOL_VERSION,
            capabilities: this._capabilities,
            clientInfo: this._clientInfo
          }
        }, InitializeResultSchema2, options);
        if (result === void 0) {
          throw new Error(`Server sent invalid initialize result: ${result}`);
        }
        if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
          throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
        }
        this._serverCapabilities = result.capabilities;
        this._serverVersion = result.serverInfo;
        this._instructions = result.instructions;
        await this.notification({
          method: "notifications/initialized"
        });
      } catch (error) {
        void this.close();
        throw error;
      }
    }
    /**
     * After initialization has completed, this will be populated with the server's reported capabilities.
     */
    getServerCapabilities() {
      return this._serverCapabilities;
    }
    /**
     * After initialization has completed, this will be populated with information about the server's name and version.
     */
    getServerVersion() {
      return this._serverVersion;
    }
    /**
     * After initialization has completed, this may be populated with information about the server's instructions.
     */
    getInstructions() {
      return this._instructions;
    }
    assertCapabilityForMethod(method) {
      var _a17, _b, _c, _d, _e;
      switch (method) {
        case "logging/setLevel":
          if (!((_a17 = this._serverCapabilities) === null || _a17 === void 0 ? void 0 : _a17.logging)) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
        case "resources/subscribe":
        case "resources/unsubscribe":
          if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
            throw new Error(`Server does not support resource subscriptions (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "completion/complete":
          if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) {
            throw new Error(`Server does not support completions (required for ${method})`);
          }
          break;
        case "initialize":
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      var _a17;
      switch (method) {
        case "notifications/roots/list_changed":
          if (!((_a17 = this._capabilities.roots) === null || _a17 === void 0 ? void 0 : _a17.listChanged)) {
            throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
          }
          break;
        case "notifications/initialized":
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      switch (method) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) {
            throw new Error(`Client does not support sampling capability (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!this._capabilities.roots) {
            throw new Error(`Client does not support roots capability (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    async ping(options) {
      return this.request({ method: "ping" }, EmptyResultSchema, options);
    }
    async complete(params, options) {
      return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
    }
    async setLoggingLevel(level, options) {
      return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
    }
    async getPrompt(params, options) {
      return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
    }
    async listPrompts(params, options) {
      return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
    }
    async listResources(params, options) {
      return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
    }
    async listResourceTemplates(params, options) {
      return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
    }
    async readResource(params, options) {
      return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
    }
    async subscribeResource(params, options) {
      return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
    }
    async unsubscribeResource(params, options) {
      return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
    }
    async callTool(params, resultSchema = CallToolResultSchema2, options) {
      const result = await this.request({ method: "tools/call", params }, resultSchema, options);
      const validator2 = this.getToolOutputValidator(params.name);
      if (validator2) {
        if (!result.structuredContent && !result.isError) {
          throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
        }
        if (result.structuredContent) {
          try {
            const isValid2 = validator2(result.structuredContent);
            if (!isValid2) {
              throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator2.errors)}`);
            }
          } catch (error) {
            if (error instanceof McpError) {
              throw error;
            }
            throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
      }
      return result;
    }
    cacheToolOutputSchemas(tools) {
      this._cachedToolOutputValidators.clear();
      for (const tool of tools) {
        if (tool.outputSchema) {
          try {
            const validator2 = this._ajv.compile(tool.outputSchema);
            this._cachedToolOutputValidators.set(tool.name, validator2);
          } catch (error) {
            console.warn(`Failed to compile output schema for tool ${tool.name}: ${error}`);
          }
        }
      }
    }
    getToolOutputValidator(toolName) {
      return this._cachedToolOutputValidators.get(toolName);
    }
    async listTools(params, options) {
      const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema2, options);
      this.cacheToolOutputSchemas(result.tools);
      return result;
    }
    async sendRootsListChanged() {
      return this.notification({ method: "notifications/roots/list_changed" });
    }
  };

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/pkce-challenge/dist/index.browser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var crypto2;
  crypto2 = globalThis.crypto;
  async function getRandomValues(size3) {
    return (await crypto2).getRandomValues(new Uint8Array(size3));
  }
  async function random(size3) {
    const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
    let result = "";
    const randomUints = await getRandomValues(size3);
    for (let i = 0; i < size3; i++) {
      const randomIndex = randomUints[i] % mask.length;
      result += mask[randomIndex];
    }
    return result;
  }
  async function generateVerifier(length2) {
    return await random(length2);
  }
  async function generateChallenge(code_verifier) {
    const buffer = await (await crypto2).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
    return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
  }
  async function pkceChallenge(length2) {
    if (!length2)
      length2 = 43;
    if (length2 < 43 || length2 > 128) {
      throw `Expected a length between 43 and 128. Received ${length2}.`;
    }
    const verifier = await generateVerifier(length2);
    const challenge = await generateChallenge(verifier);
    return {
      code_verifier: verifier,
      code_challenge: challenge
    };
  }

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var OAuthProtectedResourceMetadataSchema = external_exports.object({
    resource: external_exports.string().url(),
    authorization_servers: external_exports.array(external_exports.string().url()).optional(),
    jwks_uri: external_exports.string().url().optional(),
    scopes_supported: external_exports.array(external_exports.string()).optional(),
    bearer_methods_supported: external_exports.array(external_exports.string()).optional(),
    resource_signing_alg_values_supported: external_exports.array(external_exports.string()).optional(),
    resource_name: external_exports.string().optional(),
    resource_documentation: external_exports.string().optional(),
    resource_policy_uri: external_exports.string().url().optional(),
    resource_tos_uri: external_exports.string().url().optional(),
    tls_client_certificate_bound_access_tokens: external_exports.boolean().optional(),
    authorization_details_types_supported: external_exports.array(external_exports.string()).optional(),
    dpop_signing_alg_values_supported: external_exports.array(external_exports.string()).optional(),
    dpop_bound_access_tokens_required: external_exports.boolean().optional()
  }).passthrough();
  var OAuthMetadataSchema = external_exports.object({
    issuer: external_exports.string(),
    authorization_endpoint: external_exports.string(),
    token_endpoint: external_exports.string(),
    registration_endpoint: external_exports.string().optional(),
    scopes_supported: external_exports.array(external_exports.string()).optional(),
    response_types_supported: external_exports.array(external_exports.string()),
    response_modes_supported: external_exports.array(external_exports.string()).optional(),
    grant_types_supported: external_exports.array(external_exports.string()).optional(),
    token_endpoint_auth_methods_supported: external_exports.array(external_exports.string()).optional(),
    token_endpoint_auth_signing_alg_values_supported: external_exports.array(external_exports.string()).optional(),
    service_documentation: external_exports.string().optional(),
    revocation_endpoint: external_exports.string().optional(),
    revocation_endpoint_auth_methods_supported: external_exports.array(external_exports.string()).optional(),
    revocation_endpoint_auth_signing_alg_values_supported: external_exports.array(external_exports.string()).optional(),
    introspection_endpoint: external_exports.string().optional(),
    introspection_endpoint_auth_methods_supported: external_exports.array(external_exports.string()).optional(),
    introspection_endpoint_auth_signing_alg_values_supported: external_exports.array(external_exports.string()).optional(),
    code_challenge_methods_supported: external_exports.array(external_exports.string()).optional()
  }).passthrough();
  var OAuthTokensSchema = external_exports.object({
    access_token: external_exports.string(),
    token_type: external_exports.string(),
    expires_in: external_exports.number().optional(),
    scope: external_exports.string().optional(),
    refresh_token: external_exports.string().optional()
  }).strip();
  var OAuthErrorResponseSchema = external_exports.object({
    error: external_exports.string(),
    error_description: external_exports.string().optional(),
    error_uri: external_exports.string().optional()
  });
  var OAuthClientMetadataSchema = external_exports.object({
    redirect_uris: external_exports.array(external_exports.string()).refine((uris) => uris.every((uri) => URL.canParse(uri)), { message: "redirect_uris must contain valid URLs" }),
    token_endpoint_auth_method: external_exports.string().optional(),
    grant_types: external_exports.array(external_exports.string()).optional(),
    response_types: external_exports.array(external_exports.string()).optional(),
    client_name: external_exports.string().optional(),
    client_uri: external_exports.string().optional(),
    logo_uri: external_exports.string().optional(),
    scope: external_exports.string().optional(),
    contacts: external_exports.array(external_exports.string()).optional(),
    tos_uri: external_exports.string().optional(),
    policy_uri: external_exports.string().optional(),
    jwks_uri: external_exports.string().optional(),
    jwks: external_exports.any().optional(),
    software_id: external_exports.string().optional(),
    software_version: external_exports.string().optional()
  }).strip();
  var OAuthClientInformationSchema = external_exports.object({
    client_id: external_exports.string(),
    client_secret: external_exports.string().optional(),
    client_id_issued_at: external_exports.number().optional(),
    client_secret_expires_at: external_exports.number().optional()
  }).strip();
  var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
  var OAuthClientRegistrationErrorSchema = external_exports.object({
    error: external_exports.string(),
    error_description: external_exports.string().optional()
  }).strip();
  var OAuthTokenRevocationRequestSchema = external_exports.object({
    token: external_exports.string(),
    token_type_hint: external_exports.string().optional()
  }).strip();

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
  var UnauthorizedError = class extends Error {
    constructor(message) {
      super(message !== null && message !== void 0 ? message : "Unauthorized");
    }
  };
  async function auth(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl }) {
    let authorizationServerUrl = serverUrl;
    try {
      const resourceMetadata = await discoverOAuthProtectedResourceMetadata(resourceMetadataUrl || serverUrl);
      if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
        authorizationServerUrl = resourceMetadata.authorization_servers[0];
      }
    } catch (error) {
      console.warn("Could not load OAuth Protected Resource metadata, falling back to /.well-known/oauth-authorization-server", error);
    }
    const metadata = await discoverOAuthMetadata(authorizationServerUrl);
    let clientInformation = await Promise.resolve(provider.clientInformation());
    if (!clientInformation) {
      if (authorizationCode !== void 0) {
        throw new Error("Existing OAuth client information is required when exchanging an authorization code");
      }
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata,
        clientMetadata: provider.clientMetadata
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
    if (authorizationCode !== void 0) {
      const codeVerifier2 = await provider.codeVerifier();
      const tokens3 = await exchangeAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        authorizationCode,
        codeVerifier: codeVerifier2,
        redirectUri: provider.redirectUrl
      });
      await provider.saveTokens(tokens3);
      return "AUTHORIZED";
    }
    const tokens2 = await provider.tokens();
    if (tokens2 === null || tokens2 === void 0 ? void 0 : tokens2.refresh_token) {
      try {
        const newTokens = await refreshAuthorization(authorizationServerUrl, {
          metadata,
          clientInformation,
          refreshToken: tokens2.refresh_token
        });
        await provider.saveTokens(newTokens);
        return "AUTHORIZED";
      } catch (error) {
        console.error("Could not refresh OAuth tokens:", error);
      }
    }
    const state = provider.state ? await provider.state() : void 0;
    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
      metadata,
      clientInformation,
      state,
      redirectUrl: provider.redirectUrl,
      scope: scope || provider.clientMetadata.scope
    });
    await provider.saveCodeVerifier(codeVerifier);
    await provider.redirectToAuthorization(authorizationUrl);
    return "REDIRECT";
  }
  function extractResourceMetadataUrl(res) {
    const authenticateHeader = res.headers.get("WWW-Authenticate");
    if (!authenticateHeader) {
      return void 0;
    }
    const [type, scheme] = authenticateHeader.split(" ");
    if (type.toLowerCase() !== "bearer" || !scheme) {
      console.log("Invalid WWW-Authenticate header format, expected 'Bearer'");
      return void 0;
    }
    const regex2 = /resource_metadata="([^"]*)"/;
    const match2 = regex2.exec(authenticateHeader);
    if (!match2) {
      return void 0;
    }
    try {
      return new URL(match2[1]);
    } catch (_a17) {
      console.log("Invalid resource metadata url: ", match2[1]);
      return void 0;
    }
  }
  async function discoverOAuthProtectedResourceMetadata(serverUrl, opts) {
    var _a17;
    let url;
    if (opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl) {
      url = new URL(opts === null || opts === void 0 ? void 0 : opts.resourceMetadataUrl);
    } else {
      url = new URL("/.well-known/oauth-protected-resource", serverUrl);
    }
    let response;
    try {
      response = await fetch(url, {
        headers: {
          "MCP-Protocol-Version": (_a17 = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a17 !== void 0 ? _a17 : LATEST_PROTOCOL_VERSION
        }
      });
    } catch (error) {
      if (error instanceof TypeError) {
        response = await fetch(url);
      } else {
        throw error;
      }
    }
    if (response.status === 404) {
      throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
    }
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
    }
    return OAuthProtectedResourceMetadataSchema.parse(await response.json());
  }
  async function discoverOAuthMetadata(authorizationServerUrl, opts) {
    var _a17;
    const url = new URL("/.well-known/oauth-authorization-server", authorizationServerUrl);
    let response;
    try {
      response = await fetch(url, {
        headers: {
          "MCP-Protocol-Version": (_a17 = opts === null || opts === void 0 ? void 0 : opts.protocolVersion) !== null && _a17 !== void 0 ? _a17 : LATEST_PROTOCOL_VERSION
        }
      });
    } catch (error) {
      if (error instanceof TypeError) {
        response = await fetch(url);
      } else {
        throw error;
      }
    }
    if (response.status === 404) {
      return void 0;
    }
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);
    }
    return OAuthMetadataSchema.parse(await response.json());
  }
  async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state }) {
    const responseType = "code";
    const codeChallengeMethod = "S256";
    let authorizationUrl;
    if (metadata) {
      authorizationUrl = new URL(metadata.authorization_endpoint);
      if (!metadata.response_types_supported.includes(responseType)) {
        throw new Error(`Incompatible auth server: does not support response type ${responseType}`);
      }
      if (!metadata.code_challenge_methods_supported || !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)) {
        throw new Error(`Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`);
      }
    } else {
      authorizationUrl = new URL("/authorize", authorizationServerUrl);
    }
    const challenge = await pkceChallenge();
    const codeVerifier = challenge.code_verifier;
    const codeChallenge = challenge.code_challenge;
    authorizationUrl.searchParams.set("response_type", responseType);
    authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
    authorizationUrl.searchParams.set("code_challenge", codeChallenge);
    authorizationUrl.searchParams.set("code_challenge_method", codeChallengeMethod);
    authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
    if (state) {
      authorizationUrl.searchParams.set("state", state);
    }
    if (scope) {
      authorizationUrl.searchParams.set("scope", scope);
    }
    return { authorizationUrl, codeVerifier };
  }
  async function exchangeAuthorization(authorizationServerUrl, { metadata, clientInformation, authorizationCode, codeVerifier, redirectUri }) {
    const grantType = "authorization_code";
    let tokenUrl;
    if (metadata) {
      tokenUrl = new URL(metadata.token_endpoint);
      if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
      }
    } else {
      tokenUrl = new URL("/token", authorizationServerUrl);
    }
    const params = new URLSearchParams({
      grant_type: grantType,
      client_id: clientInformation.client_id,
      code: authorizationCode,
      code_verifier: codeVerifier,
      redirect_uri: String(redirectUri)
    });
    if (clientInformation.client_secret) {
      params.set("client_secret", clientInformation.client_secret);
    }
    const response = await fetch(tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params
    });
    if (!response.ok) {
      throw new Error(`Token exchange failed: HTTP ${response.status}`);
    }
    return OAuthTokensSchema.parse(await response.json());
  }
  async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken }) {
    const grantType = "refresh_token";
    let tokenUrl;
    if (metadata) {
      tokenUrl = new URL(metadata.token_endpoint);
      if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {
        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);
      }
    } else {
      tokenUrl = new URL("/token", authorizationServerUrl);
    }
    const params = new URLSearchParams({
      grant_type: grantType,
      client_id: clientInformation.client_id,
      refresh_token: refreshToken
    });
    if (clientInformation.client_secret) {
      params.set("client_secret", clientInformation.client_secret);
    }
    const response = await fetch(tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params
    });
    if (!response.ok) {
      throw new Error(`Token refresh failed: HTTP ${response.status}`);
    }
    return OAuthTokensSchema.parse({ refresh_token: refreshToken, ...await response.json() });
  }
  async function registerClient(authorizationServerUrl, { metadata, clientMetadata }) {
    let registrationUrl;
    if (metadata) {
      if (!metadata.registration_endpoint) {
        throw new Error("Incompatible auth server: does not support dynamic client registration");
      }
      registrationUrl = new URL(metadata.registration_endpoint);
    } else {
      registrationUrl = new URL("/register", authorizationServerUrl);
    }
    const response = await fetch(registrationUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(clientMetadata)
    });
    if (!response.ok) {
      throw new Error(`Dynamic client registration failed: HTTP ${response.status}`);
    }
    return OAuthClientInformationFullSchema.parse(await response.json());
  }

  // ../../node_modules/eventsource-parser/dist/stream.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/eventsource-parser/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ParseError = class extends Error {
    constructor(message, options) {
      super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
  };
  function noop(_arg) {
  }
  function createParser(callbacks) {
    if (typeof callbacks == "function")
      throw new TypeError(
        "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
      );
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data2 = "", eventType = "";
    function feed(newChunk) {
      const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
      for (const line2 of complete)
        parseLine(line2);
      incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line2) {
      if (line2 === "") {
        dispatchEvent();
        return;
      }
      if (line2.startsWith(":")) {
        onComment && onComment(line2.slice(line2.startsWith(": ") ? 2 : 1));
        return;
      }
      const fieldSeparatorIndex = line2.indexOf(":");
      if (fieldSeparatorIndex !== -1) {
        const field = line2.slice(0, fieldSeparatorIndex), offset4 = line2[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line2.slice(fieldSeparatorIndex + offset4);
        processField(field, value, line2);
        return;
      }
      processField(line2, "", line2);
    }
    function processField(field, value, line2) {
      switch (field) {
        case "event":
          eventType = value;
          break;
        case "data":
          data2 = `${data2}${value}
`;
          break;
        case "id":
          id = value.includes("\0") ? void 0 : value;
          break;
        case "retry":
          /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
            new ParseError(`Invalid \`retry\` value: "${value}"`, {
              type: "invalid-retry",
              value,
              line: line2
            })
          );
          break;
        default:
          onError(
            new ParseError(
              `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
              { type: "unknown-field", field, value, line: line2 }
            )
          );
          break;
      }
    }
    function dispatchEvent() {
      data2.length > 0 && onEvent({
        id,
        event: eventType || void 0,
        // If the data buffer's last character is a U+000A LINE FEED (LF) character,
        // then remove the last character from the data buffer.
        data: data2.endsWith(`
`) ? data2.slice(0, -1) : data2
      }), id = void 0, data2 = "", eventType = "";
    }
    function reset(options = {}) {
      incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data2 = "", eventType = "", incompleteLine = "";
    }
    return { feed, reset };
  }
  function splitLines2(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for (; searchIndex < chunk.length; ) {
      const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
      let lineEnd = -1;
      if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
        incompleteLine = chunk.slice(searchIndex);
        break;
      } else {
        const line2 = chunk.slice(searchIndex, lineEnd);
        lines.push(line2), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
      }
    }
    return [lines, incompleteLine];
  }

  // ../../node_modules/eventsource-parser/dist/stream.js
  var EventSourceParserStream = class extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}) {
      let parser;
      super({
        start(controller) {
          parser = createParser({
            onEvent: (event) => {
              controller.enqueue(event);
            },
            onError(error) {
              onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
            },
            onRetry,
            onComment
          });
        },
        transform(chunk) {
          parser.feed(chunk);
        }
      });
    }
  };

  // ../../node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
  var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
    initialReconnectionDelay: 1e3,
    maxReconnectionDelay: 3e4,
    reconnectionDelayGrowFactor: 1.5,
    maxRetries: 2
  };
  var StreamableHTTPError = class extends Error {
    constructor(code4, message) {
      super(`Streamable HTTP error: ${message}`);
      this.code = code4;
    }
  };
  var StreamableHTTPClientTransport = class {
    constructor(url, opts) {
      var _a17;
      this._url = url;
      this._resourceMetadataUrl = void 0;
      this._requestInit = opts === null || opts === void 0 ? void 0 : opts.requestInit;
      this._authProvider = opts === null || opts === void 0 ? void 0 : opts.authProvider;
      this._sessionId = opts === null || opts === void 0 ? void 0 : opts.sessionId;
      this._reconnectionOptions = (_a17 = opts === null || opts === void 0 ? void 0 : opts.reconnectionOptions) !== null && _a17 !== void 0 ? _a17 : DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
    }
    async _authThenStart() {
      var _a17;
      if (!this._authProvider) {
        throw new UnauthorizedError("No auth provider");
      }
      let result;
      try {
        result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl });
      } catch (error) {
        (_a17 = this.onerror) === null || _a17 === void 0 ? void 0 : _a17.call(this, error);
        throw error;
      }
      if (result !== "AUTHORIZED") {
        throw new UnauthorizedError();
      }
      return await this._startOrAuthSse({ resumptionToken: void 0 });
    }
    async _commonHeaders() {
      var _a17;
      const headers = {};
      if (this._authProvider) {
        const tokens2 = await this._authProvider.tokens();
        if (tokens2) {
          headers["Authorization"] = `Bearer ${tokens2.access_token}`;
        }
      }
      if (this._sessionId) {
        headers["mcp-session-id"] = this._sessionId;
      }
      return new Headers({ ...headers, ...(_a17 = this._requestInit) === null || _a17 === void 0 ? void 0 : _a17.headers });
    }
    async _startOrAuthSse(options) {
      var _a17, _b;
      const { resumptionToken } = options;
      try {
        const headers = await this._commonHeaders();
        headers.set("Accept", "text/event-stream");
        if (resumptionToken) {
          headers.set("last-event-id", resumptionToken);
        }
        const response = await fetch(this._url, {
          method: "GET",
          headers,
          signal: (_a17 = this._abortController) === null || _a17 === void 0 ? void 0 : _a17.signal
        });
        if (!response.ok) {
          if (response.status === 401 && this._authProvider) {
            return await this._authThenStart();
          }
          if (response.status === 405) {
            return;
          }
          throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
        }
        this._handleSseStream(response.body, options);
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
        throw error;
      }
    }
    /**
     * Calculates the next reconnection delay using  backoff algorithm
     *
     * @param attempt Current reconnection attempt count for the specific stream
     * @returns Time to wait in milliseconds before next reconnection attempt
     */
    _getNextReconnectionDelay(attempt) {
      const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
      const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
      const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
      return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
    }
    /**
     * Schedule a reconnection attempt with exponential backoff
     *
     * @param lastEventId The ID of the last received event for resumability
     * @param attemptCount Current reconnection attempt count for this specific stream
     */
    _scheduleReconnection(options, attemptCount = 0) {
      var _a17;
      const maxRetries = this._reconnectionOptions.maxRetries;
      if (maxRetries > 0 && attemptCount >= maxRetries) {
        (_a17 = this.onerror) === null || _a17 === void 0 ? void 0 : _a17.call(this, new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
        return;
      }
      const delay2 = this._getNextReconnectionDelay(attemptCount);
      setTimeout(() => {
        this._startOrAuthSse(options).catch((error) => {
          var _a18;
          (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
          this._scheduleReconnection(options, attemptCount + 1);
        });
      }, delay2);
    }
    _handleSseStream(stream, options) {
      if (!stream) {
        return;
      }
      const { onresumptiontoken, replayMessageId } = options;
      let lastEventId;
      const processStream = async () => {
        var _a17, _b, _c, _d;
        try {
          const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).getReader();
          while (true) {
            const { value: event, done } = await reader.read();
            if (done) {
              break;
            }
            if (event.id) {
              lastEventId = event.id;
              onresumptiontoken === null || onresumptiontoken === void 0 ? void 0 : onresumptiontoken(event.id);
            }
            if (!event.event || event.event === "message") {
              try {
                const message = JSONRPCMessageSchema2.parse(JSON.parse(event.data));
                if (replayMessageId !== void 0 && isJSONRPCResponse(message)) {
                  message.id = replayMessageId;
                }
                (_a17 = this.onmessage) === null || _a17 === void 0 ? void 0 : _a17.call(this, message);
              } catch (error) {
                (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
              }
            }
          }
        } catch (error) {
          (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, new Error(`SSE stream disconnected: ${error}`));
          if (this._abortController && !this._abortController.signal.aborted) {
            if (lastEventId !== void 0) {
              try {
                this._scheduleReconnection({
                  resumptionToken: lastEventId,
                  onresumptiontoken,
                  replayMessageId
                }, 0);
              } catch (error2) {
                (_d = this.onerror) === null || _d === void 0 ? void 0 : _d.call(this, new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
              }
            }
          }
        }
      };
      processStream();
    }
    async start() {
      if (this._abortController) {
        throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
      }
      this._abortController = new AbortController();
    }
    /**
     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
     */
    async finishAuth(authorizationCode) {
      if (!this._authProvider) {
        throw new UnauthorizedError("No auth provider");
      }
      const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode, resourceMetadataUrl: this._resourceMetadataUrl });
      if (result !== "AUTHORIZED") {
        throw new UnauthorizedError("Failed to authorize");
      }
    }
    async close() {
      var _a17, _b;
      (_a17 = this._abortController) === null || _a17 === void 0 ? void 0 : _a17.abort();
      (_b = this.onclose) === null || _b === void 0 ? void 0 : _b.call(this);
    }
    async send(message, options) {
      var _a17, _b, _c;
      try {
        const { resumptionToken, onresumptiontoken } = options || {};
        if (resumptionToken) {
          this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => {
            var _a18;
            return (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, err);
          });
          return;
        }
        const headers = await this._commonHeaders();
        headers.set("content-type", "application/json");
        headers.set("accept", "application/json, text/event-stream");
        const init = {
          ...this._requestInit,
          method: "POST",
          headers,
          body: JSON.stringify(message),
          signal: (_a17 = this._abortController) === null || _a17 === void 0 ? void 0 : _a17.signal
        };
        const response = await fetch(this._url, init);
        const sessionId = response.headers.get("mcp-session-id");
        if (sessionId) {
          this._sessionId = sessionId;
        }
        if (!response.ok) {
          if (response.status === 401 && this._authProvider) {
            this._resourceMetadataUrl = extractResourceMetadataUrl(response);
            const result = await auth(this._authProvider, { serverUrl: this._url, resourceMetadataUrl: this._resourceMetadataUrl });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
          const text9 = await response.text().catch(() => null);
          throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text9}`);
        }
        if (response.status === 202) {
          if (isInitializedNotification(message)) {
            this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => {
              var _a18;
              return (_a18 = this.onerror) === null || _a18 === void 0 ? void 0 : _a18.call(this, err);
            });
          }
          return;
        }
        const messages = Array.isArray(message) ? message : [message];
        const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
        const contentType = response.headers.get("content-type");
        if (hasRequests) {
          if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/event-stream")) {
            this._handleSseStream(response.body, { onresumptiontoken });
          } else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("application/json")) {
            const data2 = await response.json();
            const responseMessages = Array.isArray(data2) ? data2.map((msg) => JSONRPCMessageSchema2.parse(msg)) : [JSONRPCMessageSchema2.parse(data2)];
            for (const msg of responseMessages) {
              (_b = this.onmessage) === null || _b === void 0 ? void 0 : _b.call(this, msg);
            }
          } else {
            throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
          }
        }
      } catch (error) {
        (_c = this.onerror) === null || _c === void 0 ? void 0 : _c.call(this, error);
        throw error;
      }
    }
    get sessionId() {
      return this._sessionId;
    }
    /**
     * Terminates the current session by sending a DELETE request to the server.
     *
     * Clients that no longer need a particular session
     * (e.g., because the user is leaving the client application) SHOULD send an
     * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
     * terminate the session.
     *
     * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
     * the server does not allow clients to terminate sessions.
     */
    async terminateSession() {
      var _a17, _b;
      if (!this._sessionId) {
        return;
      }
      try {
        const headers = await this._commonHeaders();
        const init = {
          ...this._requestInit,
          method: "DELETE",
          headers,
          signal: (_a17 = this._abortController) === null || _a17 === void 0 ? void 0 : _a17.signal
        };
        const response = await fetch(this._url, init);
        if (!response.ok && response.status !== 405) {
          throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
        }
        this._sessionId = void 0;
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
        throw error;
      }
    }
  };

  // ../../packages/aihappey-auth/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-auth/dist/OAuthCallbackPage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var import_react9 = __toESM(require_react());

  // ../../packages/aihappey-auth/dist/mcp/oauthClient.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var OAUTH_TARGET_URL_KEY = "mcp_oauth_target_url";
  var OAUTH_FLOW_DETAILS_KEY = "mcp_oauth_flow_details";
  var OAUTH_CODE_VERIFIER_KEY = "mcp_oauth_code_verifier";
  var OAUTH_STATE_KEY = "mcp_oauth_state";
  var ACCESS_TOKEN_STORAGE_PREFIX = "mcp_access_token_";
  var createPkceChallenge = async () => {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    const code_verifier = btoa(String.fromCharCode(...array)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    const encoder = new TextEncoder();
    const data2 = encoder.encode(code_verifier);
    const digest = await crypto.subtle.digest("SHA-256", data2);
    const code_challenge = btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    return { code_verifier, code_challenge };
  };
  var initiateOAuthFlow = async (mcpServerUrl, storage, clientName = "MCP Happey Web Client") => {
    storage.set(OAUTH_TARGET_URL_KEY, mcpServerUrl);
    const parsedMcpUrl = new URL(mcpServerUrl);
    const mcpOrigin = parsedMcpUrl.origin;
    let mcpPath = parsedMcpUrl.pathname;
    if (mcpPath.startsWith("/"))
      mcpPath = mcpPath.substring(1);
    const fullPathForWellKnown = mcpPath && mcpPath !== "/" ? `/${mcpPath}` : "";
    const protectedResourceUrl = `${mcpOrigin}/.well-known/oauth-protected-resource${fullPathForWellKnown}`;
    const prResponse = await fetch(protectedResourceUrl);
    if (!prResponse.ok)
      throw new Error("Failed to fetch protected resource metadata");
    const prMetadata = await prResponse.json();
    if (!prMetadata.authorization_servers?.length)
      throw new Error("No authorization_servers found in protected resource metadata.");
    const authServerMetadataUrl = prMetadata.authorization_servers[0];
    const asResponse = await fetch(authServerMetadataUrl);
    if (!asResponse.ok)
      throw new Error("Failed to fetch authorization server metadata");
    const asMetadata = await asResponse.json();
    if (!asMetadata.authorization_endpoint || !asMetadata.token_endpoint || !asMetadata.registration_endpoint)
      throw new Error("Incomplete authorization server metadata (missing endpoint(s)).");
    const redirectUri = `${window.location.origin}/oauth-callback`;
    const clientRegPayload = {
      client_name: clientName,
      redirect_uris: [redirectUri],
      grant_types: ["authorization_code"],
      response_types: ["code"],
      token_endpoint_auth_method: "none",
      scope: prMetadata.scopes_supported?.join(" ")
    };
    const regResponse = await fetch(asMetadata.registration_endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(clientRegPayload)
    });
    if (!regResponse.ok)
      throw new Error("Dynamic client registration failed");
    const clientInfo = await regResponse.json();
    const clientId = clientInfo.client_id;
    const flowDetails = {
      clientId,
      tokenEndpoint: asMetadata.token_endpoint,
      redirectUri,
      authServerMetadataUrl
    };
    storage.set(OAUTH_FLOW_DETAILS_KEY, JSON.stringify(flowDetails));
    const { code_verifier, code_challenge } = await createPkceChallenge();
    const state = crypto.randomUUID();
    storage.set(OAUTH_CODE_VERIFIER_KEY, code_verifier);
    storage.set(OAUTH_STATE_KEY, state);
    const authUrl = new URL(asMetadata.authorization_endpoint);
    authUrl.searchParams.set("client_id", clientId);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("redirect_uri", redirectUri);
    authUrl.searchParams.set("code_challenge", code_challenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    authUrl.searchParams.set("state", state);
    if (clientRegPayload.scope)
      authUrl.searchParams.set("scope", clientRegPayload.scope);
    return authUrl.toString();
  };
  var handleOAuthCallback = async (storage) => {
    const params = new URLSearchParams(window.location.search);
    const code4 = params.get("code");
    const receivedState = params.get("state");
    const error = params.get("error");
    const errorDescription = params.get("error_description");
    const storedState = storage.get(OAUTH_STATE_KEY);
    const codeVerifier = storage.get(OAUTH_CODE_VERIFIER_KEY);
    const flowDetailsRaw = storage.get(OAUTH_FLOW_DETAILS_KEY);
    const targetUrl = storage.get(OAUTH_TARGET_URL_KEY) || void 0;
    storage.del(OAUTH_STATE_KEY);
    storage.del(OAUTH_CODE_VERIFIER_KEY);
    storage.del(OAUTH_FLOW_DETAILS_KEY);
    if (error)
      return { error, errorDescription: errorDescription || "Unknown OAuth error occurred." };
    if (!code4)
      return { error: "missing_code", errorDescription: "Authorization code is missing from callback." };
    if (!storedState)
      return { error: "missing_stored_state", errorDescription: "Stored OAuth state is missing." };
    if (receivedState !== storedState)
      return { error: "state_mismatch", errorDescription: "OAuth state mismatch. Possible CSRF attack." };
    if (!codeVerifier)
      return { error: "missing_verifier", errorDescription: "PKCE code verifier is missing." };
    if (!flowDetailsRaw)
      return { error: "missing_flow_details", errorDescription: "OAuth flow details missing." };
    try {
      const flowDetails = JSON.parse(flowDetailsRaw);
      const tokenPayload = new URLSearchParams();
      tokenPayload.set("grant_type", "authorization_code");
      tokenPayload.set("client_id", flowDetails.clientId);
      tokenPayload.set("code", code4);
      tokenPayload.set("redirect_uri", flowDetails.redirectUri);
      tokenPayload.set("code_verifier", codeVerifier);
      const tokenResponse = await fetch(flowDetails.tokenEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: tokenPayload.toString()
      });
      if (!tokenResponse.ok) {
        const errorBody = await tokenResponse.json().catch(() => ({
          error: "token_exchange_failed",
          error_description: "Failed to parse error from token endpoint."
        }));
        return {
          error: errorBody.error || "token_exchange_failed",
          errorDescription: errorBody.error_description || `Token exchange failed with status ${tokenResponse.status}`
        };
      }
      const tokens2 = await tokenResponse.json();
      if (!tokens2.access_token) {
        return { error: "missing_access_token", errorDescription: "Access token not found in token response." };
      }
      return { accessToken: tokens2.access_token, targetUrl };
    } catch (err) {
      return {
        error: "callback_processing_error",
        errorDescription: err instanceof Error ? err.message : "Unexpected error during callback processing."
      };
    }
  };
  var saveAccessToken = (serverUrl, token2, storage) => {
    storage.set(`${ACCESS_TOKEN_STORAGE_PREFIX}${serverUrl}`, token2);
  };
  var getAccessToken = (serverUrl, storage) => {
    return storage.get(`${ACCESS_TOKEN_STORAGE_PREFIX}${serverUrl}`);
  };

  // ../../packages/aihappey-auth/dist/mcp/helpers.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-auth/dist/storage/defaultStorage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var localStorageAuth = {
    get: (key) => {
      try {
        return typeof window !== "undefined" ? localStorage.getItem(key) : null;
      } catch {
        return null;
      }
    },
    set: (key, value) => {
      try {
        if (typeof window !== "undefined")
          localStorage.setItem(key, value);
      } catch {
      }
    },
    del: (key) => {
      try {
        if (typeof window !== "undefined")
          localStorage.removeItem(key);
      } catch {
      }
    }
  };

  // ../../packages/aihappey-auth/dist/mcp/helpers.js
  function getMcpAccessToken(url, storage = localStorageAuth) {
    return getAccessToken(url, storage);
  }
  function setMcpAccessToken(url, token2, storage = localStorageAuth) {
    saveAccessToken(url, token2, storage);
  }
  async function initiateMcpOAuthFlow(url, opts, storage = localStorageAuth) {
    const authUrl = await initiateOAuthFlow(url, storage);
    if (opts?.navigate !== false) {
      window.location.assign(authUrl);
    }
    return authUrl;
  }

  // ../../packages/aihappey-auth/dist/OAuthCallbackPage.js
  var OAUTH_TARGET_URL_KEY2 = "mcp_oauth_target_url";
  var OAuthCallbackPage = () => {
    const [status, setStatus] = (0, import_react9.useState)("pending");
    const [message, setMessage] = (0, import_react9.useState)("Processing authentication callback...");
    const navigate = useNavigate();
    const setToken = useAppStore((s) => s.setToken);
    (0, import_react9.useEffect)(() => {
      const processCallback = async () => {
        const result = await handleOAuthCallback(localStorageAuth);
        if ("error" in result) {
          setStatus("error");
          setMessage(`OAuth Error: ${result.error} - ${result.errorDescription || "Please try again."}`);
          localStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          return;
        }
        if (result.accessToken && result.targetUrl) {
          setMcpAccessToken(result.targetUrl, result.accessToken, localStorageAuth);
          setToken(result.targetUrl, result.accessToken);
          setStatus("success");
          setMessage("Authentication successful! Redirecting...");
          sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          setTimeout(() => {
            navigate("/");
          }, 1500);
        } else {
          setStatus("error");
          setMessage("OAuth Error: Could not retrieve access token or target URL after callback.");
          if (localStorage.getItem(OAUTH_TARGET_URL_KEY2) || sessionStorage.getItem(OAUTH_TARGET_URL_KEY2)) {
            localStorage.removeItem(OAUTH_TARGET_URL_KEY2);
            sessionStorage.removeItem(OAUTH_TARGET_URL_KEY2);
          }
          setTimeout(() => {
            navigate("/");
          }, 2e3);
        }
      };
      processCallback();
    }, [navigate, setToken]);
    return (0, import_jsx_runtime2.jsxs)("div", { style: { padding: 20, textAlign: "center", fontFamily: "sans-serif" }, children: [(0, import_jsx_runtime2.jsx)("h2", { children: "OAuth Authentication Callback" }), (0, import_jsx_runtime2.jsx)("p", { children: message }), status === "pending" && (0, import_jsx_runtime2.jsx)("p", { children: "Please wait..." }), status === "success" && (0, import_jsx_runtime2.jsxs)("p", { children: ["If you are not redirected automatically, please", " ", (0, import_jsx_runtime2.jsx)("a", { href: "/", children: "click here to return to the application" }), "."] }), status === "error" && (0, import_jsx_runtime2.jsxs)("p", { children: ["Please ", (0, import_jsx_runtime2.jsx)("a", { href: "/", children: "return to the application" }), " and try again."] })] });
  };
  var OAuthCallbackPage_default = OAuthCallbackPage;

  // ../../packages/aihappey-auth/dist/initAuth.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-auth/dist/msal/provider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());

  // ../../node_modules/@azure/msal-react/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-react/dist/MsalContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React14 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-browser/dist/index.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/utils/BrowserUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/index-browser.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/client/BaseClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/AuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/utils/Constants.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Constants = {
    LIBRARY_NAME: "MSAL.JS",
    SKU: "msal.js.common",
    // Prefix for all library cache entries
    CACHE_PREFIX: "msal",
    // default authority
    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
    DEFAULT_COMMON_TENANT: "common",
    // ADFS String
    ADFS: "adfs",
    DSTS: "dstsv2",
    // Default AAD Instance Discovery Endpoint
    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
    // CIAM URL
    CIAM_AUTH_URL: ".ciamlogin.com",
    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
    // Resource delimiter - used for certain cache entries
    RESOURCE_DELIM: "|",
    // Placeholder for non-existent account ids/objects
    NO_ACCOUNT: "NO_ACCOUNT",
    // Claims
    CLAIMS: "claims",
    // Consumer UTID
    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
    // Default scopes
    OPENID_SCOPE: "openid",
    PROFILE_SCOPE: "profile",
    OFFLINE_ACCESS_SCOPE: "offline_access",
    EMAIL_SCOPE: "email",
    CODE_GRANT_TYPE: "authorization_code",
    RT_GRANT_TYPE: "refresh_token",
    S256_CODE_CHALLENGE_METHOD: "S256",
    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
    AUTHORIZATION_PENDING: "authorization_pending",
    NOT_DEFINED: "not_defined",
    EMPTY_STRING: "",
    NOT_APPLICABLE: "N/A",
    NOT_AVAILABLE: "Not Available",
    FORWARD_SLASH: "/",
    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
    IMDS_VERSION: "2020-06-01",
    IMDS_TIMEOUT: 2e3,
    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
    KNOWN_PUBLIC_CLOUDS: [
      "login.microsoftonline.com",
      "login.windows.net",
      "login.microsoft.com",
      "sts.windows.net"
    ],
    SHR_NONCE_VALIDITY: 240,
    INVALID_INSTANCE: "invalid_instance"
  };
  var HttpStatus = {
    SUCCESS: 200,
    SUCCESS_RANGE_START: 200,
    SUCCESS_RANGE_END: 299,
    REDIRECT: 302,
    CLIENT_ERROR: 400,
    CLIENT_ERROR_RANGE_START: 400,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    REQUEST_TIMEOUT: 408,
    GONE: 410,
    TOO_MANY_REQUESTS: 429,
    CLIENT_ERROR_RANGE_END: 499,
    SERVER_ERROR: 500,
    SERVER_ERROR_RANGE_START: 500,
    SERVICE_UNAVAILABLE: 503,
    GATEWAY_TIMEOUT: 504,
    SERVER_ERROR_RANGE_END: 599,
    MULTI_SIDED_ERROR: 600
  };
  var OIDC_DEFAULT_SCOPES = [
    Constants.OPENID_SCOPE,
    Constants.PROFILE_SCOPE,
    Constants.OFFLINE_ACCESS_SCOPE
  ];
  var OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
  var HeaderNames = {
    CONTENT_TYPE: "Content-Type",
    CONTENT_LENGTH: "Content-Length",
    RETRY_AFTER: "Retry-After",
    CCS_HEADER: "X-AnchorMailbox",
    WWWAuthenticate: "WWW-Authenticate",
    AuthenticationInfo: "Authentication-Info",
    X_MS_REQUEST_ID: "x-ms-request-id",
    X_MS_HTTP_VERSION: "x-ms-httpver"
  };
  var PersistentCacheKeys = {
    ACTIVE_ACCOUNT_FILTERS: "active-account-filters"
    // new cache entry for active_account for a more robust version for browser
  };
  var AADAuthorityConstants = {
    COMMON: "common",
    ORGANIZATIONS: "organizations",
    CONSUMERS: "consumers"
  };
  var ClaimsRequestKeys = {
    ACCESS_TOKEN: "access_token",
    XMS_CC: "xms_cc"
  };
  var PromptValue = {
    LOGIN: "login",
    SELECT_ACCOUNT: "select_account",
    CONSENT: "consent",
    NONE: "none",
    CREATE: "create",
    NO_SESSION: "no_session"
  };
  var CodeChallengeMethodValues = {
    PLAIN: "plain",
    S256: "S256"
  };
  var OAuthResponseType = {
    CODE: "code",
    IDTOKEN_TOKEN: "id_token token",
    IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token"
  };
  var ServerResponseType = {
    QUERY: "query",
    FRAGMENT: "fragment"
  };
  var ResponseMode = {
    QUERY: "query",
    FRAGMENT: "fragment",
    FORM_POST: "form_post"
  };
  var GrantType = {
    IMPLICIT_GRANT: "implicit",
    AUTHORIZATION_CODE_GRANT: "authorization_code",
    CLIENT_CREDENTIALS_GRANT: "client_credentials",
    RESOURCE_OWNER_PASSWORD_GRANT: "password",
    REFRESH_TOKEN_GRANT: "refresh_token",
    DEVICE_CODE_GRANT: "device_code",
    JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
  };
  var CacheAccountType = {
    MSSTS_ACCOUNT_TYPE: "MSSTS",
    ADFS_ACCOUNT_TYPE: "ADFS",
    MSAV1_ACCOUNT_TYPE: "MSA",
    GENERIC_ACCOUNT_TYPE: "Generic"
    // NTLM, Kerberos, FBA, Basic etc
  };
  var Separators = {
    CACHE_KEY_SEPARATOR: "-",
    CLIENT_INFO_SEPARATOR: "."
  };
  var CredentialType = {
    ID_TOKEN: "IdToken",
    ACCESS_TOKEN: "AccessToken",
    ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
    REFRESH_TOKEN: "RefreshToken"
  };
  var APP_METADATA = "appmetadata";
  var CLIENT_INFO = "client_info";
  var THE_FAMILY_ID = "1";
  var AUTHORITY_METADATA_CONSTANTS = {
    CACHE_KEY: "authority-metadata",
    REFRESH_TIME_SECONDS: 3600 * 24
    // 24 Hours
  };
  var AuthorityMetadataSource = {
    CONFIG: "config",
    CACHE: "cache",
    NETWORK: "network",
    HARDCODED_VALUES: "hardcoded_values"
  };
  var SERVER_TELEM_CONSTANTS = {
    SCHEMA_VERSION: 5,
    MAX_CUR_HEADER_BYTES: 80,
    MAX_LAST_HEADER_BYTES: 330,
    MAX_CACHED_ERRORS: 50,
    CACHE_KEY: "server-telemetry",
    CATEGORY_SEPARATOR: "|",
    VALUE_SEPARATOR: ",",
    OVERFLOW_TRUE: "1",
    OVERFLOW_FALSE: "0",
    UNKNOWN_ERROR: "unknown_error"
  };
  var AuthenticationScheme = {
    BEARER: "Bearer",
    POP: "pop",
    SSH: "ssh-cert"
  };
  var ThrottlingConstants = {
    // Default time to throttle RequestThumbprint in seconds
    DEFAULT_THROTTLE_TIME_SECONDS: 60,
    // Default maximum time to throttle in seconds, overrides what the server sends back
    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
    // Prefix for storing throttling entries
    THROTTLING_PREFIX: "throttling",
    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
  };
  var Errors = {
    INVALID_GRANT_ERROR: "invalid_grant",
    CLIENT_MISMATCH_ERROR: "client_mismatch"
  };
  var PasswordGrantConstants = {
    username: "username",
    password: "password"
  };
  var ResponseCodes = {
    httpSuccess: 200,
    httpBadRequest: 400
  };
  var RegionDiscoverySources = {
    FAILED_AUTO_DETECTION: "1",
    INTERNAL_CACHE: "2",
    ENVIRONMENT_VARIABLE: "3",
    IMDS: "4"
  };
  var RegionDiscoveryOutcomes = {
    CONFIGURED_MATCHES_DETECTED: "1",
    CONFIGURED_NO_AUTO_DETECTION: "2",
    CONFIGURED_NOT_DETECTED: "3",
    AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
    AUTO_DETECTION_REQUESTED_FAILED: "5"
  };
  var CacheOutcome = {
    // When a token is found in the cache or the cache is not supposed to be hit when making the request
    NOT_APPLICABLE: "0",
    // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
    FORCE_REFRESH_OR_CLAIMS: "1",
    // When the token request goes to the identity provider because no cached access token exists
    NO_CACHED_ACCESS_TOKEN: "2",
    // When the token request goes to the identity provider because cached access token expired
    CACHED_ACCESS_TOKEN_EXPIRED: "3",
    // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
    PROACTIVELY_REFRESHED: "4"
  };
  var JsonWebTokenTypes = {
    Jwt: "JWT",
    Jwk: "JWK",
    Pop: "pop"
  };
  var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;

  // ../../node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs
  var AuthErrorCodes_exports = {};
  __export(AuthErrorCodes_exports, {
    postRequestFailed: () => postRequestFailed,
    unexpectedError: () => unexpectedError
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var unexpectedError = "unexpected_error";
  var postRequestFailed = "post_request_failed";

  // ../../node_modules/@azure/msal-common/dist/error/AuthError.mjs
  var AuthErrorMessages = {
    [unexpectedError]: "Unexpected error in authentication.",
    [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
  };
  var AuthErrorMessage = {
    unexpectedError: {
      code: unexpectedError,
      desc: AuthErrorMessages[unexpectedError]
    },
    postRequestFailed: {
      code: postRequestFailed,
      desc: AuthErrorMessages[postRequestFailed]
    }
  };
  var AuthError = class _AuthError extends Error {
    constructor(errorCode, errorMessage, suberror) {
      const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
      super(errorString);
      Object.setPrototypeOf(this, _AuthError.prototype);
      this.errorCode = errorCode || Constants.EMPTY_STRING;
      this.errorMessage = errorMessage || Constants.EMPTY_STRING;
      this.subError = suberror || Constants.EMPTY_STRING;
      this.name = "AuthError";
    }
    setCorrelationId(correlationId) {
      this.correlationId = correlationId;
    }
  };
  function createAuthError(code4, additionalMessage) {
    return new AuthError(code4, additionalMessage ? `${AuthErrorMessages[code4]} ${additionalMessage}` : AuthErrorMessages[code4]);
  }

  // ../../node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs
  var ClientAuthErrorCodes_exports = {};
  __export(ClientAuthErrorCodes_exports, {
    authTimeNotFound: () => authTimeNotFound,
    authorizationCodeMissingFromServerResponse: () => authorizationCodeMissingFromServerResponse,
    bindingKeyNotRemoved: () => bindingKeyNotRemoved,
    cannotAppendScopeSet: () => cannotAppendScopeSet,
    cannotRemoveEmptyScope: () => cannotRemoveEmptyScope,
    clientInfoDecodingError: () => clientInfoDecodingError,
    clientInfoEmptyError: () => clientInfoEmptyError,
    deviceCodeExpired: () => deviceCodeExpired,
    deviceCodePollingCancelled: () => deviceCodePollingCancelled,
    deviceCodeUnknownError: () => deviceCodeUnknownError,
    emptyInputScopeSet: () => emptyInputScopeSet,
    endSessionEndpointNotSupported: () => endSessionEndpointNotSupported,
    endpointResolutionError: () => endpointResolutionError,
    hashNotDeserialized: () => hashNotDeserialized,
    invalidAssertion: () => invalidAssertion,
    invalidCacheEnvironment: () => invalidCacheEnvironment,
    invalidCacheRecord: () => invalidCacheRecord,
    invalidClientCredential: () => invalidClientCredential,
    invalidState: () => invalidState,
    keyIdMissing: () => keyIdMissing,
    maxAgeTranspired: () => maxAgeTranspired,
    methodNotImplemented: () => methodNotImplemented,
    missingTenantIdError: () => missingTenantIdError,
    multipleMatchingAccounts: () => multipleMatchingAccounts,
    multipleMatchingAppMetadata: () => multipleMatchingAppMetadata,
    multipleMatchingTokens: () => multipleMatchingTokens,
    nestedAppAuthBridgeDisabled: () => nestedAppAuthBridgeDisabled,
    networkError: () => networkError,
    noAccountFound: () => noAccountFound,
    noAccountInSilentRequest: () => noAccountInSilentRequest,
    noCryptoObject: () => noCryptoObject,
    noNetworkConnectivity: () => noNetworkConnectivity,
    nonceMismatch: () => nonceMismatch,
    nullOrEmptyToken: () => nullOrEmptyToken,
    openIdConfigError: () => openIdConfigError,
    requestCannotBeMade: () => requestCannotBeMade,
    stateMismatch: () => stateMismatch,
    stateNotFound: () => stateNotFound,
    tokenClaimsCnfRequiredForSignedJwt: () => tokenClaimsCnfRequiredForSignedJwt,
    tokenParsingError: () => tokenParsingError,
    tokenRefreshRequired: () => tokenRefreshRequired,
    unexpectedCredentialType: () => unexpectedCredentialType,
    userCanceled: () => userCanceled,
    userTimeoutReached: () => userTimeoutReached
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var clientInfoDecodingError = "client_info_decoding_error";
  var clientInfoEmptyError = "client_info_empty_error";
  var tokenParsingError = "token_parsing_error";
  var nullOrEmptyToken = "null_or_empty_token";
  var endpointResolutionError = "endpoints_resolution_error";
  var networkError = "network_error";
  var openIdConfigError = "openid_config_error";
  var hashNotDeserialized = "hash_not_deserialized";
  var invalidState = "invalid_state";
  var stateMismatch = "state_mismatch";
  var stateNotFound = "state_not_found";
  var nonceMismatch = "nonce_mismatch";
  var authTimeNotFound = "auth_time_not_found";
  var maxAgeTranspired = "max_age_transpired";
  var multipleMatchingTokens = "multiple_matching_tokens";
  var multipleMatchingAccounts = "multiple_matching_accounts";
  var multipleMatchingAppMetadata = "multiple_matching_appMetadata";
  var requestCannotBeMade = "request_cannot_be_made";
  var cannotRemoveEmptyScope = "cannot_remove_empty_scope";
  var cannotAppendScopeSet = "cannot_append_scopeset";
  var emptyInputScopeSet = "empty_input_scopeset";
  var deviceCodePollingCancelled = "device_code_polling_cancelled";
  var deviceCodeExpired = "device_code_expired";
  var deviceCodeUnknownError = "device_code_unknown_error";
  var noAccountInSilentRequest = "no_account_in_silent_request";
  var invalidCacheRecord = "invalid_cache_record";
  var invalidCacheEnvironment = "invalid_cache_environment";
  var noAccountFound = "no_account_found";
  var noCryptoObject = "no_crypto_object";
  var unexpectedCredentialType = "unexpected_credential_type";
  var invalidAssertion = "invalid_assertion";
  var invalidClientCredential = "invalid_client_credential";
  var tokenRefreshRequired = "token_refresh_required";
  var userTimeoutReached = "user_timeout_reached";
  var tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
  var authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
  var bindingKeyNotRemoved = "binding_key_not_removed";
  var endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
  var keyIdMissing = "key_id_missing";
  var noNetworkConnectivity = "no_network_connectivity";
  var userCanceled = "user_canceled";
  var missingTenantIdError = "missing_tenant_id_error";
  var methodNotImplemented = "method_not_implemented";
  var nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";

  // ../../node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs
  var ClientAuthErrorMessages = {
    [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
    [clientInfoEmptyError]: "The client info was empty",
    [tokenParsingError]: "Token cannot be parsed",
    [nullOrEmptyToken]: "The token is null or empty",
    [endpointResolutionError]: "Endpoints cannot be resolved",
    [networkError]: "Network request failed",
    [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
    [hashNotDeserialized]: "The hash parameters could not be deserialized",
    [invalidState]: "State was not the expected format",
    [stateMismatch]: "State mismatch error",
    [stateNotFound]: "State not found",
    [nonceMismatch]: "Nonce mismatch error",
    [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
    [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
    [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
    [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
    [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
    [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
    [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
    [cannotAppendScopeSet]: "Cannot append ScopeSet",
    [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
    [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
    [deviceCodeExpired]: "Device code is expired.",
    [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
    [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
    [invalidCacheRecord]: "Cache record object was null or undefined.",
    [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
    [noAccountFound]: "No account found in cache for given key.",
    [noCryptoObject]: "No crypto object detected.",
    [unexpectedCredentialType]: "Unexpected credential type.",
    [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
    [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
    [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
    [userTimeoutReached]: "User defined timeout for device code polling reached",
    [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
    [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
    [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
    [endSessionEndpointNotSupported]: "The provided authority does not support logout",
    [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
    [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
    [userCanceled]: "User cancelled the flow.",
    [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
    [methodNotImplemented]: "This method has not been implemented",
    [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled"
  };
  var ClientAuthErrorMessage = {
    clientInfoDecodingError: {
      code: clientInfoDecodingError,
      desc: ClientAuthErrorMessages[clientInfoDecodingError]
    },
    clientInfoEmptyError: {
      code: clientInfoEmptyError,
      desc: ClientAuthErrorMessages[clientInfoEmptyError]
    },
    tokenParsingError: {
      code: tokenParsingError,
      desc: ClientAuthErrorMessages[tokenParsingError]
    },
    nullOrEmptyToken: {
      code: nullOrEmptyToken,
      desc: ClientAuthErrorMessages[nullOrEmptyToken]
    },
    endpointResolutionError: {
      code: endpointResolutionError,
      desc: ClientAuthErrorMessages[endpointResolutionError]
    },
    networkError: {
      code: networkError,
      desc: ClientAuthErrorMessages[networkError]
    },
    unableToGetOpenidConfigError: {
      code: openIdConfigError,
      desc: ClientAuthErrorMessages[openIdConfigError]
    },
    hashNotDeserialized: {
      code: hashNotDeserialized,
      desc: ClientAuthErrorMessages[hashNotDeserialized]
    },
    invalidStateError: {
      code: invalidState,
      desc: ClientAuthErrorMessages[invalidState]
    },
    stateMismatchError: {
      code: stateMismatch,
      desc: ClientAuthErrorMessages[stateMismatch]
    },
    stateNotFoundError: {
      code: stateNotFound,
      desc: ClientAuthErrorMessages[stateNotFound]
    },
    nonceMismatchError: {
      code: nonceMismatch,
      desc: ClientAuthErrorMessages[nonceMismatch]
    },
    authTimeNotFoundError: {
      code: authTimeNotFound,
      desc: ClientAuthErrorMessages[authTimeNotFound]
    },
    maxAgeTranspired: {
      code: maxAgeTranspired,
      desc: ClientAuthErrorMessages[maxAgeTranspired]
    },
    multipleMatchingTokens: {
      code: multipleMatchingTokens,
      desc: ClientAuthErrorMessages[multipleMatchingTokens]
    },
    multipleMatchingAccounts: {
      code: multipleMatchingAccounts,
      desc: ClientAuthErrorMessages[multipleMatchingAccounts]
    },
    multipleMatchingAppMetadata: {
      code: multipleMatchingAppMetadata,
      desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
    },
    tokenRequestCannotBeMade: {
      code: requestCannotBeMade,
      desc: ClientAuthErrorMessages[requestCannotBeMade]
    },
    removeEmptyScopeError: {
      code: cannotRemoveEmptyScope,
      desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
    },
    appendScopeSetError: {
      code: cannotAppendScopeSet,
      desc: ClientAuthErrorMessages[cannotAppendScopeSet]
    },
    emptyInputScopeSetError: {
      code: emptyInputScopeSet,
      desc: ClientAuthErrorMessages[emptyInputScopeSet]
    },
    DeviceCodePollingCancelled: {
      code: deviceCodePollingCancelled,
      desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
    },
    DeviceCodeExpired: {
      code: deviceCodeExpired,
      desc: ClientAuthErrorMessages[deviceCodeExpired]
    },
    DeviceCodeUnknownError: {
      code: deviceCodeUnknownError,
      desc: ClientAuthErrorMessages[deviceCodeUnknownError]
    },
    NoAccountInSilentRequest: {
      code: noAccountInSilentRequest,
      desc: ClientAuthErrorMessages[noAccountInSilentRequest]
    },
    invalidCacheRecord: {
      code: invalidCacheRecord,
      desc: ClientAuthErrorMessages[invalidCacheRecord]
    },
    invalidCacheEnvironment: {
      code: invalidCacheEnvironment,
      desc: ClientAuthErrorMessages[invalidCacheEnvironment]
    },
    noAccountFound: {
      code: noAccountFound,
      desc: ClientAuthErrorMessages[noAccountFound]
    },
    noCryptoObj: {
      code: noCryptoObject,
      desc: ClientAuthErrorMessages[noCryptoObject]
    },
    unexpectedCredentialType: {
      code: unexpectedCredentialType,
      desc: ClientAuthErrorMessages[unexpectedCredentialType]
    },
    invalidAssertion: {
      code: invalidAssertion,
      desc: ClientAuthErrorMessages[invalidAssertion]
    },
    invalidClientCredential: {
      code: invalidClientCredential,
      desc: ClientAuthErrorMessages[invalidClientCredential]
    },
    tokenRefreshRequired: {
      code: tokenRefreshRequired,
      desc: ClientAuthErrorMessages[tokenRefreshRequired]
    },
    userTimeoutReached: {
      code: userTimeoutReached,
      desc: ClientAuthErrorMessages[userTimeoutReached]
    },
    tokenClaimsRequired: {
      code: tokenClaimsCnfRequiredForSignedJwt,
      desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
    },
    noAuthorizationCodeFromServer: {
      code: authorizationCodeMissingFromServerResponse,
      desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
    },
    bindingKeyNotRemovedError: {
      code: bindingKeyNotRemoved,
      desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
    },
    logoutNotSupported: {
      code: endSessionEndpointNotSupported,
      desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
    },
    keyIdMissing: {
      code: keyIdMissing,
      desc: ClientAuthErrorMessages[keyIdMissing]
    },
    noNetworkConnectivity: {
      code: noNetworkConnectivity,
      desc: ClientAuthErrorMessages[noNetworkConnectivity]
    },
    userCanceledError: {
      code: userCanceled,
      desc: ClientAuthErrorMessages[userCanceled]
    },
    missingTenantIdError: {
      code: missingTenantIdError,
      desc: ClientAuthErrorMessages[missingTenantIdError]
    },
    nestedAppAuthBridgeDisabled: {
      code: nestedAppAuthBridgeDisabled,
      desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
    }
  };
  var ClientAuthError = class _ClientAuthError extends AuthError {
    constructor(errorCode, additionalMessage) {
      super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
      this.name = "ClientAuthError";
      Object.setPrototypeOf(this, _ClientAuthError.prototype);
    }
  };
  function createClientAuthError(errorCode, additionalMessage) {
    return new ClientAuthError(errorCode, additionalMessage);
  }

  // ../../node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs
  var DEFAULT_CRYPTO_IMPLEMENTATION = {
    createNewGuid: () => {
      throw createClientAuthError(methodNotImplemented);
    },
    base64Decode: () => {
      throw createClientAuthError(methodNotImplemented);
    },
    base64Encode: () => {
      throw createClientAuthError(methodNotImplemented);
    },
    base64UrlEncode: () => {
      throw createClientAuthError(methodNotImplemented);
    },
    encodeKid: () => {
      throw createClientAuthError(methodNotImplemented);
    },
    async getPublicKeyThumbprint() {
      throw createClientAuthError(methodNotImplemented);
    },
    async removeTokenBindingKey() {
      throw createClientAuthError(methodNotImplemented);
    },
    async clearKeystore() {
      throw createClientAuthError(methodNotImplemented);
    },
    async signJwt() {
      throw createClientAuthError(methodNotImplemented);
    },
    async hashString() {
      throw createClientAuthError(methodNotImplemented);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/logger/Logger.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["Error"] = 0] = "Error";
    LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
    LogLevel2[LogLevel2["Info"] = 2] = "Info";
    LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
    LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
  })(LogLevel || (LogLevel = {}));
  var Logger = class _Logger {
    constructor(loggerOptions, packageName, packageVersion) {
      this.level = LogLevel.Info;
      const defaultLoggerCallback = () => {
        return;
      };
      const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
      this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
      this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
      this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : LogLevel.Info;
      this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
      this.packageName = packageName || Constants.EMPTY_STRING;
      this.packageVersion = packageVersion || Constants.EMPTY_STRING;
    }
    static createDefaultLoggerOptions() {
      return {
        loggerCallback: () => {
        },
        piiLoggingEnabled: false,
        logLevel: LogLevel.Info
      };
    }
    /**
     * Create new Logger with existing configurations.
     */
    clone(packageName, packageVersion, correlationId) {
      return new _Logger({
        loggerCallback: this.localCallback,
        piiLoggingEnabled: this.piiLoggingEnabled,
        logLevel: this.level,
        correlationId: correlationId || this.correlationId
      }, packageName, packageVersion);
    }
    /**
     * Log message with required options.
     */
    logMessage(logMessage, options) {
      if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
        return;
      }
      const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
      const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
      const log = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel[options.logLevel]} - ${logMessage}`;
      this.executeCallback(options.logLevel, log, options.containsPii || false);
    }
    /**
     * Execute callback with message.
     */
    executeCallback(level, message, containsPii) {
      if (this.localCallback) {
        this.localCallback(level, message, containsPii);
      }
    }
    /**
     * Logs error messages.
     */
    error(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Error,
        containsPii: false,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs error messages with PII.
     */
    errorPii(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Error,
        containsPii: true,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs warning messages.
     */
    warning(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Warning,
        containsPii: false,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs warning messages with PII.
     */
    warningPii(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Warning,
        containsPii: true,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs info messages.
     */
    info(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Info,
        containsPii: false,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs info messages with PII.
     */
    infoPii(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Info,
        containsPii: true,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs verbose messages.
     */
    verbose(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Verbose,
        containsPii: false,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs verbose messages with PII.
     */
    verbosePii(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Verbose,
        containsPii: true,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs trace messages.
     */
    trace(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Trace,
        containsPii: false,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Logs trace messages with PII.
     */
    tracePii(message, correlationId) {
      this.logMessage(message, {
        logLevel: LogLevel.Trace,
        containsPii: true,
        correlationId: correlationId || Constants.EMPTY_STRING
      });
    }
    /**
     * Returns whether PII Logging is enabled or not.
     */
    isPiiLoggingEnabled() {
      return this.piiLoggingEnabled || false;
    }
  };

  // ../../node_modules/@azure/msal-common/dist/packageMetadata.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var name17 = "@azure/msal-common";
  var version = "15.6.0";

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var AzureCloudInstance = {
    // AzureCloudInstance is not specified.
    None: "none",
    // Microsoft Azure public cloud
    AzurePublic: "https://login.microsoftonline.com",
    // Microsoft PPE
    AzurePpe: "https://login.windows-ppe.net",
    // Microsoft Chinese national/regional cloud
    AzureChina: "https://login.chinacloudapi.cn",
    // Microsoft German national/regional cloud ("Black Forest")
    AzureGermany: "https://login.microsoftonline.de",
    // US Government cloud
    AzureUsGovernment: "https://login.microsoftonline.us"
  };

  // ../../node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
  var CacheHelpers_exports = {};
  __export(CacheHelpers_exports, {
    createAccessTokenEntity: () => createAccessTokenEntity,
    createIdTokenEntity: () => createIdTokenEntity,
    createRefreshTokenEntity: () => createRefreshTokenEntity,
    generateAppMetadataKey: () => generateAppMetadataKey,
    generateAuthorityMetadataExpiresAt: () => generateAuthorityMetadataExpiresAt,
    generateCredentialKey: () => generateCredentialKey,
    isAccessTokenEntity: () => isAccessTokenEntity,
    isAppMetadataEntity: () => isAppMetadataEntity,
    isAuthorityMetadataEntity: () => isAuthorityMetadataEntity,
    isAuthorityMetadataExpired: () => isAuthorityMetadataExpired,
    isCredentialEntity: () => isCredentialEntity,
    isIdTokenEntity: () => isIdTokenEntity,
    isRefreshTokenEntity: () => isRefreshTokenEntity,
    isServerTelemetryEntity: () => isServerTelemetryEntity,
    isThrottlingEntity: () => isThrottlingEntity,
    updateAuthorityEndpointMetadata: () => updateAuthorityEndpointMetadata,
    updateCloudDiscoveryMetadata: () => updateCloudDiscoveryMetadata
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/account/AuthToken.mjs
  var AuthToken_exports = {};
  __export(AuthToken_exports, {
    checkMaxAge: () => checkMaxAge,
    extractTokenClaims: () => extractTokenClaims,
    getJWSPayload: () => getJWSPayload
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function extractTokenClaims(encodedToken, base64Decode2) {
    const jswPayload = getJWSPayload(encodedToken);
    try {
      const base64Decoded = base64Decode2(jswPayload);
      return JSON.parse(base64Decoded);
    } catch (err) {
      throw createClientAuthError(tokenParsingError);
    }
  }
  function getJWSPayload(authToken) {
    if (!authToken) {
      throw createClientAuthError(nullOrEmptyToken);
    }
    const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
    const matches = tokenPartsRegex.exec(authToken);
    if (!matches || matches.length < 4) {
      throw createClientAuthError(tokenParsingError);
    }
    return matches[2];
  }
  function checkMaxAge(authTime, maxAge) {
    const fiveMinuteSkew = 3e5;
    if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
      throw createClientAuthError(maxAgeTranspired);
    }
  }

  // ../../node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs
  var TimeUtils_exports = {};
  __export(TimeUtils_exports, {
    delay: () => delay,
    isTokenExpired: () => isTokenExpired,
    nowSeconds: () => nowSeconds,
    toDateFromSeconds: () => toDateFromSeconds,
    toSecondsFromDate: () => toSecondsFromDate,
    wasClockTurnedBack: () => wasClockTurnedBack
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function nowSeconds() {
    return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
  }
  function toSecondsFromDate(date) {
    return date.getTime() / 1e3;
  }
  function toDateFromSeconds(seconds) {
    if (seconds) {
      return new Date(Number(seconds) * 1e3);
    }
    return /* @__PURE__ */ new Date();
  }
  function isTokenExpired(expiresOn, offset4) {
    const expirationSec = Number(expiresOn) || 0;
    const offsetCurrentTimeSec = nowSeconds() + offset4;
    return offsetCurrentTimeSec > expirationSec;
  }
  function wasClockTurnedBack(cachedAt) {
    const cachedAtSec = Number(cachedAt);
    return cachedAtSec > nowSeconds();
  }
  function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
  }

  // ../../node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs
  function generateCredentialKey(credentialEntity) {
    const credentialKey = [
      generateAccountId(credentialEntity),
      generateCredentialId(credentialEntity),
      generateTarget(credentialEntity),
      generateClaimsHash(credentialEntity),
      generateScheme(credentialEntity)
    ];
    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
    const idTokenEntity = {
      credentialType: CredentialType.ID_TOKEN,
      homeAccountId,
      environment,
      clientId,
      secret: idToken,
      realm: tenantId
    };
    return idTokenEntity;
  }
  function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode2, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
    const atEntity = {
      homeAccountId,
      credentialType: CredentialType.ACCESS_TOKEN,
      secret: accessToken,
      cachedAt: nowSeconds().toString(),
      expiresOn: expiresOn.toString(),
      extendedExpiresOn: extExpiresOn.toString(),
      environment,
      clientId,
      realm: tenantId,
      target: scopes,
      tokenType: tokenType || AuthenticationScheme.BEARER
    };
    if (userAssertionHash) {
      atEntity.userAssertionHash = userAssertionHash;
    }
    if (refreshOn) {
      atEntity.refreshOn = refreshOn.toString();
    }
    if (requestedClaims) {
      atEntity.requestedClaims = requestedClaims;
      atEntity.requestedClaimsHash = requestedClaimsHash;
    }
    if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
      switch (atEntity.tokenType) {
        case AuthenticationScheme.POP:
          const tokenClaims = extractTokenClaims(accessToken, base64Decode2);
          if (!tokenClaims?.cnf?.kid) {
            throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
          }
          atEntity.keyId = tokenClaims.cnf.kid;
          break;
        case AuthenticationScheme.SSH:
          atEntity.keyId = keyId;
      }
    }
    return atEntity;
  }
  function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
    const rtEntity = {
      credentialType: CredentialType.REFRESH_TOKEN,
      homeAccountId,
      environment,
      clientId,
      secret: refreshToken
    };
    if (userAssertionHash) {
      rtEntity.userAssertionHash = userAssertionHash;
    }
    if (familyId) {
      rtEntity.familyId = familyId;
    }
    if (expiresOn) {
      rtEntity.expiresOn = expiresOn.toString();
    }
    return rtEntity;
  }
  function isCredentialEntity(entity) {
    return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
  }
  function isAccessTokenEntity(entity) {
    if (!entity) {
      return false;
    }
    return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
  }
  function isIdTokenEntity(entity) {
    if (!entity) {
      return false;
    }
    return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
  }
  function isRefreshTokenEntity(entity) {
    if (!entity) {
      return false;
    }
    return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
  }
  function generateAccountId(credentialEntity) {
    const accountId = [
      credentialEntity.homeAccountId,
      credentialEntity.environment
    ];
    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  function generateCredentialId(credentialEntity) {
    const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;
    const credentialId = [
      credentialEntity.credentialType,
      clientOrFamilyId,
      credentialEntity.realm || ""
    ];
    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  function generateTarget(credentialEntity) {
    return (credentialEntity.target || "").toLowerCase();
  }
  function generateClaimsHash(credentialEntity) {
    return (credentialEntity.requestedClaimsHash || "").toLowerCase();
  }
  function generateScheme(credentialEntity) {
    return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : "";
  }
  function isServerTelemetryEntity(key, entity) {
    const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
    let validateEntity = true;
    if (entity) {
      validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
    }
    return validateKey && validateEntity;
  }
  function isThrottlingEntity(key, entity) {
    let validateKey = false;
    if (key) {
      validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
    }
    let validateEntity = true;
    if (entity) {
      validateEntity = entity.hasOwnProperty("throttleTime");
    }
    return validateKey && validateEntity;
  }
  function generateAppMetadataKey({ environment, clientId }) {
    const appMetaDataKeyArray = [
      APP_METADATA,
      environment,
      clientId
    ];
    return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
  }
  function isAppMetadataEntity(key, entity) {
    if (!entity) {
      return false;
    }
    return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
  }
  function isAuthorityMetadataEntity(key, entity) {
    if (!entity) {
      return false;
    }
    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
  }
  function generateAuthorityMetadataExpiresAt() {
    return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
  }
  function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
    authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
    authorityMetadata.token_endpoint = updatedValues.token_endpoint;
    authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
    authorityMetadata.issuer = updatedValues.issuer;
    authorityMetadata.endpointsFromNetwork = fromNetwork;
    authorityMetadata.jwks_uri = updatedValues.jwks_uri;
  }
  function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
    authorityMetadata.aliases = updatedValues.aliases;
    authorityMetadata.preferred_cache = updatedValues.preferred_cache;
    authorityMetadata.preferred_network = updatedValues.preferred_network;
    authorityMetadata.aliasesFromNetwork = fromNetwork;
  }
  function isAuthorityMetadataExpired(metadata) {
    return metadata.expiresAt <= nowSeconds();
  }

  // ../../node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs
  var ClientConfigurationErrorCodes_exports = {};
  __export(ClientConfigurationErrorCodes_exports, {
    authorityMismatch: () => authorityMismatch,
    authorityUriInsecure: () => authorityUriInsecure,
    cannotAllowPlatformBroker: () => cannotAllowPlatformBroker,
    cannotSetOIDCOptions: () => cannotSetOIDCOptions,
    claimsRequestParsingError: () => claimsRequestParsingError,
    emptyInputScopesError: () => emptyInputScopesError,
    invalidAuthenticationHeader: () => invalidAuthenticationHeader,
    invalidAuthorityMetadata: () => invalidAuthorityMetadata,
    invalidClaims: () => invalidClaims,
    invalidCloudDiscoveryMetadata: () => invalidCloudDiscoveryMetadata,
    invalidCodeChallengeMethod: () => invalidCodeChallengeMethod,
    invalidPromptValue: () => invalidPromptValue,
    logoutRequestEmpty: () => logoutRequestEmpty,
    missingNonceAuthenticationHeader: () => missingNonceAuthenticationHeader,
    missingSshJwk: () => missingSshJwk,
    missingSshKid: () => missingSshKid,
    pkceParamsMissing: () => pkceParamsMissing,
    redirectUriEmpty: () => redirectUriEmpty,
    tokenRequestEmpty: () => tokenRequestEmpty,
    untrustedAuthority: () => untrustedAuthority,
    urlEmptyError: () => urlEmptyError,
    urlParseError: () => urlParseError
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var redirectUriEmpty = "redirect_uri_empty";
  var claimsRequestParsingError = "claims_request_parsing_error";
  var authorityUriInsecure = "authority_uri_insecure";
  var urlParseError = "url_parse_error";
  var urlEmptyError = "empty_url_error";
  var emptyInputScopesError = "empty_input_scopes_error";
  var invalidPromptValue = "invalid_prompt_value";
  var invalidClaims = "invalid_claims";
  var tokenRequestEmpty = "token_request_empty";
  var logoutRequestEmpty = "logout_request_empty";
  var invalidCodeChallengeMethod = "invalid_code_challenge_method";
  var pkceParamsMissing = "pkce_params_missing";
  var invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
  var invalidAuthorityMetadata = "invalid_authority_metadata";
  var untrustedAuthority = "untrusted_authority";
  var missingSshJwk = "missing_ssh_jwk";
  var missingSshKid = "missing_ssh_kid";
  var missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
  var invalidAuthenticationHeader = "invalid_authentication_header";
  var cannotSetOIDCOptions = "cannot_set_OIDCOptions";
  var cannotAllowPlatformBroker = "cannot_allow_platform_broker";
  var authorityMismatch = "authority_mismatch";

  // ../../node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs
  var ClientConfigurationErrorMessages = {
    [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
    [claimsRequestParsingError]: "Could not parse the given claims request object.",
    [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
    [urlParseError]: "URL could not be parsed into appropriate segments.",
    [urlEmptyError]: "URL was empty or null.",
    [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
    [invalidPromptValue]: "Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
    [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
    [tokenRequestEmpty]: "Token request was empty and not found in cache.",
    [logoutRequestEmpty]: "The logout request was null or undefined.",
    [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
    [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
    [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
    [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
    [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
    [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
    [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
    [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
    [invalidAuthenticationHeader]: "Invalid authentication header provided",
    [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
    [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
    [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
  };
  var ClientConfigurationErrorMessage = {
    redirectUriNotSet: {
      code: redirectUriEmpty,
      desc: ClientConfigurationErrorMessages[redirectUriEmpty]
    },
    claimsRequestParsingError: {
      code: claimsRequestParsingError,
      desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
    },
    authorityUriInsecure: {
      code: authorityUriInsecure,
      desc: ClientConfigurationErrorMessages[authorityUriInsecure]
    },
    urlParseError: {
      code: urlParseError,
      desc: ClientConfigurationErrorMessages[urlParseError]
    },
    urlEmptyError: {
      code: urlEmptyError,
      desc: ClientConfigurationErrorMessages[urlEmptyError]
    },
    emptyScopesError: {
      code: emptyInputScopesError,
      desc: ClientConfigurationErrorMessages[emptyInputScopesError]
    },
    invalidPrompt: {
      code: invalidPromptValue,
      desc: ClientConfigurationErrorMessages[invalidPromptValue]
    },
    invalidClaimsRequest: {
      code: invalidClaims,
      desc: ClientConfigurationErrorMessages[invalidClaims]
    },
    tokenRequestEmptyError: {
      code: tokenRequestEmpty,
      desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
    },
    logoutRequestEmptyError: {
      code: logoutRequestEmpty,
      desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
    },
    invalidCodeChallengeMethod: {
      code: invalidCodeChallengeMethod,
      desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
    },
    invalidCodeChallengeParams: {
      code: pkceParamsMissing,
      desc: ClientConfigurationErrorMessages[pkceParamsMissing]
    },
    invalidCloudDiscoveryMetadata: {
      code: invalidCloudDiscoveryMetadata,
      desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
    },
    invalidAuthorityMetadata: {
      code: invalidAuthorityMetadata,
      desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
    },
    untrustedAuthority: {
      code: untrustedAuthority,
      desc: ClientConfigurationErrorMessages[untrustedAuthority]
    },
    missingSshJwk: {
      code: missingSshJwk,
      desc: ClientConfigurationErrorMessages[missingSshJwk]
    },
    missingSshKid: {
      code: missingSshKid,
      desc: ClientConfigurationErrorMessages[missingSshKid]
    },
    missingNonceAuthenticationHeader: {
      code: missingNonceAuthenticationHeader,
      desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
    },
    invalidAuthenticationHeader: {
      code: invalidAuthenticationHeader,
      desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
    },
    cannotSetOIDCOptions: {
      code: cannotSetOIDCOptions,
      desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
    },
    cannotAllowPlatformBroker: {
      code: cannotAllowPlatformBroker,
      desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
    },
    authorityMismatch: {
      code: authorityMismatch,
      desc: ClientConfigurationErrorMessages[authorityMismatch]
    }
  };
  var ClientConfigurationError = class _ClientConfigurationError extends AuthError {
    constructor(errorCode) {
      super(errorCode, ClientConfigurationErrorMessages[errorCode]);
      this.name = "ClientConfigurationError";
      Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
    }
  };
  function createClientConfigurationError(errorCode) {
    return new ClientConfigurationError(errorCode);
  }

  // ../../node_modules/@azure/msal-common/dist/utils/StringUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var StringUtils = class {
    /**
     * Check if stringified object is empty
     * @param strObj
     */
    static isEmptyObj(strObj) {
      if (strObj) {
        try {
          const obj = JSON.parse(strObj);
          return Object.keys(obj).length === 0;
        } catch (e) {
        }
      }
      return true;
    }
    static startsWith(str, search2) {
      return str.indexOf(search2) === 0;
    }
    static endsWith(str, search2) {
      return str.length >= search2.length && str.lastIndexOf(search2) === str.length - search2.length;
    }
    /**
     * Parses string into an object.
     *
     * @param query
     */
    static queryStringToObject(query) {
      const obj = {};
      const params = query.split("&");
      const decode2 = (s) => decodeURIComponent(s.replace(/\+/g, " "));
      params.forEach((pair) => {
        if (pair.trim()) {
          const [key, value] = pair.split(/=(.+)/g, 2);
          if (key && value) {
            obj[decode2(key)] = decode2(value);
          }
        }
      });
      return obj;
    }
    /**
     * Trims entries in an array.
     *
     * @param arr
     */
    static trimArrayEntries(arr) {
      return arr.map((entry) => entry.trim());
    }
    /**
     * Removes empty strings from array
     * @param arr
     */
    static removeEmptyStringsFromArray(arr) {
      return arr.filter((entry) => {
        return !!entry;
      });
    }
    /**
     * Attempts to parse a string into JSON
     * @param str
     */
    static jsonParseHelper(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return null;
      }
    }
    /**
     * Tests if a given string matches a given pattern, with support for wildcards and queries.
     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
     * @param input String to match against
     */
    static matchPattern(pattern, input) {
      const regex2 = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
      return regex2.test(input);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/request/ScopeSet.mjs
  var ScopeSet = class _ScopeSet {
    constructor(inputScopes) {
      const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
      const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
      if (!filteredInput || !filteredInput.length) {
        throw createClientConfigurationError(emptyInputScopesError);
      }
      this.scopes = /* @__PURE__ */ new Set();
      filteredInput.forEach((scope) => this.scopes.add(scope));
    }
    /**
     * Factory method to create ScopeSet from space-delimited string
     * @param inputScopeString
     * @param appClientId
     * @param scopesRequired
     */
    static fromString(inputScopeString) {
      const scopeString = inputScopeString || Constants.EMPTY_STRING;
      const inputScopes = scopeString.split(" ");
      return new _ScopeSet(inputScopes);
    }
    /**
     * Creates the set of scopes to search for in cache lookups
     * @param inputScopeString
     * @returns
     */
    static createSearchScopes(inputScopeString) {
      const scopeSet = new _ScopeSet(inputScopeString);
      if (!scopeSet.containsOnlyOIDCScopes()) {
        scopeSet.removeOIDCScopes();
      } else {
        scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
      }
      return scopeSet;
    }
    /**
     * Check if a given scope is present in this set of scopes.
     * @param scope
     */
    containsScope(scope) {
      const lowerCaseScopes = this.printScopesLowerCase().split(" ");
      const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
      return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
    }
    /**
     * Check if a set of scopes is present in this set of scopes.
     * @param scopeSet
     */
    containsScopeSet(scopeSet) {
      if (!scopeSet || scopeSet.scopes.size <= 0) {
        return false;
      }
      return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
    }
    /**
     * Check if set of scopes contains only the defaults
     */
    containsOnlyOIDCScopes() {
      let defaultScopeCount = 0;
      OIDC_SCOPES.forEach((defaultScope) => {
        if (this.containsScope(defaultScope)) {
          defaultScopeCount += 1;
        }
      });
      return this.scopes.size === defaultScopeCount;
    }
    /**
     * Appends single scope if passed
     * @param newScope
     */
    appendScope(newScope) {
      if (newScope) {
        this.scopes.add(newScope.trim());
      }
    }
    /**
     * Appends multiple scopes if passed
     * @param newScopes
     */
    appendScopes(newScopes) {
      try {
        newScopes.forEach((newScope) => this.appendScope(newScope));
      } catch (e) {
        throw createClientAuthError(cannotAppendScopeSet);
      }
    }
    /**
     * Removes element from set of scopes.
     * @param scope
     */
    removeScope(scope) {
      if (!scope) {
        throw createClientAuthError(cannotRemoveEmptyScope);
      }
      this.scopes.delete(scope.trim());
    }
    /**
     * Removes default scopes from set of scopes
     * Primarily used to prevent cache misses if the default scopes are not returned from the server
     */
    removeOIDCScopes() {
      OIDC_SCOPES.forEach((defaultScope) => {
        this.scopes.delete(defaultScope);
      });
    }
    /**
     * Combines an array of scopes with the current set of scopes.
     * @param otherScopes
     */
    unionScopeSets(otherScopes) {
      if (!otherScopes) {
        throw createClientAuthError(emptyInputScopeSet);
      }
      const unionScopes = /* @__PURE__ */ new Set();
      otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
      this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
      return unionScopes;
    }
    /**
     * Check if scopes intersect between this set and another.
     * @param otherScopes
     */
    intersectingScopeSets(otherScopes) {
      if (!otherScopes) {
        throw createClientAuthError(emptyInputScopeSet);
      }
      if (!otherScopes.containsOnlyOIDCScopes()) {
        otherScopes.removeOIDCScopes();
      }
      const unionScopes = this.unionScopeSets(otherScopes);
      const sizeOtherScopes = otherScopes.getScopeCount();
      const sizeThisScopes = this.getScopeCount();
      const sizeUnionScopes = unionScopes.size;
      return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
    }
    /**
     * Returns size of set of scopes.
     */
    getScopeCount() {
      return this.scopes.size;
    }
    /**
     * Returns the scopes as an array of string values
     */
    asArray() {
      const array = [];
      this.scopes.forEach((val) => array.push(val));
      return array;
    }
    /**
     * Prints scopes into a space-delimited string
     */
    printScopes() {
      if (this.scopes) {
        const scopeArr = this.asArray();
        return scopeArr.join(" ");
      }
      return Constants.EMPTY_STRING;
    }
    /**
     * Prints scopes into a space-delimited lower-case string (used for caching)
     */
    printScopesLowerCase() {
      return this.printScopes().toLowerCase();
    }
  };

  // ../../node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/account/ClientInfo.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function buildClientInfo(rawClientInfo, base64Decode2) {
    if (!rawClientInfo) {
      throw createClientAuthError(clientInfoEmptyError);
    }
    try {
      const decodedClientInfo = base64Decode2(rawClientInfo);
      return JSON.parse(decodedClientInfo);
    } catch (e) {
      throw createClientAuthError(clientInfoDecodingError);
    }
  }
  function buildClientInfoFromHomeAccountId(homeAccountId) {
    if (!homeAccountId) {
      throw createClientAuthError(clientInfoDecodingError);
    }
    const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
    return {
      uid: clientInfoParts[0],
      utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
    };
  }

  // ../../node_modules/@azure/msal-common/dist/account/AccountInfo.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
    return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
  }
  function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
    if (idTokenClaims) {
      const { oid, sub, tid, name: name21, tfp, acr } = idTokenClaims;
      const tenantId2 = tid || tfp || acr || "";
      return {
        tenantId: tenantId2,
        localAccountId: oid || sub || "",
        name: name21,
        isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
      };
    } else {
      return {
        tenantId,
        localAccountId,
        isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
      };
    }
  }
  function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
    let updatedAccountInfo = baseAccountInfo;
    if (tenantProfile) {
      const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
      updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
    }
    if (idTokenClaims) {
      const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
      updatedAccountInfo = {
        ...updatedAccountInfo,
        ...claimsSourcedTenantProfile,
        idTokenClaims,
        idToken: idTokenSecret
      };
      return updatedAccountInfo;
    }
    return updatedAccountInfo;
  }

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var AuthorityType = {
    Default: 0,
    Adfs: 1,
    Dsts: 2,
    Ciam: 3
  };

  // ../../node_modules/@azure/msal-common/dist/account/TokenClaims.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getTenantIdFromIdTokenClaims(idTokenClaims) {
    if (idTokenClaims) {
      const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
      return tenantId || null;
    }
    return null;
  }

  // ../../node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ProtocolMode = {
    /**
     * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
     */
    AAD: "AAD",
    /**
     * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
     * Support is limited for this mode.
     */
    OIDC: "OIDC",
    /**
     * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
     */
    EAR: "EAR"
  };

  // ../../node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs
  var AccountEntity = class _AccountEntity {
    /**
     * Generate Account Id key component as per the schema: <home_account_id>-<environment>
     */
    generateAccountId() {
      const accountId = [this.homeAccountId, this.environment];
      return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }
    /**
     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
     */
    generateAccountKey() {
      return _AccountEntity.generateAccountCacheKey({
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId
      });
    }
    /**
     * Returns the AccountInfo interface for this account.
     */
    getAccountInfo() {
      return {
        homeAccountId: this.homeAccountId,
        environment: this.environment,
        tenantId: this.realm,
        username: this.username,
        localAccountId: this.localAccountId,
        name: this.name,
        nativeAccountId: this.nativeAccountId,
        authorityType: this.authorityType,
        // Deserialize tenant profiles array into a Map
        tenantProfiles: new Map((this.tenantProfiles || []).map((tenantProfile) => {
          return [tenantProfile.tenantId, tenantProfile];
        }))
      };
    }
    /**
     * Returns true if the account entity is in single tenant format (outdated), false otherwise
     */
    isSingleTenant() {
      return !this.tenantProfiles;
    }
    /**
     * Generates account key from interface
     * @param accountInterface
     */
    static generateAccountCacheKey(accountInterface) {
      const homeTenantId = accountInterface.homeAccountId.split(".")[1];
      const accountKey = [
        accountInterface.homeAccountId,
        accountInterface.environment || "",
        homeTenantId || accountInterface.tenantId || ""
      ];
      return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }
    /**
     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
     * @param accountDetails
     */
    static createAccount(accountDetails, authority, base64Decode2) {
      const account = new _AccountEntity();
      if (authority.authorityType === AuthorityType.Adfs) {
        account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
      } else if (authority.protocolMode === ProtocolMode.OIDC) {
        account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
      } else {
        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
      }
      let clientInfo;
      if (accountDetails.clientInfo && base64Decode2) {
        clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode2);
      }
      account.clientInfo = accountDetails.clientInfo;
      account.homeAccountId = accountDetails.homeAccountId;
      account.nativeAccountId = accountDetails.nativeAccountId;
      const env2 = accountDetails.environment || authority && authority.getPreferredCache();
      if (!env2) {
        throw createClientAuthError(invalidCacheEnvironment);
      }
      account.environment = env2;
      account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
      account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || "";
      const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
      const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;
      account.username = preferredUsername || email || "";
      account.name = accountDetails.idTokenClaims?.name || "";
      account.cloudGraphHostName = accountDetails.cloudGraphHostName;
      account.msGraphHost = accountDetails.msGraphHost;
      if (accountDetails.tenantProfiles) {
        account.tenantProfiles = accountDetails.tenantProfiles;
      } else {
        const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
        account.tenantProfiles = [tenantProfile];
      }
      return account;
    }
    /**
     * Creates an AccountEntity object from AccountInfo
     * @param accountInfo
     * @param cloudGraphHostName
     * @param msGraphHost
     * @returns
     */
    static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
      const account = new _AccountEntity();
      account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
      account.homeAccountId = accountInfo.homeAccountId;
      account.localAccountId = accountInfo.localAccountId;
      account.nativeAccountId = accountInfo.nativeAccountId;
      account.realm = accountInfo.tenantId;
      account.environment = accountInfo.environment;
      account.username = accountInfo.username;
      account.name = accountInfo.name;
      account.cloudGraphHostName = cloudGraphHostName;
      account.msGraphHost = msGraphHost;
      account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
      return account;
    }
    /**
     * Generate HomeAccountId from server response
     * @param serverClientInfo
     * @param authType
     */
    static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
      if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
        if (serverClientInfo) {
          try {
            const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
            if (clientInfo.uid && clientInfo.utid) {
              return `${clientInfo.uid}.${clientInfo.utid}`;
            }
          } catch (e) {
          }
        }
        logger.warning("No client info in response");
      }
      return idTokenClaims?.sub || "";
    }
    /**
     * Validates an entity: checks for all expected params
     * @param entity
     */
    static isAccountEntity(entity) {
      if (!entity) {
        return false;
      }
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
    }
    /**
     * Helper function to determine whether 2 accountInfo objects represent the same account
     * @param accountA
     * @param accountB
     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
     */
    static accountInfoIsEqual(accountA, accountB, compareClaims) {
      if (!accountA || !accountB) {
        return false;
      }
      let claimsMatch = true;
      if (compareClaims) {
        const accountAClaims = accountA.idTokenClaims || {};
        const accountBClaims = accountB.idTokenClaims || {};
        claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
      }
      return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
    }
  };

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/url/UrlString.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs
  var UrlUtils_exports = {};
  __export(UrlUtils_exports, {
    getDeserializedResponse: () => getDeserializedResponse,
    mapToQueryString: () => mapToQueryString,
    stripLeadingHashOrQuery: () => stripLeadingHashOrQuery
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function stripLeadingHashOrQuery(responseString) {
    if (responseString.startsWith("#/")) {
      return responseString.substring(2);
    } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
      return responseString.substring(1);
    }
    return responseString;
  }
  function getDeserializedResponse(responseString) {
    if (!responseString || responseString.indexOf("=") < 0) {
      return null;
    }
    try {
      const normalizedResponse = stripLeadingHashOrQuery(responseString);
      const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
      if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
        return deserializedHash;
      }
    } catch (e) {
      throw createClientAuthError(hashNotDeserialized);
    }
    return null;
  }
  function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
    const queryParameterArray = new Array();
    parameters.forEach((value, key) => {
      if (!encodeExtraParams && extraQueryParameters && key in extraQueryParameters) {
        queryParameterArray.push(`${key}=${value}`);
      } else {
        queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
      }
    });
    return queryParameterArray.join("&");
  }

  // ../../node_modules/@azure/msal-common/dist/url/UrlString.mjs
  var UrlString = class _UrlString {
    get urlString() {
      return this._urlString;
    }
    constructor(url) {
      this._urlString = url;
      if (!this._urlString) {
        throw createClientConfigurationError(urlEmptyError);
      }
      if (!url.includes("#")) {
        this._urlString = _UrlString.canonicalizeUri(url);
      }
    }
    /**
     * Ensure urls are lower case and end with a / character.
     * @param url
     */
    static canonicalizeUri(url) {
      if (url) {
        let lowerCaseUrl = url.toLowerCase();
        if (StringUtils.endsWith(lowerCaseUrl, "?")) {
          lowerCaseUrl = lowerCaseUrl.slice(0, -1);
        } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
          lowerCaseUrl = lowerCaseUrl.slice(0, -2);
        }
        if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
          lowerCaseUrl += "/";
        }
        return lowerCaseUrl;
      }
      return url;
    }
    /**
     * Throws if urlString passed is not a valid authority URI string.
     */
    validateAsUri() {
      let components;
      try {
        components = this.getUrlComponents();
      } catch (e) {
        throw createClientConfigurationError(urlParseError);
      }
      if (!components.HostNameAndPort || !components.PathSegments) {
        throw createClientConfigurationError(urlParseError);
      }
      if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
        throw createClientConfigurationError(authorityUriInsecure);
      }
    }
    /**
     * Given a url and a query string return the url with provided query string appended
     * @param url
     * @param queryString
     */
    static appendQueryString(url, queryString) {
      if (!queryString) {
        return url;
      }
      return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
    }
    /**
     * Returns a url with the hash removed
     * @param url
     */
    static removeHashFromUrl(url) {
      return _UrlString.canonicalizeUri(url.split("#")[0]);
    }
    /**
     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
     * @param href The url
     * @param tenantId The tenant id to replace
     */
    replaceTenantPath(tenantId) {
      const urlObject = this.getUrlComponents();
      const pathArray = urlObject.PathSegments;
      if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
        pathArray[0] = tenantId;
      }
      return _UrlString.constructAuthorityUriFromObject(urlObject);
    }
    /**
     * Parses out the components from a url string.
     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
     */
    getUrlComponents() {
      const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
      const match2 = this.urlString.match(regEx);
      if (!match2) {
        throw createClientConfigurationError(urlParseError);
      }
      const urlComponents = {
        Protocol: match2[1],
        HostNameAndPort: match2[4],
        AbsolutePath: match2[5],
        QueryString: match2[7]
      };
      let pathSegments = urlComponents.AbsolutePath.split("/");
      pathSegments = pathSegments.filter((val) => val && val.length > 0);
      urlComponents.PathSegments = pathSegments;
      if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
        urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
      }
      return urlComponents;
    }
    static getDomainFromUrl(url) {
      const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
      const match2 = url.match(regEx);
      if (!match2) {
        throw createClientConfigurationError(urlParseError);
      }
      return match2[2];
    }
    static getAbsoluteUrl(relativeUrl, baseUrl) {
      if (relativeUrl[0] === Constants.FORWARD_SLASH) {
        const url = new _UrlString(baseUrl);
        const baseComponents = url.getUrlComponents();
        return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
      }
      return relativeUrl;
    }
    static constructAuthorityUriFromObject(urlObject) {
      return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
    }
    /**
     * Check if the hash of the URL string contains known properties
     * @deprecated This API will be removed in a future version
     */
    static hashContainsKnownProperties(response) {
      return !!getDeserializedResponse(response);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs
  var rawMetdataJSON = {
    endpointMetadata: {
      "login.microsoftonline.com": {
        token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
        jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
        issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
        authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
        end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
      },
      "login.chinacloudapi.cn": {
        token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
        jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
        issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
        authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
        end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
      },
      "login.microsoftonline.us": {
        token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
        jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
        issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
        authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
        end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
      }
    },
    instanceDiscoveryMetadata: {
      tenant_discovery_endpoint: "https://{canonicalAuthority}/v2.0/.well-known/openid-configuration",
      metadata: [
        {
          preferred_network: "login.microsoftonline.com",
          preferred_cache: "login.windows.net",
          aliases: [
            "login.microsoftonline.com",
            "login.windows.net",
            "login.microsoft.com",
            "sts.windows.net"
          ]
        },
        {
          preferred_network: "login.partner.microsoftonline.cn",
          preferred_cache: "login.partner.microsoftonline.cn",
          aliases: [
            "login.partner.microsoftonline.cn",
            "login.chinacloudapi.cn"
          ]
        },
        {
          preferred_network: "login.microsoftonline.de",
          preferred_cache: "login.microsoftonline.de",
          aliases: ["login.microsoftonline.de"]
        },
        {
          preferred_network: "login.microsoftonline.us",
          preferred_cache: "login.microsoftonline.us",
          aliases: [
            "login.microsoftonline.us",
            "login.usgovcloudapi.net"
          ]
        },
        {
          preferred_network: "login-us.microsoftonline.com",
          preferred_cache: "login-us.microsoftonline.com",
          aliases: ["login-us.microsoftonline.com"]
        }
      ]
    }
  };
  var EndpointMetadata = rawMetdataJSON.endpointMetadata;
  var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
  var InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
  InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
    metadataEntry.aliases.forEach((alias) => {
      InstanceDiscoveryMetadataAliases.add(alias);
    });
  });
  function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
    let staticAliases;
    const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
    if (canonicalAuthority) {
      const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
      staticAliases = getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) || staticAuthorityOptions.knownAuthorities;
    }
    return staticAliases || [];
  }
  function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
    logger?.trace(`getAliasesFromMetadata called with source: ${source}`);
    if (authorityHost && cloudDiscoveryMetadata) {
      const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
      if (metadata) {
        logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
        return metadata.aliases;
      } else {
        logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
      }
    }
    return null;
  }
  function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
    return metadata;
  }
  function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
    for (let i = 0; i < response.length; i++) {
      const metadata = response[i];
      if (metadata.aliases.includes(authorityHost)) {
        return metadata;
      }
    }
    return null;
  }

  // ../../node_modules/@azure/msal-common/dist/error/CacheError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cacheQuotaExceededErrorCode = "cache_quota_exceeded";
  var cacheUnknownErrorCode = "cache_error_unknown";

  // ../../node_modules/@azure/msal-common/dist/error/CacheError.mjs
  var CacheErrorMessages = {
    [cacheQuotaExceededErrorCode]: "Exceeded cache storage capacity.",
    [cacheUnknownErrorCode]: "Unexpected error occurred when using cache storage."
  };
  var CacheError = class _CacheError extends Error {
    constructor(errorCode, errorMessage) {
      const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheUnknownErrorCode]);
      super(`${errorCode}: ${message}`);
      Object.setPrototypeOf(this, _CacheError.prototype);
      this.name = "CacheError";
      this.errorCode = errorCode;
      this.errorMessage = message;
    }
  };

  // ../../node_modules/@azure/msal-common/dist/cache/CacheManager.mjs
  var CacheManager = class {
    constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {
      this.clientId = clientId;
      this.cryptoImpl = cryptoImpl;
      this.commonLogger = logger.clone(name17, version);
      this.staticAuthorityOptions = staticAuthorityOptions;
    }
    /**
     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
     * @param accountFilter - (Optional) filter to narrow down the accounts returned
     * @returns Array of AccountInfo objects in cache
     */
    getAllAccounts(accountFilter) {
      return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);
    }
    /**
     * Gets first tenanted AccountInfo object found based on provided filters
     */
    getAccountInfoFilteredBy(accountFilter) {
      const allAccounts = this.getAllAccounts(accountFilter);
      if (allAccounts.length > 1) {
        const sortedAccounts = allAccounts.sort((account) => {
          return account.idTokenClaims ? -1 : 1;
        });
        return sortedAccounts[0];
      } else if (allAccounts.length === 1) {
        return allAccounts[0];
      } else {
        return null;
      }
    }
    /**
     * Returns a single matching
     * @param accountFilter
     * @returns
     */
    getBaseAccountInfo(accountFilter) {
      const accountEntities = this.getAccountsFilteredBy(accountFilter);
      if (accountEntities.length > 0) {
        return accountEntities[0].getAccountInfo();
      } else {
        return null;
      }
    }
    /**
     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
     * and builds the account info objects from the matching ID token's claims
     * @param cachedAccounts
     * @param accountFilter
     * @returns Array of AccountInfo objects that match account and tenant profile filters
     */
    buildTenantProfiles(cachedAccounts, accountFilter) {
      return cachedAccounts.flatMap((accountEntity) => {
        return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter?.tenantId, accountFilter);
      });
    }
    getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {
      let tenantedAccountInfo = null;
      let idTokenClaims;
      if (tenantProfileFilter) {
        if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
          return null;
        }
      }
      const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);
      if (idToken) {
        idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
        if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
          return null;
        }
      }
      tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
      return tenantedAccountInfo;
    }
    getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {
      const accountInfo = accountEntity.getAccountInfo();
      let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
      const tokenKeys = this.getTokenKeys();
      if (targetTenantId) {
        const tenantProfile = searchTenantProfiles.get(targetTenantId);
        if (tenantProfile) {
          searchTenantProfiles = /* @__PURE__ */ new Map([
            [targetTenantId, tenantProfile]
          ]);
        } else {
          return [];
        }
      }
      const matchingTenantProfiles = [];
      searchTenantProfiles.forEach((tenantProfile) => {
        const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);
        if (tenantedAccountInfo) {
          matchingTenantProfiles.push(tenantedAccountInfo);
        }
      });
      return matchingTenantProfiles;
    }
    tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
      if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
        return false;
      }
      if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
        return false;
      }
      if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
        return false;
      }
      return true;
    }
    idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
      if (tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
          return false;
        }
        if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
          return false;
        }
        if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
          return false;
        }
      }
      return true;
    }
    /**
     * saves a cache record
     * @param cacheRecord {CacheRecord}
     * @param storeInCache {?StoreInCache}
     * @param correlationId {?string} correlation id
     */
    async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
      if (!cacheRecord) {
        throw createClientAuthError(invalidCacheRecord);
      }
      try {
        if (!!cacheRecord.account) {
          await this.setAccount(cacheRecord.account, correlationId);
        }
        if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
          await this.setIdTokenCredential(cacheRecord.idToken, correlationId);
        }
        if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
          await this.saveAccessToken(cacheRecord.accessToken, correlationId);
        }
        if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
          await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId);
        }
        if (!!cacheRecord.appMetadata) {
          this.setAppMetadata(cacheRecord.appMetadata);
        }
      } catch (e) {
        this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
        if (e instanceof Error) {
          this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e.message}`, correlationId);
          if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
            this.commonLogger?.error(`CacheManager.saveCacheRecord: exceeded storage quota`, correlationId);
            throw new CacheError(cacheQuotaExceededErrorCode);
          } else {
            throw new CacheError(e.name, e.message);
          }
        } else {
          this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e}`, correlationId);
          throw new CacheError(cacheUnknownErrorCode);
        }
      }
    }
    /**
     * saves access token credential
     * @param credential
     */
    async saveAccessToken(credential, correlationId) {
      const accessTokenFilter = {
        clientId: credential.clientId,
        credentialType: credential.credentialType,
        environment: credential.environment,
        homeAccountId: credential.homeAccountId,
        realm: credential.realm,
        tokenType: credential.tokenType,
        requestedClaimsHash: credential.requestedClaimsHash
      };
      const tokenKeys = this.getTokenKeys();
      const currentScopes = ScopeSet.fromString(credential.target);
      const removedAccessTokens = [];
      tokenKeys.accessToken.forEach((key) => {
        if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
          return;
        }
        const tokenEntity = this.getAccessTokenCredential(key);
        if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
          const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
          if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
            removedAccessTokens.push(this.removeAccessToken(key));
          }
        }
      });
      await Promise.all(removedAccessTokens);
      await this.setAccessTokenCredential(credential, correlationId);
    }
    /**
     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
     * @param accountFilter - An object containing Account properties to filter by
     */
    getAccountsFilteredBy(accountFilter) {
      const allAccountKeys = this.getAccountKeys();
      const matchingAccounts = [];
      allAccountKeys.forEach((cacheKey) => {
        if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {
          return;
        }
        const entity = this.getAccount(cacheKey, this.commonLogger);
        if (!entity) {
          return;
        }
        if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
          return;
        }
        if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
          return;
        }
        if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
          return;
        }
        if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
          return;
        }
        if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
          return;
        }
        if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
          return;
        }
        const tenantProfileFilter = {
          localAccountId: accountFilter?.localAccountId,
          name: accountFilter?.name
        };
        const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
          return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
        });
        if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
          return;
        }
        matchingAccounts.push(entity);
      });
      return matchingAccounts;
    }
    /**
     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided
     * @param key
     * @param homeAccountId
     * @param tenantId
     * @returns
     */
    isAccountKey(key, homeAccountId, tenantId) {
      if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
        return false;
      }
      if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {
        return false;
      }
      if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {
        return false;
      }
      return true;
    }
    /**
     * Returns true if the given key matches our credential key schema.
     * @param key
     */
    isCredentialKey(key) {
      if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
        return false;
      }
      const lowerCaseKey = key.toLowerCase();
      if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
        return false;
      }
      if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
        const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;
        const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;
        if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
          return false;
        }
      } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    }
    /**
     * Returns whether or not the given credential entity matches the filter
     * @param entity
     * @param filter
     * @returns
     */
    credentialMatchesFilter(entity, filter3) {
      if (!!filter3.clientId && !this.matchClientId(entity, filter3.clientId)) {
        return false;
      }
      if (!!filter3.userAssertionHash && !this.matchUserAssertionHash(entity, filter3.userAssertionHash)) {
        return false;
      }
      if (typeof filter3.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter3.homeAccountId)) {
        return false;
      }
      if (!!filter3.environment && !this.matchEnvironment(entity, filter3.environment)) {
        return false;
      }
      if (!!filter3.realm && !this.matchRealm(entity, filter3.realm)) {
        return false;
      }
      if (!!filter3.credentialType && !this.matchCredentialType(entity, filter3.credentialType)) {
        return false;
      }
      if (!!filter3.familyId && !this.matchFamilyId(entity, filter3.familyId)) {
        return false;
      }
      if (!!filter3.target && !this.matchTarget(entity, filter3.target)) {
        return false;
      }
      if (filter3.requestedClaimsHash || entity.requestedClaimsHash) {
        if (entity.requestedClaimsHash !== filter3.requestedClaimsHash) {
          return false;
        }
      }
      if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
        if (!!filter3.tokenType && !this.matchTokenType(entity, filter3.tokenType)) {
          return false;
        }
        if (filter3.tokenType === AuthenticationScheme.SSH) {
          if (filter3.keyId && !this.matchKeyId(entity, filter3.keyId)) {
            return false;
          }
        }
      }
      return true;
    }
    /**
     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
     * @param filter
     */
    getAppMetadataFilteredBy(filter3) {
      const allCacheKeys = this.getKeys();
      const matchingAppMetadata = {};
      allCacheKeys.forEach((cacheKey) => {
        if (!this.isAppMetadata(cacheKey)) {
          return;
        }
        const entity = this.getAppMetadata(cacheKey);
        if (!entity) {
          return;
        }
        if (!!filter3.environment && !this.matchEnvironment(entity, filter3.environment)) {
          return;
        }
        if (!!filter3.clientId && !this.matchClientId(entity, filter3.clientId)) {
          return;
        }
        matchingAppMetadata[cacheKey] = entity;
      });
      return matchingAppMetadata;
    }
    /**
     * retrieve authorityMetadata that contains a matching alias
     * @param filter
     */
    getAuthorityMetadataByAlias(host) {
      const allCacheKeys = this.getAuthorityMetadataKeys();
      let matchedEntity = null;
      allCacheKeys.forEach((cacheKey) => {
        if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
          return;
        }
        const entity = this.getAuthorityMetadata(cacheKey);
        if (!entity) {
          return;
        }
        if (entity.aliases.indexOf(host) === -1) {
          return;
        }
        matchedEntity = entity;
      });
      return matchedEntity;
    }
    /**
     * Removes all accounts and related tokens from cache.
     */
    async removeAllAccounts() {
      const allAccountKeys = this.getAccountKeys();
      const removedAccounts = [];
      allAccountKeys.forEach((cacheKey) => {
        removedAccounts.push(this.removeAccount(cacheKey));
      });
      await Promise.all(removedAccounts);
    }
    /**
     * Removes the account and related tokens for a given account key
     * @param account
     */
    async removeAccount(accountKey) {
      const account = this.getAccount(accountKey, this.commonLogger);
      if (!account) {
        return;
      }
      await this.removeAccountContext(account);
      this.removeItem(accountKey);
    }
    /**
     * Removes credentials associated with the provided account
     * @param account
     */
    async removeAccountContext(account) {
      const allTokenKeys = this.getTokenKeys();
      const accountId = account.generateAccountId();
      const removedCredentials = [];
      allTokenKeys.idToken.forEach((key) => {
        if (key.indexOf(accountId) === 0) {
          this.removeIdToken(key);
        }
      });
      allTokenKeys.accessToken.forEach((key) => {
        if (key.indexOf(accountId) === 0) {
          removedCredentials.push(this.removeAccessToken(key));
        }
      });
      allTokenKeys.refreshToken.forEach((key) => {
        if (key.indexOf(accountId) === 0) {
          this.removeRefreshToken(key);
        }
      });
      await Promise.all(removedCredentials);
    }
    /**
     * returns a boolean if the given credential is removed
     * @param credential
     */
    async removeAccessToken(key) {
      const credential = this.getAccessTokenCredential(key);
      if (!credential) {
        return;
      }
      if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {
        if (credential.tokenType === AuthenticationScheme.POP) {
          const accessTokenWithAuthSchemeEntity = credential;
          const kid = accessTokenWithAuthSchemeEntity.keyId;
          if (kid) {
            try {
              await this.cryptoImpl.removeTokenBindingKey(kid);
            } catch (error) {
              throw createClientAuthError(bindingKeyNotRemoved);
            }
          }
        }
      }
      return this.removeItem(key);
    }
    /**
     * Removes all app metadata objects from cache.
     */
    removeAppMetadata() {
      const allCacheKeys = this.getKeys();
      allCacheKeys.forEach((cacheKey) => {
        if (this.isAppMetadata(cacheKey)) {
          this.removeItem(cacheKey);
        }
      });
      return true;
    }
    /**
     * Retrieve AccountEntity from cache
     * @param account
     */
    readAccountFromCache(account) {
      const accountKey = AccountEntity.generateAccountCacheKey(account);
      return this.getAccount(accountKey, this.commonLogger);
    }
    /**
     * Retrieve IdTokenEntity from cache
     * @param account {AccountInfo}
     * @param tokenKeys {?TokenKeys}
     * @param targetRealm {?string}
     * @param performanceClient {?IPerformanceClient}
     * @param correlationId {?string}
     */
    getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {
      this.commonLogger.trace("CacheManager - getIdToken called");
      const idTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType: CredentialType.ID_TOKEN,
        clientId: this.clientId,
        realm: targetRealm
      };
      const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);
      const numIdTokens = idTokenMap.size;
      if (numIdTokens < 1) {
        this.commonLogger.info("CacheManager:getIdToken - No token found");
        return null;
      } else if (numIdTokens > 1) {
        let tokensToBeRemoved = idTokenMap;
        if (!targetRealm) {
          const homeIdTokenMap = /* @__PURE__ */ new Map();
          idTokenMap.forEach((idToken, key) => {
            if (idToken.realm === account.tenantId) {
              homeIdTokenMap.set(key, idToken);
            }
          });
          const numHomeIdTokens = homeIdTokenMap.size;
          if (numHomeIdTokens < 1) {
            this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
            return idTokenMap.values().next().value;
          } else if (numHomeIdTokens === 1) {
            this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
            return homeIdTokenMap.values().next().value;
          } else {
            tokensToBeRemoved = homeIdTokenMap;
          }
        }
        this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
        tokensToBeRemoved.forEach((idToken, key) => {
          this.removeIdToken(key);
        });
        if (performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
        }
        return null;
      }
      this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
      return idTokenMap.values().next().value;
    }
    /**
     * Gets all idTokens matching the given filter
     * @param filter
     * @returns
     */
    getIdTokensByFilter(filter3, tokenKeys) {
      const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
      const idTokens = /* @__PURE__ */ new Map();
      idTokenKeys.forEach((key) => {
        if (!this.idTokenKeyMatchesFilter(key, {
          clientId: this.clientId,
          ...filter3
        })) {
          return;
        }
        const idToken = this.getIdTokenCredential(key);
        if (idToken && this.credentialMatchesFilter(idToken, filter3)) {
          idTokens.set(key, idToken);
        }
      });
      return idTokens;
    }
    /**
     * Validate the cache key against filter before retrieving and parsing cache value
     * @param key
     * @param filter
     * @returns
     */
    idTokenKeyMatchesFilter(inputKey, filter3) {
      const key = inputKey.toLowerCase();
      if (filter3.clientId && key.indexOf(filter3.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.homeAccountId && key.indexOf(filter3.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    }
    /**
     * Removes idToken from the cache
     * @param key
     */
    removeIdToken(key) {
      this.removeItem(key);
    }
    /**
     * Removes refresh token from the cache
     * @param key
     */
    removeRefreshToken(key) {
      this.removeItem(key);
    }
    /**
     * Retrieve AccessTokenEntity from cache
     * @param account {AccountInfo}
     * @param request {BaseAuthRequest}
     * @param tokenKeys {?TokenKeys}
     * @param performanceClient {?IPerformanceClient}
     * @param correlationId {?string}
     */
    getAccessToken(account, request, tokenKeys, targetRealm, performanceClient, correlationId) {
      this.commonLogger.trace("CacheManager - getAccessToken called");
      const scopes = ScopeSet.createSearchScopes(request.scopes);
      const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
      const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
      const accessTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType,
        clientId: this.clientId,
        realm: targetRealm || account.tenantId,
        target: scopes,
        tokenType: authScheme,
        keyId: request.sshKid,
        requestedClaimsHash: request.requestedClaimsHash
      };
      const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
      const accessTokens = [];
      accessTokenKeys.forEach((key) => {
        if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
          const accessToken = this.getAccessTokenCredential(key);
          if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
            accessTokens.push(accessToken);
          }
        }
      });
      const numAccessTokens = accessTokens.length;
      if (numAccessTokens < 1) {
        this.commonLogger.info("CacheManager:getAccessToken - No token found");
        return null;
      } else if (numAccessTokens > 1) {
        this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");
        accessTokens.forEach((accessToken) => {
          void this.removeAccessToken(generateCredentialKey(accessToken));
        });
        if (performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
        }
        return null;
      }
      this.commonLogger.info("CacheManager:getAccessToken - Returning access token");
      return accessTokens[0];
    }
    /**
     * Validate the cache key against filter before retrieving and parsing cache value
     * @param key
     * @param filter
     * @param keyMustContainAllScopes
     * @returns
     */
    accessTokenKeyMatchesFilter(inputKey, filter3, keyMustContainAllScopes) {
      const key = inputKey.toLowerCase();
      if (filter3.clientId && key.indexOf(filter3.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.homeAccountId && key.indexOf(filter3.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.realm && key.indexOf(filter3.realm.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.requestedClaimsHash && key.indexOf(filter3.requestedClaimsHash.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.target) {
        const scopes = filter3.target.asArray();
        for (let i = 0; i < scopes.length; i++) {
          if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
            return false;
          } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
            return true;
          }
        }
      }
      return true;
    }
    /**
     * Gets all access tokens matching the filter
     * @param filter
     * @returns
     */
    getAccessTokensByFilter(filter3) {
      const tokenKeys = this.getTokenKeys();
      const accessTokens = [];
      tokenKeys.accessToken.forEach((key) => {
        if (!this.accessTokenKeyMatchesFilter(key, filter3, true)) {
          return;
        }
        const accessToken = this.getAccessTokenCredential(key);
        if (accessToken && this.credentialMatchesFilter(accessToken, filter3)) {
          accessTokens.push(accessToken);
        }
      });
      return accessTokens;
    }
    /**
     * Helper to retrieve the appropriate refresh token from cache
     * @param account {AccountInfo}
     * @param familyRT {boolean}
     * @param tokenKeys {?TokenKeys}
     * @param performanceClient {?IPerformanceClient}
     * @param correlationId {?string}
     */
    getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {
      this.commonLogger.trace("CacheManager - getRefreshToken called");
      const id = familyRT ? THE_FAMILY_ID : void 0;
      const refreshTokenFilter = {
        homeAccountId: account.homeAccountId,
        environment: account.environment,
        credentialType: CredentialType.REFRESH_TOKEN,
        clientId: this.clientId,
        familyId: id
      };
      const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
      const refreshTokens = [];
      refreshTokenKeys.forEach((key) => {
        if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
          const refreshToken = this.getRefreshTokenCredential(key);
          if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
            refreshTokens.push(refreshToken);
          }
        }
      });
      const numRefreshTokens = refreshTokens.length;
      if (numRefreshTokens < 1) {
        this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
        return null;
      }
      if (numRefreshTokens > 1 && performanceClient && correlationId) {
        performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
      }
      this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
      return refreshTokens[0];
    }
    /**
     * Validate the cache key against filter before retrieving and parsing cache value
     * @param key
     * @param filter
     */
    refreshTokenKeyMatchesFilter(inputKey, filter3) {
      const key = inputKey.toLowerCase();
      if (filter3.familyId && key.indexOf(filter3.familyId.toLowerCase()) === -1) {
        return false;
      }
      if (!filter3.familyId && filter3.clientId && key.indexOf(filter3.clientId.toLowerCase()) === -1) {
        return false;
      }
      if (filter3.homeAccountId && key.indexOf(filter3.homeAccountId.toLowerCase()) === -1) {
        return false;
      }
      return true;
    }
    /**
     * Retrieve AppMetadataEntity from cache
     */
    readAppMetadataFromCache(environment) {
      const appMetadataFilter = {
        environment,
        clientId: this.clientId
      };
      const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
      const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
      const numAppMetadata = appMetadataEntries.length;
      if (numAppMetadata < 1) {
        return null;
      } else if (numAppMetadata > 1) {
        throw createClientAuthError(multipleMatchingAppMetadata);
      }
      return appMetadataEntries[0];
    }
    /**
     * Return the family_id value associated  with FOCI
     * @param environment
     * @param clientId
     */
    isAppMetadataFOCI(environment) {
      const appMetadata = this.readAppMetadataFromCache(environment);
      return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
    }
    /**
     * helper to match account ids
     * @param value
     * @param homeAccountId
     */
    matchHomeAccountId(entity, homeAccountId) {
      return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
    }
    /**
     * helper to match account ids
     * @param entity
     * @param localAccountId
     * @returns
     */
    matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
      const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
      return localAccountId === idTokenLocalAccountId;
    }
    matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
      return tenantProfile.localAccountId === localAccountId;
    }
    /**
     * helper to match names
     * @param entity
     * @param name
     * @returns true if the downcased name properties are present and match in the filter and the entity
     */
    matchName(claims, name21) {
      return !!(name21.toLowerCase() === claims.name?.toLowerCase());
    }
    /**
     * helper to match usernames
     * @param entity
     * @param username
     * @returns
     */
    matchUsername(cachedUsername, filterUsername) {
      return !!(cachedUsername && typeof cachedUsername === "string" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
    }
    /**
     * helper to match assertion
     * @param value
     * @param oboAssertion
     */
    matchUserAssertionHash(entity, userAssertionHash) {
      return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
    }
    /**
     * helper to match environment
     * @param value
     * @param environment
     */
    matchEnvironment(entity, environment) {
      if (this.staticAuthorityOptions) {
        const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
        if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
          return true;
        }
      }
      const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
      if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
        return true;
      }
      return false;
    }
    /**
     * helper to match credential type
     * @param entity
     * @param credentialType
     */
    matchCredentialType(entity, credentialType) {
      return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
    }
    /**
     * helper to match client ids
     * @param entity
     * @param clientId
     */
    matchClientId(entity, clientId) {
      return !!(entity.clientId && clientId === entity.clientId);
    }
    /**
     * helper to match family ids
     * @param entity
     * @param familyId
     */
    matchFamilyId(entity, familyId) {
      return !!(entity.familyId && familyId === entity.familyId);
    }
    /**
     * helper to match realm
     * @param entity
     * @param realm
     */
    matchRealm(entity, realm) {
      return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
    }
    /**
     * helper to match nativeAccountId
     * @param entity
     * @param nativeAccountId
     * @returns boolean indicating the match result
     */
    matchNativeAccountId(entity, nativeAccountId) {
      return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
    }
    /**
     * helper to match loginHint which can be either:
     * 1. login_hint ID token claim
     * 2. username in cached account object
     * 3. upn in ID token claims
     * @param entity
     * @param loginHint
     * @returns
     */
    matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
      if (tokenClaims.login_hint === loginHint) {
        return true;
      }
      if (tokenClaims.preferred_username === loginHint) {
        return true;
      }
      if (tokenClaims.upn === loginHint) {
        return true;
      }
      return false;
    }
    /**
     * Helper to match sid
     * @param entity
     * @param sid
     * @returns true if the sid claim is present and matches the filter
     */
    matchSid(idTokenClaims, sid) {
      return idTokenClaims.sid === sid;
    }
    matchAuthorityType(entity, authorityType) {
      return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
    }
    /**
     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
     * @param entity
     * @param target
     */
    matchTarget(entity, target) {
      const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
      if (isNotAccessTokenCredential || !entity.target) {
        return false;
      }
      const entityScopeSet = ScopeSet.fromString(entity.target);
      return entityScopeSet.containsScopeSet(target);
    }
    /**
     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
     * @param entity
     * @param tokenType
     */
    matchTokenType(entity, tokenType) {
      return !!(entity.tokenType && entity.tokenType === tokenType);
    }
    /**
     * Returns true if the credential's keyId matches the one in the request, false otherwise
     * @param entity
     * @param keyId
     */
    matchKeyId(entity, keyId) {
      return !!(entity.keyId && entity.keyId === keyId);
    }
    /**
     * returns if a given cache entity is of the type appmetadata
     * @param key
     */
    isAppMetadata(key) {
      return key.indexOf(APP_METADATA) !== -1;
    }
    /**
     * returns if a given cache entity is of the type authoritymetadata
     * @param key
     */
    isAuthorityMetadata(key) {
      return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
    }
    /**
     * returns cache key used for cloud instance metadata
     */
    generateAuthorityMetadataCacheKey(authority) {
      return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
    }
    /**
     * Helper to convert serialized data to object
     * @param obj
     * @param json
     */
    static toObject(obj, json) {
      for (const propertyName in json) {
        obj[propertyName] = json[propertyName];
      }
      return obj;
    }
  };
  var DefaultStorageClass = class extends CacheManager {
    async setAccount() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAccount() {
      throw createClientAuthError(methodNotImplemented);
    }
    async setIdTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    getIdTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    async setAccessTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAccessTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    async setRefreshTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    getRefreshTokenCredential() {
      throw createClientAuthError(methodNotImplemented);
    }
    setAppMetadata() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAppMetadata() {
      throw createClientAuthError(methodNotImplemented);
    }
    setServerTelemetry() {
      throw createClientAuthError(methodNotImplemented);
    }
    getServerTelemetry() {
      throw createClientAuthError(methodNotImplemented);
    }
    setAuthorityMetadata() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAuthorityMetadata() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAuthorityMetadataKeys() {
      throw createClientAuthError(methodNotImplemented);
    }
    setThrottlingCache() {
      throw createClientAuthError(methodNotImplemented);
    }
    getThrottlingCache() {
      throw createClientAuthError(methodNotImplemented);
    }
    removeItem() {
      throw createClientAuthError(methodNotImplemented);
    }
    getKeys() {
      throw createClientAuthError(methodNotImplemented);
    }
    getAccountKeys() {
      throw createClientAuthError(methodNotImplemented);
    }
    getTokenKeys() {
      throw createClientAuthError(methodNotImplemented);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs
  var DEFAULT_SYSTEM_OPTIONS = {
    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
    preventCorsPreflight: false
  };
  var DEFAULT_LOGGER_IMPLEMENTATION = {
    loggerCallback: () => {
    },
    piiLoggingEnabled: false,
    logLevel: LogLevel.Info,
    correlationId: Constants.EMPTY_STRING
  };
  var DEFAULT_CACHE_OPTIONS = {
    claimsBasedCachingEnabled: false
  };
  var DEFAULT_NETWORK_IMPLEMENTATION = {
    async sendGetRequestAsync() {
      throw createClientAuthError(methodNotImplemented);
    },
    async sendPostRequestAsync() {
      throw createClientAuthError(methodNotImplemented);
    }
  };
  var DEFAULT_LIBRARY_INFO = {
    sku: Constants.SKU,
    version,
    cpu: Constants.EMPTY_STRING,
    os: Constants.EMPTY_STRING
  };
  var DEFAULT_CLIENT_CREDENTIALS = {
    clientSecret: Constants.EMPTY_STRING,
    clientAssertion: void 0
  };
  var DEFAULT_AZURE_CLOUD_OPTIONS = {
    azureCloudInstance: AzureCloudInstance.None,
    tenant: `${Constants.DEFAULT_COMMON_TENANT}`
  };
  var DEFAULT_TELEMETRY_OPTIONS = {
    application: {
      appName: "",
      appVersion: ""
    }
  };
  function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
    const loggerOptions = {
      ...DEFAULT_LOGGER_IMPLEMENTATION,
      ...userLoggerOption
    };
    return {
      authOptions: buildAuthOptions(userAuthOptions),
      systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
      loggerOptions,
      cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
      storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions)),
      networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
      cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
      clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
      libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
      telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
      serverTelemetryManager: serverTelemetryManager || null,
      persistencePlugin: persistencePlugin || null,
      serializableCache: serializableCache || null
    };
  }
  function buildAuthOptions(authOptions) {
    return {
      clientCapabilities: [],
      azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
      skipAuthorityMetadataCache: false,
      instanceAware: false,
      encodeExtraQueryParams: false,
      ...authOptions
    };
  }
  function isOidcProtocolMode(config) {
    return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
  }

  // ../../node_modules/@azure/msal-common/dist/account/CcsCredential.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var CcsCredentialType = {
    HOME_ACCOUNT_ID: "home_account_id",
    UPN: "UPN"
  };

  // ../../node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
  var RequestParameterBuilder_exports = {};
  __export(RequestParameterBuilder_exports, {
    addApplicationTelemetry: () => addApplicationTelemetry,
    addAuthorizationCode: () => addAuthorizationCode,
    addBrokerParameters: () => addBrokerParameters,
    addCcsOid: () => addCcsOid,
    addCcsUpn: () => addCcsUpn,
    addClaims: () => addClaims,
    addClientAssertion: () => addClientAssertion,
    addClientAssertionType: () => addClientAssertionType,
    addClientCapabilitiesToClaims: () => addClientCapabilitiesToClaims,
    addClientId: () => addClientId,
    addClientInfo: () => addClientInfo,
    addClientSecret: () => addClientSecret,
    addCodeChallengeParams: () => addCodeChallengeParams,
    addCodeVerifier: () => addCodeVerifier,
    addCorrelationId: () => addCorrelationId,
    addDeviceCode: () => addDeviceCode,
    addDomainHint: () => addDomainHint,
    addEARParameters: () => addEARParameters,
    addExtraQueryParameters: () => addExtraQueryParameters,
    addGrantType: () => addGrantType,
    addIdTokenHint: () => addIdTokenHint,
    addInstanceAware: () => addInstanceAware,
    addLibraryInfo: () => addLibraryInfo,
    addLoginHint: () => addLoginHint,
    addLogoutHint: () => addLogoutHint,
    addNativeBroker: () => addNativeBroker,
    addNonce: () => addNonce,
    addOboAssertion: () => addOboAssertion,
    addPassword: () => addPassword,
    addPopToken: () => addPopToken,
    addPostLogoutRedirectUri: () => addPostLogoutRedirectUri,
    addPrompt: () => addPrompt,
    addRedirectUri: () => addRedirectUri,
    addRefreshToken: () => addRefreshToken,
    addRequestTokenUse: () => addRequestTokenUse,
    addResponseMode: () => addResponseMode,
    addResponseType: () => addResponseType,
    addScopes: () => addScopes,
    addServerTelemetry: () => addServerTelemetry,
    addSid: () => addSid,
    addSshJwk: () => addSshJwk,
    addState: () => addState,
    addThrottling: () => addThrottling,
    addUsername: () => addUsername,
    instrumentBrokerParams: () => instrumentBrokerParams
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs
  var AADServerParamKeys_exports = {};
  __export(AADServerParamKeys_exports, {
    ACCESS_TOKEN: () => ACCESS_TOKEN,
    BROKER_CLIENT_ID: () => BROKER_CLIENT_ID,
    BROKER_REDIRECT_URI: () => BROKER_REDIRECT_URI,
    CCS_HEADER: () => CCS_HEADER,
    CLAIMS: () => CLAIMS,
    CLIENT_ASSERTION: () => CLIENT_ASSERTION,
    CLIENT_ASSERTION_TYPE: () => CLIENT_ASSERTION_TYPE,
    CLIENT_ID: () => CLIENT_ID,
    CLIENT_INFO: () => CLIENT_INFO2,
    CLIENT_REQUEST_ID: () => CLIENT_REQUEST_ID,
    CLIENT_SECRET: () => CLIENT_SECRET,
    CODE: () => CODE,
    CODE_CHALLENGE: () => CODE_CHALLENGE,
    CODE_CHALLENGE_METHOD: () => CODE_CHALLENGE_METHOD,
    CODE_VERIFIER: () => CODE_VERIFIER,
    DEVICE_CODE: () => DEVICE_CODE,
    DOMAIN_HINT: () => DOMAIN_HINT,
    EAR_JWE_CRYPTO: () => EAR_JWE_CRYPTO,
    EAR_JWK: () => EAR_JWK,
    ERROR: () => ERROR,
    ERROR_DESCRIPTION: () => ERROR_DESCRIPTION,
    EXPIRES_IN: () => EXPIRES_IN,
    FOCI: () => FOCI,
    GRANT_TYPE: () => GRANT_TYPE,
    ID_TOKEN: () => ID_TOKEN,
    ID_TOKEN_HINT: () => ID_TOKEN_HINT,
    INSTANCE_AWARE: () => INSTANCE_AWARE,
    LOGIN_HINT: () => LOGIN_HINT,
    LOGOUT_HINT: () => LOGOUT_HINT,
    NATIVE_BROKER: () => NATIVE_BROKER,
    NONCE: () => NONCE,
    OBO_ASSERTION: () => OBO_ASSERTION,
    ON_BEHALF_OF: () => ON_BEHALF_OF,
    POST_LOGOUT_URI: () => POST_LOGOUT_URI,
    PROMPT: () => PROMPT,
    REDIRECT_URI: () => REDIRECT_URI,
    REFRESH_TOKEN: () => REFRESH_TOKEN,
    REFRESH_TOKEN_EXPIRES_IN: () => REFRESH_TOKEN_EXPIRES_IN,
    REQUESTED_TOKEN_USE: () => REQUESTED_TOKEN_USE,
    REQ_CNF: () => REQ_CNF,
    RESPONSE_MODE: () => RESPONSE_MODE,
    RESPONSE_TYPE: () => RESPONSE_TYPE,
    RETURN_SPA_CODE: () => RETURN_SPA_CODE,
    SCOPE: () => SCOPE,
    SESSION_STATE: () => SESSION_STATE,
    SID: () => SID,
    STATE: () => STATE,
    TOKEN_TYPE: () => TOKEN_TYPE,
    X_APP_NAME: () => X_APP_NAME,
    X_APP_VER: () => X_APP_VER,
    X_CLIENT_CPU: () => X_CLIENT_CPU,
    X_CLIENT_CURR_TELEM: () => X_CLIENT_CURR_TELEM,
    X_CLIENT_EXTRA_SKU: () => X_CLIENT_EXTRA_SKU,
    X_CLIENT_LAST_TELEM: () => X_CLIENT_LAST_TELEM,
    X_CLIENT_OS: () => X_CLIENT_OS,
    X_CLIENT_SKU: () => X_CLIENT_SKU,
    X_CLIENT_VER: () => X_CLIENT_VER,
    X_MS_LIB_CAPABILITY: () => X_MS_LIB_CAPABILITY
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var CLIENT_ID = "client_id";
  var REDIRECT_URI = "redirect_uri";
  var RESPONSE_TYPE = "response_type";
  var RESPONSE_MODE = "response_mode";
  var GRANT_TYPE = "grant_type";
  var CLAIMS = "claims";
  var SCOPE = "scope";
  var ERROR = "error";
  var ERROR_DESCRIPTION = "error_description";
  var ACCESS_TOKEN = "access_token";
  var ID_TOKEN = "id_token";
  var REFRESH_TOKEN = "refresh_token";
  var EXPIRES_IN = "expires_in";
  var REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
  var STATE = "state";
  var NONCE = "nonce";
  var PROMPT = "prompt";
  var SESSION_STATE = "session_state";
  var CLIENT_INFO2 = "client_info";
  var CODE = "code";
  var CODE_CHALLENGE = "code_challenge";
  var CODE_CHALLENGE_METHOD = "code_challenge_method";
  var CODE_VERIFIER = "code_verifier";
  var CLIENT_REQUEST_ID = "client-request-id";
  var X_CLIENT_SKU = "x-client-SKU";
  var X_CLIENT_VER = "x-client-VER";
  var X_CLIENT_OS = "x-client-OS";
  var X_CLIENT_CPU = "x-client-CPU";
  var X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
  var X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
  var X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
  var X_APP_NAME = "x-app-name";
  var X_APP_VER = "x-app-ver";
  var POST_LOGOUT_URI = "post_logout_redirect_uri";
  var ID_TOKEN_HINT = "id_token_hint";
  var DEVICE_CODE = "device_code";
  var CLIENT_SECRET = "client_secret";
  var CLIENT_ASSERTION = "client_assertion";
  var CLIENT_ASSERTION_TYPE = "client_assertion_type";
  var TOKEN_TYPE = "token_type";
  var REQ_CNF = "req_cnf";
  var OBO_ASSERTION = "assertion";
  var REQUESTED_TOKEN_USE = "requested_token_use";
  var ON_BEHALF_OF = "on_behalf_of";
  var FOCI = "foci";
  var CCS_HEADER = "X-AnchorMailbox";
  var RETURN_SPA_CODE = "return_spa_code";
  var NATIVE_BROKER = "nativebroker";
  var LOGOUT_HINT = "logout_hint";
  var SID = "sid";
  var LOGIN_HINT = "login_hint";
  var DOMAIN_HINT = "domain_hint";
  var X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
  var BROKER_CLIENT_ID = "brk_client_id";
  var BROKER_REDIRECT_URI = "brk_redirect_uri";
  var INSTANCE_AWARE = "instance_aware";
  var EAR_JWK = "ear_jwk";
  var EAR_JWE_CRYPTO = "ear_jwe_crypto";

  // ../../node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs
  function instrumentBrokerParams(parameters, correlationId, performanceClient) {
    if (!correlationId) {
      return;
    }
    const clientId = parameters.get(CLIENT_ID);
    if (clientId && parameters.has(BROKER_CLIENT_ID)) {
      performanceClient?.addFields({
        embeddedClientId: clientId,
        embeddedRedirectUri: parameters.get(REDIRECT_URI)
      }, correlationId);
    }
  }
  function addResponseType(parameters, responseType) {
    parameters.set(RESPONSE_TYPE, responseType);
  }
  function addResponseMode(parameters, responseMode) {
    parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
  }
  function addNativeBroker(parameters) {
    parameters.set(NATIVE_BROKER, "1");
  }
  function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
    if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
      defaultScopes.push("openid");
    }
    const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
    const scopeSet = new ScopeSet(requestScopes);
    parameters.set(SCOPE, scopeSet.printScopes());
  }
  function addClientId(parameters, clientId) {
    parameters.set(CLIENT_ID, clientId);
  }
  function addRedirectUri(parameters, redirectUri) {
    parameters.set(REDIRECT_URI, redirectUri);
  }
  function addPostLogoutRedirectUri(parameters, redirectUri) {
    parameters.set(POST_LOGOUT_URI, redirectUri);
  }
  function addIdTokenHint(parameters, idTokenHint) {
    parameters.set(ID_TOKEN_HINT, idTokenHint);
  }
  function addDomainHint(parameters, domainHint) {
    parameters.set(DOMAIN_HINT, domainHint);
  }
  function addLoginHint(parameters, loginHint) {
    parameters.set(LOGIN_HINT, loginHint);
  }
  function addCcsUpn(parameters, loginHint) {
    parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
  }
  function addCcsOid(parameters, clientInfo) {
    parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
  }
  function addSid(parameters, sid) {
    parameters.set(SID, sid);
  }
  function addClaims(parameters, claims, clientCapabilities) {
    const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
    try {
      JSON.parse(mergedClaims);
    } catch (e) {
      throw createClientConfigurationError(invalidClaims);
    }
    parameters.set(CLAIMS, mergedClaims);
  }
  function addCorrelationId(parameters, correlationId) {
    parameters.set(CLIENT_REQUEST_ID, correlationId);
  }
  function addLibraryInfo(parameters, libraryInfo) {
    parameters.set(X_CLIENT_SKU, libraryInfo.sku);
    parameters.set(X_CLIENT_VER, libraryInfo.version);
    if (libraryInfo.os) {
      parameters.set(X_CLIENT_OS, libraryInfo.os);
    }
    if (libraryInfo.cpu) {
      parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
    }
  }
  function addApplicationTelemetry(parameters, appTelemetry) {
    if (appTelemetry?.appName) {
      parameters.set(X_APP_NAME, appTelemetry.appName);
    }
    if (appTelemetry?.appVersion) {
      parameters.set(X_APP_VER, appTelemetry.appVersion);
    }
  }
  function addPrompt(parameters, prompt) {
    parameters.set(PROMPT, prompt);
  }
  function addState(parameters, state) {
    if (state) {
      parameters.set(STATE, state);
    }
  }
  function addNonce(parameters, nonce) {
    parameters.set(NONCE, nonce);
  }
  function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
    if (codeChallenge && codeChallengeMethod) {
      parameters.set(CODE_CHALLENGE, codeChallenge);
      parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
    } else {
      throw createClientConfigurationError(pkceParamsMissing);
    }
  }
  function addAuthorizationCode(parameters, code4) {
    parameters.set(CODE, code4);
  }
  function addDeviceCode(parameters, code4) {
    parameters.set(DEVICE_CODE, code4);
  }
  function addRefreshToken(parameters, refreshToken) {
    parameters.set(REFRESH_TOKEN, refreshToken);
  }
  function addCodeVerifier(parameters, codeVerifier) {
    parameters.set(CODE_VERIFIER, codeVerifier);
  }
  function addClientSecret(parameters, clientSecret) {
    parameters.set(CLIENT_SECRET, clientSecret);
  }
  function addClientAssertion(parameters, clientAssertion) {
    if (clientAssertion) {
      parameters.set(CLIENT_ASSERTION, clientAssertion);
    }
  }
  function addClientAssertionType(parameters, clientAssertionType) {
    if (clientAssertionType) {
      parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
    }
  }
  function addOboAssertion(parameters, oboAssertion) {
    parameters.set(OBO_ASSERTION, oboAssertion);
  }
  function addRequestTokenUse(parameters, tokenUse) {
    parameters.set(REQUESTED_TOKEN_USE, tokenUse);
  }
  function addGrantType(parameters, grantType) {
    parameters.set(GRANT_TYPE, grantType);
  }
  function addClientInfo(parameters) {
    parameters.set(CLIENT_INFO, "1");
  }
  function addInstanceAware(parameters) {
    if (!parameters.has(INSTANCE_AWARE)) {
      parameters.set(INSTANCE_AWARE, "true");
    }
  }
  function addExtraQueryParameters(parameters, eQParams) {
    Object.entries(eQParams).forEach(([key, value]) => {
      if (!parameters.has(key) && value) {
        parameters.set(key, value);
      }
    });
  }
  function addClientCapabilitiesToClaims(claims, clientCapabilities) {
    let mergedClaims;
    if (!claims) {
      mergedClaims = {};
    } else {
      try {
        mergedClaims = JSON.parse(claims);
      } catch (e) {
        throw createClientConfigurationError(invalidClaims);
      }
    }
    if (clientCapabilities && clientCapabilities.length > 0) {
      if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
      }
      mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
        values: clientCapabilities
      };
    }
    return JSON.stringify(mergedClaims);
  }
  function addUsername(parameters, username) {
    parameters.set(PasswordGrantConstants.username, username);
  }
  function addPassword(parameters, password) {
    parameters.set(PasswordGrantConstants.password, password);
  }
  function addPopToken(parameters, cnfString) {
    if (cnfString) {
      parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
      parameters.set(REQ_CNF, cnfString);
    }
  }
  function addSshJwk(parameters, sshJwkString) {
    if (sshJwkString) {
      parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
      parameters.set(REQ_CNF, sshJwkString);
    }
  }
  function addServerTelemetry(parameters, serverTelemetryManager) {
    parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
    parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
  }
  function addThrottling(parameters) {
    parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
  }
  function addLogoutHint(parameters, logoutHint) {
    parameters.set(LOGOUT_HINT, logoutHint);
  }
  function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
    if (!parameters.has(BROKER_CLIENT_ID)) {
      parameters.set(BROKER_CLIENT_ID, brokerClientId);
    }
    if (!parameters.has(BROKER_REDIRECT_URI)) {
      parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
    }
  }
  function addEARParameters(parameters, jwk) {
    parameters.set(EAR_JWK, encodeURIComponent(jwk));
    const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
    parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
  }

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
  var AuthorityFactory_exports = {};
  __export(AuthorityFactory_exports, {
    createDiscoveredInstance: () => createDiscoveredInstance
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/authority/Authority.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isOpenIdConfigResponse(response) {
    return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
  }

  // ../../node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isCloudInstanceDiscoveryResponse(response) {
    return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
  }

  // ../../node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isCloudInstanceDiscoveryErrorResponse(response) {
    return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
  }

  // ../../node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var PerformanceEvents = {
    /**
     * acquireTokenByCode API (msal-browser and msal-node).
     * Used to acquire tokens by trading an authorization code against the token endpoint.
     */
    AcquireTokenByCode: "acquireTokenByCode",
    /**
     * acquireTokenByRefreshToken API (msal-browser and msal-node).
     * Used to renew an access token using a refresh token against the token endpoint.
     */
    AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
    /**
     * acquireTokenSilent API (msal-browser and msal-node).
     * Used to silently acquire a new access token (from the cache or the network).
     */
    AcquireTokenSilent: "acquireTokenSilent",
    /**
     * acquireTokenSilentAsync (msal-browser).
     * Internal API for acquireTokenSilent.
     */
    AcquireTokenSilentAsync: "acquireTokenSilentAsync",
    /**
     * acquireTokenPopup (msal-browser).
     * Used to acquire a new access token interactively through pop ups
     */
    AcquireTokenPopup: "acquireTokenPopup",
    /**
     * acquireTokenPreRedirect (msal-browser).
     * First part of the redirect flow.
     * Used to acquire a new access token interactively through redirects.
     */
    AcquireTokenPreRedirect: "acquireTokenPreRedirect",
    /**
     * acquireTokenRedirect (msal-browser).
     * Second part of the redirect flow.
     * Used to acquire a new access token interactively through redirects.
     */
    AcquireTokenRedirect: "acquireTokenRedirect",
    /**
     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
     */
    CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
    /**
     * signJwt API in CryptoOpts class (msal-browser).
     * Used to signed a pop token.
     */
    CryptoOptsSignJwt: "cryptoOptsSignJwt",
    /**
     * acquireToken API in the SilentCacheClient class (msal-browser).
     * Used to read access tokens from the cache.
     */
    SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
    /**
     * acquireToken API in the SilentIframeClient class (msal-browser).
     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
     */
    SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
    AwaitConcurrentIframe: "awaitConcurrentIframe",
    /**
     * acquireToken API in SilentRereshClient (msal-browser).
     * Used to acquire a new set of tokens from the token endpoint using a refresh token.
     */
    SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
    /**
     * ssoSilent API (msal-browser).
     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
     */
    SsoSilent: "ssoSilent",
    /**
     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
     * Used to load authority metadata for a request.
     */
    StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
    /**
     * acquireToken APIs in msal-browser.
     * Used to make an /authorize endpoint call with native brokering enabled.
     */
    FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
    /**
     * acquireToken API in NativeInteractionClient class (msal-browser).
     * Used to acquire a token from Native component when native brokering is enabled.
     */
    NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
    /**
     * Time spent creating default headers for requests to token endpoint
     */
    BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
    /**
     * Time spent sending/waiting for the response of a request to the token endpoint
     */
    NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
    RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
    AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
    /**
     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
     */
    BrokerHandhshake: "brokerHandshake",
    /**
     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
     */
    AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
    /**
     * Time taken for token acquisition by broker
     */
    AcquireTokenByBroker: "acquireTokenByBroker",
    /**
     * Time spent on the network for refresh token acquisition
     */
    RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
    /**
     * Time taken for acquiring refresh token , records RT size
     */
    RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
    /**
     * Time taken for acquiring cached refresh token
     */
    RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
    /**
     * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
     */
    RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
    /**
     * Helper function to create token request body in RefreshTokenClient (msal-common).
     */
    RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
    /**
     * acquireTokenFromCache (msal-browser).
     * Internal API for acquiring token from cache
     */
    AcquireTokenFromCache: "acquireTokenFromCache",
    SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
    SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
    /**
     * acquireTokenBySilentIframe (msal-browser).
     * Internal API for acquiring token by silent Iframe
     */
    AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
    /**
     * Internal API for initializing base request in BaseInteractionClient (msal-browser)
     */
    InitializeBaseRequest: "initializeBaseRequest",
    /**
     * Internal API for initializing silent request in SilentCacheClient (msal-browser)
     */
    InitializeSilentRequest: "initializeSilentRequest",
    InitializeClientApplication: "initializeClientApplication",
    InitializeCache: "initializeCache",
    /**
     * Helper function in SilentIframeClient class (msal-browser).
     */
    SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
    /**
     * SilentHandler
     */
    SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
    SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
    SilentHandlerLoadFrame: "silentHandlerLoadFrame",
    SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
    /**
     * Helper functions in StandardInteractionClient class (msal-browser)
     */
    StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
    StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
    StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
    /**
     * getAuthCodeUrl API (msal-browser and msal-node).
     */
    GetAuthCodeUrl: "getAuthCodeUrl",
    GetStandardParams: "getStandardParams",
    /**
     * Functions from InteractionHandler (msal-browser)
     */
    HandleCodeResponseFromServer: "handleCodeResponseFromServer",
    HandleCodeResponse: "handleCodeResponse",
    HandleResponseEar: "handleResponseEar",
    HandleResponsePlatformBroker: "handleResponsePlatformBroker",
    HandleResponseCode: "handleResponseCode",
    UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
    /**
     * APIs in Authorization Code Client (msal-common)
     */
    AuthClientAcquireToken: "authClientAcquireToken",
    AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
    AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
    /**
     * Generate functions in PopTokenGenerator (msal-common)
     */
    PopTokenGenerateCnf: "popTokenGenerateCnf",
    PopTokenGenerateKid: "popTokenGenerateKid",
    /**
     * handleServerTokenResponse API in ResponseHandler (msal-common)
     */
    HandleServerTokenResponse: "handleServerTokenResponse",
    DeserializeResponse: "deserializeResponse",
    /**
     * Authority functions
     */
    AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
    AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
    AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
    AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
    AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
    AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
    AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
    AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
    /**
     * Region Discovery functions
     */
    RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
    RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
    RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
    AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
    GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
    GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
    HandleRedirectPromiseMeasurement: "handleRedirectPromise",
    HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
    UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
    UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
    NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
    NativeGenerateAuthResult: "nativeGenerateAuthResult",
    RemoveHiddenIframe: "removeHiddenIframe",
    /**
     * Cache operations
     */
    ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
    CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
    ImportExistingCache: "importExistingCache",
    SetUserData: "setUserData",
    LocalStorageUpdated: "localStorageUpdated",
    /**
     * Crypto Operations
     */
    GeneratePkceCodes: "generatePkceCodes",
    GenerateCodeVerifier: "generateCodeVerifier",
    GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
    Sha256Digest: "sha256Digest",
    GetRandomValues: "getRandomValues",
    GenerateHKDF: "generateHKDF",
    GenerateBaseKey: "generateBaseKey",
    Base64Decode: "base64Decode",
    UrlEncodeArr: "urlEncodeArr",
    Encrypt: "encrypt",
    Decrypt: "decrypt",
    GenerateEarKey: "generateEarKey",
    DecryptEarResponse: "decryptEarResponse"
  };
  var PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
    [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
    [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
    [PerformanceEvents.AcquireTokenSilent, "ATS"],
    [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
    [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
    [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
    [
      PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
      "CryptoGetPKThumb"
    ],
    [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
    [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
    [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
    [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
    [PerformanceEvents.SsoSilent, "SsoSlt"],
    [
      PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
      "StdIntClientGetDiscAuth"
    ],
    [
      PerformanceEvents.FetchAccountIdWithNativeBroker,
      "FetchAccIdWithNtvBroker"
    ],
    [
      PerformanceEvents.NativeInteractionClientAcquireToken,
      "NtvIntClientAT"
    ],
    [
      PerformanceEvents.BaseClientCreateTokenRequestHeaders,
      "BaseClientCreateTReqHead"
    ],
    [
      PerformanceEvents.NetworkClientSendPostRequestAsync,
      "NetClientSendPost"
    ],
    [
      PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
      "RTClientExecPost"
    ],
    [
      PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
      "AuthCodeClientExecPost"
    ],
    [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
    [
      PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
      "ATByRTInBroker"
    ],
    [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
    [
      PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
      "RTClientExecTReq"
    ],
    [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
    [
      PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
      "RTClientATWithCachedRT"
    ],
    [
      PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
      "RTClientATByRT"
    ],
    [
      PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
      "RTClientCreateTReqBody"
    ],
    [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
    [
      PerformanceEvents.SilentFlowClientAcquireCachedToken,
      "SltFlowClientATCached"
    ],
    [
      PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
      "SltFlowClientGenResFromCache"
    ],
    [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
    [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
    [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
    [
      PerformanceEvents.InitializeClientApplication,
      "InitClientApplication"
    ],
    [PerformanceEvents.InitializeCache, "InitCache"],
    [PerformanceEvents.ImportExistingCache, "importCache"],
    [PerformanceEvents.SetUserData, "setUserData"],
    [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
    [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
    [
      PerformanceEvents.SilentHandlerInitiateAuthRequest,
      "SHandlerInitAuthReq"
    ],
    [
      PerformanceEvents.SilentHandlerMonitorIframeForHash,
      "SltHandlerMonitorIframeForHash"
    ],
    [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
    [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
    [
      PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
      "StdIntClientCreateAuthCodeClient"
    ],
    [
      PerformanceEvents.StandardInteractionClientGetClientConfiguration,
      "StdIntClientGetClientConf"
    ],
    [
      PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
      "StdIntClientInitAuthReq"
    ],
    [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
    [
      PerformanceEvents.HandleCodeResponseFromServer,
      "HandleCodeResFromServer"
    ],
    [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
    [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
    [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
    [
      PerformanceEvents.HandleResponsePlatformBroker,
      "HandleRespPlatBroker"
    ],
    [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
    [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
    [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
    [
      PerformanceEvents.AuthClientCreateTokenRequestBody,
      "AuthClientCreateTReqBody"
    ],
    [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
    [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
    [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
    [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
    [
      PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
      "AuthFactCreateDiscInst"
    ],
    [
      PerformanceEvents.AuthorityResolveEndpointsAsync,
      "AuthResolveEndpointsAsync"
    ],
    [
      PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
      "AuthResolveEndpointsFromLocal"
    ],
    [
      PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
      "AuthGetCDMetaFromNet"
    ],
    [
      PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
      "AuthUpdCDMeta"
    ],
    [
      PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
      "AuthUpdCDMetaFromNet"
    ],
    [
      PerformanceEvents.AuthorityUpdateEndpointMetadata,
      "AuthUpdEndpointMeta"
    ],
    [
      PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
      "AuthUpdMetaWithRegInfo"
    ],
    [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
    [
      PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
      "RegDiscGetRegFromIMDS"
    ],
    [
      PerformanceEvents.RegionDiscoveryGetCurrentVersion,
      "RegDiscGetCurrentVer"
    ],
    [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
    [
      PerformanceEvents.GetEndpointMetadataFromNetwork,
      "GetEndpointMetaFromNet"
    ],
    [
      PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
      "GetCDMetaFromNet"
    ],
    [
      PerformanceEvents.HandleRedirectPromiseMeasurement,
      "HandleRedirectPromise"
    ],
    [
      PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
      "HandleNtvRedirectPromise"
    ],
    [
      PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
      "UpdateCDMeta"
    ],
    [
      PerformanceEvents.UsernamePasswordClientAcquireToken,
      "UserPassClientAT"
    ],
    [
      PerformanceEvents.NativeMessageHandlerHandshake,
      "NtvMsgHandlerHandshake"
    ],
    [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
    [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
    [
      PerformanceEvents.ClearTokensAndKeysWithClaims,
      "ClearTAndKeysWithClaims"
    ],
    [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
    [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
    [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
    [
      PerformanceEvents.GenerateCodeChallengeFromVerifier,
      "GenCodeChallengeFromVerifier"
    ],
    [PerformanceEvents.Sha256Digest, "Sha256Digest"],
    [PerformanceEvents.GetRandomValues, "GetRandomValues"],
    [PerformanceEvents.GenerateHKDF, "genHKDF"],
    [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
    [PerformanceEvents.Base64Decode, "b64Decode"],
    [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
    [PerformanceEvents.Encrypt, "encrypt"],
    [PerformanceEvents.Decrypt, "decrypt"],
    [PerformanceEvents.GenerateEarKey, "genEarKey"],
    [PerformanceEvents.DecryptEarResponse, "decryptEarResp"]
  ]);
  var PerformanceEventStatus = {
    NotStarted: 0,
    InProgress: 1,
    Completed: 2
  };

  // ../../node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
    return (...args) => {
      logger.trace(`Executing function ${eventName}`);
      const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
      if (correlationId) {
        const eventCount = eventName + "CallCount";
        telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
      }
      try {
        const result = callback(...args);
        inProgressEvent?.end({
          success: true
        });
        logger.trace(`Returning result from ${eventName}`);
        return result;
      } catch (e) {
        logger.trace(`Error occurred in ${eventName}`);
        try {
          logger.trace(JSON.stringify(e));
        } catch (e2) {
          logger.trace("Unable to print error message.");
        }
        inProgressEvent?.end({
          success: false
        }, e);
        throw e;
      }
    };
  };
  var invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
    return (...args) => {
      logger.trace(`Executing function ${eventName}`);
      const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
      if (correlationId) {
        const eventCount = eventName + "CallCount";
        telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
      }
      telemetryClient?.setPreQueueTime(eventName, correlationId);
      return callback(...args).then((response) => {
        logger.trace(`Returning result from ${eventName}`);
        inProgressEvent?.end({
          success: true
        });
        return response;
      }).catch((e) => {
        logger.trace(`Error occurred in ${eventName}`);
        try {
          logger.trace(JSON.stringify(e));
        } catch (e2) {
          logger.trace("Unable to print error message.");
        }
        inProgressEvent?.end({
          success: false
        }, e);
        throw e;
      });
    };
  };

  // ../../node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs
  var RegionDiscovery = class _RegionDiscovery {
    constructor(networkInterface, logger, performanceClient, correlationId) {
      this.networkInterface = networkInterface;
      this.logger = logger;
      this.performanceClient = performanceClient;
      this.correlationId = correlationId;
    }
    /**
     * Detect the region from the application's environment.
     *
     * @returns Promise<string | null>
     */
    async detectRegion(environmentRegion, regionDiscoveryMetadata) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
      let autodetectedRegionName = environmentRegion;
      if (!autodetectedRegionName) {
        const options = _RegionDiscovery.IMDS_OPTIONS;
        try {
          const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
          if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
            autodetectedRegionName = localIMDSVersionResponse.body;
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
          }
          if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {
            const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
            if (!currentIMDSVersion) {
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
              return null;
            }
            const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
              autodetectedRegionName = currentIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
          }
        } catch (e) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
          return null;
        }
      } else {
        regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
      }
      if (!autodetectedRegionName) {
        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
      }
      return autodetectedRegionName || null;
    }
    /**
     * Make the call to the IMDS endpoint
     *
     * @param imdsEndpointUrl
     * @returns Promise<NetworkResponse<string>>
     */
    async getRegionFromIMDS(version5, options) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
      return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version5}&format=text`, options, Constants.IMDS_TIMEOUT);
    }
    /**
     * Get the most recent version of the IMDS endpoint available
     *
     * @returns Promise<string | null>
     */
    async getCurrentVersion(options) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
      try {
        const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
        if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
          return response.body["newest-versions"][0];
        }
        return null;
      } catch (e) {
        return null;
      }
    }
  };
  RegionDiscovery.IMDS_OPTIONS = {
    headers: {
      Metadata: "true"
    }
  };

  // ../../node_modules/@azure/msal-common/dist/authority/Authority.mjs
  var Authority = class _Authority {
    constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
      this.canonicalAuthority = authority;
      this._canonicalAuthority.validateAsUri();
      this.networkInterface = networkInterface;
      this.cacheManager = cacheManager;
      this.authorityOptions = authorityOptions;
      this.regionDiscoveryMetadata = {
        region_used: void 0,
        region_source: void 0,
        region_outcome: void 0
      };
      this.logger = logger;
      this.performanceClient = performanceClient;
      this.correlationId = correlationId;
      this.managedIdentity = managedIdentity || false;
      this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
    }
    /**
     * Get {@link AuthorityType}
     * @param authorityUri {@link IUri}
     * @private
     */
    getAuthorityType(authorityUri) {
      if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
        return AuthorityType.Ciam;
      }
      const pathSegments = authorityUri.PathSegments;
      if (pathSegments.length) {
        switch (pathSegments[0].toLowerCase()) {
          case Constants.ADFS:
            return AuthorityType.Adfs;
          case Constants.DSTS:
            return AuthorityType.Dsts;
        }
      }
      return AuthorityType.Default;
    }
    // See above for AuthorityType
    get authorityType() {
      return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
    }
    /**
     * ProtocolMode enum representing the way endpoints are constructed.
     */
    get protocolMode() {
      return this.authorityOptions.protocolMode;
    }
    /**
     * Returns authorityOptions which can be used to reinstantiate a new authority instance
     */
    get options() {
      return this.authorityOptions;
    }
    /**
     * A URL that is the authority set by the developer
     */
    get canonicalAuthority() {
      return this._canonicalAuthority.urlString;
    }
    /**
     * Sets canonical authority.
     */
    set canonicalAuthority(url) {
      this._canonicalAuthority = new UrlString(url);
      this._canonicalAuthority.validateAsUri();
      this._canonicalAuthorityUrlComponents = null;
    }
    /**
     * Get authority components.
     */
    get canonicalAuthorityUrlComponents() {
      if (!this._canonicalAuthorityUrlComponents) {
        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
      }
      return this._canonicalAuthorityUrlComponents;
    }
    /**
     * Get hostname and port i.e. login.microsoftonline.com
     */
    get hostnameAndPort() {
      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
    }
    /**
     * Get tenant for authority.
     */
    get tenant() {
      return this.canonicalAuthorityUrlComponents.PathSegments[0];
    }
    /**
     * OAuth /authorize endpoint for requests
     */
    get authorizationEndpoint() {
      if (this.discoveryComplete()) {
        return this.replacePath(this.metadata.authorization_endpoint);
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * OAuth /token endpoint for requests
     */
    get tokenEndpoint() {
      if (this.discoveryComplete()) {
        return this.replacePath(this.metadata.token_endpoint);
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    get deviceCodeEndpoint() {
      if (this.discoveryComplete()) {
        return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * OAuth logout endpoint for requests
     */
    get endSessionEndpoint() {
      if (this.discoveryComplete()) {
        if (!this.metadata.end_session_endpoint) {
          throw createClientAuthError(endSessionEndpointNotSupported);
        }
        return this.replacePath(this.metadata.end_session_endpoint);
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * OAuth issuer for requests
     */
    get selfSignedJwtAudience() {
      if (this.discoveryComplete()) {
        return this.replacePath(this.metadata.issuer);
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * Jwks_uri for token signing keys
     */
    get jwksUri() {
      if (this.discoveryComplete()) {
        return this.replacePath(this.metadata.jwks_uri);
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
     * @param authorityUri {@link IUri}
     * @private
     */
    canReplaceTenant(authorityUri) {
      return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
    }
    /**
     * Replaces tenant in url path with current tenant. Defaults to common.
     * @param urlString
     */
    replaceTenant(urlString) {
      return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
    }
    /**
     * Replaces path such as tenant or policy with the current tenant or policy.
     * @param urlString
     */
    replacePath(urlString) {
      let endpoint = urlString;
      const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
      const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
      const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
      const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
      currentAuthorityParts.forEach((currentPart, index2) => {
        let cachedPart = cachedAuthorityParts[index2];
        if (index2 === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
          const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
          if (cachedPart !== tenantId) {
            this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
            cachedPart = tenantId;
          }
        }
        if (currentPart !== cachedPart) {
          endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
        }
      });
      return this.replaceTenant(endpoint);
    }
    /**
     * The default open id configuration endpoint for any canonical authority.
     */
    get defaultOpenIdConfigurationEndpoint() {
      const canonicalAuthorityHost = this.hostnameAndPort;
      if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
        return `${this.canonicalAuthority}.well-known/openid-configuration`;
      }
      return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
    }
    /**
     * Boolean that returns whether or not tenant discovery has been completed.
     */
    discoveryComplete() {
      return !!this.metadata;
    }
    /**
     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
     * and the /authorize, /token and logout endpoints.
     */
    async resolveEndpointsAsync() {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
      const metadataEntity = this.getCurrentMetadataEntity();
      const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
      this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
      const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
      this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
        source: endpointSource
      });
      this.performanceClient?.addFields({
        cloudDiscoverySource,
        authorityEndpointSource: endpointSource
      }, this.correlationId);
    }
    /**
     * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
     * from the configured canonical authority
     * @returns
     */
    getCurrentMetadataEntity() {
      let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
      if (!metadataEntity) {
        metadataEntity = {
          aliases: [],
          preferred_cache: this.hostnameAndPort,
          preferred_network: this.hostnameAndPort,
          canonical_authority: this.canonicalAuthority,
          authorization_endpoint: "",
          token_endpoint: "",
          end_session_endpoint: "",
          issuer: "",
          aliasesFromNetwork: false,
          endpointsFromNetwork: false,
          expiresAt: generateAuthorityMetadataExpiresAt(),
          jwks_uri: ""
        };
      }
      return metadataEntity;
    }
    /**
     * Updates cached metadata based on metadata source and sets the instance's metadata
     * property to the same value
     * @param metadataEntity
     * @param cloudDiscoverySource
     * @param endpointMetadataResult
     */
    updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
      if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
        metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
        metadataEntity.canonical_authority = this.canonicalAuthority;
      }
      const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
      this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
      this.metadata = metadataEntity;
    }
    /**
     * Update AuthorityMetadataEntity with new endpoints and return where the information came from
     * @param metadataEntity
     */
    async updateEndpointMetadata(metadataEntity) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
      const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
      if (localMetadata) {
        if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            if (localMetadata.metadata) {
              const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
              updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
              metadataEntity.canonical_authority = this.canonicalAuthority;
            }
          }
        }
        return localMetadata.source;
      }
      let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
      if (metadata) {
        if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
          metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
        }
        updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
        return AuthorityMetadataSource.NETWORK;
      } else {
        throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
      }
    }
    /**
     * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
     * response if the source is hardcoded metadata
     * @param metadataEntity
     * @returns
     */
    updateEndpointMetadataFromLocalSources(metadataEntity) {
      this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
      const configMetadata = this.getEndpointMetadataFromConfig();
      if (configMetadata) {
        this.logger.verbose("Found endpoint metadata in authority configuration");
        updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
        return {
          source: AuthorityMetadataSource.CONFIG
        };
      }
      this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
      if (this.authorityOptions.skipAuthorityMetadataCache) {
        this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
      } else {
        const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
        if (hardcodedMetadata) {
          updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
          return {
            source: AuthorityMetadataSource.HARDCODED_VALUES,
            metadata: hardcodedMetadata
          };
        } else {
          this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
        }
      }
      const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
      if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
        this.logger.verbose("Found endpoint metadata in the cache.");
        return { source: AuthorityMetadataSource.CACHE };
      } else if (metadataEntityExpired) {
        this.logger.verbose("The metadata entity is expired.");
      }
      return null;
    }
    /**
     * Compares the number of url components after the domain to determine if the cached
     * authority metadata can be used for the requested authority. Protects against same domain different
     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
     * @param metadataEntity
     */
    isAuthoritySameType(metadataEntity) {
      const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
      const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
      return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
    }
    /**
     * Parse authorityMetadata config option
     */
    getEndpointMetadataFromConfig() {
      if (this.authorityOptions.authorityMetadata) {
        try {
          return JSON.parse(this.authorityOptions.authorityMetadata);
        } catch (e) {
          throw createClientConfigurationError(invalidAuthorityMetadata);
        }
      }
      return null;
    }
    /**
     * Gets OAuth endpoints from the given OpenID configuration endpoint.
     *
     * @param hasHardcodedMetadata boolean
     */
    async getEndpointMetadataFromNetwork() {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
      const options = {};
      const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
      this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
      try {
        const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
        const isValidResponse = isOpenIdConfigResponse(response.body);
        if (isValidResponse) {
          return response.body;
        } else {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
          return null;
        }
      } catch (e) {
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
        return null;
      }
    }
    /**
     * Get OAuth endpoints for common authorities.
     */
    getEndpointMetadataFromHardcodedValues() {
      if (this.hostnameAndPort in EndpointMetadata) {
        return EndpointMetadata[this.hostnameAndPort];
      }
      return null;
    }
    /**
     * Update the retrieved metadata with regional information.
     * User selected Azure region will be used if configured.
     */
    async updateMetadataWithRegionalInformation(metadata) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
      const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
      if (userConfiguredAzureRegion) {
        if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
          this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
          return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
        }
        const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);
        if (autodetectedRegionName) {
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
          this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
          return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
        }
        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
      }
      return metadata;
    }
    /**
     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
     * and returns where the information was retrieved from
     * @param metadataEntity
     * @returns AuthorityMetadataSource
     */
    async updateCloudDiscoveryMetadata(metadataEntity) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
      const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
      if (localMetadataSource) {
        return localMetadataSource;
      }
      const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
      if (metadata) {
        updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
        return AuthorityMetadataSource.NETWORK;
      }
      throw createClientConfigurationError(untrustedAuthority);
    }
    updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
      this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
      this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
      this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
      this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
      const metadata = this.getCloudDiscoveryMetadataFromConfig();
      if (metadata) {
        this.logger.verbose("Found cloud discovery metadata in authority configuration");
        updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
        return AuthorityMetadataSource.CONFIG;
      }
      this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
      if (this.options.skipAuthorityMetadataCache) {
        this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
      } else {
        const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
        if (hardcodedMetadata) {
          this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
          updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
          return AuthorityMetadataSource.HARDCODED_VALUES;
        }
        this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
      }
      const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
      if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
        this.logger.verbose("Found cloud discovery metadata in the cache.");
        return AuthorityMetadataSource.CACHE;
      } else if (metadataEntityExpired) {
        this.logger.verbose("The metadata entity is expired.");
      }
      return null;
    }
    /**
     * Parse cloudDiscoveryMetadata config or check knownAuthorities
     */
    getCloudDiscoveryMetadataFromConfig() {
      if (this.authorityType === AuthorityType.Ciam) {
        this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
        return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      }
      if (this.authorityOptions.cloudDiscoveryMetadata) {
        this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
        try {
          this.logger.verbose("Attempting to parse the cloud discovery metadata.");
          const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
          const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
          this.logger.verbose("Parsed the cloud discovery metadata.");
          if (metadata) {
            this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
            return metadata;
          } else {
            this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
          }
        } catch (e) {
          this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
          throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
        }
      }
      if (this.isInKnownAuthorities()) {
        this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
        return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      }
      return null;
    }
    /**
     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
     *
     * @param hasHardcodedMetadata boolean
     */
    async getCloudDiscoveryMetadataFromNetwork() {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
      const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
      const options = {};
      let match2 = null;
      try {
        const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
        let typedResponseBody;
        let metadata;
        if (isCloudInstanceDiscoveryResponse(response.body)) {
          typedResponseBody = response.body;
          metadata = typedResponseBody.metadata;
          this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
        } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
          this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
          typedResponseBody = response.body;
          if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
            this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
            return null;
          }
          this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
          this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
          this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
          metadata = [];
        } else {
          this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
          return null;
        }
        this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
        match2 = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
      } catch (error) {
        if (error instanceof AuthError) {
          this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
        } else {
          const typedError = error;
          this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
        }
        return null;
      }
      if (!match2) {
        this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
        this.logger.verbose("Creating custom Authority for custom domain scenario.");
        match2 = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
      }
      return match2;
    }
    /**
     * Helper function to determine if this host is included in the knownAuthorities config option
     */
    isInKnownAuthorities() {
      const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
        return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
      });
      return matches.length > 0;
    }
    /**
     * helper function to populate the authority based on azureCloudOptions
     * @param authorityString
     * @param azureCloudOptions
     */
    static generateAuthority(authorityString, azureCloudOptions) {
      let authorityAzureCloudInstance;
      if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
        const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
        authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
      }
      return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
    }
    /**
     * Creates cloud discovery metadata object from a given host
     * @param host
     */
    static createCloudDiscoveryMetadataFromHost(host) {
      return {
        preferred_network: host,
        preferred_cache: host,
        aliases: [host]
      };
    }
    /**
     * helper function to generate environment from authority object
     */
    getPreferredCache() {
      if (this.managedIdentity) {
        return Constants.DEFAULT_AUTHORITY_HOST;
      } else if (this.discoveryComplete()) {
        return this.metadata.preferred_cache;
      } else {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    /**
     * Returns whether or not the provided host is an alias of this authority instance
     * @param host
     */
    isAlias(host) {
      return this.metadata.aliases.indexOf(host) > -1;
    }
    /**
     * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
     * @param host
     */
    isAliasOfKnownMicrosoftAuthority(host) {
      return InstanceDiscoveryMetadataAliases.has(host);
    }
    /**
     * Checks whether the provided host is that of a public cloud authority
     *
     * @param authority string
     * @returns bool
     */
    static isPublicCloudAuthority(host) {
      return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
    }
    /**
     * Rebuild the authority string with the region
     *
     * @param host string
     * @param region string
     */
    static buildRegionalAuthorityString(host, region, queryString) {
      const authorityUrlInstance = new UrlString(host);
      authorityUrlInstance.validateAsUri();
      const authorityUrlParts = authorityUrlInstance.getUrlComponents();
      let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
      if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
        hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
      }
      const url = UrlString.constructAuthorityUriFromObject({
        ...authorityUrlInstance.getUrlComponents(),
        HostNameAndPort: hostNameAndPort
      }).urlString;
      if (queryString)
        return `${url}?${queryString}`;
      return url;
    }
    /**
     * Replace the endpoints in the metadata object with their regional equivalents.
     *
     * @param metadata OpenIdConfigResponse
     * @param azureRegion string
     */
    static replaceWithRegionalInformation(metadata, azureRegion) {
      const regionalMetadata = { ...metadata };
      regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
      regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
      if (regionalMetadata.end_session_endpoint) {
        regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
      }
      return regionalMetadata;
    }
    /**
     * Transform CIAM_AUTHORIY as per the below rules:
     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
     *
     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
     * `ciamlogin.com` can also change in the future and we should accommodate the same
     *
     * @param authority
     */
    static transformCIAMAuthority(authority) {
      let ciamAuthority = authority;
      const authorityUrl = new UrlString(authority);
      const authorityUrlComponents = authorityUrl.getUrlComponents();
      if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
        const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
        ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
      }
      return ciamAuthority;
    }
  };
  Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
    "{tenant}",
    "{tenantid}",
    AADAuthorityConstants.COMMON,
    AADAuthorityConstants.CONSUMERS,
    AADAuthorityConstants.ORGANIZATIONS
  ]);
  function getTenantFromAuthorityString(authority) {
    const authorityUrl = new UrlString(authority);
    const authorityUrlComponents = authorityUrl.getUrlComponents();
    const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
    switch (tenantId) {
      case AADAuthorityConstants.COMMON:
      case AADAuthorityConstants.ORGANIZATIONS:
      case AADAuthorityConstants.CONSUMERS:
        return void 0;
      default:
        return tenantId;
    }
  }
  function formatAuthorityUri(authorityUri) {
    return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
  }
  function buildStaticAuthorityOptions(authOptions) {
    const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
    let cloudDiscoveryMetadata = void 0;
    if (rawCloudDiscoveryMetadata) {
      try {
        cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
      } catch (e) {
        throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
      }
    }
    return {
      canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
      knownAuthorities: authOptions.knownAuthorities,
      cloudDiscoveryMetadata
    };
  }

  // ../../node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs
  async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
    performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
    const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
    const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
    try {
      await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
      return acquireTokenAuthority;
    } catch (e) {
      throw createClientAuthError(endpointResolutionError);
    }
  }

  // ../../node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/ServerError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ServerError = class _ServerError extends AuthError {
    constructor(errorCode, errorMessage, subError, errorNo, status) {
      super(errorCode, errorMessage, subError);
      this.name = "ServerError";
      this.errorNo = errorNo;
      this.status = status;
      Object.setPrototypeOf(this, _ServerError.prototype);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getRequestThumbprint(clientId, request, homeAccountId) {
    return {
      clientId,
      authority: request.authority,
      scopes: request.scopes,
      homeAccountIdentifier: homeAccountId,
      claims: request.claims,
      authenticationScheme: request.authenticationScheme,
      resourceRequestMethod: request.resourceRequestMethod,
      resourceRequestUri: request.resourceRequestUri,
      shrClaims: request.shrClaims,
      sshKid: request.sshKid,
      embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId
    };
  }

  // ../../node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs
  var ThrottlingUtils = class _ThrottlingUtils {
    /**
     * Prepares a RequestThumbprint to be stored as a key.
     * @param thumbprint
     */
    static generateThrottlingStorageKey(thumbprint) {
      return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
    }
    /**
     * Performs necessary throttling checks before a network request.
     * @param cacheManager
     * @param thumbprint
     */
    static preProcess(cacheManager, thumbprint) {
      const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
      const value = cacheManager.getThrottlingCache(key);
      if (value) {
        if (value.throttleTime < Date.now()) {
          cacheManager.removeItem(key);
          return;
        }
        throw new ServerError(value.errorCodes?.join(" ") || Constants.EMPTY_STRING, value.errorMessage, value.subError);
      }
    }
    /**
     * Performs necessary throttling checks after a network request.
     * @param cacheManager
     * @param thumbprint
     * @param response
     */
    static postProcess(cacheManager, thumbprint, response) {
      if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
        const thumbprintValue = {
          throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
          error: response.body.error,
          errorCodes: response.body.error_codes,
          errorMessage: response.body.error_description,
          subError: response.body.suberror
        };
        cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);
      }
    }
    /**
     * Checks a NetworkResponse object's status codes against 429 or 5xx
     * @param response
     */
    static checkResponseStatus(response) {
      return response.status === 429 || response.status >= 500 && response.status < 600;
    }
    /**
     * Checks a NetworkResponse object's RetryAfter header
     * @param response
     */
    static checkResponseForRetryAfter(response) {
      if (response.headers) {
        return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
      }
      return false;
    }
    /**
     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
     * @param throttleTime
     */
    static calculateThrottleTime(throttleTime) {
      const time = throttleTime <= 0 ? 0 : throttleTime;
      const currentSeconds = Date.now() / 1e3;
      return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
    }
    static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
      const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
      const key = this.generateThrottlingStorageKey(thumbprint);
      cacheManager.removeItem(key);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/error/NetworkError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var NetworkError = class _NetworkError extends AuthError {
    constructor(error, httpStatus, responseHeaders) {
      super(error.errorCode, error.errorMessage, error.subError);
      Object.setPrototypeOf(this, _NetworkError.prototype);
      this.name = "NetworkError";
      this.error = error;
      this.httpStatus = httpStatus;
      this.responseHeaders = responseHeaders;
    }
  };
  function createNetworkError(error, httpStatus, responseHeaders, additionalError) {
    error.errorMessage = `${error.errorMessage}, additionalErrorInfo: error.name:${additionalError?.name}, error.message:${additionalError?.message}`;
    return new NetworkError(error, httpStatus, responseHeaders);
  }

  // ../../node_modules/@azure/msal-common/dist/client/BaseClient.mjs
  var BaseClient = class {
    constructor(configuration, performanceClient) {
      this.config = buildClientConfiguration(configuration);
      this.logger = new Logger(this.config.loggerOptions, name17, version);
      this.cryptoUtils = this.config.cryptoInterface;
      this.cacheManager = this.config.storageInterface;
      this.networkClient = this.config.networkInterface;
      this.serverTelemetryManager = this.config.serverTelemetryManager;
      this.authority = this.config.authOptions.authority;
      this.performanceClient = performanceClient;
    }
    /**
     * Creates default headers for requests to token endpoint
     */
    createTokenRequestHeaders(ccsCred) {
      const headers = {};
      headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
      if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
        switch (ccsCred.type) {
          case CcsCredentialType.HOME_ACCOUNT_ID:
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
              headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
            } catch (e) {
              this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
            }
            break;
          case CcsCredentialType.UPN:
            headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
            break;
        }
      }
      return headers;
    }
    /**
     * Http post to token endpoint
     * @param tokenEndpoint
     * @param queryString
     * @param headers
     * @param thumbprint
     */
    async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
      if (queuedEvent) {
        this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
      }
      const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
      if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
        this.config.serverTelemetryManager.clearTelemetryCache();
      }
      return response;
    }
    /**
     * Wraps sendPostRequestAsync with necessary preflight and postflight logic
     * @param thumbprint - Request thumbprint for throttling
     * @param tokenEndpoint - Endpoint to make the POST to
     * @param options - Body and Headers to include on the POST request
     * @param correlationId - CorrelationId for telemetry
     */
    async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
      ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
      let response;
      try {
        response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
        const responseHeaders = response.headers || {};
        this.performanceClient?.addFields({
          refreshTokenSize: response.body.refresh_token?.length || 0,
          httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
          requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
        }, correlationId);
      } catch (e) {
        if (e instanceof NetworkError) {
          const responseHeaders = e.responseHeaders;
          if (responseHeaders) {
            this.performanceClient?.addFields({
              httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
              requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
              contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
              contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
              httpStatus: e.httpStatus
            }, correlationId);
          }
          throw e.error;
        }
        if (e instanceof AuthError) {
          throw e;
        } else {
          throw createClientAuthError(networkError);
        }
      }
      ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
      return response;
    }
    /**
     * Updates the authority object of the client. Endpoint discovery must be completed.
     * @param updatedAuthority
     */
    async updateAuthority(cloudInstanceHostname, correlationId) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
      const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
      const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
      this.authority = cloudInstanceAuthority;
    }
    /**
     * Creates query string for the /token request
     * @param request
     */
    createTokenQueryParameters(request) {
      const parameters = /* @__PURE__ */ new Map();
      if (request.embeddedClientId) {
        addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
      }
      if (request.tokenQueryParameters) {
        addExtraQueryParameters(parameters, request.tokenQueryParameters);
      }
      addCorrelationId(parameters, request.correlationId);
      instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
      return mapToQueryString(parameters);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs
  var InteractionRequiredAuthErrorCodes_exports = {};
  __export(InteractionRequiredAuthErrorCodes_exports, {
    badToken: () => badToken,
    consentRequired: () => consentRequired,
    interactionRequired: () => interactionRequired,
    loginRequired: () => loginRequired,
    nativeAccountUnavailable: () => nativeAccountUnavailable,
    noTokensFound: () => noTokensFound,
    refreshTokenExpired: () => refreshTokenExpired
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var noTokensFound = "no_tokens_found";
  var nativeAccountUnavailable = "native_account_unavailable";
  var refreshTokenExpired = "refresh_token_expired";
  var interactionRequired = "interaction_required";
  var consentRequired = "consent_required";
  var loginRequired = "login_required";
  var badToken = "bad_token";

  // ../../node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs
  var InteractionRequiredServerErrorMessage = [
    interactionRequired,
    consentRequired,
    loginRequired,
    badToken
  ];
  var InteractionRequiredAuthSubErrorMessage = [
    "message_only",
    "additional_action",
    "basic_action",
    "user_password_expired",
    "consent_required",
    "bad_token"
  ];
  var InteractionRequiredAuthErrorMessages = {
    [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
    [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
    [refreshTokenExpired]: "Refresh token has expired.",
    [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve."
  };
  var InteractionRequiredAuthErrorMessage = {
    noTokensFoundError: {
      code: noTokensFound,
      desc: InteractionRequiredAuthErrorMessages[noTokensFound]
    },
    native_account_unavailable: {
      code: nativeAccountUnavailable,
      desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
    },
    bad_token: {
      code: badToken,
      desc: InteractionRequiredAuthErrorMessages[badToken]
    }
  };
  var InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
    constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
      super(errorCode, errorMessage, subError);
      Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
      this.timestamp = timestamp || Constants.EMPTY_STRING;
      this.traceId = traceId || Constants.EMPTY_STRING;
      this.correlationId = correlationId || Constants.EMPTY_STRING;
      this.claims = claims || Constants.EMPTY_STRING;
      this.name = "InteractionRequiredAuthError";
      this.errorNo = errorNo;
    }
  };
  function isInteractionRequiredError(errorCode, errorString, subError) {
    const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
    const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
    const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
      return errorString.indexOf(irErrorCode) > -1;
    });
    return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
  }
  function createInteractionRequiredAuthError(errorCode) {
    return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
  }

  // ../../node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ProtocolUtils = class _ProtocolUtils {
    /**
     * Appends user state with random guid, or returns random guid.
     * @param userState
     * @param randomGuid
     */
    static setRequestState(cryptoObj, userState, meta) {
      const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
      return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
    }
    /**
     * Generates the state value used by the common library.
     * @param randomGuid
     * @param cryptoObj
     */
    static generateLibraryState(cryptoObj, meta) {
      if (!cryptoObj) {
        throw createClientAuthError(noCryptoObject);
      }
      const stateObj = {
        id: cryptoObj.createNewGuid()
      };
      if (meta) {
        stateObj.meta = meta;
      }
      const stateString = JSON.stringify(stateObj);
      return cryptoObj.base64Encode(stateString);
    }
    /**
     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
     * @param state
     * @param cryptoObj
     */
    static parseRequestState(cryptoObj, state) {
      if (!cryptoObj) {
        throw createClientAuthError(noCryptoObject);
      }
      if (!state) {
        throw createClientAuthError(invalidState);
      }
      try {
        const splitState = state.split(Constants.RESOURCE_DELIM);
        const libraryState = splitState[0];
        const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
        const libraryStateString = cryptoObj.base64Decode(libraryState);
        const libraryStateObj = JSON.parse(libraryStateString);
        return {
          userRequestState: userState || Constants.EMPTY_STRING,
          libraryState: libraryStateObj
        };
      } catch (e) {
        throw createClientAuthError(invalidState);
      }
    }
  };

  // ../../node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var KeyLocation = {
    SW: "sw",
    UHW: "uhw"
  };
  var PopTokenGenerator = class {
    constructor(cryptoUtils, performanceClient) {
      this.cryptoUtils = cryptoUtils;
      this.performanceClient = performanceClient;
    }
    /**
     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
     * @param request
     * @returns
     */
    async generateCnf(request, logger) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
      const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
      const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
      return {
        kid: reqCnf.kid,
        reqCnfString
      };
    }
    /**
     * Generates key_id for a SHR token request
     * @param request
     * @returns
     */
    async generateKid(request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
      const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
      return {
        kid: kidThumbprint,
        xms_ksl: KeyLocation.SW
      };
    }
    /**
     * Signs the POP access_token with the local generated key-pair
     * @param accessToken
     * @param request
     * @returns
     */
    async signPopToken(accessToken, keyId, request) {
      return this.signPayload(accessToken, keyId, request);
    }
    /**
     * Utility function to generate the signed JWT for an access_token
     * @param payload
     * @param kid
     * @param request
     * @param claims
     * @returns
     */
    async signPayload(payload, keyId, request, claims) {
      const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
      const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
      const resourceUrlComponents = resourceUrlString?.getUrlComponents();
      return this.cryptoUtils.signJwt({
        at: payload,
        ts: nowSeconds(),
        m: resourceRequestMethod?.toUpperCase(),
        u: resourceUrlComponents?.HostNameAndPort,
        nonce: shrNonce || this.cryptoUtils.createNewGuid(),
        p: resourceUrlComponents?.AbsolutePath,
        q: resourceUrlComponents?.QueryString ? [[], resourceUrlComponents.QueryString] : void 0,
        client_claims: shrClaims || void 0,
        ...claims
      }, keyId, shrOptions, request.correlationId);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var TokenCacheContext = class {
    constructor(tokenCache, hasChanged) {
      this.cache = tokenCache;
      this.hasChanged = hasChanged;
    }
    /**
     * boolean which indicates the changes in cache
     */
    get cacheHasChanged() {
      return this.hasChanged;
    }
    /**
     * function to retrieve the token cache
     */
    get tokenCache() {
      return this.cache;
    }
  };

  // ../../node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs
  var ResponseHandler = class _ResponseHandler {
    constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
      this.clientId = clientId;
      this.cacheStorage = cacheStorage;
      this.cryptoObj = cryptoObj;
      this.logger = logger;
      this.serializableCache = serializableCache;
      this.persistencePlugin = persistencePlugin;
      this.performanceClient = performanceClient;
    }
    /**
     * Function which validates server authorization token response.
     * @param serverResponse
     * @param refreshAccessToken
     */
    validateTokenResponse(serverResponse, refreshAccessToken) {
      if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
        const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
        const serverErrorNo = serverResponse.error_codes?.length ? serverResponse.error_codes[0] : void 0;
        const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
        if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
          this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
          return;
        } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
          this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
          return;
        }
        if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
          throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
        }
        throw serverError;
      }
    }
    /**
     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
     * @param serverTokenResponse
     * @param authority
     */
    async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
      let idTokenClaims;
      if (serverTokenResponse.id_token) {
        idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
        if (authCodePayload && authCodePayload.nonce) {
          if (idTokenClaims.nonce !== authCodePayload.nonce) {
            throw createClientAuthError(nonceMismatch);
          }
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
      }
      this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
      let requestStateObj;
      if (!!authCodePayload && !!authCodePayload.state) {
        requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
      }
      serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
      const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
      let cacheContext;
      try {
        if (this.persistencePlugin && this.serializableCache) {
          this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
          cacheContext = new TokenCacheContext(this.serializableCache, true);
          await this.persistencePlugin.beforeCacheAccess(cacheContext);
        }
        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
          const key = cacheRecord.account.generateAccountKey();
          const account = this.cacheStorage.getAccount(key);
          if (!account) {
            this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
            return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
          }
        }
        await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, request.storeInCache);
      } finally {
        if (this.persistencePlugin && this.serializableCache && cacheContext) {
          this.logger.verbose("Persistence enabled, calling afterCacheAccess");
          await this.persistencePlugin.afterCacheAccess(cacheContext);
        }
      }
      return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
    }
    /**
     * Generates CacheRecord
     * @param serverTokenResponse
     * @param idTokenObj
     * @param authority
     */
    generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
      const env2 = authority.getPreferredCache();
      if (!env2) {
        throw createClientAuthError(invalidCacheEnvironment);
      }
      const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
      let cachedIdToken;
      let cachedAccount;
      if (serverTokenResponse.id_token && !!idTokenClaims) {
        cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env2, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
        cachedAccount = buildAccountToCache(
          this.cacheStorage,
          authority,
          this.homeAccountIdentifier,
          this.cryptoObj.base64Decode,
          idTokenClaims,
          serverTokenResponse.client_info,
          env2,
          claimsTenantId,
          authCodePayload,
          void 0,
          // nativeAccountId
          this.logger
        );
      }
      let cachedAccessToken = null;
      if (serverTokenResponse.access_token) {
        const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
        const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
        const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
        const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
        const tokenExpirationSeconds = reqTimestamp + expiresIn;
        const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
        const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
        cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env2, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
      }
      let cachedRefreshToken = null;
      if (serverTokenResponse.refresh_token) {
        let rtExpiresOn;
        if (serverTokenResponse.refresh_token_expires_in) {
          const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
          rtExpiresOn = reqTimestamp + rtExpiresIn;
        }
        cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env2, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
      }
      let cachedAppMetadata = null;
      if (serverTokenResponse.foci) {
        cachedAppMetadata = {
          clientId: this.clientId,
          environment: env2,
          familyId: serverTokenResponse.foci
        };
      }
      return {
        account: cachedAccount,
        idToken: cachedIdToken,
        accessToken: cachedAccessToken,
        refreshToken: cachedRefreshToken,
        appMetadata: cachedAppMetadata
      };
    }
    /**
     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
     *
     * Optionally takes a state string that is set as-is in the response.
     *
     * @param cacheRecord
     * @param idTokenObj
     * @param fromTokenCache
     * @param stateString
     */
    static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
      let accessToken = Constants.EMPTY_STRING;
      let responseScopes = [];
      let expiresOn = null;
      let extExpiresOn;
      let refreshOn;
      let familyId = Constants.EMPTY_STRING;
      if (cacheRecord.accessToken) {
        if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
          const popTokenGenerator = new PopTokenGenerator(cryptoObj);
          const { secret, keyId } = cacheRecord.accessToken;
          if (!keyId) {
            throw createClientAuthError(keyIdMissing);
          }
          accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
        } else {
          accessToken = cacheRecord.accessToken.secret;
        }
        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
        expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
        extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
        if (cacheRecord.accessToken.refreshOn) {
          refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
        }
      }
      if (cacheRecord.appMetadata) {
        familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
      }
      const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
      const tid = idTokenClaims?.tid || "";
      if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
        cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
      }
      const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
        cacheRecord.account.getAccountInfo(),
        void 0,
        // tenantProfile optional
        idTokenClaims,
        cacheRecord.idToken?.secret
      ) : null;
      return {
        authority: authority.canonicalAuthority,
        uniqueId: uid,
        tenantId: tid,
        scopes: responseScopes,
        account: accountInfo,
        idToken: cacheRecord?.idToken?.secret || "",
        idTokenClaims: idTokenClaims || {},
        accessToken,
        fromCache: fromTokenCache,
        expiresOn,
        extExpiresOn,
        refreshOn,
        correlationId: request.correlationId,
        requestId: requestId || Constants.EMPTY_STRING,
        familyId,
        tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
        state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
        cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,
        msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
        code: serverTokenResponse?.spa_code,
        fromNativeBroker: false
      };
    }
  };
  function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode2, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
    logger?.verbose("setCachedAccount called");
    const accountKeys = cacheStorage.getAccountKeys();
    const baseAccountKey = accountKeys.find((accountKey) => {
      return accountKey.startsWith(homeAccountId);
    });
    let cachedAccount = null;
    if (baseAccountKey) {
      cachedAccount = cacheStorage.getAccount(baseAccountKey);
    }
    const baseAccount = cachedAccount || AccountEntity.createAccount({
      homeAccountId,
      idTokenClaims,
      clientInfo,
      environment,
      cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
      msGraphHost: authCodePayload?.msgraph_host,
      nativeAccountId
    }, authority, base64Decode2);
    const tenantProfiles = baseAccount.tenantProfiles || [];
    const tenantId = claimsTenantId || baseAccount.realm;
    if (tenantId && !tenantProfiles.find((tenantProfile) => {
      return tenantProfile.tenantId === tenantId;
    })) {
      const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
      tenantProfiles.push(newTenantProfile);
    }
    baseAccount.tenantProfiles = tenantProfiles;
    return baseAccount;
  }

  // ../../node_modules/@azure/msal-common/dist/request/RequestValidator.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var RequestValidator = class {
    /**
     * Utility to check if the `redirectUri` in the request is a non-null value
     * @param redirectUri
     */
    static validateRedirectUri(redirectUri) {
      if (!redirectUri) {
        throw createClientConfigurationError(redirectUriEmpty);
      }
    }
    /**
     * Utility to validate prompt sent by the user in the request
     * @param prompt
     */
    static validatePrompt(prompt) {
      const promptValues = [];
      for (const value in PromptValue) {
        promptValues.push(PromptValue[value]);
      }
      if (promptValues.indexOf(prompt) < 0) {
        throw createClientConfigurationError(invalidPromptValue);
      }
    }
    static validateClaims(claims) {
      try {
        JSON.parse(claims);
      } catch (e) {
        throw createClientConfigurationError(invalidClaims);
      }
    }
    /**
     * Utility to validate code_challenge and code_challenge_method
     * @param codeChallenge
     * @param codeChallengeMethod
     */
    static validateCodeChallengeParams(codeChallenge, codeChallengeMethod) {
      if (!codeChallenge || !codeChallengeMethod) {
        throw createClientConfigurationError(pkceParamsMissing);
      } else {
        this.validateCodeChallengeMethod(codeChallengeMethod);
      }
    }
    /**
     * Utility to validate code_challenge_method
     * @param codeChallengeMethod
     */
    static validateCodeChallengeMethod(codeChallengeMethod) {
      if ([
        CodeChallengeMethodValues.PLAIN,
        CodeChallengeMethodValues.S256
      ].indexOf(codeChallengeMethod) < 0) {
        throw createClientConfigurationError(invalidCodeChallengeMethod);
      }
    }
  };

  // ../../node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
    if (typeof clientAssertion === "string") {
      return clientAssertion;
    } else {
      const config = {
        clientId,
        tokenEndpoint
      };
      return clientAssertion(config);
    }
  }

  // ../../node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs
  var AuthorizationCodeClient = class extends BaseClient {
    constructor(configuration, performanceClient) {
      super(configuration, performanceClient);
      this.includeRedirectUri = true;
      this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
    }
    /**
     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
     * authorization_code_grant
     * @param request
     */
    async acquireToken(request, authCodePayload) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
      if (!request.code) {
        throw createClientAuthError(requestCannotBeMade);
      }
      const reqTimestamp = nowSeconds();
      const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
      const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
      const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
      responseHandler.validateTokenResponse(response.body);
      return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, void 0, void 0, void 0, requestId);
    }
    /**
     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param authorityUri
     */
    getLogoutUri(logoutRequest) {
      if (!logoutRequest) {
        throw createClientConfigurationError(logoutRequestEmpty);
      }
      const queryString = this.createLogoutUrlQueryString(logoutRequest);
      return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
    }
    /**
     * Executes POST request to token endpoint
     * @param authority
     * @param request
     */
    async executeTokenRequest(authority, request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
      const queryParametersString = this.createTokenQueryParameters(request);
      const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
      const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
      let ccsCredential = void 0;
      if (request.clientInfo) {
        try {
          const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
          ccsCredential = {
            credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          };
        } catch (e) {
          this.logger.verbose("Could not parse client info for CCS Header: " + e);
        }
      }
      const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
      const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
      return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
    }
    /**
     * Generates a map for all the params to be sent to the service
     * @param request
     */
    async createTokenRequestBody(request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
      const parameters = /* @__PURE__ */ new Map();
      addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
      if (!this.includeRedirectUri) {
        RequestValidator.validateRedirectUri(request.redirectUri);
      } else {
        addRedirectUri(parameters, request.redirectUri);
      }
      addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
      addAuthorizationCode(parameters, request.code);
      addLibraryInfo(parameters, this.config.libraryInfo);
      addApplicationTelemetry(parameters, this.config.telemetry.application);
      addThrottling(parameters);
      if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
        addServerTelemetry(parameters, this.serverTelemetryManager);
      }
      if (request.codeVerifier) {
        addCodeVerifier(parameters, request.codeVerifier);
      }
      if (this.config.clientCredentials.clientSecret) {
        addClientSecret(parameters, this.config.clientCredentials.clientSecret);
      }
      if (this.config.clientCredentials.clientAssertion) {
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
        addClientAssertionType(parameters, clientAssertion.assertionType);
      }
      addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
      addClientInfo(parameters);
      if (request.authenticationScheme === AuthenticationScheme.POP) {
        const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
        let reqCnfData;
        if (!request.popKid) {
          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
          reqCnfData = generatedReqCnfData.reqCnfString;
        } else {
          reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
        }
        addPopToken(parameters, reqCnfData);
      } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
        if (request.sshJwk) {
          addSshJwk(parameters, request.sshJwk);
        } else {
          throw createClientConfigurationError(missingSshJwk);
        }
      }
      if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
      }
      let ccsCred = void 0;
      if (request.clientInfo) {
        try {
          const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
          ccsCred = {
            credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          };
        } catch (e) {
          this.logger.verbose("Could not parse client info for CCS Header: " + e);
        }
      } else {
        ccsCred = request.ccsCredential;
      }
      if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
        switch (ccsCred.type) {
          case CcsCredentialType.HOME_ACCOUNT_ID:
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
            }
            break;
          case CcsCredentialType.UPN:
            addCcsUpn(parameters, ccsCred.credential);
            break;
        }
      }
      if (request.embeddedClientId) {
        addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
      }
      if (request.tokenBodyParameters) {
        addExtraQueryParameters(parameters, request.tokenBodyParameters);
      }
      if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
        addExtraQueryParameters(parameters, {
          [RETURN_SPA_CODE]: "1"
        });
      }
      instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
      return mapToQueryString(parameters);
    }
    /**
     * This API validates the `EndSessionRequest` and creates a URL
     * @param request
     */
    createLogoutUrlQueryString(request) {
      const parameters = /* @__PURE__ */ new Map();
      if (request.postLogoutRedirectUri) {
        addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
      }
      if (request.correlationId) {
        addCorrelationId(parameters, request.correlationId);
      }
      if (request.idTokenHint) {
        addIdTokenHint(parameters, request.idTokenHint);
      }
      if (request.state) {
        addState(parameters, request.state);
      }
      if (request.logoutHint) {
        addLogoutHint(parameters, request.logoutHint);
      }
      if (request.extraQueryParameters) {
        addExtraQueryParameters(parameters, request.extraQueryParameters);
      }
      if (this.config.authOptions.instanceAware) {
        addInstanceAware(parameters);
      }
      return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
  var RefreshTokenClient = class extends BaseClient {
    constructor(configuration, performanceClient) {
      super(configuration, performanceClient);
    }
    async acquireToken(request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
      const reqTimestamp = nowSeconds();
      const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
      const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
      const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
      responseHandler.validateTokenResponse(response.body);
      return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache, requestId);
    }
    /**
     * Gets cached refresh token and attaches to request, then calls acquireToken API
     * @param request
     */
    async acquireTokenByRefreshToken(request) {
      if (!request) {
        throw createClientConfigurationError(tokenRequestEmpty);
      }
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
      if (!request.account) {
        throw createClientAuthError(noAccountInSilentRequest);
      }
      const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
      if (isFOCI) {
        try {
          return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
        } catch (e) {
          const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
          const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
          if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
            return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
          } else {
            throw e;
          }
        }
      }
      return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
    }
    /**
     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
     * @param request
     */
    async acquireTokenWithCachedRefreshToken(request, foci) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
      const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, void 0, this.performanceClient, request.correlationId);
      if (!refreshToken) {
        throw createInteractionRequiredAuthError(noTokensFound);
      }
      if (refreshToken.expiresOn && isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
        this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
        throw createInteractionRequiredAuthError(refreshTokenExpired);
      }
      const refreshTokenRequest = {
        ...request,
        refreshToken: refreshToken.secret,
        authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
        ccsCredential: {
          credential: request.account.homeAccountId,
          type: CcsCredentialType.HOME_ACCOUNT_ID
        }
      };
      try {
        return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
      } catch (e) {
        if (e instanceof InteractionRequiredAuthError) {
          this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
          if (e.subError === badToken) {
            this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
            const badRefreshTokenKey = generateCredentialKey(refreshToken);
            this.cacheManager.removeRefreshToken(badRefreshTokenKey);
          }
        }
        throw e;
      }
    }
    /**
     * Constructs the network message and makes a NW call to the underlying secure token service
     * @param request
     * @param authority
     */
    async executeTokenRequest(request, authority) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
      const queryParametersString = this.createTokenQueryParameters(request);
      const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
      const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
      const headers = this.createTokenRequestHeaders(request.ccsCredential);
      const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
      return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
    }
    /**
     * Helper function to create the token request body
     * @param request
     */
    async createTokenRequestBody(request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
      const parameters = /* @__PURE__ */ new Map();
      addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
      if (request.redirectUri) {
        addRedirectUri(parameters, request.redirectUri);
      }
      addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
      addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
      addClientInfo(parameters);
      addLibraryInfo(parameters, this.config.libraryInfo);
      addApplicationTelemetry(parameters, this.config.telemetry.application);
      addThrottling(parameters);
      if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
        addServerTelemetry(parameters, this.serverTelemetryManager);
      }
      addRefreshToken(parameters, request.refreshToken);
      if (this.config.clientCredentials.clientSecret) {
        addClientSecret(parameters, this.config.clientCredentials.clientSecret);
      }
      if (this.config.clientCredentials.clientAssertion) {
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
        addClientAssertionType(parameters, clientAssertion.assertionType);
      }
      if (request.authenticationScheme === AuthenticationScheme.POP) {
        const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
        let reqCnfData;
        if (!request.popKid) {
          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
          reqCnfData = generatedReqCnfData.reqCnfString;
        } else {
          reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
        }
        addPopToken(parameters, reqCnfData);
      } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
        if (request.sshJwk) {
          addSshJwk(parameters, request.sshJwk);
        } else {
          throw createClientConfigurationError(missingSshJwk);
        }
      }
      if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
        addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
      }
      if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
        switch (request.ccsCredential.type) {
          case CcsCredentialType.HOME_ACCOUNT_ID:
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
            }
            break;
          case CcsCredentialType.UPN:
            addCcsUpn(parameters, request.ccsCredential.credential);
            break;
        }
      }
      if (request.embeddedClientId) {
        addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
      }
      if (request.tokenBodyParameters) {
        addExtraQueryParameters(parameters, request.tokenBodyParameters);
      }
      instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
      return mapToQueryString(parameters);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SilentFlowClient = class extends BaseClient {
    constructor(configuration, performanceClient) {
      super(configuration, performanceClient);
    }
    /**
     * Retrieves token from cache or throws an error if it must be refreshed.
     * @param request
     */
    async acquireCachedToken(request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
      let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
      if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
        this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
        throw createClientAuthError(tokenRefreshRequired);
      }
      if (!request.account) {
        throw createClientAuthError(noAccountInSilentRequest);
      }
      const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
      const tokenKeys = this.cacheManager.getTokenKeys();
      const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId, this.performanceClient, request.correlationId);
      if (!cachedAccessToken) {
        this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
        throw createClientAuthError(tokenRefreshRequired);
      } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
        this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
        throw createClientAuthError(tokenRefreshRequired);
      } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
        lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
      }
      const environment = request.authority || this.authority.getPreferredCache();
      const cacheRecord = {
        account: this.cacheManager.readAccountFromCache(request.account),
        accessToken: cachedAccessToken,
        idToken: this.cacheManager.getIdToken(request.account, tokenKeys, requestTenantId, this.performanceClient, request.correlationId),
        refreshToken: null,
        appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
      };
      this.setCacheOutcome(lastCacheOutcome, request.correlationId);
      if (this.config.serverTelemetryManager) {
        this.config.serverTelemetryManager.incrementCacheHits();
      }
      return [
        await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
        lastCacheOutcome
      ];
    }
    setCacheOutcome(cacheOutcome, correlationId) {
      this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
      this.performanceClient?.addFields({
        cacheOutcome
      }, correlationId);
      if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
        this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
      }
    }
    /**
     * Helper function to build response object from the CacheRecord
     * @param cacheRecord
     */
    async generateResultFromCacheRecord(cacheRecord, request) {
      this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
      let idTokenClaims;
      if (cacheRecord.idToken) {
        idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
      }
      if (request.maxAge || request.maxAge === 0) {
        const authTime = idTokenClaims?.auth_time;
        if (!authTime) {
          throw createClientAuthError(authTimeNotFound);
        }
        checkMaxAge(authTime, request.maxAge);
      }
      return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/network/INetworkModule.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var StubbedNetworkModule = {
    sendGetRequestAsync: () => {
      return Promise.reject(createClientAuthError(methodNotImplemented));
    },
    sendPostRequestAsync: () => {
      return Promise.reject(createClientAuthError(methodNotImplemented));
    }
  };

  // ../../node_modules/@azure/msal-common/dist/protocol/Authorize.mjs
  var Authorize_exports = {};
  __export(Authorize_exports, {
    getAuthorizationCodePayload: () => getAuthorizationCodePayload,
    getAuthorizeUrl: () => getAuthorizeUrl,
    getStandardAuthorizeRequestParameters: () => getStandardAuthorizeRequestParameters,
    validateAuthorizationResponse: () => validateAuthorizationResponse
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
    const correlationId = request.correlationId;
    const parameters = /* @__PURE__ */ new Map();
    addClientId(parameters, request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId);
    const requestScopes = [
      ...request.scopes || [],
      ...request.extraScopesToConsent || []
    ];
    addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
    addRedirectUri(parameters, request.redirectUri);
    addCorrelationId(parameters, correlationId);
    addResponseMode(parameters, request.responseMode);
    addClientInfo(parameters);
    if (request.prompt) {
      addPrompt(parameters, request.prompt);
      performanceClient?.addFields({ prompt: request.prompt }, correlationId);
    }
    if (request.domainHint) {
      addDomainHint(parameters, request.domainHint);
      performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);
    }
    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
      if (request.sid && request.prompt === PromptValue.NONE) {
        logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
        addSid(parameters, request.sid);
        performanceClient?.addFields({ sidFromRequest: true }, correlationId);
      } else if (request.account) {
        const accountSid = extractAccountSid(request.account);
        let accountLoginHintClaim = extractLoginHint(request.account);
        if (accountLoginHintClaim && request.domainHint) {
          logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
          accountLoginHintClaim = null;
        }
        if (accountLoginHintClaim) {
          logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
          addLoginHint(parameters, accountLoginHintClaim);
          performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
            addCcsOid(parameters, clientInfo);
          } catch (e) {
            logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
          }
        } else if (accountSid && request.prompt === PromptValue.NONE) {
          logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
          addSid(parameters, accountSid);
          performanceClient?.addFields({ sidFromClaim: true }, correlationId);
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
            addCcsOid(parameters, clientInfo);
          } catch (e) {
            logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
          }
        } else if (request.loginHint) {
          logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
          addLoginHint(parameters, request.loginHint);
          addCcsUpn(parameters, request.loginHint);
          performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
        } else if (request.account.username) {
          logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
          addLoginHint(parameters, request.account.username);
          performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);
          try {
            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
            addCcsOid(parameters, clientInfo);
          } catch (e) {
            logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
          }
        }
      } else if (request.loginHint) {
        logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
        addLoginHint(parameters, request.loginHint);
        addCcsUpn(parameters, request.loginHint);
        performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
      }
    } else {
      logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
    }
    if (request.nonce) {
      addNonce(parameters, request.nonce);
    }
    if (request.state) {
      addState(parameters, request.state);
    }
    if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
      addClaims(parameters, request.claims, authOptions.clientCapabilities);
    }
    if (request.embeddedClientId) {
      addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
    }
    if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
      addInstanceAware(parameters);
    }
    return parameters;
  }
  function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
    const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
    return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
  }
  function getAuthorizationCodePayload(serverParams, cachedState) {
    validateAuthorizationResponse(serverParams, cachedState);
    if (!serverParams.code) {
      throw createClientAuthError(authorizationCodeMissingFromServerResponse);
    }
    return serverParams;
  }
  function validateAuthorizationResponse(serverResponse, requestState) {
    if (!serverResponse.state || !requestState) {
      throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
    }
    let decodedServerResponseState;
    let decodedRequestState;
    try {
      decodedServerResponseState = decodeURIComponent(serverResponse.state);
    } catch (e) {
      throw createClientAuthError(invalidState, serverResponse.state);
    }
    try {
      decodedRequestState = decodeURIComponent(requestState);
    } catch (e) {
      throw createClientAuthError(invalidState, serverResponse.state);
    }
    if (decodedServerResponseState !== decodedRequestState) {
      throw createClientAuthError(stateMismatch);
    }
    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
      const serverErrorNo = parseServerErrorNo(serverResponse);
      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
        throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
      }
      throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
    }
  }
  function parseServerErrorNo(serverResponse) {
    const errorCodePrefix = "code=";
    const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
    return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
  }
  function extractAccountSid(account) {
    return account.idTokenClaims?.sid || null;
  }
  function extractLoginHint(account) {
    return account.idTokenClaims?.login_hint || null;
  }

  // ../../node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var skuGroupSeparator = ",";
  var skuValueSeparator = "|";
  function makeExtraSkuString(params) {
    const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
    const skuMap = /* @__PURE__ */ new Map([
      [0, [libraryName, libraryVersion]],
      [2, [extensionName, extensionVersion]]
    ]);
    let skuArr = [];
    if (skus?.length) {
      skuArr = skus.split(skuGroupSeparator);
      if (skuArr.length < 4) {
        return skus;
      }
    } else {
      skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
    }
    skuMap.forEach((value, key) => {
      if (value.length === 2 && value[0]?.length && value[1]?.length) {
        setSku({
          skuArr,
          index: key,
          skuName: value[0],
          skuVersion: value[1]
        });
      }
    });
    return skuArr.join(skuGroupSeparator);
  }
  function setSku(params) {
    const { skuArr, index: index2, skuName, skuVersion } = params;
    if (index2 >= skuArr.length) {
      return;
    }
    skuArr[index2] = [skuName, skuVersion].join(skuValueSeparator);
  }
  var ServerTelemetryManager = class _ServerTelemetryManager {
    constructor(telemetryRequest, cacheManager) {
      this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
      this.cacheManager = cacheManager;
      this.apiId = telemetryRequest.apiId;
      this.correlationId = telemetryRequest.correlationId;
      this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
      this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
      this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
    }
    /**
     * API to add MSER Telemetry to request
     */
    generateCurrentRequestHeaderValue() {
      const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
      const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
      const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
      if (nativeBrokerErrorCode?.length) {
        platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
      }
      const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      const regionDiscoveryFields = this.getRegionDiscoveryFields();
      const requestWithRegionDiscoveryFields = [
        request,
        regionDiscoveryFields
      ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [
        SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
        requestWithRegionDiscoveryFields,
        platformFields
      ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    }
    /**
     * API to add MSER Telemetry for the last failed request
     */
    generateLastRequestHeaderValue() {
      const lastRequests = this.getLastRequests();
      const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
      const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      const errorCount = lastRequests.errors.length;
      const overflow2 = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
      const platformFields = [errorCount, overflow2].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
      return [
        SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
        lastRequests.cacheHits,
        failedRequests,
        errors,
        platformFields
      ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
    }
    /**
     * API to cache token failures for MSER data capture
     * @param error
     */
    cacheFailedRequest(error) {
      const lastRequests = this.getLastRequests();
      if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
        lastRequests.failedRequests.shift();
        lastRequests.failedRequests.shift();
        lastRequests.errors.shift();
      }
      lastRequests.failedRequests.push(this.apiId, this.correlationId);
      if (error instanceof Error && !!error && error.toString()) {
        if (error instanceof AuthError) {
          if (error.subError) {
            lastRequests.errors.push(error.subError);
          } else if (error.errorCode) {
            lastRequests.errors.push(error.errorCode);
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(error.toString());
        }
      } else {
        lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
      }
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      return;
    }
    /**
     * Update server telemetry cache entry by incrementing cache hit counter
     */
    incrementCacheHits() {
      const lastRequests = this.getLastRequests();
      lastRequests.cacheHits += 1;
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
      return lastRequests.cacheHits;
    }
    /**
     * Get the server telemetry entity from cache or initialize a new one
     */
    getLastRequests() {
      const initialValue = {
        failedRequests: [],
        errors: [],
        cacheHits: 0
      };
      const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
      return lastRequests || initialValue;
    }
    /**
     * Remove server telemetry cache entry
     */
    clearTelemetryCache() {
      const lastRequests = this.getLastRequests();
      const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
      const errorCount = lastRequests.errors.length;
      if (numErrorsFlushed === errorCount) {
        this.cacheManager.removeItem(this.telemetryCacheKey);
      } else {
        const serverTelemEntity = {
          failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
          errors: lastRequests.errors.slice(numErrorsFlushed),
          cacheHits: 0
        };
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
      }
    }
    /**
     * Returns the maximum number of errors that can be flushed to the server in the next network request
     * @param serverTelemetryEntity
     */
    static maxErrorsToSend(serverTelemetryEntity) {
      let i;
      let maxErrors = 0;
      let dataSize = 0;
      const errorCount = serverTelemetryEntity.errors.length;
      for (i = 0; i < errorCount; i++) {
        const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
        const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
        const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
        dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
        if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
          maxErrors += 1;
        } else {
          break;
        }
      }
      return maxErrors;
    }
    /**
     * Get the region discovery fields
     *
     * @returns string
     */
    getRegionDiscoveryFields() {
      const regionDiscoveryFields = [];
      regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
      regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
      regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
      return regionDiscoveryFields.join(",");
    }
    /**
     * Update the region discovery metadata
     *
     * @param regionDiscoveryMetadata
     * @returns void
     */
    updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
      this.regionUsed = regionDiscoveryMetadata.region_used;
      this.regionSource = regionDiscoveryMetadata.region_source;
      this.regionOutcome = regionDiscoveryMetadata.region_outcome;
    }
    /**
     * Set cache outcome
     */
    setCacheOutcome(cacheOutcome) {
      this.cacheOutcome = cacheOutcome;
    }
    setNativeBrokerErrorCode(errorCode) {
      const lastRequests = this.getLastRequests();
      lastRequests.nativeBrokerErrorCode = errorCode;
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    }
    getNativeBrokerErrorCode() {
      return this.getLastRequests().nativeBrokerErrorCode;
    }
    clearNativeBrokerErrorCode() {
      const lastRequests = this.getLastRequests();
      delete lastRequests.nativeBrokerErrorCode;
      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
    }
    static makeExtraSkuString(params) {
      return makeExtraSkuString(params);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/crypto/JoseHeader.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/JoseHeaderError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-common/dist/error/JoseHeaderErrorCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var missingKidError = "missing_kid_error";
  var missingAlgError = "missing_alg_error";

  // ../../node_modules/@azure/msal-common/dist/error/JoseHeaderError.mjs
  var JoseHeaderErrorMessages = {
    [missingKidError]: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided.",
    [missingAlgError]: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
  };
  var JoseHeaderError = class _JoseHeaderError extends AuthError {
    constructor(errorCode, errorMessage) {
      super(errorCode, errorMessage);
      this.name = "JoseHeaderError";
      Object.setPrototypeOf(this, _JoseHeaderError.prototype);
    }
  };
  function createJoseHeaderError(code4) {
    return new JoseHeaderError(code4, JoseHeaderErrorMessages[code4]);
  }

  // ../../node_modules/@azure/msal-common/dist/crypto/JoseHeader.mjs
  var JoseHeader = class _JoseHeader {
    constructor(options) {
      this.typ = options.typ;
      this.alg = options.alg;
      this.kid = options.kid;
    }
    /**
     * Builds SignedHttpRequest formatted JOSE Header from the
     * JOSE Header options provided or previously set on the object and returns
     * the stringified header object.
     * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
     * @param shrHeaderOptions
     * @returns
     */
    static getShrHeaderString(shrHeaderOptions) {
      if (!shrHeaderOptions.kid) {
        throw createJoseHeaderError(missingKidError);
      }
      if (!shrHeaderOptions.alg) {
        throw createJoseHeaderError(missingAlgError);
      }
      const shrHeader = new _JoseHeader({
        // Access Token PoP headers must have type pop, but the type header can be overriden for special cases
        typ: shrHeaderOptions.typ || JsonWebTokenTypes.Pop,
        kid: shrHeaderOptions.kid,
        alg: shrHeaderOptions.alg
      });
      return JSON.stringify(shrHeader);
    }
  };

  // ../../node_modules/@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var StubPerformanceMeasurement = class {
    startMeasurement() {
      return;
    }
    endMeasurement() {
      return;
    }
    flushMeasurement() {
      return null;
    }
  };
  var StubPerformanceClient = class {
    generateId() {
      return "callback-id";
    }
    startMeasurement(measureName, correlationId) {
      return {
        end: () => null,
        discard: () => {
        },
        add: () => {
        },
        increment: () => {
        },
        event: {
          eventId: this.generateId(),
          status: PerformanceEventStatus.InProgress,
          authority: "",
          libraryName: "",
          libraryVersion: "",
          clientId: "",
          name: measureName,
          startTimeMs: Date.now(),
          correlationId: correlationId || ""
        },
        measurement: new StubPerformanceMeasurement()
      };
    }
    startPerformanceMeasurement() {
      return new StubPerformanceMeasurement();
    }
    calculateQueuedTime() {
      return 0;
    }
    addQueueMeasurement() {
      return;
    }
    setPreQueueTime() {
      return;
    }
    endMeasurement() {
      return null;
    }
    discardMeasurements() {
      return;
    }
    removePerformanceCallback() {
      return true;
    }
    addPerformanceCallback() {
      return "";
    }
    emitEvents() {
      return;
    }
    addFields() {
      return;
    }
    incrementFields() {
      return;
    }
    cacheEventByCorrelationId() {
      return;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserAuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserAuthErrorCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var pkceNotCreated = "pkce_not_created";
  var earJwkEmpty = "ear_jwk_empty";
  var earJweEmpty = "ear_jwe_empty";
  var cryptoNonExistent = "crypto_nonexistent";
  var emptyNavigateUri = "empty_navigate_uri";
  var hashEmptyError = "hash_empty_error";
  var noStateInHash = "no_state_in_hash";
  var hashDoesNotContainKnownProperties = "hash_does_not_contain_known_properties";
  var unableToParseState = "unable_to_parse_state";
  var stateInteractionTypeMismatch = "state_interaction_type_mismatch";
  var interactionInProgress = "interaction_in_progress";
  var popupWindowError = "popup_window_error";
  var emptyWindowError = "empty_window_error";
  var userCancelled = "user_cancelled";
  var monitorPopupTimeout = "monitor_popup_timeout";
  var monitorWindowTimeout = "monitor_window_timeout";
  var redirectInIframe = "redirect_in_iframe";
  var blockIframeReload = "block_iframe_reload";
  var blockNestedPopups = "block_nested_popups";
  var iframeClosedPrematurely = "iframe_closed_prematurely";
  var silentLogoutUnsupported = "silent_logout_unsupported";
  var noAccountError = "no_account_error";
  var silentPromptValueError = "silent_prompt_value_error";
  var noTokenRequestCacheError = "no_token_request_cache_error";
  var unableToParseTokenRequestCacheError = "unable_to_parse_token_request_cache_error";
  var authRequestNotSetError = "auth_request_not_set_error";
  var invalidCacheType = "invalid_cache_type";
  var nonBrowserEnvironment = "non_browser_environment";
  var databaseNotOpen = "database_not_open";
  var noNetworkConnectivity2 = "no_network_connectivity";
  var postRequestFailed2 = "post_request_failed";
  var getRequestFailed = "get_request_failed";
  var failedToParseResponse = "failed_to_parse_response";
  var unableToLoadToken = "unable_to_load_token";
  var cryptoKeyNotFound = "crypto_key_not_found";
  var authCodeRequired = "auth_code_required";
  var authCodeOrNativeAccountIdRequired = "auth_code_or_nativeAccountId_required";
  var spaCodeAndNativeAccountIdPresent = "spa_code_and_nativeAccountId_present";
  var databaseUnavailable = "database_unavailable";
  var unableToAcquireTokenFromNativePlatform = "unable_to_acquire_token_from_native_platform";
  var nativeHandshakeTimeout = "native_handshake_timeout";
  var nativeExtensionNotInstalled = "native_extension_not_installed";
  var nativeConnectionNotEstablished = "native_connection_not_established";
  var uninitializedPublicClientApplication = "uninitialized_public_client_application";
  var nativePromptNotSupported = "native_prompt_not_supported";
  var invalidBase64String = "invalid_base64_string";
  var invalidPopTokenRequest = "invalid_pop_token_request";
  var failedToBuildHeaders = "failed_to_build_headers";
  var failedToParseHeaders = "failed_to_parse_headers";
  var failedToDecryptEarResponse = "failed_to_decrypt_ear_response";

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserAuthError.mjs
  var ErrorLink = "For more visit: aka.ms/msaljs/browser-errors";
  var BrowserAuthErrorMessages = {
    [pkceNotCreated]: "The PKCE code challenge and verifier could not be generated.",
    [earJwkEmpty]: "No EAR encryption key provided. This is unexpected.",
    [earJweEmpty]: "Server response does not contain ear_jwe property. This is unexpected.",
    [cryptoNonExistent]: "The crypto object or function is not available.",
    [emptyNavigateUri]: "Navigation URI is empty. Please check stack trace for more info.",
    [hashEmptyError]: `Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash. ${ErrorLink}`,
    [noStateInHash]: "Hash does not contain state. Please verify that the request originated from msal.",
    [hashDoesNotContainKnownProperties]: `Hash does not contain known properites. Please verify that your redirectUri is not changing the hash.  ${ErrorLink}`,
    [unableToParseState]: "Unable to parse state. Please verify that the request originated from msal.",
    [stateInteractionTypeMismatch]: "Hash contains state but the interaction type does not match the caller.",
    [interactionInProgress]: `Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.   ${ErrorLink}`,
    [popupWindowError]: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser.",
    [emptyWindowError]: "window.open returned null or undefined window object.",
    [userCancelled]: "User cancelled the flow.",
    [monitorPopupTimeout]: `Token acquisition in popup failed due to timeout.  ${ErrorLink}`,
    [monitorWindowTimeout]: `Token acquisition in iframe failed due to timeout.  ${ErrorLink}`,
    [redirectInIframe]: "Redirects are not supported for iframed or brokered applications. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs.",
    [blockIframeReload]: `Request was blocked inside an iframe because MSAL detected an authentication response.  ${ErrorLink}`,
    [blockNestedPopups]: "Request was blocked inside a popup because MSAL detected it was running in a popup.",
    [iframeClosedPrematurely]: "The iframe being monitored was closed prematurely.",
    [silentLogoutUnsupported]: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead.",
    [noAccountError]: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request.",
    [silentPromptValueError]: "The value given for the prompt value is not valid for silent requests - must be set to 'none' or 'no_session'.",
    [noTokenRequestCacheError]: "No token request found in cache.",
    [unableToParseTokenRequestCacheError]: "The cached token request could not be parsed.",
    [authRequestNotSetError]: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler",
    [invalidCacheType]: "Invalid cache type",
    [nonBrowserEnvironment]: "Login and token requests are not supported in non-browser environments.",
    [databaseNotOpen]: "Database is not open!",
    [noNetworkConnectivity2]: "No network connectivity. Check your internet connection.",
    [postRequestFailed2]: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'",
    [getRequestFailed]: "Network request failed. Please check the network trace to determine root cause.",
    [failedToParseResponse]: "Failed to parse network response. Check network trace.",
    [unableToLoadToken]: "Error loading token to cache.",
    [cryptoKeyNotFound]: "Cryptographic Key or Keypair not found in browser storage.",
    [authCodeRequired]: "An authorization code must be provided (as the `code` property on the request) to this flow.",
    [authCodeOrNativeAccountIdRequired]: "An authorization code or nativeAccountId must be provided to this flow.",
    [spaCodeAndNativeAccountIdPresent]: "Request cannot contain both spa code and native account id.",
    [databaseUnavailable]: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts.",
    [unableToAcquireTokenFromNativePlatform]: `Unable to acquire token from native platform.  ${ErrorLink}`,
    [nativeHandshakeTimeout]: "Timed out while attempting to establish connection to browser extension",
    [nativeExtensionNotInstalled]: "Native extension is not installed. If you think this is a mistake call the initialize function.",
    [nativeConnectionNotEstablished]: `Connection to native platform has not been established. Please install a compatible browser extension and run initialize().  ${ErrorLink}`,
    [uninitializedPublicClientApplication]: `You must call and await the initialize function before attempting to call any other MSAL API.  ${ErrorLink}`,
    [nativePromptNotSupported]: "The provided prompt is not supported by the native platform. This request should be routed to the web based flow.",
    [invalidBase64String]: "Invalid base64 encoded string.",
    [invalidPopTokenRequest]: "Invalid PoP token request. The request should not have both a popKid value and signPopToken set to true.",
    [failedToBuildHeaders]: "Failed to build request headers object.",
    [failedToParseHeaders]: "Failed to parse response headers",
    [failedToDecryptEarResponse]: "Failed to decrypt ear response"
  };
  var BrowserAuthErrorMessage = {
    pkceNotGenerated: {
      code: pkceNotCreated,
      desc: BrowserAuthErrorMessages[pkceNotCreated]
    },
    cryptoDoesNotExist: {
      code: cryptoNonExistent,
      desc: BrowserAuthErrorMessages[cryptoNonExistent]
    },
    emptyNavigateUriError: {
      code: emptyNavigateUri,
      desc: BrowserAuthErrorMessages[emptyNavigateUri]
    },
    hashEmptyError: {
      code: hashEmptyError,
      desc: BrowserAuthErrorMessages[hashEmptyError]
    },
    hashDoesNotContainStateError: {
      code: noStateInHash,
      desc: BrowserAuthErrorMessages[noStateInHash]
    },
    hashDoesNotContainKnownPropertiesError: {
      code: hashDoesNotContainKnownProperties,
      desc: BrowserAuthErrorMessages[hashDoesNotContainKnownProperties]
    },
    unableToParseStateError: {
      code: unableToParseState,
      desc: BrowserAuthErrorMessages[unableToParseState]
    },
    stateInteractionTypeMismatchError: {
      code: stateInteractionTypeMismatch,
      desc: BrowserAuthErrorMessages[stateInteractionTypeMismatch]
    },
    interactionInProgress: {
      code: interactionInProgress,
      desc: BrowserAuthErrorMessages[interactionInProgress]
    },
    popupWindowError: {
      code: popupWindowError,
      desc: BrowserAuthErrorMessages[popupWindowError]
    },
    emptyWindowError: {
      code: emptyWindowError,
      desc: BrowserAuthErrorMessages[emptyWindowError]
    },
    userCancelledError: {
      code: userCancelled,
      desc: BrowserAuthErrorMessages[userCancelled]
    },
    monitorPopupTimeoutError: {
      code: monitorPopupTimeout,
      desc: BrowserAuthErrorMessages[monitorPopupTimeout]
    },
    monitorIframeTimeoutError: {
      code: monitorWindowTimeout,
      desc: BrowserAuthErrorMessages[monitorWindowTimeout]
    },
    redirectInIframeError: {
      code: redirectInIframe,
      desc: BrowserAuthErrorMessages[redirectInIframe]
    },
    blockTokenRequestsInHiddenIframeError: {
      code: blockIframeReload,
      desc: BrowserAuthErrorMessages[blockIframeReload]
    },
    blockAcquireTokenInPopupsError: {
      code: blockNestedPopups,
      desc: BrowserAuthErrorMessages[blockNestedPopups]
    },
    iframeClosedPrematurelyError: {
      code: iframeClosedPrematurely,
      desc: BrowserAuthErrorMessages[iframeClosedPrematurely]
    },
    silentLogoutUnsupportedError: {
      code: silentLogoutUnsupported,
      desc: BrowserAuthErrorMessages[silentLogoutUnsupported]
    },
    noAccountError: {
      code: noAccountError,
      desc: BrowserAuthErrorMessages[noAccountError]
    },
    silentPromptValueError: {
      code: silentPromptValueError,
      desc: BrowserAuthErrorMessages[silentPromptValueError]
    },
    noTokenRequestCacheError: {
      code: noTokenRequestCacheError,
      desc: BrowserAuthErrorMessages[noTokenRequestCacheError]
    },
    unableToParseTokenRequestCacheError: {
      code: unableToParseTokenRequestCacheError,
      desc: BrowserAuthErrorMessages[unableToParseTokenRequestCacheError]
    },
    authRequestNotSet: {
      code: authRequestNotSetError,
      desc: BrowserAuthErrorMessages[authRequestNotSetError]
    },
    invalidCacheType: {
      code: invalidCacheType,
      desc: BrowserAuthErrorMessages[invalidCacheType]
    },
    notInBrowserEnvironment: {
      code: nonBrowserEnvironment,
      desc: BrowserAuthErrorMessages[nonBrowserEnvironment]
    },
    databaseNotOpen: {
      code: databaseNotOpen,
      desc: BrowserAuthErrorMessages[databaseNotOpen]
    },
    noNetworkConnectivity: {
      code: noNetworkConnectivity2,
      desc: BrowserAuthErrorMessages[noNetworkConnectivity2]
    },
    postRequestFailed: {
      code: postRequestFailed2,
      desc: BrowserAuthErrorMessages[postRequestFailed2]
    },
    getRequestFailed: {
      code: getRequestFailed,
      desc: BrowserAuthErrorMessages[getRequestFailed]
    },
    failedToParseNetworkResponse: {
      code: failedToParseResponse,
      desc: BrowserAuthErrorMessages[failedToParseResponse]
    },
    unableToLoadTokenError: {
      code: unableToLoadToken,
      desc: BrowserAuthErrorMessages[unableToLoadToken]
    },
    signingKeyNotFoundInStorage: {
      code: cryptoKeyNotFound,
      desc: BrowserAuthErrorMessages[cryptoKeyNotFound]
    },
    authCodeRequired: {
      code: authCodeRequired,
      desc: BrowserAuthErrorMessages[authCodeRequired]
    },
    authCodeOrNativeAccountRequired: {
      code: authCodeOrNativeAccountIdRequired,
      desc: BrowserAuthErrorMessages[authCodeOrNativeAccountIdRequired]
    },
    spaCodeAndNativeAccountPresent: {
      code: spaCodeAndNativeAccountIdPresent,
      desc: BrowserAuthErrorMessages[spaCodeAndNativeAccountIdPresent]
    },
    databaseUnavailable: {
      code: databaseUnavailable,
      desc: BrowserAuthErrorMessages[databaseUnavailable]
    },
    unableToAcquireTokenFromNativePlatform: {
      code: unableToAcquireTokenFromNativePlatform,
      desc: BrowserAuthErrorMessages[unableToAcquireTokenFromNativePlatform]
    },
    nativeHandshakeTimeout: {
      code: nativeHandshakeTimeout,
      desc: BrowserAuthErrorMessages[nativeHandshakeTimeout]
    },
    nativeExtensionNotInstalled: {
      code: nativeExtensionNotInstalled,
      desc: BrowserAuthErrorMessages[nativeExtensionNotInstalled]
    },
    nativeConnectionNotEstablished: {
      code: nativeConnectionNotEstablished,
      desc: BrowserAuthErrorMessages[nativeConnectionNotEstablished]
    },
    uninitializedPublicClientApplication: {
      code: uninitializedPublicClientApplication,
      desc: BrowserAuthErrorMessages[uninitializedPublicClientApplication]
    },
    nativePromptNotSupported: {
      code: nativePromptNotSupported,
      desc: BrowserAuthErrorMessages[nativePromptNotSupported]
    },
    invalidBase64StringError: {
      code: invalidBase64String,
      desc: BrowserAuthErrorMessages[invalidBase64String]
    },
    invalidPopTokenRequest: {
      code: invalidPopTokenRequest,
      desc: BrowserAuthErrorMessages[invalidPopTokenRequest]
    }
  };
  var BrowserAuthError = class _BrowserAuthError extends AuthError {
    constructor(errorCode, subError) {
      super(errorCode, BrowserAuthErrorMessages[errorCode], subError);
      Object.setPrototypeOf(this, _BrowserAuthError.prototype);
      this.name = "BrowserAuthError";
    }
  };
  function createBrowserAuthError(errorCode, subError) {
    return new BrowserAuthError(errorCode, subError);
  }

  // ../../node_modules/@azure/msal-browser/dist/utils/BrowserConstants.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var BrowserConstants = {
    /**
     * Interaction in progress cache value
     */
    INTERACTION_IN_PROGRESS_VALUE: "interaction_in_progress",
    /**
     * Invalid grant error code
     */
    INVALID_GRANT_ERROR: "invalid_grant",
    /**
     * Default popup window width
     */
    POPUP_WIDTH: 483,
    /**
     * Default popup window height
     */
    POPUP_HEIGHT: 600,
    /**
     * Name of the popup window starts with
     */
    POPUP_NAME_PREFIX: "msal",
    /**
     * Default popup monitor poll interval in milliseconds
     */
    DEFAULT_POLL_INTERVAL_MS: 30,
    /**
     * Msal-browser SKU
     */
    MSAL_SKU: "msal.js.browser"
  };
  var NativeConstants = {
    CHANNEL_ID: "53ee284d-920a-4b59-9d30-a60315b26836",
    PREFERRED_EXTENSION_ID: "ppnbnpeolgkicgegkbkbjmhlideopiji",
    MATS_TELEMETRY: "MATS"
  };
  var NativeExtensionMethod = {
    HandshakeRequest: "Handshake",
    HandshakeResponse: "HandshakeResponse",
    GetToken: "GetToken",
    Response: "Response"
  };
  var BrowserCacheLocation = {
    LocalStorage: "localStorage",
    SessionStorage: "sessionStorage",
    MemoryStorage: "memoryStorage"
  };
  var HTTP_REQUEST_TYPE = {
    GET: "GET",
    POST: "POST"
  };
  var INTERACTION_TYPE = {
    SIGNIN: "signin",
    SIGNOUT: "signout"
  };
  var TemporaryCacheKeys = {
    ORIGIN_URI: "request.origin",
    URL_HASH: "urlHash",
    REQUEST_PARAMS: "request.params",
    VERIFIER: "code.verifier",
    INTERACTION_STATUS_KEY: "interaction.status",
    NATIVE_REQUEST: "request.native"
  };
  var StaticCacheKeys = {
    ACCOUNT_KEYS: "msal.account.keys",
    TOKEN_KEYS: "msal.token.keys"
  };
  var InMemoryCacheKeys = {
    WRAPPER_SKU: "wrapper.sku",
    WRAPPER_VER: "wrapper.version"
  };
  var ApiId = {
    acquireTokenRedirect: 861,
    acquireTokenPopup: 862,
    ssoSilent: 863,
    acquireTokenSilent_authCode: 864,
    handleRedirectPromise: 865,
    acquireTokenByCode: 866,
    acquireTokenSilent_silentFlow: 61,
    logout: 961,
    logoutPopup: 962
  };
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2["Redirect"] = "redirect";
    InteractionType2["Popup"] = "popup";
    InteractionType2["Silent"] = "silent";
    InteractionType2["None"] = "none";
  })(InteractionType || (InteractionType = {}));
  var InteractionStatus = {
    /**
     * Initial status before interaction occurs
     */
    Startup: "startup",
    /**
     * Status set when all login calls occuring
     */
    Login: "login",
    /**
     * Status set when logout call occuring
     */
    Logout: "logout",
    /**
     * Status set for acquireToken calls
     */
    AcquireToken: "acquireToken",
    /**
     * Status set for ssoSilent calls
     */
    SsoSilent: "ssoSilent",
    /**
     * Status set when handleRedirect in progress
     */
    HandleRedirect: "handleRedirect",
    /**
     * Status set when interaction is complete
     */
    None: "none"
  };
  var DEFAULT_REQUEST = {
    scopes: OIDC_DEFAULT_SCOPES
  };
  var KEY_FORMAT_JWK = "jwk";
  var WrapperSKU = {
    React: "@azure/msal-react",
    Angular: "@azure/msal-angular"
  };
  var DB_NAME = "msal.db";
  var DB_VERSION = 1;
  var DB_TABLE_NAME = `${DB_NAME}.keys`;
  var CacheLookupPolicy = {
    /*
     * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired
     * or cannot be found the refresh token will be used to acquire a new one. Finally, if the refresh token
     * is expired acquireTokenSilent will attempt to acquire new access and refresh tokens.
     */
    Default: 0,
    /*
     * acquireTokenSilent will only look for access tokens in the cache. It will not attempt to renew access or
     * refresh tokens.
     */
    AccessToken: 1,
    /*
     * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired or
     * cannot be found, the refresh token will be used to acquire a new one. If the refresh token is expired, it
     * will not be renewed and acquireTokenSilent will fail.
     */
    AccessTokenAndRefreshToken: 2,
    /*
     * acquireTokenSilent will not attempt to retrieve access tokens from the cache and will instead attempt to
     * exchange the cached refresh token for a new access token. If the refresh token is expired, it will not be
     * renewed and acquireTokenSilent will fail.
     */
    RefreshToken: 3,
    /*
     * acquireTokenSilent will not look in the cache for the access token. It will go directly to network with the
     * cached refresh token. If the refresh token is expired an attempt will be made to renew it. This is equivalent to
     * setting "forceRefresh: true".
     */
    RefreshTokenAndNetwork: 4,
    /*
     * acquireTokenSilent will attempt to renew both access and refresh tokens. It will not look in the cache. This will
     * always fail if 3rd party cookies are blocked by the browser.
     */
    Skip: 5
  };
  var iFrameRenewalPolicies = [
    CacheLookupPolicy.Default,
    CacheLookupPolicy.Skip,
    CacheLookupPolicy.RefreshTokenAndNetwork
  ];
  var LOG_LEVEL_CACHE_KEY = "msal.browser.log.level";
  var LOG_PII_CACHE_KEY = "msal.browser.log.pii";

  // ../../node_modules/@azure/msal-browser/dist/crypto/BrowserCrypto.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/encode/Base64Encode.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function urlEncode(input) {
    return encodeURIComponent(base64Encode(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"));
  }
  function urlEncodeArr(inputArr) {
    return base64EncArr(inputArr).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64Encode(input) {
    return base64EncArr(new TextEncoder().encode(input));
  }
  function base64EncArr(aBytes) {
    const binString = Array.from(aBytes, (x) => String.fromCodePoint(x)).join("");
    return btoa(binString);
  }

  // ../../node_modules/@azure/msal-browser/dist/encode/Base64Decode.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function base64Decode(input) {
    return new TextDecoder().decode(base64DecToArr(input));
  }
  function base64DecToArr(base64String) {
    let encodedString = base64String.replace(/-/g, "+").replace(/_/g, "/");
    switch (encodedString.length % 4) {
      case 0:
        break;
      case 2:
        encodedString += "==";
        break;
      case 3:
        encodedString += "=";
        break;
      default:
        throw createBrowserAuthError(invalidBase64String);
    }
    const binString = atob(encodedString);
    return Uint8Array.from(binString, (m) => m.codePointAt(0) || 0);
  }

  // ../../node_modules/@azure/msal-browser/dist/crypto/BrowserCrypto.mjs
  var PKCS1_V15_KEYGEN_ALG = "RSASSA-PKCS1-v1_5";
  var AES_GCM = "AES-GCM";
  var HKDF = "HKDF";
  var S256_HASH_ALG = "SHA-256";
  var MODULUS_LENGTH = 2048;
  var PUBLIC_EXPONENT = new Uint8Array([1, 0, 1]);
  var UUID_CHARS = "0123456789abcdef";
  var UINT32_ARR = new Uint32Array(1);
  var RAW = "raw";
  var ENCRYPT = "encrypt";
  var DECRYPT = "decrypt";
  var DERIVE_KEY = "deriveKey";
  var SUBTLE_SUBERROR = "crypto_subtle_undefined";
  var keygenAlgorithmOptions = {
    name: PKCS1_V15_KEYGEN_ALG,
    hash: S256_HASH_ALG,
    modulusLength: MODULUS_LENGTH,
    publicExponent: PUBLIC_EXPONENT
  };
  function validateCryptoAvailable(skipValidateSubtleCrypto) {
    if (!window) {
      throw createBrowserAuthError(nonBrowserEnvironment);
    }
    if (!window.crypto) {
      throw createBrowserAuthError(cryptoNonExistent);
    }
    if (!skipValidateSubtleCrypto && !window.crypto.subtle) {
      throw createBrowserAuthError(cryptoNonExistent, SUBTLE_SUBERROR);
    }
  }
  async function sha256Digest(dataString, performanceClient, correlationId) {
    performanceClient?.addQueueMeasurement(PerformanceEvents.Sha256Digest, correlationId);
    const encoder = new TextEncoder();
    const data2 = encoder.encode(dataString);
    return window.crypto.subtle.digest(S256_HASH_ALG, data2);
  }
  function getRandomValues2(dataBuffer) {
    return window.crypto.getRandomValues(dataBuffer);
  }
  function getRandomUint32() {
    window.crypto.getRandomValues(UINT32_ARR);
    return UINT32_ARR[0];
  }
  function createNewGuid() {
    const currentTimestamp = Date.now();
    const baseRand = getRandomUint32() * 1024 + (getRandomUint32() & 1023);
    const bytes = new Uint8Array(16);
    const randA = Math.trunc(baseRand / 2 ** 30);
    const randBHi = baseRand & 2 ** 30 - 1;
    const randBLo = getRandomUint32();
    bytes[0] = currentTimestamp / 2 ** 40;
    bytes[1] = currentTimestamp / 2 ** 32;
    bytes[2] = currentTimestamp / 2 ** 24;
    bytes[3] = currentTimestamp / 2 ** 16;
    bytes[4] = currentTimestamp / 2 ** 8;
    bytes[5] = currentTimestamp;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    let text9 = "";
    for (let i = 0; i < bytes.length; i++) {
      text9 += UUID_CHARS.charAt(bytes[i] >>> 4);
      text9 += UUID_CHARS.charAt(bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text9 += "-";
      }
    }
    return text9;
  }
  async function generateKeyPair(extractable, usages) {
    return window.crypto.subtle.generateKey(keygenAlgorithmOptions, extractable, usages);
  }
  async function exportJwk(key) {
    return window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);
  }
  async function importJwk(key, extractable, usages) {
    return window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, keygenAlgorithmOptions, extractable, usages);
  }
  async function sign(key, data2) {
    return window.crypto.subtle.sign(keygenAlgorithmOptions, key, data2);
  }
  async function generateEarKey() {
    const key = await generateBaseKey();
    const keyStr = urlEncodeArr(new Uint8Array(key));
    const jwk = {
      alg: "dir",
      kty: "oct",
      k: keyStr
    };
    return base64Encode(JSON.stringify(jwk));
  }
  async function importEarKey(earJwk) {
    const b64DecodedJwk = base64Decode(earJwk);
    const jwkJson = JSON.parse(b64DecodedJwk);
    const rawKey = jwkJson.k;
    const keyBuffer = base64DecToArr(rawKey);
    return window.crypto.subtle.importKey(RAW, keyBuffer, AES_GCM, false, [
      DECRYPT
    ]);
  }
  async function decryptEarResponse(earJwk, earJwe) {
    const earJweParts = earJwe.split(".");
    if (earJweParts.length !== 5) {
      throw createBrowserAuthError(failedToDecryptEarResponse, "jwe_length");
    }
    const key = await importEarKey(earJwk).catch(() => {
      throw createBrowserAuthError(failedToDecryptEarResponse, "import_key");
    });
    try {
      const header = new TextEncoder().encode(earJweParts[0]);
      const iv = base64DecToArr(earJweParts[2]);
      const ciphertext = base64DecToArr(earJweParts[3]);
      const tag = base64DecToArr(earJweParts[4]);
      const tagLengthBits = tag.byteLength * 8;
      const encryptedData = new Uint8Array(ciphertext.length + tag.length);
      encryptedData.set(ciphertext);
      encryptedData.set(tag, ciphertext.length);
      const decryptedData = await window.crypto.subtle.decrypt({
        name: AES_GCM,
        iv,
        tagLength: tagLengthBits,
        additionalData: header
      }, key, encryptedData);
      return new TextDecoder().decode(decryptedData);
    } catch (e) {
      throw createBrowserAuthError(failedToDecryptEarResponse, "decrypt");
    }
  }
  async function generateBaseKey() {
    const key = await window.crypto.subtle.generateKey({
      name: AES_GCM,
      length: 256
    }, true, [ENCRYPT, DECRYPT]);
    return window.crypto.subtle.exportKey(RAW, key);
  }
  async function generateHKDF(baseKey) {
    return window.crypto.subtle.importKey(RAW, baseKey, HKDF, false, [
      DERIVE_KEY
    ]);
  }
  async function deriveKey(baseKey, nonce, context) {
    return window.crypto.subtle.deriveKey({
      name: HKDF,
      salt: nonce,
      hash: S256_HASH_ALG,
      info: new TextEncoder().encode(context)
    }, baseKey, { name: AES_GCM, length: 256 }, false, [ENCRYPT, DECRYPT]);
  }
  async function encrypt(baseKey, rawData, context) {
    const encodedData = new TextEncoder().encode(rawData);
    const nonce = window.crypto.getRandomValues(new Uint8Array(16));
    const derivedKey = await deriveKey(baseKey, nonce, context);
    const encryptedData = await window.crypto.subtle.encrypt({
      name: AES_GCM,
      iv: new Uint8Array(12)
      // New key is derived for every encrypt so we don't need a new nonce
    }, derivedKey, encodedData);
    return {
      data: urlEncodeArr(new Uint8Array(encryptedData)),
      nonce: urlEncodeArr(nonce)
    };
  }
  async function decrypt(baseKey, nonce, context, encryptedData) {
    const encodedData = base64DecToArr(encryptedData);
    const derivedKey = await deriveKey(baseKey, base64DecToArr(nonce), context);
    const decryptedData = await window.crypto.subtle.decrypt({
      name: AES_GCM,
      iv: new Uint8Array(12)
      // New key is derived for every encrypt so we don't need a new nonce
    }, derivedKey, encodedData);
    return new TextDecoder().decode(decryptedData);
  }
  async function hashString(plainText) {
    const hashBuffer = await sha256Digest(plainText);
    const hashBytes = new Uint8Array(hashBuffer);
    return urlEncodeArr(hashBytes);
  }

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthErrorCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var storageNotSupported = "storage_not_supported";
  var stubbedPublicClientApplicationCalled = "stubbed_public_client_application_called";
  var inMemRedirectUnavailable = "in_mem_redirect_unavailable";

  // ../../node_modules/@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs
  var BrowserConfigurationAuthErrorMessages = {
    [storageNotSupported]: "Given storage configuration option was not supported.",
    [stubbedPublicClientApplicationCalled]: "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors",
    [inMemRedirectUnavailable]: "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true."
  };
  var BrowserConfigurationAuthErrorMessage = {
    storageNotSupportedError: {
      code: storageNotSupported,
      desc: BrowserConfigurationAuthErrorMessages[storageNotSupported]
    },
    stubPcaInstanceCalled: {
      code: stubbedPublicClientApplicationCalled,
      desc: BrowserConfigurationAuthErrorMessages[stubbedPublicClientApplicationCalled]
    },
    inMemRedirectUnavailable: {
      code: inMemRedirectUnavailable,
      desc: BrowserConfigurationAuthErrorMessages[inMemRedirectUnavailable]
    }
  };
  var BrowserConfigurationAuthError = class _BrowserConfigurationAuthError extends AuthError {
    constructor(errorCode, errorMessage) {
      super(errorCode, errorMessage);
      this.name = "BrowserConfigurationAuthError";
      Object.setPrototypeOf(this, _BrowserConfigurationAuthError.prototype);
    }
  };
  function createBrowserConfigurationAuthError(errorCode) {
    return new BrowserConfigurationAuthError(errorCode, BrowserConfigurationAuthErrorMessages[errorCode]);
  }

  // ../../node_modules/@azure/msal-browser/dist/utils/BrowserUtils.mjs
  function clearHash(contentWindow) {
    contentWindow.location.hash = "";
    if (typeof contentWindow.history.replaceState === "function") {
      contentWindow.history.replaceState(null, "", `${contentWindow.location.origin}${contentWindow.location.pathname}${contentWindow.location.search}`);
    }
  }
  function replaceHash(url) {
    const urlParts = url.split("#");
    urlParts.shift();
    window.location.hash = urlParts.length > 0 ? urlParts.join("#") : "";
  }
  function isInIframe() {
    return window.parent !== window;
  }
  function isInPopup() {
    return typeof window !== "undefined" && !!window.opener && window.opener !== window && typeof window.name === "string" && window.name.indexOf(`${BrowserConstants.POPUP_NAME_PREFIX}.`) === 0;
  }
  function getCurrentUri() {
    return typeof window !== "undefined" && window.location ? window.location.href.split("?")[0].split("#")[0] : "";
  }
  function getHomepage() {
    const currentUrl = new UrlString(window.location.href);
    const urlComponents = currentUrl.getUrlComponents();
    return `${urlComponents.Protocol}//${urlComponents.HostNameAndPort}/`;
  }
  function blockReloadInHiddenIframes() {
    const isResponseHash = UrlString.hashContainsKnownProperties(window.location.hash);
    if (isResponseHash && isInIframe()) {
      throw createBrowserAuthError(blockIframeReload);
    }
  }
  function blockRedirectInIframe(allowRedirectInIframe) {
    if (isInIframe() && !allowRedirectInIframe) {
      throw createBrowserAuthError(redirectInIframe);
    }
  }
  function blockAcquireTokenInPopups() {
    if (isInPopup()) {
      throw createBrowserAuthError(blockNestedPopups);
    }
  }
  function blockNonBrowserEnvironment() {
    if (typeof window === "undefined") {
      throw createBrowserAuthError(nonBrowserEnvironment);
    }
  }
  function blockAPICallsBeforeInitialize(initialized) {
    if (!initialized) {
      throw createBrowserAuthError(uninitializedPublicClientApplication);
    }
  }
  function preflightCheck(initialized) {
    blockNonBrowserEnvironment();
    blockReloadInHiddenIframes();
    blockAcquireTokenInPopups();
    blockAPICallsBeforeInitialize(initialized);
  }
  function redirectPreflightCheck(initialized, config) {
    preflightCheck(initialized);
    blockRedirectInIframe(config.system.allowRedirectInIframe);
    if (config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage && !config.cache.storeAuthStateInCookie) {
      throw createBrowserConfigurationAuthError(inMemRedirectUnavailable);
    }
  }
  function preconnect(authority) {
    const link3 = document.createElement("link");
    link3.rel = "preconnect";
    link3.href = new URL(authority).origin;
    link3.crossOrigin = "anonymous";
    document.head.appendChild(link3);
    window.setTimeout(() => {
      try {
        document.head.removeChild(link3);
      } catch {
      }
    }, 1e4);
  }
  function createGuid() {
    return createNewGuid();
  }

  // ../../node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/config/Configuration.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/navigation/NavigationClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var NavigationClient = class _NavigationClient {
    /**
     * Navigates to other pages within the same web application
     * @param url
     * @param options
     */
    navigateInternal(url, options) {
      return _NavigationClient.defaultNavigateWindow(url, options);
    }
    /**
     * Navigates to other pages outside the web application i.e. the Identity Provider
     * @param url
     * @param options
     */
    navigateExternal(url, options) {
      return _NavigationClient.defaultNavigateWindow(url, options);
    }
    /**
     * Default navigation implementation invoked by the internal and external functions
     * @param url
     * @param options
     */
    static defaultNavigateWindow(url, options) {
      if (options.noHistory) {
        window.location.replace(url);
      } else {
        window.location.assign(url);
      }
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, options.timeout);
      });
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/network/FetchClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var FetchClient = class {
    /**
     * Fetch Client for REST endpoints - Get request
     * @param url
     * @param headers
     * @param body
     */
    async sendGetRequestAsync(url, options) {
      let response;
      let responseHeaders = {};
      let responseStatus = 0;
      const reqHeaders = getFetchHeaders(options);
      try {
        response = await fetch(url, {
          method: HTTP_REQUEST_TYPE.GET,
          headers: reqHeaders
        });
      } catch (e) {
        throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? getRequestFailed : noNetworkConnectivity2), void 0, void 0, e);
      }
      responseHeaders = getHeaderDict(response.headers);
      try {
        responseStatus = response.status;
        return {
          headers: responseHeaders,
          body: await response.json(),
          status: responseStatus
        };
      } catch (e) {
        throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);
      }
    }
    /**
     * Fetch Client for REST endpoints - Post request
     * @param url
     * @param headers
     * @param body
     */
    async sendPostRequestAsync(url, options) {
      const reqBody = options && options.body || "";
      const reqHeaders = getFetchHeaders(options);
      let response;
      let responseStatus = 0;
      let responseHeaders = {};
      try {
        response = await fetch(url, {
          method: HTTP_REQUEST_TYPE.POST,
          headers: reqHeaders,
          body: reqBody
        });
      } catch (e) {
        throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? postRequestFailed2 : noNetworkConnectivity2), void 0, void 0, e);
      }
      responseHeaders = getHeaderDict(response.headers);
      try {
        responseStatus = response.status;
        return {
          headers: responseHeaders,
          body: await response.json(),
          status: responseStatus
        };
      } catch (e) {
        throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);
      }
    }
  };
  function getFetchHeaders(options) {
    try {
      const headers = new Headers();
      if (!(options && options.headers)) {
        return headers;
      }
      const optionsHeaders = options.headers;
      Object.entries(optionsHeaders).forEach(([key, value]) => {
        headers.append(key, value);
      });
      return headers;
    } catch (e) {
      throw createNetworkError(createBrowserAuthError(failedToBuildHeaders), void 0, void 0, e);
    }
  }
  function getHeaderDict(headers) {
    try {
      const headerDict = {};
      headers.forEach((value, key) => {
        headerDict[key] = value;
      });
      return headerDict;
    } catch (e) {
      throw createBrowserAuthError(failedToParseHeaders);
    }
  }

  // ../../node_modules/@azure/msal-browser/dist/config/Configuration.mjs
  var DEFAULT_POPUP_TIMEOUT_MS = 6e4;
  var DEFAULT_IFRAME_TIMEOUT_MS = 1e4;
  var DEFAULT_REDIRECT_TIMEOUT_MS = 3e4;
  var DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS = 2e3;
  function buildConfiguration({ auth: userInputAuth, cache: userInputCache, system: userInputSystem, telemetry: userInputTelemetry }, isBrowserEnvironment) {
    const DEFAULT_AUTH_OPTIONS = {
      clientId: Constants.EMPTY_STRING,
      authority: `${Constants.DEFAULT_AUTHORITY}`,
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants.EMPTY_STRING,
      authorityMetadata: Constants.EMPTY_STRING,
      redirectUri: typeof window !== "undefined" ? getCurrentUri() : "",
      postLogoutRedirectUri: Constants.EMPTY_STRING,
      navigateToLoginRequestUrl: true,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      OIDCOptions: {
        serverResponseType: ServerResponseType.FRAGMENT,
        defaultScopes: [
          Constants.OPENID_SCOPE,
          Constants.PROFILE_SCOPE,
          Constants.OFFLINE_ACCESS_SCOPE
        ]
      },
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false,
      supportsNestedAppAuth: false,
      instanceAware: false,
      encodeExtraQueryParams: false
    };
    const DEFAULT_CACHE_OPTIONS2 = {
      cacheLocation: BrowserCacheLocation.SessionStorage,
      temporaryCacheLocation: BrowserCacheLocation.SessionStorage,
      storeAuthStateInCookie: false,
      secureCookies: false,
      // Default cache migration to true if cache location is localStorage since entries are preserved across tabs/windows. Migration has little to no benefit in sessionStorage and memoryStorage
      cacheMigrationEnabled: userInputCache && userInputCache.cacheLocation === BrowserCacheLocation.LocalStorage ? true : false,
      claimsBasedCachingEnabled: false
    };
    const DEFAULT_LOGGER_OPTIONS = {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      loggerCallback: () => {
      },
      logLevel: LogLevel.Info,
      piiLoggingEnabled: false
    };
    const DEFAULT_BROWSER_SYSTEM_OPTIONS = {
      ...DEFAULT_SYSTEM_OPTIONS,
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: isBrowserEnvironment ? new FetchClient() : StubbedNetworkModule,
      navigationClient: new NavigationClient(),
      loadFrameTimeout: 0,
      // If loadFrameTimeout is provided, use that as default.
      windowHashTimeout: userInputSystem?.loadFrameTimeout || DEFAULT_POPUP_TIMEOUT_MS,
      iframeHashTimeout: userInputSystem?.loadFrameTimeout || DEFAULT_IFRAME_TIMEOUT_MS,
      navigateFrameWait: 0,
      redirectNavigationTimeout: DEFAULT_REDIRECT_TIMEOUT_MS,
      asyncPopups: false,
      allowRedirectInIframe: false,
      allowPlatformBroker: false,
      nativeBrokerHandshakeTimeout: userInputSystem?.nativeBrokerHandshakeTimeout || DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS,
      pollIntervalMilliseconds: BrowserConstants.DEFAULT_POLL_INTERVAL_MS
    };
    const providedSystemOptions = {
      ...DEFAULT_BROWSER_SYSTEM_OPTIONS,
      ...userInputSystem,
      loggerOptions: userInputSystem?.loggerOptions || DEFAULT_LOGGER_OPTIONS
    };
    const DEFAULT_TELEMETRY_OPTIONS2 = {
      application: {
        appName: Constants.EMPTY_STRING,
        appVersion: Constants.EMPTY_STRING
      },
      client: new StubPerformanceClient()
    };
    if (userInputAuth?.protocolMode !== ProtocolMode.OIDC && userInputAuth?.OIDCOptions) {
      const logger = new Logger(providedSystemOptions.loggerOptions);
      logger.warning(JSON.stringify(createClientConfigurationError(ClientConfigurationErrorCodes_exports.cannotSetOIDCOptions)));
    }
    if (userInputAuth?.protocolMode && userInputAuth.protocolMode === ProtocolMode.OIDC && providedSystemOptions?.allowPlatformBroker) {
      throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.cannotAllowPlatformBroker);
    }
    const overlayedConfig = {
      auth: {
        ...DEFAULT_AUTH_OPTIONS,
        ...userInputAuth,
        OIDCOptions: {
          ...DEFAULT_AUTH_OPTIONS.OIDCOptions,
          ...userInputAuth?.OIDCOptions
        }
      },
      cache: { ...DEFAULT_CACHE_OPTIONS2, ...userInputCache },
      system: providedSystemOptions,
      telemetry: { ...DEFAULT_TELEMETRY_OPTIONS2, ...userInputTelemetry }
    };
    return overlayedConfig;
  }

  // ../../node_modules/@azure/msal-browser/dist/packageMetadata.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var name18 = "@azure/msal-browser";
  var version2 = "4.12.0";

  // ../../node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs
  var BaseOperatingContext = class _BaseOperatingContext {
    static loggerCallback(level, message) {
      switch (level) {
        case LogLevel.Error:
          console.error(message);
          return;
        case LogLevel.Info:
          console.info(message);
          return;
        case LogLevel.Verbose:
          console.debug(message);
          return;
        case LogLevel.Warning:
          console.warn(message);
          return;
        default:
          console.log(message);
          return;
      }
    }
    constructor(config) {
      this.browserEnvironment = typeof window !== "undefined";
      this.config = buildConfiguration(config, this.browserEnvironment);
      let sessionStorage2;
      try {
        sessionStorage2 = window[BrowserCacheLocation.SessionStorage];
      } catch (e) {
      }
      const logLevelKey = sessionStorage2?.getItem(LOG_LEVEL_CACHE_KEY);
      const piiLoggingKey = sessionStorage2?.getItem(LOG_PII_CACHE_KEY)?.toLowerCase();
      const piiLoggingEnabled = piiLoggingKey === "true" ? true : piiLoggingKey === "false" ? false : void 0;
      const loggerOptions = { ...this.config.system.loggerOptions };
      const logLevel = logLevelKey && Object.keys(LogLevel).includes(logLevelKey) ? LogLevel[logLevelKey] : void 0;
      if (logLevel) {
        loggerOptions.loggerCallback = _BaseOperatingContext.loggerCallback;
        loggerOptions.logLevel = logLevel;
      }
      if (piiLoggingEnabled !== void 0) {
        loggerOptions.piiLoggingEnabled = piiLoggingEnabled;
      }
      this.logger = new Logger(loggerOptions, name18, version2);
      this.available = false;
    }
    /**
     * Return the MSAL config
     * @returns BrowserConfiguration
     */
    getConfig() {
      return this.config;
    }
    /**
     * Returns the MSAL Logger
     * @returns Logger
     */
    getLogger() {
      return this.logger;
    }
    isAvailable() {
      return this.available;
    }
    isBrowserEnvironment() {
      return this.browserEnvironment;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var StandardOperatingContext = class _StandardOperatingContext extends BaseOperatingContext {
    /**
     * Return the module name.  Intended for use with import() to enable dynamic import
     * of the implementation associated with this operating context
     * @returns
     */
    getModuleName() {
      return _StandardOperatingContext.MODULE_NAME;
    }
    /**
     * Returns the unique identifier for this operating context
     * @returns string
     */
    getId() {
      return _StandardOperatingContext.ID;
    }
    /**
     * Checks whether the operating context is available.
     * Confirms that the code is running a browser rather.  This is required.
     * @returns Promise<boolean> indicating whether this operating context is currently available.
     */
    async initialize() {
      this.available = typeof window !== "undefined";
      return this.available;
    }
  };
  StandardOperatingContext.MODULE_NAME = "";
  StandardOperatingContext.ID = "StandardOperatingContext";

  // ../../node_modules/@azure/msal-browser/dist/controllers/StandardController.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/crypto/CryptoOps.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/cache/DatabaseStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var DatabaseStorage = class {
    constructor() {
      this.dbName = DB_NAME;
      this.version = DB_VERSION;
      this.tableName = DB_TABLE_NAME;
      this.dbOpen = false;
    }
    /**
     * Opens IndexedDB instance.
     */
    async open() {
      return new Promise((resolve, reject) => {
        const openDB = window.indexedDB.open(this.dbName, this.version);
        openDB.addEventListener("upgradeneeded", (e) => {
          const event = e;
          event.target.result.createObjectStore(this.tableName);
        });
        openDB.addEventListener("success", (e) => {
          const event = e;
          this.db = event.target.result;
          this.dbOpen = true;
          resolve();
        });
        openDB.addEventListener("error", () => reject(createBrowserAuthError(databaseUnavailable)));
      });
    }
    /**
     * Closes the connection to IndexedDB database when all pending transactions
     * complete.
     */
    closeConnection() {
      const db = this.db;
      if (db && this.dbOpen) {
        db.close();
        this.dbOpen = false;
      }
    }
    /**
     * Opens database if it's not already open
     */
    async validateDbIsOpen() {
      if (!this.dbOpen) {
        return this.open();
      }
    }
    /**
     * Retrieves item from IndexedDB instance.
     * @param key
     */
    async getItem(key) {
      await this.validateDbIsOpen();
      return new Promise((resolve, reject) => {
        if (!this.db) {
          return reject(createBrowserAuthError(databaseNotOpen));
        }
        const transaction = this.db.transaction([this.tableName], "readonly");
        const objectStore = transaction.objectStore(this.tableName);
        const dbGet = objectStore.get(key);
        dbGet.addEventListener("success", (e) => {
          const event = e;
          this.closeConnection();
          resolve(event.target.result);
        });
        dbGet.addEventListener("error", (e) => {
          this.closeConnection();
          reject(e);
        });
      });
    }
    /**
     * Adds item to IndexedDB under given key
     * @param key
     * @param payload
     */
    async setItem(key, payload) {
      await this.validateDbIsOpen();
      return new Promise((resolve, reject) => {
        if (!this.db) {
          return reject(createBrowserAuthError(databaseNotOpen));
        }
        const transaction = this.db.transaction([this.tableName], "readwrite");
        const objectStore = transaction.objectStore(this.tableName);
        const dbPut = objectStore.put(payload, key);
        dbPut.addEventListener("success", () => {
          this.closeConnection();
          resolve();
        });
        dbPut.addEventListener("error", (e) => {
          this.closeConnection();
          reject(e);
        });
      });
    }
    /**
     * Removes item from IndexedDB under given key
     * @param key
     */
    async removeItem(key) {
      await this.validateDbIsOpen();
      return new Promise((resolve, reject) => {
        if (!this.db) {
          return reject(createBrowserAuthError(databaseNotOpen));
        }
        const transaction = this.db.transaction([this.tableName], "readwrite");
        const objectStore = transaction.objectStore(this.tableName);
        const dbDelete = objectStore.delete(key);
        dbDelete.addEventListener("success", () => {
          this.closeConnection();
          resolve();
        });
        dbDelete.addEventListener("error", (e) => {
          this.closeConnection();
          reject(e);
        });
      });
    }
    /**
     * Get all the keys from the storage object as an iterable array of strings.
     */
    async getKeys() {
      await this.validateDbIsOpen();
      return new Promise((resolve, reject) => {
        if (!this.db) {
          return reject(createBrowserAuthError(databaseNotOpen));
        }
        const transaction = this.db.transaction([this.tableName], "readonly");
        const objectStore = transaction.objectStore(this.tableName);
        const dbGetKeys = objectStore.getAllKeys();
        dbGetKeys.addEventListener("success", (e) => {
          const event = e;
          this.closeConnection();
          resolve(event.target.result);
        });
        dbGetKeys.addEventListener("error", (e) => {
          this.closeConnection();
          reject(e);
        });
      });
    }
    /**
     *
     * Checks whether there is an object under the search key in the object store
     */
    async containsKey(key) {
      await this.validateDbIsOpen();
      return new Promise((resolve, reject) => {
        if (!this.db) {
          return reject(createBrowserAuthError(databaseNotOpen));
        }
        const transaction = this.db.transaction([this.tableName], "readonly");
        const objectStore = transaction.objectStore(this.tableName);
        const dbContainsKey = objectStore.count(key);
        dbContainsKey.addEventListener("success", (e) => {
          const event = e;
          this.closeConnection();
          resolve(event.target.result === 1);
        });
        dbContainsKey.addEventListener("error", (e) => {
          this.closeConnection();
          reject(e);
        });
      });
    }
    /**
     * Deletes the MSAL database. The database is deleted rather than cleared to make it possible
     * for client applications to downgrade to a previous MSAL version without worrying about forward compatibility issues
     * with IndexedDB database versions.
     */
    async deleteDatabase() {
      if (this.db && this.dbOpen) {
        this.closeConnection();
      }
      return new Promise((resolve, reject) => {
        const deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);
        const id = setTimeout(() => reject(false), 200);
        deleteDbRequest.addEventListener("success", () => {
          clearTimeout(id);
          return resolve(true);
        });
        deleteDbRequest.addEventListener("blocked", () => {
          clearTimeout(id);
          return resolve(true);
        });
        deleteDbRequest.addEventListener("error", () => {
          clearTimeout(id);
          return reject(false);
        });
      });
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/MemoryStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var MemoryStorage = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    async initialize() {
    }
    getItem(key) {
      return this.cache.get(key) || null;
    }
    getUserData(key) {
      return this.getItem(key);
    }
    setItem(key, value) {
      this.cache.set(key, value);
    }
    async setUserData(key, value) {
      this.setItem(key, value);
    }
    removeItem(key) {
      this.cache.delete(key);
    }
    getKeys() {
      const cacheKeys = [];
      this.cache.forEach((value, key) => {
        cacheKeys.push(key);
      });
      return cacheKeys;
    }
    containsKey(key) {
      return this.cache.has(key);
    }
    clear() {
      this.cache.clear();
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs
  var AsyncMemoryStorage = class {
    constructor(logger) {
      this.inMemoryCache = new MemoryStorage();
      this.indexedDBCache = new DatabaseStorage();
      this.logger = logger;
    }
    handleDatabaseAccessError(error) {
      if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {
        this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.");
      } else {
        throw error;
      }
    }
    /**
     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous
     * storage object if item isn't found in-memory.
     * @param key
     */
    async getItem(key) {
      const item = this.inMemoryCache.getItem(key);
      if (!item) {
        try {
          this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage.");
          return await this.indexedDBCache.getItem(key);
        } catch (e) {
          this.handleDatabaseAccessError(e);
        }
      }
      return item;
    }
    /**
     * Sets the item in the in-memory cache and then tries to set it in the asynchronous
     * storage object with the given key.
     * @param key
     * @param value
     */
    async setItem(key, value) {
      this.inMemoryCache.setItem(key, value);
      try {
        await this.indexedDBCache.setItem(key, value);
      } catch (e) {
        this.handleDatabaseAccessError(e);
      }
    }
    /**
     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.
     * @param key
     */
    async removeItem(key) {
      this.inMemoryCache.removeItem(key);
      try {
        await this.indexedDBCache.removeItem(key);
      } catch (e) {
        this.handleDatabaseAccessError(e);
      }
    }
    /**
     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the
     * asynchronous storage object.
     */
    async getKeys() {
      const cacheKeys = this.inMemoryCache.getKeys();
      if (cacheKeys.length === 0) {
        try {
          this.logger.verbose("In-memory cache is empty, now querying persistent storage.");
          return await this.indexedDBCache.getKeys();
        } catch (e) {
          this.handleDatabaseAccessError(e);
        }
      }
      return cacheKeys;
    }
    /**
     * Returns true or false if the given key is present in the cache.
     * @param key
     */
    async containsKey(key) {
      const containsKey = this.inMemoryCache.containsKey(key);
      if (!containsKey) {
        try {
          this.logger.verbose("Key not found in in-memory cache, now querying persistent storage.");
          return await this.indexedDBCache.containsKey(key);
        } catch (e) {
          this.handleDatabaseAccessError(e);
        }
      }
      return containsKey;
    }
    /**
     * Clears in-memory Map
     */
    clearInMemory() {
      this.logger.verbose(`Deleting in-memory keystore`);
      this.inMemoryCache.clear();
      this.logger.verbose(`In-memory keystore deleted`);
    }
    /**
     * Tries to delete the IndexedDB database
     * @returns
     */
    async clearPersistent() {
      try {
        this.logger.verbose("Deleting persistent keystore");
        const dbDeleted = await this.indexedDBCache.deleteDatabase();
        if (dbDeleted) {
          this.logger.verbose("Persistent keystore deleted");
        }
        return dbDeleted;
      } catch (e) {
        this.handleDatabaseAccessError(e);
        return false;
      }
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/crypto/CryptoOps.mjs
  var CryptoOps = class _CryptoOps {
    constructor(logger, performanceClient, skipValidateSubtleCrypto) {
      this.logger = logger;
      validateCryptoAvailable(skipValidateSubtleCrypto ?? false);
      this.cache = new AsyncMemoryStorage(this.logger);
      this.performanceClient = performanceClient;
    }
    /**
     * Creates a new random GUID - used to populate state and nonce.
     * @returns string (GUID)
     */
    createNewGuid() {
      return createNewGuid();
    }
    /**
     * Encodes input string to base64.
     * @param input
     */
    base64Encode(input) {
      return base64Encode(input);
    }
    /**
     * Decodes input string from base64.
     * @param input
     */
    base64Decode(input) {
      return base64Decode(input);
    }
    /**
     * Encodes input string to base64 URL safe string.
     * @param input
     */
    base64UrlEncode(input) {
      return urlEncode(input);
    }
    /**
     * Stringifies and base64Url encodes input public key
     * @param inputKid
     * @returns Base64Url encoded public key
     */
    encodeKid(inputKid) {
      return this.base64UrlEncode(JSON.stringify({ kid: inputKid }));
    }
    /**
     * Generates a keypair, stores it and returns a thumbprint
     * @param request
     */
    async getPublicKeyThumbprint(request) {
      const publicKeyThumbMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);
      const keyPair = await generateKeyPair(_CryptoOps.EXTRACTABLE, _CryptoOps.POP_KEY_USAGES);
      const publicKeyJwk = await exportJwk(keyPair.publicKey);
      const pubKeyThumprintObj = {
        e: publicKeyJwk.e,
        kty: publicKeyJwk.kty,
        n: publicKeyJwk.n
      };
      const publicJwkString = getSortedObjectString(pubKeyThumprintObj);
      const publicJwkHash = await this.hashString(publicJwkString);
      const privateKeyJwk = await exportJwk(keyPair.privateKey);
      const unextractablePrivateKey = await importJwk(privateKeyJwk, false, ["sign"]);
      await this.cache.setItem(publicJwkHash, {
        privateKey: unextractablePrivateKey,
        publicKey: keyPair.publicKey,
        requestMethod: request.resourceRequestMethod,
        requestUri: request.resourceRequestUri
      });
      if (publicKeyThumbMeasurement) {
        publicKeyThumbMeasurement.end({
          success: true
        });
      }
      return publicJwkHash;
    }
    /**
     * Removes cryptographic keypair from key store matching the keyId passed in
     * @param kid
     */
    async removeTokenBindingKey(kid) {
      await this.cache.removeItem(kid);
      const keyFound = await this.cache.containsKey(kid);
      return !keyFound;
    }
    /**
     * Removes all cryptographic keys from IndexedDB storage
     */
    async clearKeystore() {
      this.cache.clearInMemory();
      try {
        await this.cache.clearPersistent();
        return true;
      } catch (e) {
        if (e instanceof Error) {
          this.logger.error(`Clearing keystore failed with error: ${e.message}`);
        } else {
          this.logger.error("Clearing keystore failed with unknown error");
        }
        return false;
      }
    }
    /**
     * Signs the given object as a jwt payload with private key retrieved by given kid.
     * @param payload
     * @param kid
     */
    async signJwt(payload, kid, shrOptions, correlationId) {
      const signJwtMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);
      const cachedKeyPair = await this.cache.getItem(kid);
      if (!cachedKeyPair) {
        throw createBrowserAuthError(cryptoKeyNotFound);
      }
      const publicKeyJwk = await exportJwk(cachedKeyPair.publicKey);
      const publicKeyJwkString = getSortedObjectString(publicKeyJwk);
      const encodedKeyIdThumbprint = urlEncode(JSON.stringify({ kid }));
      const shrHeader = JoseHeader.getShrHeaderString({
        ...shrOptions?.header,
        alg: publicKeyJwk.alg,
        kid: encodedKeyIdThumbprint
      });
      const encodedShrHeader = urlEncode(shrHeader);
      payload.cnf = {
        jwk: JSON.parse(publicKeyJwkString)
      };
      const encodedPayload = urlEncode(JSON.stringify(payload));
      const tokenString = `${encodedShrHeader}.${encodedPayload}`;
      const encoder = new TextEncoder();
      const tokenBuffer = encoder.encode(tokenString);
      const signatureBuffer = await sign(cachedKeyPair.privateKey, tokenBuffer);
      const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));
      const signedJwt = `${tokenString}.${encodedSignature}`;
      if (signJwtMeasurement) {
        signJwtMeasurement.end({
          success: true
        });
      }
      return signedJwt;
    }
    /**
     * Returns the SHA-256 hash of an input string
     * @param plainText
     */
    async hashString(plainText) {
      return hashString(plainText);
    }
  };
  CryptoOps.POP_KEY_USAGES = ["sign", "verify"];
  CryptoOps.EXTRACTABLE = true;
  function getSortedObjectString(obj) {
    return JSON.stringify(obj, Object.keys(obj).sort());
  }

  // ../../node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/cache/LocalStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/cache/CookieStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1e3;
  var SameSiteOptions = {
    Lax: "Lax",
    None: "None"
  };
  var CookieStorage = class {
    initialize() {
      return Promise.resolve();
    }
    getItem(key) {
      const name21 = `${encodeURIComponent(key)}`;
      const cookieList = document.cookie.split(";");
      for (let i = 0; i < cookieList.length; i++) {
        const cookie = cookieList[i];
        const [key2, ...rest] = decodeURIComponent(cookie).trim().split("=");
        const value = rest.join("=");
        if (key2 === name21) {
          return value;
        }
      }
      return "";
    }
    getUserData() {
      throw createClientAuthError(ClientAuthErrorCodes_exports.methodNotImplemented);
    }
    setItem(key, value, cookieLifeDays, secure = true, sameSite = SameSiteOptions.Lax) {
      let cookieStr = `${encodeURIComponent(key)}=${encodeURIComponent(value)};path=/;SameSite=${sameSite};`;
      if (cookieLifeDays) {
        const expireTime = getCookieExpirationTime(cookieLifeDays);
        cookieStr += `expires=${expireTime};`;
      }
      if (secure || sameSite === SameSiteOptions.None) {
        cookieStr += "Secure;";
      }
      document.cookie = cookieStr;
    }
    async setUserData() {
      return Promise.reject(createClientAuthError(ClientAuthErrorCodes_exports.methodNotImplemented));
    }
    removeItem(key) {
      this.setItem(key, "", -1);
    }
    getKeys() {
      const cookieList = document.cookie.split(";");
      const keys2 = [];
      cookieList.forEach((cookie) => {
        const cookieParts = decodeURIComponent(cookie).trim().split("=");
        keys2.push(cookieParts[0]);
      });
      return keys2;
    }
    containsKey(key) {
      return this.getKeys().includes(key);
    }
  };
  function getCookieExpirationTime(cookieLifeDays) {
    const today = /* @__PURE__ */ new Date();
    const expr = new Date(today.getTime() + cookieLifeDays * COOKIE_LIFE_MULTIPLIER);
    return expr.toUTCString();
  }

  // ../../node_modules/@azure/msal-browser/dist/cache/CacheHelpers.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getAccountKeys(storage) {
    const accountKeys = storage.getItem(StaticCacheKeys.ACCOUNT_KEYS);
    if (accountKeys) {
      return JSON.parse(accountKeys);
    }
    return [];
  }
  function getTokenKeys(clientId, storage) {
    const item = storage.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${clientId}`);
    if (item) {
      const tokenKeys = JSON.parse(item);
      if (tokenKeys && tokenKeys.hasOwnProperty("idToken") && tokenKeys.hasOwnProperty("accessToken") && tokenKeys.hasOwnProperty("refreshToken")) {
        return tokenKeys;
      }
    }
    return {
      idToken: [],
      accessToken: [],
      refreshToken: []
    };
  }

  // ../../node_modules/@azure/msal-browser/dist/cache/LocalStorage.mjs
  var ENCRYPTION_KEY = "msal.cache.encryption";
  var BROADCAST_CHANNEL_NAME = "msal.broadcast.cache";
  var LocalStorage = class {
    constructor(clientId, logger, performanceClient) {
      if (!window.localStorage) {
        throw createBrowserConfigurationAuthError(storageNotSupported);
      }
      this.memoryStorage = new MemoryStorage();
      this.initialized = false;
      this.clientId = clientId;
      this.logger = logger;
      this.performanceClient = performanceClient;
      this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    }
    async initialize(correlationId) {
      const cookies = new CookieStorage();
      const cookieString = cookies.getItem(ENCRYPTION_KEY);
      let parsedCookie = { key: "", id: "" };
      if (cookieString) {
        try {
          parsedCookie = JSON.parse(cookieString);
        } catch (e) {
        }
      }
      if (parsedCookie.key && parsedCookie.id) {
        const baseKey = invoke(base64DecToArr, PerformanceEvents.Base64Decode, this.logger, this.performanceClient, correlationId)(parsedCookie.key);
        this.encryptionCookie = {
          id: parsedCookie.id,
          key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)
        };
        await invokeAsync(this.importExistingCache.bind(this), PerformanceEvents.ImportExistingCache, this.logger, this.performanceClient, correlationId)(correlationId);
      } else {
        this.clear();
        const id = createNewGuid();
        const baseKey = await invokeAsync(generateBaseKey, PerformanceEvents.GenerateBaseKey, this.logger, this.performanceClient, correlationId)();
        const keyStr = invoke(urlEncodeArr, PerformanceEvents.UrlEncodeArr, this.logger, this.performanceClient, correlationId)(new Uint8Array(baseKey));
        this.encryptionCookie = {
          id,
          key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)
        };
        const cookieData = {
          id,
          key: keyStr
        };
        cookies.setItem(
          ENCRYPTION_KEY,
          JSON.stringify(cookieData),
          0,
          // Expiration - 0 means cookie will be cleared at the end of the browser session
          true,
          // Secure flag
          SameSiteOptions.None
          // SameSite must be None to support iframed apps
        );
      }
      this.broadcast.addEventListener("message", this.updateCache.bind(this));
      this.initialized = true;
    }
    getItem(key) {
      return window.localStorage.getItem(key);
    }
    getUserData(key) {
      if (!this.initialized) {
        throw createBrowserAuthError(uninitializedPublicClientApplication);
      }
      return this.memoryStorage.getItem(key);
    }
    setItem(key, value) {
      window.localStorage.setItem(key, value);
    }
    async setUserData(key, value, correlationId) {
      if (!this.initialized || !this.encryptionCookie) {
        throw createBrowserAuthError(uninitializedPublicClientApplication);
      }
      const { data: data2, nonce } = await invokeAsync(encrypt, PerformanceEvents.Encrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, value, this.getContext(key));
      const encryptedData = {
        id: this.encryptionCookie.id,
        nonce,
        data: data2
      };
      this.memoryStorage.setItem(key, value);
      this.setItem(key, JSON.stringify(encryptedData));
      this.broadcast.postMessage({
        key,
        value,
        context: this.getContext(key)
      });
    }
    removeItem(key) {
      if (this.memoryStorage.containsKey(key)) {
        this.memoryStorage.removeItem(key);
        this.broadcast.postMessage({
          key,
          value: null,
          context: this.getContext(key)
        });
      }
      window.localStorage.removeItem(key);
    }
    getKeys() {
      return Object.keys(window.localStorage);
    }
    containsKey(key) {
      return window.localStorage.hasOwnProperty(key);
    }
    /**
     * Removes all known MSAL keys from the cache
     */
    clear() {
      this.memoryStorage.clear();
      const accountKeys = getAccountKeys(this);
      accountKeys.forEach((key) => this.removeItem(key));
      const tokenKeys = getTokenKeys(this.clientId, this);
      tokenKeys.idToken.forEach((key) => this.removeItem(key));
      tokenKeys.accessToken.forEach((key) => this.removeItem(key));
      tokenKeys.refreshToken.forEach((key) => this.removeItem(key));
      this.getKeys().forEach((cacheKey) => {
        if (cacheKey.startsWith(Constants.CACHE_PREFIX) || cacheKey.indexOf(this.clientId) !== -1) {
          this.removeItem(cacheKey);
        }
      });
    }
    /**
     * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage
     * @returns
     */
    async importExistingCache(correlationId) {
      if (!this.encryptionCookie) {
        return;
      }
      let accountKeys = getAccountKeys(this);
      accountKeys = await this.importArray(accountKeys, correlationId);
      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
      const tokenKeys = getTokenKeys(this.clientId, this);
      tokenKeys.idToken = await this.importArray(tokenKeys.idToken, correlationId);
      tokenKeys.accessToken = await this.importArray(tokenKeys.accessToken, correlationId);
      tokenKeys.refreshToken = await this.importArray(tokenKeys.refreshToken, correlationId);
      this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));
    }
    /**
     * Helper to decrypt and save cache entries
     * @param key
     * @returns
     */
    async getItemFromEncryptedCache(key, correlationId) {
      if (!this.encryptionCookie) {
        return null;
      }
      const rawCache = this.getItem(key);
      if (!rawCache) {
        return null;
      }
      let encObj;
      try {
        encObj = JSON.parse(rawCache);
      } catch (e) {
        return null;
      }
      if (!encObj.id || !encObj.nonce || !encObj.data) {
        this.performanceClient.incrementFields({ unencryptedCacheCount: 1 }, correlationId);
        return null;
      }
      if (encObj.id !== this.encryptionCookie.id) {
        this.performanceClient.incrementFields({ encryptedCacheExpiredCount: 1 }, correlationId);
        return null;
      }
      return invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, encObj.nonce, this.getContext(key), encObj.data);
    }
    /**
     * Helper to decrypt and save an array of cache keys
     * @param arr
     * @returns Array of keys successfully imported
     */
    async importArray(arr, correlationId) {
      const importedArr = [];
      const promiseArr = [];
      arr.forEach((key) => {
        const promise = this.getItemFromEncryptedCache(key, correlationId).then((value) => {
          if (value) {
            this.memoryStorage.setItem(key, value);
            importedArr.push(key);
          } else {
            this.removeItem(key);
          }
        });
        promiseArr.push(promise);
      });
      await Promise.all(promiseArr);
      return importedArr;
    }
    /**
     * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries
     * @param key
     * @returns
     */
    getContext(key) {
      let context = "";
      if (key.includes(this.clientId)) {
        context = this.clientId;
      }
      return context;
    }
    updateCache(event) {
      this.logger.trace("Updating internal cache from broadcast event");
      const perfMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.LocalStorageUpdated);
      perfMeasurement.add({ isBackground: true });
      const { key, value, context } = event.data;
      if (!key) {
        this.logger.error("Broadcast event missing key");
        perfMeasurement.end({ success: false, errorCode: "noKey" });
        return;
      }
      if (context && context !== this.clientId) {
        this.logger.trace(`Ignoring broadcast event from clientId: ${context}`);
        perfMeasurement.end({
          success: false,
          errorCode: "contextMismatch"
        });
        return;
      }
      if (!value) {
        this.memoryStorage.removeItem(key);
        this.logger.verbose("Removed item from internal cache");
      } else {
        this.memoryStorage.setItem(key, value);
        this.logger.verbose("Updated item in internal cache");
      }
      perfMeasurement.end({ success: true });
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/SessionStorage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SessionStorage = class {
    constructor() {
      if (!window.sessionStorage) {
        throw createBrowserConfigurationAuthError(storageNotSupported);
      }
    }
    async initialize() {
    }
    getItem(key) {
      return window.sessionStorage.getItem(key);
    }
    getUserData(key) {
      return this.getItem(key);
    }
    setItem(key, value) {
      window.sessionStorage.setItem(key, value);
    }
    async setUserData(key, value) {
      this.setItem(key, value);
    }
    removeItem(key) {
      window.sessionStorage.removeItem(key);
    }
    getKeys() {
      return Object.keys(window.sessionStorage);
    }
    containsKey(key) {
      return window.sessionStorage.hasOwnProperty(key);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/event/EventType.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var EventType = {
    INITIALIZE_START: "msal:initializeStart",
    INITIALIZE_END: "msal:initializeEnd",
    ACCOUNT_ADDED: "msal:accountAdded",
    ACCOUNT_REMOVED: "msal:accountRemoved",
    ACTIVE_ACCOUNT_CHANGED: "msal:activeAccountChanged",
    LOGIN_START: "msal:loginStart",
    LOGIN_SUCCESS: "msal:loginSuccess",
    LOGIN_FAILURE: "msal:loginFailure",
    ACQUIRE_TOKEN_START: "msal:acquireTokenStart",
    ACQUIRE_TOKEN_SUCCESS: "msal:acquireTokenSuccess",
    ACQUIRE_TOKEN_FAILURE: "msal:acquireTokenFailure",
    ACQUIRE_TOKEN_NETWORK_START: "msal:acquireTokenFromNetworkStart",
    SSO_SILENT_START: "msal:ssoSilentStart",
    SSO_SILENT_SUCCESS: "msal:ssoSilentSuccess",
    SSO_SILENT_FAILURE: "msal:ssoSilentFailure",
    ACQUIRE_TOKEN_BY_CODE_START: "msal:acquireTokenByCodeStart",
    ACQUIRE_TOKEN_BY_CODE_SUCCESS: "msal:acquireTokenByCodeSuccess",
    ACQUIRE_TOKEN_BY_CODE_FAILURE: "msal:acquireTokenByCodeFailure",
    HANDLE_REDIRECT_START: "msal:handleRedirectStart",
    HANDLE_REDIRECT_END: "msal:handleRedirectEnd",
    POPUP_OPENED: "msal:popupOpened",
    LOGOUT_START: "msal:logoutStart",
    LOGOUT_SUCCESS: "msal:logoutSuccess",
    LOGOUT_FAILURE: "msal:logoutFailure",
    LOGOUT_END: "msal:logoutEnd",
    RESTORE_FROM_BFCACHE: "msal:restoreFromBFCache"
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.mjs
  var BrowserCacheManager = class extends CacheManager {
    constructor(clientId, cacheConfig, cryptoImpl, logger, performanceClient, eventHandler, staticAuthorityOptions) {
      super(clientId, cryptoImpl, logger, staticAuthorityOptions);
      this.cacheConfig = cacheConfig;
      this.logger = logger;
      this.internalStorage = new MemoryStorage();
      this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger, performanceClient);
      this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger, performanceClient);
      this.cookieStorage = new CookieStorage();
      this.performanceClient = performanceClient;
      this.eventHandler = eventHandler;
    }
    async initialize(correlationId) {
      await this.browserStorage.initialize(correlationId);
    }
    /**
     * Parses passed value as JSON object, JSON.parse() will throw an error.
     * @param input
     */
    validateAndParseJson(jsonValue) {
      try {
        const parsedJson = JSON.parse(jsonValue);
        return parsedJson && typeof parsedJson === "object" ? parsedJson : null;
      } catch (error) {
        return null;
      }
    }
    /**
     * Reads account from cache, deserializes it into an account entity and returns it.
     * If account is not found from the key, returns null and removes key from map.
     * @param accountKey
     * @returns
     */
    getAccount(accountKey) {
      this.logger.trace("BrowserCacheManager.getAccount called");
      const serializedAccount = this.browserStorage.getUserData(accountKey);
      if (!serializedAccount) {
        this.removeAccountKeyFromMap(accountKey);
        return null;
      }
      const parsedAccount = this.validateAndParseJson(serializedAccount);
      if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {
        this.removeAccountKeyFromMap(accountKey);
        return null;
      }
      return CacheManager.toObject(new AccountEntity(), parsedAccount);
    }
    /**
     * set account entity in the platform cache
     * @param account
     */
    async setAccount(account, correlationId) {
      this.logger.trace("BrowserCacheManager.setAccount called");
      const key = account.generateAccountKey();
      await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, JSON.stringify(account), correlationId);
      const wasAdded = this.addAccountKeyToMap(key);
      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {
        this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, void 0, account.getAccountInfo());
      }
    }
    /**
     * Returns the array of account keys currently cached
     * @returns
     */
    getAccountKeys() {
      return getAccountKeys(this.browserStorage);
    }
    /**
     * Add a new account to the key map
     * @param key
     */
    addAccountKeyToMap(key) {
      this.logger.trace("BrowserCacheManager.addAccountKeyToMap called");
      this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);
      const accountKeys = this.getAccountKeys();
      if (accountKeys.indexOf(key) === -1) {
        accountKeys.push(key);
        this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
        this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key added");
        return true;
      } else {
        this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key already exists in map");
        return false;
      }
    }
    /**
     * Remove an account from the key map
     * @param key
     */
    removeAccountKeyFromMap(key) {
      this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap called");
      this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);
      const accountKeys = this.getAccountKeys();
      const removalIndex = accountKeys.indexOf(key);
      if (removalIndex > -1) {
        accountKeys.splice(removalIndex, 1);
        this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
        this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap account key removed");
      } else {
        this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap key not found in existing map");
      }
    }
    /**
     * Extends inherited removeAccount function to include removal of the account key from the map
     * @param key
     */
    async removeAccount(key) {
      void super.removeAccount(key);
      this.removeAccountKeyFromMap(key);
    }
    /**
     * Removes credentials associated with the provided account
     * @param account
     */
    async removeAccountContext(account) {
      await super.removeAccountContext(account);
      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
        this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, void 0, account.getAccountInfo());
      }
    }
    /**
     * Removes given idToken from the cache and from the key map
     * @param key
     */
    removeIdToken(key) {
      super.removeIdToken(key);
      this.removeTokenKey(key, CredentialType.ID_TOKEN);
    }
    /**
     * Removes given accessToken from the cache and from the key map
     * @param key
     */
    async removeAccessToken(key) {
      void super.removeAccessToken(key);
      this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);
    }
    /**
     * Removes given refreshToken from the cache and from the key map
     * @param key
     */
    removeRefreshToken(key) {
      super.removeRefreshToken(key);
      this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);
    }
    /**
     * Gets the keys for the cached tokens associated with this clientId
     * @returns
     */
    getTokenKeys() {
      return getTokenKeys(this.clientId, this.browserStorage);
    }
    /**
     * Adds the given key to the token key map
     * @param key
     * @param type
     */
    addTokenKey(key, type) {
      this.logger.trace("BrowserCacheManager addTokenKey called");
      const tokenKeys = this.getTokenKeys();
      switch (type) {
        case CredentialType.ID_TOKEN:
          if (tokenKeys.idToken.indexOf(key) === -1) {
            this.logger.info("BrowserCacheManager: addTokenKey - idToken added to map");
            tokenKeys.idToken.push(key);
          }
          break;
        case CredentialType.ACCESS_TOKEN:
          if (tokenKeys.accessToken.indexOf(key) === -1) {
            this.logger.info("BrowserCacheManager: addTokenKey - accessToken added to map");
            tokenKeys.accessToken.push(key);
          }
          break;
        case CredentialType.REFRESH_TOKEN:
          if (tokenKeys.refreshToken.indexOf(key) === -1) {
            this.logger.info("BrowserCacheManager: addTokenKey - refreshToken added to map");
            tokenKeys.refreshToken.push(key);
          }
          break;
        default:
          this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.unexpectedCredentialType);
      }
      this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));
    }
    /**
     * Removes the given key from the token key map
     * @param key
     * @param type
     */
    removeTokenKey(key, type) {
      this.logger.trace("BrowserCacheManager removeTokenKey called");
      const tokenKeys = this.getTokenKeys();
      switch (type) {
        case CredentialType.ID_TOKEN:
          this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);
          const idRemoval = tokenKeys.idToken.indexOf(key);
          if (idRemoval > -1) {
            this.logger.info("BrowserCacheManager: removeTokenKey - idToken removed from map");
            tokenKeys.idToken.splice(idRemoval, 1);
          } else {
            this.logger.info("BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.");
          }
          break;
        case CredentialType.ACCESS_TOKEN:
          this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);
          const accessRemoval = tokenKeys.accessToken.indexOf(key);
          if (accessRemoval > -1) {
            this.logger.info("BrowserCacheManager: removeTokenKey - accessToken removed from map");
            tokenKeys.accessToken.splice(accessRemoval, 1);
          } else {
            this.logger.info("BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.");
          }
          break;
        case CredentialType.REFRESH_TOKEN:
          this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);
          const refreshRemoval = tokenKeys.refreshToken.indexOf(key);
          if (refreshRemoval > -1) {
            this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken removed from map");
            tokenKeys.refreshToken.splice(refreshRemoval, 1);
          } else {
            this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.");
          }
          break;
        default:
          this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);
          throw createClientAuthError(ClientAuthErrorCodes_exports.unexpectedCredentialType);
      }
      this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));
    }
    /**
     * generates idToken entity from a string
     * @param idTokenKey
     */
    getIdTokenCredential(idTokenKey) {
      const value = this.browserStorage.getUserData(idTokenKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
        this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);
        return null;
      }
      const parsedIdToken = this.validateAndParseJson(value);
      if (!parsedIdToken || !CacheHelpers_exports.isIdTokenEntity(parsedIdToken)) {
        this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
        this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);
        return null;
      }
      this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit");
      return parsedIdToken;
    }
    /**
     * set IdToken credential to the platform cache
     * @param idToken
     */
    async setIdTokenCredential(idToken, correlationId) {
      this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
      const idTokenKey = CacheHelpers_exports.generateCredentialKey(idToken);
      await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(idTokenKey, JSON.stringify(idToken), correlationId);
      this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);
    }
    /**
     * generates accessToken entity from a string
     * @param key
     */
    getAccessTokenCredential(accessTokenKey) {
      const value = this.browserStorage.getUserData(accessTokenKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
        this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
        return null;
      }
      const parsedAccessToken = this.validateAndParseJson(value);
      if (!parsedAccessToken || !CacheHelpers_exports.isAccessTokenEntity(parsedAccessToken)) {
        this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
        this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
        return null;
      }
      this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit");
      return parsedAccessToken;
    }
    /**
     * set accessToken credential to the platform cache
     * @param accessToken
     */
    async setAccessTokenCredential(accessToken, correlationId) {
      this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
      const accessTokenKey = CacheHelpers_exports.generateCredentialKey(accessToken);
      await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(accessTokenKey, JSON.stringify(accessToken), correlationId);
      this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
    }
    /**
     * generates refreshToken entity from a string
     * @param refreshTokenKey
     */
    getRefreshTokenCredential(refreshTokenKey) {
      const value = this.browserStorage.getUserData(refreshTokenKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
        this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
        return null;
      }
      const parsedRefreshToken = this.validateAndParseJson(value);
      if (!parsedRefreshToken || !CacheHelpers_exports.isRefreshTokenEntity(parsedRefreshToken)) {
        this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
        this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
        return null;
      }
      this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit");
      return parsedRefreshToken;
    }
    /**
     * set refreshToken credential to the platform cache
     * @param refreshToken
     */
    async setRefreshTokenCredential(refreshToken, correlationId) {
      this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
      const refreshTokenKey = CacheHelpers_exports.generateCredentialKey(refreshToken);
      await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(refreshTokenKey, JSON.stringify(refreshToken), correlationId);
      this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
    }
    /**
     * fetch appMetadata entity from the platform cache
     * @param appMetadataKey
     */
    getAppMetadata(appMetadataKey) {
      const value = this.browserStorage.getItem(appMetadataKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
        return null;
      }
      const parsedMetadata = this.validateAndParseJson(value);
      if (!parsedMetadata || !CacheHelpers_exports.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {
        this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
        return null;
      }
      this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit");
      return parsedMetadata;
    }
    /**
     * set appMetadata entity to the platform cache
     * @param appMetadata
     */
    setAppMetadata(appMetadata) {
      this.logger.trace("BrowserCacheManager.setAppMetadata called");
      const appMetadataKey = CacheHelpers_exports.generateAppMetadataKey(appMetadata);
      this.browserStorage.setItem(appMetadataKey, JSON.stringify(appMetadata));
    }
    /**
     * fetch server telemetry entity from the platform cache
     * @param serverTelemetryKey
     */
    getServerTelemetry(serverTelemetryKey) {
      const value = this.browserStorage.getItem(serverTelemetryKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
        return null;
      }
      const parsedEntity = this.validateAndParseJson(value);
      if (!parsedEntity || !CacheHelpers_exports.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {
        this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
        return null;
      }
      this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit");
      return parsedEntity;
    }
    /**
     * set server telemetry entity to the platform cache
     * @param serverTelemetryKey
     * @param serverTelemetry
     */
    setServerTelemetry(serverTelemetryKey, serverTelemetry) {
      this.logger.trace("BrowserCacheManager.setServerTelemetry called");
      this.browserStorage.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));
    }
    /**
     *
     */
    getAuthorityMetadata(key) {
      const value = this.internalStorage.getItem(key);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit");
        return null;
      }
      const parsedMetadata = this.validateAndParseJson(value);
      if (parsedMetadata && CacheHelpers_exports.isAuthorityMetadataEntity(key, parsedMetadata)) {
        this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit");
        return parsedMetadata;
      }
      return null;
    }
    /**
     *
     */
    getAuthorityMetadataKeys() {
      const allKeys = this.internalStorage.getKeys();
      return allKeys.filter((key) => {
        return this.isAuthorityMetadata(key);
      });
    }
    /**
     * Sets wrapper metadata in memory
     * @param wrapperSKU
     * @param wrapperVersion
     */
    setWrapperMetadata(wrapperSKU, wrapperVersion) {
      this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);
      this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);
    }
    /**
     * Returns wrapper metadata from in-memory storage
     */
    getWrapperMetadata() {
      const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;
      const version5 = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;
      return [sku, version5];
    }
    /**
     *
     * @param entity
     */
    setAuthorityMetadata(key, entity) {
      this.logger.trace("BrowserCacheManager.setAuthorityMetadata called");
      this.internalStorage.setItem(key, JSON.stringify(entity));
    }
    /**
     * Gets the active account
     */
    getActiveAccount() {
      const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
      const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);
      if (!activeAccountValueFilters) {
        this.logger.trace("BrowserCacheManager.getActiveAccount: No active account filters found");
        return null;
      }
      const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);
      if (activeAccountValueObj) {
        this.logger.trace("BrowserCacheManager.getActiveAccount: Active account filters schema found");
        return this.getAccountInfoFilteredBy({
          homeAccountId: activeAccountValueObj.homeAccountId,
          localAccountId: activeAccountValueObj.localAccountId,
          tenantId: activeAccountValueObj.tenantId
        });
      }
      this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found");
      return null;
    }
    /**
     * Sets the active account's localAccountId in cache
     * @param account
     */
    setActiveAccount(account) {
      const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
      if (account) {
        this.logger.verbose("setActiveAccount: Active account set");
        const activeAccountValue = {
          homeAccountId: account.homeAccountId,
          localAccountId: account.localAccountId,
          tenantId: account.tenantId
        };
        this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));
      } else {
        this.logger.verbose("setActiveAccount: No account passed, active account not set");
        this.browserStorage.removeItem(activeAccountKey);
      }
      this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);
    }
    /**
     * fetch throttling entity from the platform cache
     * @param throttlingCacheKey
     */
    getThrottlingCache(throttlingCacheKey) {
      const value = this.browserStorage.getItem(throttlingCacheKey);
      if (!value) {
        this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
        return null;
      }
      const parsedThrottlingCache = this.validateAndParseJson(value);
      if (!parsedThrottlingCache || !CacheHelpers_exports.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {
        this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
        return null;
      }
      this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit");
      return parsedThrottlingCache;
    }
    /**
     * set throttling entity to the platform cache
     * @param throttlingCacheKey
     * @param throttlingCache
     */
    setThrottlingCache(throttlingCacheKey, throttlingCache) {
      this.logger.trace("BrowserCacheManager.setThrottlingCache called");
      this.browserStorage.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));
    }
    /**
     * Gets cache item with given key.
     * Will retrieve from cookies if storeAuthStateInCookie is set to true.
     * @param key
     */
    getTemporaryCache(cacheKey, generateKey) {
      const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
      if (this.cacheConfig.storeAuthStateInCookie) {
        const itemCookie = this.cookieStorage.getItem(key);
        if (itemCookie) {
          this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies");
          return itemCookie;
        }
      }
      const value = this.temporaryCacheStorage.getItem(key);
      if (!value) {
        if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
          const item = this.browserStorage.getItem(key);
          if (item) {
            this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage");
            return item;
          }
        }
        this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage");
        return null;
      }
      this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned");
      return value;
    }
    /**
     * Sets the cache item with the key and value given.
     * Stores in cookie if storeAuthStateInCookie is set to true.
     * This can cause cookie overflow if used incorrectly.
     * @param key
     * @param value
     */
    setTemporaryCache(cacheKey, value, generateKey) {
      const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
      this.temporaryCacheStorage.setItem(key, value);
      if (this.cacheConfig.storeAuthStateInCookie) {
        this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie");
        this.cookieStorage.setItem(key, value, void 0, this.cacheConfig.secureCookies);
      }
    }
    /**
     * Removes the cache item with the given key.
     * @param key
     */
    removeItem(key) {
      this.browserStorage.removeItem(key);
    }
    /**
     * Removes the temporary cache item with the given key.
     * Will also clear the cookie item if storeAuthStateInCookie is set to true.
     * @param key
     */
    removeTemporaryItem(key) {
      this.temporaryCacheStorage.removeItem(key);
      if (this.cacheConfig.storeAuthStateInCookie) {
        this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie");
        this.cookieStorage.removeItem(key);
      }
    }
    /**
     * Gets all keys in window.
     */
    getKeys() {
      return this.browserStorage.getKeys();
    }
    /**
     * Clears all cache entries created by MSAL.
     */
    async clear() {
      await this.removeAllAccounts();
      this.removeAppMetadata();
      this.temporaryCacheStorage.getKeys().forEach((cacheKey) => {
        if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {
          this.removeTemporaryItem(cacheKey);
        }
      });
      this.browserStorage.getKeys().forEach((cacheKey) => {
        if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {
          this.browserStorage.removeItem(cacheKey);
        }
      });
      this.internalStorage.clear();
    }
    /**
     * Clears all access tokes that have claims prior to saving the current one
     * @param performanceClient {IPerformanceClient}
     * @param correlationId {string} correlation id
     * @returns
     */
    async clearTokensAndKeysWithClaims(performanceClient, correlationId) {
      performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);
      const tokenKeys = this.getTokenKeys();
      const removedAccessTokens = [];
      tokenKeys.accessToken.forEach((key) => {
        const credential = this.getAccessTokenCredential(key);
        if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {
          removedAccessTokens.push(this.removeAccessToken(key));
        }
      });
      await Promise.all(removedAccessTokens);
      if (removedAccessTokens.length > 0) {
        this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);
      }
    }
    /**
     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)
     * @param key
     * @param addInstanceId
     */
    generateCacheKey(key) {
      const generatedKey = this.validateAndParseJson(key);
      if (!generatedKey) {
        if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {
          return key;
        }
        return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;
      }
      return JSON.stringify(key);
    }
    /**
     * Reset all temporary cache items
     * @param state
     */
    resetRequestCache() {
      this.logger.trace("BrowserCacheManager.resetRequestCache called");
      this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));
      this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.VERIFIER));
      this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));
      this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));
      this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
      this.setInteractionInProgress(false);
    }
    cacheAuthorizeRequest(authCodeRequest, codeVerifier) {
      this.logger.trace("BrowserCacheManager.cacheAuthorizeRequest called");
      const encodedValue = base64Encode(JSON.stringify(authCodeRequest));
      this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);
      if (codeVerifier) {
        const encodedVerifier = base64Encode(codeVerifier);
        this.setTemporaryCache(TemporaryCacheKeys.VERIFIER, encodedVerifier, true);
      }
    }
    /**
     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.
     */
    getCachedRequest() {
      this.logger.trace("BrowserCacheManager.getCachedRequest called");
      const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);
      if (!encodedTokenRequest) {
        throw createBrowserAuthError(noTokenRequestCacheError);
      }
      const encodedVerifier = this.getTemporaryCache(TemporaryCacheKeys.VERIFIER, true);
      let parsedRequest;
      let verifier = "";
      try {
        parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));
        if (encodedVerifier) {
          verifier = base64Decode(encodedVerifier);
        }
      } catch (e) {
        this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);
        this.logger.error(`Parsing cached token request threw with error: ${e}`);
        throw createBrowserAuthError(unableToParseTokenRequestCacheError);
      }
      return [parsedRequest, verifier];
    }
    /**
     * Gets cached native request for redirect flows
     */
    getCachedNativeRequest() {
      this.logger.trace("BrowserCacheManager.getCachedNativeRequest called");
      const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);
      if (!cachedRequest) {
        this.logger.trace("BrowserCacheManager.getCachedNativeRequest: No cached native request found");
        return null;
      }
      const parsedRequest = this.validateAndParseJson(cachedRequest);
      if (!parsedRequest) {
        this.logger.error("BrowserCacheManager.getCachedNativeRequest: Unable to parse native request");
        return null;
      }
      return parsedRequest;
    }
    isInteractionInProgress(matchClientId) {
      const clientId = this.getInteractionInProgress()?.clientId;
      if (matchClientId) {
        return clientId === this.clientId;
      } else {
        return !!clientId;
      }
    }
    getInteractionInProgress() {
      const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;
      const value = this.getTemporaryCache(key, false);
      try {
        return value ? JSON.parse(value) : null;
      } catch (e) {
        this.logger.error(`Cannot parse interaction status. Removing temporary cache items and clearing url hash. Retrying interaction should fix the error`);
        this.removeTemporaryItem(key);
        this.resetRequestCache();
        clearHash(window);
        return null;
      }
    }
    setInteractionInProgress(inProgress, type = INTERACTION_TYPE.SIGNIN) {
      const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;
      if (inProgress) {
        if (this.getInteractionInProgress()) {
          throw createBrowserAuthError(interactionInProgress);
        } else {
          this.setTemporaryCache(key, JSON.stringify({ clientId: this.clientId, type }), false);
        }
      } else if (!inProgress && this.getInteractionInProgress()?.clientId === this.clientId) {
        this.removeTemporaryItem(key);
      }
    }
    /**
     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache
     * @param result
     * @param request
     */
    async hydrateCache(result, request) {
      const idTokenEntity = CacheHelpers_exports.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);
      let claimsHash;
      if (request.claims) {
        claimsHash = await this.cryptoImpl.hashString(request.claims);
      }
      const accessTokenEntity = CacheHelpers_exports.createAccessTokenEntity(
        result.account?.homeAccountId,
        result.account.environment,
        result.accessToken,
        this.clientId,
        result.tenantId,
        result.scopes.join(" "),
        // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date
        result.expiresOn ? TimeUtils_exports.toSecondsFromDate(result.expiresOn) : 0,
        result.extExpiresOn ? TimeUtils_exports.toSecondsFromDate(result.extExpiresOn) : 0,
        base64Decode,
        void 0,
        // refreshOn
        result.tokenType,
        void 0,
        // userAssertionHash
        request.sshKid,
        request.claims,
        claimsHash
      );
      const cacheRecord = {
        idToken: idTokenEntity,
        accessToken: accessTokenEntity
      };
      return this.saveCacheRecord(cacheRecord, result.correlationId);
    }
    /**
     * saves a cache record
     * @param cacheRecord {CacheRecord}
     * @param storeInCache {?StoreInCache}
     * @param correlationId {?string} correlation id
     */
    async saveCacheRecord(cacheRecord, correlationId, storeInCache) {
      try {
        await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);
      } catch (e) {
        if (e instanceof CacheError && this.performanceClient && correlationId) {
          try {
            const tokenKeys = this.getTokenKeys();
            this.performanceClient.addFields({
              cacheRtCount: tokenKeys.refreshToken.length,
              cacheIdCount: tokenKeys.idToken.length,
              cacheAtCount: tokenKeys.accessToken.length
            }, correlationId);
          } catch (e2) {
          }
        }
        throw e;
      }
    }
  };
  function getStorageImplementation(clientId, cacheLocation, logger, performanceClient) {
    try {
      switch (cacheLocation) {
        case BrowserCacheLocation.LocalStorage:
          return new LocalStorage(clientId, logger, performanceClient);
        case BrowserCacheLocation.SessionStorage:
          return new SessionStorage();
        case BrowserCacheLocation.MemoryStorage:
        default:
          break;
      }
    } catch (e) {
      logger.error(e);
    }
    return new MemoryStorage();
  }
  var DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger, performanceClient, eventHandler) => {
    const cacheOptions = {
      cacheLocation: BrowserCacheLocation.MemoryStorage,
      temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
      storeAuthStateInCookie: false,
      secureCookies: false,
      cacheMigrationEnabled: false,
      claimsBasedCachingEnabled: false
    };
    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger, performanceClient, eventHandler);
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/AccountManager.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getAllAccounts(logger, browserStorage, isInBrowser, accountFilter) {
    logger.verbose("getAllAccounts called");
    return isInBrowser ? browserStorage.getAllAccounts(accountFilter) : [];
  }
  function getAccount(accountFilter, logger, browserStorage) {
    logger.trace("getAccount called");
    if (Object.keys(accountFilter).length === 0) {
      logger.warning("getAccount: No accountFilter provided");
      return null;
    }
    const account = browserStorage.getAccountInfoFilteredBy(accountFilter);
    if (account) {
      logger.verbose("getAccount: Account matching provided filter found, returning");
      return account;
    } else {
      logger.verbose("getAccount: No matching account found, returning null");
      return null;
    }
  }
  function getAccountByUsername(username, logger, browserStorage) {
    logger.trace("getAccountByUsername called");
    if (!username) {
      logger.warning("getAccountByUsername: No username provided");
      return null;
    }
    const account = browserStorage.getAccountInfoFilteredBy({
      username
    });
    if (account) {
      logger.verbose("getAccountByUsername: Account matching username found, returning");
      logger.verbosePii(`getAccountByUsername: Returning signed-in accounts matching username: ${username}`);
      return account;
    } else {
      logger.verbose("getAccountByUsername: No matching account found, returning null");
      return null;
    }
  }
  function getAccountByHomeId(homeAccountId, logger, browserStorage) {
    logger.trace("getAccountByHomeId called");
    if (!homeAccountId) {
      logger.warning("getAccountByHomeId: No homeAccountId provided");
      return null;
    }
    const account = browserStorage.getAccountInfoFilteredBy({
      homeAccountId
    });
    if (account) {
      logger.verbose("getAccountByHomeId: Account matching homeAccountId found, returning");
      logger.verbosePii(`getAccountByHomeId: Returning signed-in accounts matching homeAccountId: ${homeAccountId}`);
      return account;
    } else {
      logger.verbose("getAccountByHomeId: No matching account found, returning null");
      return null;
    }
  }
  function getAccountByLocalId(localAccountId, logger, browserStorage) {
    logger.trace("getAccountByLocalId called");
    if (!localAccountId) {
      logger.warning("getAccountByLocalId: No localAccountId provided");
      return null;
    }
    const account = browserStorage.getAccountInfoFilteredBy({
      localAccountId
    });
    if (account) {
      logger.verbose("getAccountByLocalId: Account matching localAccountId found, returning");
      logger.verbosePii(`getAccountByLocalId: Returning signed-in accounts matching localAccountId: ${localAccountId}`);
      return account;
    } else {
      logger.verbose("getAccountByLocalId: No matching account found, returning null");
      return null;
    }
  }
  function setActiveAccount(account, browserStorage) {
    browserStorage.setActiveAccount(account);
  }
  function getActiveAccount(browserStorage) {
    return browserStorage.getActiveAccount();
  }

  // ../../node_modules/@azure/msal-browser/dist/event/EventHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var BROADCAST_CHANNEL_NAME2 = "msal.broadcast.event";
  var EventHandler = class {
    constructor(logger) {
      this.eventCallbacks = /* @__PURE__ */ new Map();
      this.logger = logger || new Logger({});
      if (typeof BroadcastChannel !== "undefined") {
        this.broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_NAME2);
      }
      this.invokeCrossTabCallbacks = this.invokeCrossTabCallbacks.bind(this);
    }
    /**
     * Adds event callbacks to array
     * @param callback - callback to be invoked when an event is raised
     * @param eventTypes - list of events that this callback will be invoked for, if not provided callback will be invoked for all events
     * @param callbackId - Identifier for the callback, used to locate and remove the callback when no longer required
     */
    addEventCallback(callback, eventTypes, callbackId) {
      if (typeof window !== "undefined") {
        const id = callbackId || createGuid();
        if (this.eventCallbacks.has(id)) {
          this.logger.error(`Event callback with id: ${id} is already registered. Please provide a unique id or remove the existing callback and try again.`);
          return null;
        }
        this.eventCallbacks.set(id, [callback, eventTypes || []]);
        this.logger.verbose(`Event callback registered with id: ${id}`);
        return id;
      }
      return null;
    }
    /**
     * Removes callback with provided id from callback array
     * @param callbackId
     */
    removeEventCallback(callbackId) {
      this.eventCallbacks.delete(callbackId);
      this.logger.verbose(`Event callback ${callbackId} removed.`);
    }
    /**
     * Emits events by calling callback with event message
     * @param eventType
     * @param interactionType
     * @param payload
     * @param error
     */
    emitEvent(eventType, interactionType, payload, error) {
      const message = {
        eventType,
        interactionType: interactionType || null,
        payload: payload || null,
        error: error || null,
        timestamp: Date.now()
      };
      switch (eventType) {
        case EventType.ACCOUNT_ADDED:
        case EventType.ACCOUNT_REMOVED:
        case EventType.ACTIVE_ACCOUNT_CHANGED:
          this.broadcastChannel?.postMessage(message);
          break;
        default:
          this.invokeCallbacks(message);
          break;
      }
    }
    /**
     * Invoke registered callbacks
     * @param message
     */
    invokeCallbacks(message) {
      this.eventCallbacks.forEach(([callback, eventTypes], callbackId) => {
        if (eventTypes.length === 0 || eventTypes.includes(message.eventType)) {
          this.logger.verbose(`Emitting event to callback ${callbackId}: ${message.eventType}`);
          callback.apply(null, [message]);
        }
      });
    }
    /**
     * Wrapper around invokeCallbacks to handle broadcast events received from other tabs/instances
     * @param event
     */
    invokeCrossTabCallbacks(event) {
      const message = event.data;
      this.invokeCallbacks(message);
    }
    /**
     * Listen for events broadcasted from other tabs/instances
     */
    subscribeCrossTab() {
      this.broadcastChannel?.addEventListener("message", this.invokeCrossTabCallbacks);
    }
    /**
     * Unsubscribe from broadcast events
     */
    unsubscribeCrossTab() {
      this.broadcastChannel?.removeEventListener("message", this.invokeCrossTabCallbacks);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/PopupClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/BaseInteractionClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var BaseInteractionClient = class {
    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) {
      this.config = config;
      this.browserStorage = storageImpl;
      this.browserCrypto = browserCrypto;
      this.networkClient = this.config.system.networkClient;
      this.eventHandler = eventHandler;
      this.navigationClient = navigationClient;
      this.nativeMessageHandler = nativeMessageHandler;
      this.correlationId = correlationId || createNewGuid();
      this.logger = logger.clone(BrowserConstants.MSAL_SKU, version2, this.correlationId);
      this.performanceClient = performanceClient;
    }
    async clearCacheOnLogout(account) {
      if (account) {
        if (AccountEntity.accountInfoIsEqual(account, this.browserStorage.getActiveAccount(), false)) {
          this.logger.verbose("Setting active account to null");
          this.browserStorage.setActiveAccount(null);
        }
        try {
          await this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account));
          this.logger.verbose("Cleared cache items belonging to the account provided in the logout request.");
        } catch (error) {
          this.logger.error("Account provided in logout request was not found. Local cache unchanged.");
        }
      } else {
        try {
          this.logger.verbose("No account provided in logout request, clearing all cache items.", this.correlationId);
          await this.browserStorage.clear();
          await this.browserCrypto.clearKeystore();
        } catch (e) {
          this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged.");
        }
      }
    }
    /**
     *
     * Use to get the redirect uri configured in MSAL or null.
     * @param requestRedirectUri
     * @returns Redirect URL
     *
     */
    getRedirectUri(requestRedirectUri) {
      this.logger.verbose("getRedirectUri called");
      const redirectUri = requestRedirectUri || this.config.auth.redirectUri;
      return UrlString.getAbsoluteUrl(redirectUri, getCurrentUri());
    }
    /**
     *
     * @param apiId
     * @param correlationId
     * @param forceRefresh
     */
    initializeServerTelemetryManager(apiId, forceRefresh) {
      this.logger.verbose("initializeServerTelemetryManager called");
      const telemetryPayload = {
        clientId: this.config.auth.clientId,
        correlationId: this.correlationId,
        apiId,
        forceRefresh: forceRefresh || false,
        wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
        wrapperVer: this.browserStorage.getWrapperMetadata()[1]
      };
      return new ServerTelemetryManager(telemetryPayload, this.browserStorage);
    }
    /**
     * Used to get a discovered version of the default authority.
     * @param params {
     *         requestAuthority?: string;
     *         requestAzureCloudOptions?: AzureCloudOptions;
     *         requestExtraQueryParameters?: StringDict;
     *         account?: AccountInfo;
     *        }
     */
    async getDiscoveredAuthority(params) {
      const { account } = params;
      const instanceAwareEQ = params.requestExtraQueryParameters && params.requestExtraQueryParameters.hasOwnProperty("instance_aware") ? params.requestExtraQueryParameters["instance_aware"] : void 0;
      this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);
      const authorityOptions = {
        protocolMode: this.config.auth.protocolMode,
        OIDCOptions: this.config.auth.OIDCOptions,
        knownAuthorities: this.config.auth.knownAuthorities,
        cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
        authorityMetadata: this.config.auth.authorityMetadata,
        skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
      };
      const resolvedAuthority = params.requestAuthority || this.config.auth.authority;
      const resolvedInstanceAware = instanceAwareEQ?.length ? instanceAwareEQ === "true" : this.config.auth.instanceAware;
      const userAuthority = account && resolvedInstanceAware ? this.config.auth.authority.replace(UrlString.getDomainFromUrl(resolvedAuthority), account.environment) : resolvedAuthority;
      const builtAuthority = Authority.generateAuthority(userAuthority, params.requestAzureCloudOptions || this.config.auth.azureCloudOptions);
      const discoveredAuthority = await invokeAsync(AuthorityFactory_exports.createDiscoveredInstance, PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.logger, this.performanceClient, this.correlationId)(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.correlationId, this.performanceClient);
      if (account && !discoveredAuthority.isAlias(account.environment)) {
        throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.authorityMismatch);
      }
      return discoveredAuthority;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/request/RequestHelpers.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  async function initializeBaseRequest(request, config, performanceClient, logger) {
    performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, request.correlationId);
    const authority = request.authority || config.auth.authority;
    const scopes = [...request && request.scopes || []];
    const validatedRequest = {
      ...request,
      correlationId: request.correlationId,
      authority,
      scopes
    };
    if (!validatedRequest.authenticationScheme) {
      validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;
      logger.verbose(`Authentication Scheme wasn't explicitly set in request, defaulting to "Bearer" request`);
    } else {
      if (validatedRequest.authenticationScheme === AuthenticationScheme.SSH) {
        if (!request.sshJwk) {
          throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.missingSshJwk);
        }
        if (!request.sshKid) {
          throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.missingSshKid);
        }
      }
      logger.verbose(`Authentication Scheme set to "${validatedRequest.authenticationScheme}" as configured in Auth request`);
    }
    if (config.cache.claimsBasedCachingEnabled && request.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
    !StringUtils.isEmptyObj(request.claims)) {
      validatedRequest.requestedClaimsHash = await hashString(request.claims);
    }
    return validatedRequest;
  }
  async function initializeSilentRequest(request, account, config, performanceClient, logger) {
    performanceClient.addQueueMeasurement(PerformanceEvents.InitializeSilentRequest, request.correlationId);
    const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, logger, performanceClient, request.correlationId)(request, config, performanceClient, logger);
    return {
      ...request,
      ...baseRequest,
      account,
      forceRefresh: request.forceRefresh || false
    };
  }

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs
  var StandardInteractionClient = class extends BaseInteractionClient {
    /**
     * Initializer for the logout request.
     * @param logoutRequest
     */
    initializeLogoutRequest(logoutRequest) {
      this.logger.verbose("initializeLogoutRequest called", logoutRequest?.correlationId);
      const validLogoutRequest = {
        correlationId: this.correlationId || createNewGuid(),
        ...logoutRequest
      };
      if (logoutRequest) {
        if (!logoutRequest.logoutHint) {
          if (logoutRequest.account) {
            const logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);
            if (logoutHint) {
              this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided");
              validLogoutRequest.logoutHint = logoutHint;
            }
          } else {
            this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set");
          }
        } else {
          this.logger.verbose("logoutHint has already been set in logoutRequest");
        }
      } else {
        this.logger.verbose("logoutHint will not be set since no logout request was configured");
      }
      if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {
        if (logoutRequest && logoutRequest.postLogoutRedirectUri) {
          this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", validLogoutRequest.correlationId);
          validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, getCurrentUri());
        } else if (this.config.auth.postLogoutRedirectUri === null) {
          this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", validLogoutRequest.correlationId);
        } else if (this.config.auth.postLogoutRedirectUri) {
          this.logger.verbose("Setting postLogoutRedirectUri to configured uri", validLogoutRequest.correlationId);
          validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, getCurrentUri());
        } else {
          this.logger.verbose("Setting postLogoutRedirectUri to current page", validLogoutRequest.correlationId);
          validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(getCurrentUri(), getCurrentUri());
        }
      } else {
        this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", validLogoutRequest.correlationId);
      }
      return validLogoutRequest;
    }
    /**
     * Parses login_hint ID Token Claim out of AccountInfo object to be used as
     * logout_hint in end session request.
     * @param account
     */
    getLogoutHintFromIdTokenClaims(account) {
      const idTokenClaims = account.idTokenClaims;
      if (idTokenClaims) {
        if (idTokenClaims.login_hint) {
          return idTokenClaims.login_hint;
        } else {
          this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request");
        }
      } else {
        this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request");
      }
      return null;
    }
    /**
     * Creates an Authorization Code Client with the given authority, or the default authority.
     * @param params {
     *         serverTelemetryManager: ServerTelemetryManager;
     *         authorityUrl?: string;
     *         requestAzureCloudOptions?: AzureCloudOptions;
     *         requestExtraQueryParameters?: StringDict;
     *         account?: AccountInfo;
     *        }
     */
    async createAuthCodeClient(params) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);
      const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)(params);
      return new AuthorizationCodeClient(clientConfig, this.performanceClient);
    }
    /**
     * Creates a Client Configuration object with the given request authority, or the default authority.
     * @param params {
     *         serverTelemetryManager: ServerTelemetryManager;
     *         requestAuthority?: string;
     *         requestAzureCloudOptions?: AzureCloudOptions;
     *         requestExtraQueryParameters?: boolean;
     *         account?: AccountInfo;
     *        }
     */
    async getClientConfiguration(params) {
      const { serverTelemetryManager, requestAuthority, requestAzureCloudOptions, requestExtraQueryParameters, account } = params;
      this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
      const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, this.correlationId)({
        requestAuthority,
        requestAzureCloudOptions,
        requestExtraQueryParameters,
        account
      });
      const logger = this.config.system.loggerOptions;
      return {
        authOptions: {
          clientId: this.config.auth.clientId,
          authority: discoveredAuthority,
          clientCapabilities: this.config.auth.clientCapabilities,
          redirectUri: this.config.auth.redirectUri
        },
        systemOptions: {
          tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
          preventCorsPreflight: true
        },
        loggerOptions: {
          loggerCallback: logger.loggerCallback,
          piiLoggingEnabled: logger.piiLoggingEnabled,
          logLevel: logger.logLevel,
          correlationId: this.correlationId
        },
        cacheOptions: {
          claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
        },
        cryptoInterface: this.browserCrypto,
        networkInterface: this.networkClient,
        storageInterface: this.browserStorage,
        serverTelemetryManager,
        libraryInfo: {
          sku: BrowserConstants.MSAL_SKU,
          version: version2,
          cpu: Constants.EMPTY_STRING,
          os: Constants.EMPTY_STRING
        },
        telemetry: this.config.telemetry
      };
    }
    /**
     * Helper to initialize required request parameters for interactive APIs and ssoSilent()
     * @param request
     * @param interactionType
     */
    async initializeAuthorizationRequest(request, interactionType) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);
      const redirectUri = this.getRedirectUri(request.redirectUri);
      const browserState = {
        interactionType
      };
      const state = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || Constants.EMPTY_STRING, browserState);
      const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, this.logger, this.performanceClient, this.correlationId)({ ...request, correlationId: this.correlationId }, this.config, this.performanceClient, this.logger);
      const validatedRequest = {
        ...baseRequest,
        redirectUri,
        state,
        nonce: request.nonce || createNewGuid(),
        responseMode: this.config.auth.OIDCOptions.serverResponseType
      };
      if (request.loginHint || request.sid) {
        return validatedRequest;
      }
      const account = request.account || this.browserStorage.getActiveAccount();
      if (account) {
        this.logger.verbose("Setting validated request account", this.correlationId);
        this.logger.verbosePii(`Setting validated request account: ${account.homeAccountId}`, this.correlationId);
        validatedRequest.account = account;
      }
      return validatedRequest;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeMessageHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/error/NativeAuthError.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/error/NativeAuthErrorCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var contentError = "ContentError";
  var userSwitch = "user_switch";

  // ../../node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeStatusCodes.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED";
  var USER_CANCEL = "USER_CANCEL";
  var NO_NETWORK = "NO_NETWORK";
  var PERSISTENT_ERROR = "PERSISTENT_ERROR";
  var DISABLED = "DISABLED";
  var ACCOUNT_UNAVAILABLE = "ACCOUNT_UNAVAILABLE";

  // ../../node_modules/@azure/msal-browser/dist/error/NativeAuthError.mjs
  var INVALID_METHOD_ERROR = -2147186943;
  var NativeAuthErrorMessages = {
    [userSwitch]: "User attempted to switch accounts in the native broker, which is not allowed. All new accounts must sign-in through the standard web flow first, please try again."
  };
  var NativeAuthError = class _NativeAuthError extends AuthError {
    constructor(errorCode, description, ext) {
      super(errorCode, description);
      Object.setPrototypeOf(this, _NativeAuthError.prototype);
      this.name = "NativeAuthError";
      this.ext = ext;
    }
  };
  function isFatalNativeAuthError(error) {
    if (error.ext && error.ext.status && (error.ext.status === PERSISTENT_ERROR || error.ext.status === DISABLED)) {
      return true;
    }
    if (error.ext && error.ext.error && error.ext.error === INVALID_METHOD_ERROR) {
      return true;
    }
    switch (error.errorCode) {
      case contentError:
        return true;
      default:
        return false;
    }
  }
  function createNativeAuthError(code4, description, ext) {
    if (ext && ext.status) {
      switch (ext.status) {
        case ACCOUNT_UNAVAILABLE:
          return createInteractionRequiredAuthError(InteractionRequiredAuthErrorCodes_exports.nativeAccountUnavailable);
        case USER_INTERACTION_REQUIRED:
          return new InteractionRequiredAuthError(code4, description);
        case USER_CANCEL:
          return createBrowserAuthError(userCancelled);
        case NO_NETWORK:
          return createBrowserAuthError(noNetworkConnectivity2);
      }
    }
    return new NativeAuthError(code4, NativeAuthErrorMessages[code4] || description, ext);
  }

  // ../../node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeMessageHandler.mjs
  var NativeMessageHandler = class _NativeMessageHandler {
    constructor(logger, handshakeTimeoutMs, performanceClient, extensionId) {
      this.logger = logger;
      this.handshakeTimeoutMs = handshakeTimeoutMs;
      this.extensionId = extensionId;
      this.resolvers = /* @__PURE__ */ new Map();
      this.handshakeResolvers = /* @__PURE__ */ new Map();
      this.messageChannel = new MessageChannel();
      this.windowListener = this.onWindowMessage.bind(this);
      this.performanceClient = performanceClient;
      this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);
    }
    /**
     * Sends a given message to the extension and resolves with the extension response
     * @param body
     */
    async sendMessage(body) {
      this.logger.trace("NativeMessageHandler - sendMessage called.");
      const req = {
        channel: NativeConstants.CHANNEL_ID,
        extensionId: this.extensionId,
        responseId: createNewGuid(),
        body
      };
      this.logger.trace("NativeMessageHandler - Sending request to browser extension");
      this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);
      this.messageChannel.port1.postMessage(req);
      return new Promise((resolve, reject) => {
        this.resolvers.set(req.responseId, { resolve, reject });
      });
    }
    /**
     * Returns an instance of the MessageHandler that has successfully established a connection with an extension
     * @param {Logger} logger
     * @param {number} handshakeTimeoutMs
     * @param {IPerformanceClient} performanceClient
     * @param {ICrypto} crypto
     */
    static async createProvider(logger, handshakeTimeoutMs, performanceClient) {
      logger.trace("NativeMessageHandler - createProvider called.");
      try {
        const preferredProvider = new _NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);
        await preferredProvider.sendHandshakeRequest();
        return preferredProvider;
      } catch (e) {
        const backupProvider = new _NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);
        await backupProvider.sendHandshakeRequest();
        return backupProvider;
      }
    }
    /**
     * Send handshake request helper.
     */
    async sendHandshakeRequest() {
      this.logger.trace("NativeMessageHandler - sendHandshakeRequest called.");
      window.addEventListener("message", this.windowListener, false);
      const req = {
        channel: NativeConstants.CHANNEL_ID,
        extensionId: this.extensionId,
        responseId: createNewGuid(),
        body: {
          method: NativeExtensionMethod.HandshakeRequest
        }
      };
      this.handshakeEvent.add({
        extensionId: this.extensionId,
        extensionHandshakeTimeoutMs: this.handshakeTimeoutMs
      });
      this.messageChannel.port1.onmessage = (event) => {
        this.onChannelMessage(event);
      };
      window.postMessage(req, window.origin, [this.messageChannel.port2]);
      return new Promise((resolve, reject) => {
        this.handshakeResolvers.set(req.responseId, { resolve, reject });
        this.timeoutId = window.setTimeout(() => {
          window.removeEventListener("message", this.windowListener, false);
          this.messageChannel.port1.close();
          this.messageChannel.port2.close();
          this.handshakeEvent.end({
            extensionHandshakeTimedOut: true,
            success: false
          });
          reject(createBrowserAuthError(nativeHandshakeTimeout));
          this.handshakeResolvers.delete(req.responseId);
        }, this.handshakeTimeoutMs);
      });
    }
    /**
     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.
     * @param event
     */
    onWindowMessage(event) {
      this.logger.trace("NativeMessageHandler - onWindowMessage called");
      if (event.source !== window) {
        return;
      }
      const request = event.data;
      if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {
        return;
      }
      if (request.extensionId && request.extensionId !== this.extensionId) {
        return;
      }
      if (request.body.method === NativeExtensionMethod.HandshakeRequest) {
        const handshakeResolver = this.handshakeResolvers.get(request.responseId);
        if (!handshakeResolver) {
          this.logger.trace(`NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`);
          return;
        }
        this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : "No extension installed");
        clearTimeout(this.timeoutId);
        this.messageChannel.port1.close();
        this.messageChannel.port2.close();
        window.removeEventListener("message", this.windowListener, false);
        this.handshakeEvent.end({
          success: false,
          extensionInstalled: false
        });
        handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));
      }
    }
    /**
     * Invoked when a message is received from the extension on the MessageChannel port
     * @param event
     */
    onChannelMessage(event) {
      this.logger.trace("NativeMessageHandler - onChannelMessage called.");
      const request = event.data;
      const resolver2 = this.resolvers.get(request.responseId);
      const handshakeResolver = this.handshakeResolvers.get(request.responseId);
      try {
        const method = request.body.method;
        if (method === NativeExtensionMethod.Response) {
          if (!resolver2) {
            return;
          }
          const response = request.body.response;
          this.logger.trace("NativeMessageHandler - Received response from browser extension");
          this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);
          if (response.status !== "Success") {
            resolver2.reject(createNativeAuthError(response.code, response.description, response.ext));
          } else if (response.result) {
            if (response.result["code"] && response.result["description"]) {
              resolver2.reject(createNativeAuthError(response.result["code"], response.result["description"], response.result["ext"]));
            } else {
              resolver2.resolve(response.result);
            }
          } else {
            throw createAuthError(AuthErrorCodes_exports.unexpectedError, "Event does not contain result.");
          }
          this.resolvers.delete(request.responseId);
        } else if (method === NativeExtensionMethod.HandshakeResponse) {
          if (!handshakeResolver) {
            this.logger.trace(`NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`);
            return;
          }
          clearTimeout(this.timeoutId);
          window.removeEventListener("message", this.windowListener, false);
          this.extensionId = request.extensionId;
          this.extensionVersion = request.body.version;
          this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);
          this.handshakeEvent.end({
            extensionInstalled: true,
            success: true
          });
          handshakeResolver.resolve();
          this.handshakeResolvers.delete(request.responseId);
        }
      } catch (err) {
        this.logger.error("Error parsing response from WAM Extension");
        this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);
        this.logger.errorPii(`Unable to parse ${event}`);
        if (resolver2) {
          resolver2.reject(err);
        } else if (handshakeResolver) {
          handshakeResolver.reject(err);
        }
      }
    }
    /**
     * Returns the Id for the browser extension this handler is communicating with
     * @returns
     */
    getExtensionId() {
      return this.extensionId;
    }
    /**
     * Returns the version for the browser extension this handler is communicating with
     * @returns
     */
    getExtensionVersion() {
      return this.extensionVersion;
    }
    /**
     * Returns boolean indicating whether or not the request should attempt to use native broker
     * @param logger
     * @param config
     * @param nativeExtensionProvider
     * @param authenticationScheme
     */
    static isPlatformBrokerAvailable(config, logger, nativeExtensionProvider, authenticationScheme) {
      logger.trace("isPlatformBrokerAvailable called");
      if (!config.system.allowPlatformBroker) {
        logger.trace("isPlatformBrokerAvailable: allowPlatformBroker is not enabled, returning false");
        return false;
      }
      if (!nativeExtensionProvider) {
        logger.trace("isPlatformBrokerAvailable: Platform extension provider is not initialized, returning false");
        return false;
      }
      if (authenticationScheme) {
        switch (authenticationScheme) {
          case AuthenticationScheme.BEARER:
          case AuthenticationScheme.POP:
            logger.trace("isPlatformBrokerAvailable: authenticationScheme is supported, returning true");
            return true;
          default:
            logger.trace("isPlatformBrokerAvailable: authenticationScheme is not supported, returning false");
            return false;
        }
      }
      return true;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/response/ResponseHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/utils/BrowserProtocolUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function extractBrowserRequestState(browserCrypto, state) {
    if (!state) {
      return null;
    }
    try {
      const requestStateObj = ProtocolUtils.parseRequestState(browserCrypto, state);
      return requestStateObj.libraryState.meta;
    } catch (e) {
      throw createClientAuthError(ClientAuthErrorCodes_exports.invalidState);
    }
  }

  // ../../node_modules/@azure/msal-browser/dist/response/ResponseHandler.mjs
  function deserializeResponse(responseString, responseLocation, logger) {
    const serverParams = UrlUtils_exports.getDeserializedResponse(responseString);
    if (!serverParams) {
      if (!UrlUtils_exports.stripLeadingHashOrQuery(responseString)) {
        logger.error(`The request has returned to the redirectUri but a ${responseLocation} is not present. It's likely that the ${responseLocation} has been removed or the page has been redirected by code running on the redirectUri page.`);
        throw createBrowserAuthError(hashEmptyError);
      } else {
        logger.error(`A ${responseLocation} is present in the iframe but it does not contain known properties. It's likely that the ${responseLocation} has been replaced by code running on the redirectUri page.`);
        logger.errorPii(`The ${responseLocation} detected is: ${responseString}`);
        throw createBrowserAuthError(hashDoesNotContainKnownProperties);
      }
    }
    return serverParams;
  }
  function validateInteractionType(response, browserCrypto, interactionType) {
    if (!response.state) {
      throw createBrowserAuthError(noStateInHash);
    }
    const platformStateObj = extractBrowserRequestState(browserCrypto, response.state);
    if (!platformStateObj) {
      throw createBrowserAuthError(unableToParseState);
    }
    if (platformStateObj.interactionType !== interactionType) {
      throw createBrowserAuthError(stateInteractionTypeMismatch);
    }
  }

  // ../../node_modules/@azure/msal-browser/dist/protocol/Authorize.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var InteractionHandler = class {
    constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {
      this.authModule = authCodeModule;
      this.browserStorage = storageImpl;
      this.authCodeRequest = authCodeRequest;
      this.logger = logger;
      this.performanceClient = performanceClient;
    }
    /**
     * Function to handle response parameters from hash.
     * @param locationHash
     */
    async handleCodeResponse(response, request) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponse, request.correlationId);
      let authCodeResponse;
      try {
        authCodeResponse = Authorize_exports.getAuthorizationCodePayload(response, request.state);
      } catch (e) {
        if (e instanceof ServerError && e.subError === userCancelled) {
          throw createBrowserAuthError(userCancelled);
        } else {
          throw e;
        }
      }
      return invokeAsync(this.handleCodeResponseFromServer.bind(this), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)(authCodeResponse, request);
    }
    /**
     * Process auth code response from AAD
     * @param authCodeResponse
     * @param state
     * @param authority
     * @param networkModule
     * @returns
     */
    async handleCodeResponseFromServer(authCodeResponse, request, validateNonce = true) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, request.correlationId);
      this.logger.trace("InteractionHandler.handleCodeResponseFromServer called");
      this.authCodeRequest.code = authCodeResponse.code;
      if (authCodeResponse.cloud_instance_host_name) {
        await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, request.correlationId)(authCodeResponse.cloud_instance_host_name, request.correlationId);
      }
      if (validateNonce) {
        authCodeResponse.nonce = request.nonce || void 0;
      }
      authCodeResponse.state = request.state;
      if (authCodeResponse.client_info) {
        this.authCodeRequest.clientInfo = authCodeResponse.client_info;
      } else {
        const ccsCred = this.createCcsCredentials(request);
        if (ccsCred) {
          this.authCodeRequest.ccsCredential = ccsCred;
        }
      }
      const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(this.authCodeRequest, authCodeResponse);
      return tokenResponse;
    }
    /**
     * Build ccs creds if available
     */
    createCcsCredentials(request) {
      if (request.account) {
        return {
          credential: request.account.homeAccountId,
          type: CcsCredentialType.HOME_ACCOUNT_ID
        };
      } else if (request.loginHint) {
        return {
          credential: request.loginHint,
          type: CcsCredentialType.UPN
        };
      }
      return null;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/NativeInteractionClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentCacheClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SilentCacheClient = class extends StandardInteractionClient {
    /**
     * Returns unexpired tokens from the cache, if available
     * @param silentRequest
     */
    async acquireToken(silentRequest) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentCacheClientAcquireToken, silentRequest.correlationId);
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
      const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)({
        serverTelemetryManager,
        requestAuthority: silentRequest.authority,
        requestAzureCloudOptions: silentRequest.azureCloudOptions,
        account: silentRequest.account
      });
      const silentAuthClient = new SilentFlowClient(clientConfig, this.performanceClient);
      this.logger.verbose("Silent auth client created");
      try {
        const response = await invokeAsync(silentAuthClient.acquireCachedToken.bind(silentAuthClient), PerformanceEvents.SilentFlowClientAcquireCachedToken, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest);
        const authResponse = response[0];
        this.performanceClient.addFields({
          fromCache: true
        }, silentRequest.correlationId);
        return authResponse;
      } catch (error) {
        if (error instanceof BrowserAuthError && error.errorCode === cryptoKeyNotFound) {
          this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair.");
        }
        throw error;
      }
    }
    /**
     * API to silenty clear the browser cache.
     * @param logoutRequest
     */
    logout(logoutRequest) {
      this.logger.verbose("logoutRedirect called");
      const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
      return this.clearCacheOnLogout(validLogoutRequest?.account);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/NativeInteractionClient.mjs
  var NativeInteractionClient = class extends BaseInteractionClient {
    constructor(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, nativeStorageImpl, correlationId) {
      super(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId);
      this.apiId = apiId;
      this.accountId = accountId;
      this.nativeMessageHandler = provider;
      this.nativeStorageManager = nativeStorageImpl;
      this.silentCacheClient = new SilentCacheClient(config, this.nativeStorageManager, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId);
      const extensionName = this.nativeMessageHandler.getExtensionId() === NativeConstants.PREFERRED_EXTENSION_ID ? "chrome" : this.nativeMessageHandler.getExtensionId()?.length ? "unknown" : void 0;
      this.skus = ServerTelemetryManager.makeExtraSkuString({
        libraryName: BrowserConstants.MSAL_SKU,
        libraryVersion: version2,
        extensionName,
        extensionVersion: this.nativeMessageHandler.getExtensionVersion()
      });
    }
    /**
     * Adds SKUs to request extra query parameters
     * @param request {NativeTokenRequest}
     * @private
     */
    addRequestSKUs(request) {
      request.extraParameters = {
        ...request.extraParameters,
        [AADServerParamKeys_exports.X_CLIENT_EXTRA_SKU]: this.skus
      };
    }
    /**
     * Acquire token from native platform via browser extension
     * @param request
     */
    async acquireToken(request, cacheLookupPolicy) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);
      this.logger.trace("NativeInteractionClient - acquireToken called.");
      const nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);
      const reqTimestamp = TimeUtils_exports.nowSeconds();
      const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
      try {
        const nativeRequest = await this.initializeNativeRequest(request);
        try {
          const result = await this.acquireTokensFromCache(this.accountId, nativeRequest);
          nativeATMeasurement.end({
            success: true,
            isNativeBroker: false,
            fromCache: true
          });
          return result;
        } catch (e) {
          if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
            this.logger.info("MSAL internal Cache does not contain tokens, return error as per cache policy");
            throw e;
          }
          this.logger.info("MSAL internal Cache does not contain tokens, proceed to make a native call");
        }
        const { ...nativeTokenRequest } = nativeRequest;
        const messageBody = {
          method: NativeExtensionMethod.GetToken,
          request: nativeTokenRequest
        };
        const response = await this.nativeMessageHandler.sendMessage(messageBody);
        const validatedResponse = this.validateNativeResponse(response);
        return await this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp).then((result) => {
          nativeATMeasurement.end({
            success: true,
            isNativeBroker: true,
            requestId: result.requestId
          });
          serverTelemetryManager.clearNativeBrokerErrorCode();
          return result;
        }).catch((error) => {
          nativeATMeasurement.end({
            success: false,
            errorCode: error.errorCode,
            subErrorCode: error.subError,
            isNativeBroker: true
          });
          throw error;
        });
      } catch (e) {
        if (e instanceof NativeAuthError) {
          serverTelemetryManager.setNativeBrokerErrorCode(e.errorCode);
        }
        throw e;
      }
    }
    /**
     * Creates silent flow request
     * @param request
     * @param cachedAccount
     * @returns CommonSilentFlowRequest
     */
    createSilentCacheRequest(request, cachedAccount) {
      return {
        authority: request.authority,
        correlationId: this.correlationId,
        scopes: ScopeSet.fromString(request.scope).asArray(),
        account: cachedAccount,
        forceRefresh: false
      };
    }
    /**
     * Fetches the tokens from the cache if un-expired
     * @param nativeAccountId
     * @param request
     * @returns authenticationResult
     */
    async acquireTokensFromCache(nativeAccountId, request) {
      if (!nativeAccountId) {
        this.logger.warning("NativeInteractionClient:acquireTokensFromCache - No nativeAccountId provided");
        throw createClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
      }
      const account = this.browserStorage.getBaseAccountInfo({
        nativeAccountId
      });
      if (!account) {
        throw createClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
      }
      try {
        const silentRequest = this.createSilentCacheRequest(request, account);
        const result = await this.silentCacheClient.acquireToken(silentRequest);
        const fullAccount = {
          ...account,
          idTokenClaims: result?.idTokenClaims,
          idToken: result?.idToken
        };
        return {
          ...result,
          account: fullAccount
        };
      } catch (e) {
        throw e;
      }
    }
    /**
     * Acquires a token from native platform then redirects to the redirectUri instead of returning the response
     * @param {RedirectRequest} request
     * @param {InProgressPerformanceEvent} rootMeasurement
     */
    async acquireTokenRedirect(request, rootMeasurement) {
      this.logger.trace("NativeInteractionClient - acquireTokenRedirect called.");
      const { ...remainingParameters } = request;
      delete remainingParameters.onRedirectNavigate;
      const nativeRequest = await this.initializeNativeRequest(remainingParameters);
      const messageBody = {
        method: NativeExtensionMethod.GetToken,
        request: nativeRequest
      };
      try {
        const response = await this.nativeMessageHandler.sendMessage(messageBody);
        this.validateNativeResponse(response);
      } catch (e) {
        if (e instanceof NativeAuthError) {
          const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
          serverTelemetryManager.setNativeBrokerErrorCode(e.errorCode);
          if (isFatalNativeAuthError(e)) {
            throw e;
          }
        }
      }
      this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);
      const navigationOptions = {
        apiId: ApiId.acquireTokenRedirect,
        timeout: this.config.system.redirectNavigationTimeout,
        noHistory: false
      };
      const redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);
      rootMeasurement.end({ success: true });
      await this.navigationClient.navigateExternal(redirectUri, navigationOptions);
    }
    /**
     * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response
     * @param performanceClient {IPerformanceClient?}
     * @param correlationId {string?} correlation identifier
     */
    async handleRedirectPromise(performanceClient, correlationId) {
      this.logger.trace("NativeInteractionClient - handleRedirectPromise called.");
      if (!this.browserStorage.isInteractionInProgress(true)) {
        this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
        return null;
      }
      const cachedRequest = this.browserStorage.getCachedNativeRequest();
      if (!cachedRequest) {
        this.logger.verbose("NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.");
        if (performanceClient && correlationId) {
          performanceClient?.addFields({ errorCode: "no_cached_request" }, correlationId);
        }
        return null;
      }
      const { prompt, ...request } = cachedRequest;
      if (prompt) {
        this.logger.verbose("NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window.");
      }
      this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
      const messageBody = {
        method: NativeExtensionMethod.GetToken,
        request
      };
      const reqTimestamp = TimeUtils_exports.nowSeconds();
      try {
        this.logger.verbose("NativeInteractionClient - handleRedirectPromise sending message to native broker.");
        const response = await this.nativeMessageHandler.sendMessage(messageBody);
        this.validateNativeResponse(response);
        const result = this.handleNativeResponse(response, request, reqTimestamp);
        const res = await result;
        const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
        serverTelemetryManager.clearNativeBrokerErrorCode();
        return res;
      } catch (e) {
        throw e;
      }
    }
    /**
     * Logout from native platform via browser extension
     * @param request
     */
    logout() {
      this.logger.trace("NativeInteractionClient - logout called.");
      return Promise.reject("Logout not implemented yet");
    }
    /**
     * Transform response from native platform into AuthenticationResult object which will be returned to the end user
     * @param response
     * @param request
     * @param reqTimestamp
     */
    async handleNativeResponse(response, request, reqTimestamp) {
      this.logger.trace("NativeInteractionClient - handleNativeResponse called.");
      const idTokenClaims = AuthToken_exports.extractTokenClaims(response.id_token, base64Decode);
      const homeAccountIdentifier = this.createHomeAccountIdentifier(response, idTokenClaims);
      const cachedhomeAccountId = this.browserStorage.getAccountInfoFilteredBy({
        nativeAccountId: request.accountId
      })?.homeAccountId;
      if (request.extraParameters?.child_client_id && response.account.id !== request.accountId) {
        this.logger.info("handleNativeServerResponse: Double broker flow detected, ignoring accountId mismatch");
      } else if (homeAccountIdentifier !== cachedhomeAccountId && response.account.id !== request.accountId) {
        throw createNativeAuthError(userSwitch);
      }
      const authority = await this.getDiscoveredAuthority({
        requestAuthority: request.authority
      });
      const baseAccount = buildAccountToCache(
        this.browserStorage,
        authority,
        homeAccountIdentifier,
        base64Decode,
        idTokenClaims,
        response.client_info,
        void 0,
        // environment
        idTokenClaims.tid,
        void 0,
        // auth code payload
        response.account.id,
        this.logger
      );
      response.expires_in = Number(response.expires_in);
      const result = await this.generateAuthenticationResult(response, request, idTokenClaims, baseAccount, authority.canonicalAuthority, reqTimestamp);
      await this.cacheAccount(baseAccount);
      await this.cacheNativeTokens(response, request, homeAccountIdentifier, idTokenClaims, response.access_token, result.tenantId, reqTimestamp);
      return result;
    }
    /**
     * creates an homeAccountIdentifier for the account
     * @param response
     * @param idTokenObj
     * @returns
     */
    createHomeAccountIdentifier(response, idTokenClaims) {
      const homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenClaims);
      return homeAccountIdentifier;
    }
    /**
     * Helper to generate scopes
     * @param response
     * @param request
     * @returns
     */
    generateScopes(response, request) {
      return response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);
    }
    /**
     * If PoP token is requesred, records the PoP token if returned from the WAM, else generates one in the browser
     * @param request
     * @param response
     */
    async generatePopAccessToken(response, request) {
      if (request.tokenType === AuthenticationScheme.POP && request.signPopToken) {
        if (response.shr) {
          this.logger.trace("handleNativeServerResponse: SHR is enabled in native layer");
          return response.shr;
        }
        const popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
        const shrParameters = {
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          shrNonce: request.shrNonce
        };
        if (!request.keyId) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.keyIdMissing);
        }
        return popTokenGenerator.signPopToken(response.access_token, request.keyId, shrParameters);
      } else {
        return response.access_token;
      }
    }
    /**
     * Generates authentication result
     * @param response
     * @param request
     * @param idTokenObj
     * @param accountEntity
     * @param authority
     * @param reqTimestamp
     * @returns
     */
    async generateAuthenticationResult(response, request, idTokenClaims, accountEntity, authority, reqTimestamp) {
      const mats = this.addTelemetryFromNativeResponse(response);
      const responseScopes = response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);
      const accountProperties = response.account.properties || {};
      const uid = accountProperties["UID"] || idTokenClaims.oid || idTokenClaims.sub || Constants.EMPTY_STRING;
      const tid = accountProperties["TenantId"] || idTokenClaims.tid || Constants.EMPTY_STRING;
      const accountInfo = updateAccountTenantProfileData(
        accountEntity.getAccountInfo(),
        void 0,
        // tenantProfile optional
        idTokenClaims,
        response.id_token
      );
      if (accountInfo.nativeAccountId !== response.account.id) {
        accountInfo.nativeAccountId = response.account.id;
      }
      const responseAccessToken = await this.generatePopAccessToken(response, request);
      const tokenType = request.tokenType === AuthenticationScheme.POP ? AuthenticationScheme.POP : AuthenticationScheme.BEARER;
      const result = {
        authority,
        uniqueId: uid,
        tenantId: tid,
        scopes: responseScopes.asArray(),
        account: accountInfo,
        idToken: response.id_token,
        idTokenClaims,
        accessToken: responseAccessToken,
        fromCache: mats ? this.isResponseFromCache(mats) : false,
        // Request timestamp and NativeResponse expires_in are in seconds, converting to Date for AuthenticationResult
        expiresOn: TimeUtils_exports.toDateFromSeconds(reqTimestamp + response.expires_in),
        tokenType,
        correlationId: this.correlationId,
        state: response.state,
        fromNativeBroker: true
      };
      return result;
    }
    /**
     * cache the account entity in browser storage
     * @param accountEntity
     */
    async cacheAccount(accountEntity) {
      await this.browserStorage.setAccount(accountEntity, this.correlationId);
      this.browserStorage.removeAccountContext(accountEntity).catch((e) => {
        this.logger.error(`Error occurred while removing account context from browser storage. ${e}`);
      });
    }
    /**
     * Stores the access_token and id_token in inmemory storage
     * @param response
     * @param request
     * @param homeAccountIdentifier
     * @param idTokenObj
     * @param responseAccessToken
     * @param tenantId
     * @param reqTimestamp
     */
    cacheNativeTokens(response, request, homeAccountIdentifier, idTokenClaims, responseAccessToken, tenantId, reqTimestamp) {
      const cachedIdToken = CacheHelpers_exports.createIdTokenEntity(homeAccountIdentifier, request.authority, response.id_token || "", request.clientId, idTokenClaims.tid || "");
      const expiresIn = request.tokenType === AuthenticationScheme.POP ? Constants.SHR_NONCE_VALIDITY : (typeof response.expires_in === "string" ? parseInt(response.expires_in, 10) : response.expires_in) || 0;
      const tokenExpirationSeconds = reqTimestamp + expiresIn;
      const responseScopes = this.generateScopes(response, request);
      const cachedAccessToken = CacheHelpers_exports.createAccessTokenEntity(homeAccountIdentifier, request.authority, responseAccessToken, request.clientId, idTokenClaims.tid || tenantId, responseScopes.printScopes(), tokenExpirationSeconds, 0, base64Decode, void 0, request.tokenType, void 0, request.keyId);
      const nativeCacheRecord = {
        idToken: cachedIdToken,
        accessToken: cachedAccessToken
      };
      return this.nativeStorageManager.saveCacheRecord(nativeCacheRecord, this.correlationId, request.storeInCache);
    }
    addTelemetryFromNativeResponse(response) {
      const mats = this.getMATSFromResponse(response);
      if (!mats) {
        return null;
      }
      this.performanceClient.addFields({
        extensionId: this.nativeMessageHandler.getExtensionId(),
        extensionVersion: this.nativeMessageHandler.getExtensionVersion(),
        matsBrokerVersion: mats.broker_version,
        matsAccountJoinOnStart: mats.account_join_on_start,
        matsAccountJoinOnEnd: mats.account_join_on_end,
        matsDeviceJoin: mats.device_join,
        matsPromptBehavior: mats.prompt_behavior,
        matsApiErrorCode: mats.api_error_code,
        matsUiVisible: mats.ui_visible,
        matsSilentCode: mats.silent_code,
        matsSilentBiSubCode: mats.silent_bi_sub_code,
        matsSilentMessage: mats.silent_message,
        matsSilentStatus: mats.silent_status,
        matsHttpStatus: mats.http_status,
        matsHttpEventCount: mats.http_event_count
      }, this.correlationId);
      return mats;
    }
    /**
     * Validates native platform response before processing
     * @param response
     */
    validateNativeResponse(response) {
      if (response.hasOwnProperty("access_token") && response.hasOwnProperty("id_token") && response.hasOwnProperty("client_info") && response.hasOwnProperty("account") && response.hasOwnProperty("scope") && response.hasOwnProperty("expires_in")) {
        return response;
      } else {
        throw createAuthError(AuthErrorCodes_exports.unexpectedError, "Response missing expected properties.");
      }
    }
    /**
     * Gets MATS telemetry from native response
     * @param response
     * @returns
     */
    getMATSFromResponse(response) {
      if (response.properties.MATS) {
        try {
          return JSON.parse(response.properties.MATS);
        } catch (e) {
          this.logger.error("NativeInteractionClient - Error parsing MATS telemetry, returning null instead");
        }
      }
      return null;
    }
    /**
     * Returns whether or not response came from native cache
     * @param response
     * @returns
     */
    isResponseFromCache(mats) {
      if (typeof mats.is_cached === "undefined") {
        this.logger.verbose("NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false.");
        return false;
      }
      return !!mats.is_cached;
    }
    /**
     * Translates developer provided request object into NativeRequest object
     * @param request
     */
    async initializeNativeRequest(request) {
      this.logger.trace("NativeInteractionClient - initializeNativeRequest called");
      const requestAuthority = request.authority || this.config.auth.authority;
      if (request.account) {
        await this.getDiscoveredAuthority({
          requestAuthority,
          requestAzureCloudOptions: request.azureCloudOptions,
          account: request.account
        });
      }
      const canonicalAuthority = new UrlString(requestAuthority);
      canonicalAuthority.validateAsUri();
      const { scopes, ...remainingProperties } = request;
      const scopeSet = new ScopeSet(scopes || []);
      scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);
      const getPrompt = () => {
        switch (this.apiId) {
          case ApiId.ssoSilent:
          case ApiId.acquireTokenSilent_silentFlow:
            this.logger.trace("initializeNativeRequest: silent request sets prompt to none");
            return PromptValue.NONE;
        }
        if (!request.prompt) {
          this.logger.trace("initializeNativeRequest: prompt was not provided");
          return void 0;
        }
        switch (request.prompt) {
          case PromptValue.NONE:
          case PromptValue.CONSENT:
          case PromptValue.LOGIN:
            this.logger.trace("initializeNativeRequest: prompt is compatible with native flow");
            return request.prompt;
          default:
            this.logger.trace(`initializeNativeRequest: prompt = ${request.prompt} is not compatible with native flow`);
            throw createBrowserAuthError(nativePromptNotSupported);
        }
      };
      const validatedRequest = {
        ...remainingProperties,
        accountId: this.accountId,
        clientId: this.config.auth.clientId,
        authority: canonicalAuthority.urlString,
        scope: scopeSet.printScopes(),
        redirectUri: this.getRedirectUri(request.redirectUri),
        prompt: getPrompt(),
        correlationId: this.correlationId,
        tokenType: request.authenticationScheme,
        windowTitleSubstring: document.title,
        extraParameters: {
          ...request.extraQueryParameters,
          ...request.tokenQueryParameters
        },
        extendedExpiryToken: false,
        keyId: request.popKid
      };
      if (validatedRequest.signPopToken && !!request.popKid) {
        throw createBrowserAuthError(invalidPopTokenRequest);
      }
      this.handleExtraBrokerParams(validatedRequest);
      validatedRequest.extraParameters = validatedRequest.extraParameters || {};
      validatedRequest.extraParameters.telemetry = NativeConstants.MATS_TELEMETRY;
      if (request.authenticationScheme === AuthenticationScheme.POP) {
        const shrParameters = {
          resourceRequestUri: request.resourceRequestUri,
          resourceRequestMethod: request.resourceRequestMethod,
          shrClaims: request.shrClaims,
          shrNonce: request.shrNonce
        };
        const popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
        let reqCnfData;
        if (!validatedRequest.keyId) {
          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(shrParameters, this.logger);
          reqCnfData = generatedReqCnfData.reqCnfString;
          validatedRequest.keyId = generatedReqCnfData.kid;
          validatedRequest.signPopToken = true;
        } else {
          reqCnfData = this.browserCrypto.base64UrlEncode(JSON.stringify({ kid: validatedRequest.keyId }));
          validatedRequest.signPopToken = false;
        }
        validatedRequest.reqCnf = reqCnfData;
      }
      this.addRequestSKUs(validatedRequest);
      return validatedRequest;
    }
    /**
     * Handles extra broker request parameters
     * @param request {NativeTokenRequest}
     * @private
     */
    handleExtraBrokerParams(request) {
      const hasExtraBrokerParams = request.extraParameters && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.BROKER_CLIENT_ID) && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.BROKER_REDIRECT_URI) && request.extraParameters.hasOwnProperty(AADServerParamKeys_exports.CLIENT_ID);
      if (!request.embeddedClientId && !hasExtraBrokerParams) {
        return;
      }
      let child_client_id = "";
      const child_redirect_uri = request.redirectUri;
      if (request.embeddedClientId) {
        request.redirectUri = this.config.auth.redirectUri;
        child_client_id = request.embeddedClientId;
      } else if (request.extraParameters) {
        request.redirectUri = request.extraParameters[AADServerParamKeys_exports.BROKER_REDIRECT_URI];
        child_client_id = request.extraParameters[AADServerParamKeys_exports.CLIENT_ID];
      }
      request.extraParameters = {
        child_client_id,
        child_redirect_uri
      };
      this.performanceClient?.addFields({
        embeddedClientId: child_client_id,
        embeddedRedirectUri: child_redirect_uri
      }, request.correlationId);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/protocol/Authorize.mjs
  async function getStandardParameters(config, authority, request, logger, performanceClient) {
    const parameters = Authorize_exports.getStandardAuthorizeRequestParameters({ ...config.auth, authority }, request, logger, performanceClient);
    RequestParameterBuilder_exports.addLibraryInfo(parameters, {
      sku: BrowserConstants.MSAL_SKU,
      version: version2,
      os: "",
      cpu: ""
    });
    if (config.auth.protocolMode !== ProtocolMode.OIDC) {
      RequestParameterBuilder_exports.addApplicationTelemetry(parameters, config.telemetry.application);
    }
    if (request.platformBroker) {
      RequestParameterBuilder_exports.addNativeBroker(parameters);
      if (request.authenticationScheme === AuthenticationScheme.POP) {
        const cryptoOps = new CryptoOps(logger, performanceClient);
        const popTokenGenerator = new PopTokenGenerator(cryptoOps);
        let reqCnfData;
        if (!request.popKid) {
          const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, logger, performanceClient, request.correlationId)(request, logger);
          reqCnfData = generatedReqCnfData.reqCnfString;
        } else {
          reqCnfData = cryptoOps.encodeKid(request.popKid);
        }
        RequestParameterBuilder_exports.addPopToken(parameters, reqCnfData);
      }
    }
    RequestParameterBuilder_exports.instrumentBrokerParams(parameters, request.correlationId, performanceClient);
    return parameters;
  }
  async function getAuthCodeRequestUrl(config, authority, request, logger, performanceClient) {
    if (!request.codeChallenge) {
      throw createClientConfigurationError(ClientConfigurationErrorCodes_exports.pkceParamsMissing);
    }
    const parameters = await invokeAsync(getStandardParameters, PerformanceEvents.GetStandardParams, logger, performanceClient, request.correlationId)(config, authority, request, logger, performanceClient);
    RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.CODE);
    RequestParameterBuilder_exports.addCodeChallengeParams(parameters, request.codeChallenge, Constants.S256_CODE_CHALLENGE_METHOD);
    RequestParameterBuilder_exports.addExtraQueryParameters(parameters, request.extraQueryParameters || {});
    return Authorize_exports.getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
  }
  async function getEARForm(frame, config, authority, request, logger, performanceClient) {
    if (!request.earJwk) {
      throw createBrowserAuthError(earJwkEmpty);
    }
    const parameters = await getStandardParameters(config, authority, request, logger, performanceClient);
    RequestParameterBuilder_exports.addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN_REFRESHTOKEN);
    RequestParameterBuilder_exports.addEARParameters(parameters, request.earJwk);
    const queryParams = /* @__PURE__ */ new Map();
    RequestParameterBuilder_exports.addExtraQueryParameters(queryParams, request.extraQueryParameters || {});
    const url = Authorize_exports.getAuthorizeUrl(authority, queryParams, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
    return createForm(frame, url, parameters);
  }
  function createForm(frame, authorizeUrl, parameters) {
    const form = frame.createElement("form");
    form.method = "post";
    form.action = authorizeUrl;
    parameters.forEach((value, key) => {
      const param = frame.createElement("input");
      param.hidden = true;
      param.name = key;
      param.value = value;
      form.appendChild(param);
    });
    frame.body.appendChild(form);
    return form;
  }
  async function handleResponsePlatformBroker(request, accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger, performanceClient, nativeMessageHandler) {
    if (!nativeMessageHandler) {
      throw createBrowserAuthError(nativeConnectionNotEstablished);
    }
    const browserCrypto = new CryptoOps(logger, performanceClient);
    const nativeInteractionClient = new NativeInteractionClient(config, browserStorage, browserCrypto, logger, eventHandler, config.system.navigationClient, apiId, performanceClient, nativeMessageHandler, accountId, nativeStorage, request.correlationId);
    const { userRequestState } = ProtocolUtils.parseRequestState(browserCrypto, request.state);
    return invokeAsync(nativeInteractionClient.acquireToken.bind(nativeInteractionClient), PerformanceEvents.NativeInteractionClientAcquireToken, logger, performanceClient, request.correlationId)({
      ...request,
      state: userRequestState,
      prompt: void 0
      // Server should handle the prompt, ideally native broker can do this part silently
    });
  }
  async function handleResponseCode(request, response, codeVerifier, apiId, config, authClient, browserStorage, nativeStorage, eventHandler, logger, performanceClient, nativeMessageHandler) {
    ThrottlingUtils.removeThrottle(browserStorage, config.auth.clientId, request);
    if (response.accountId) {
      return invokeAsync(handleResponsePlatformBroker, PerformanceEvents.HandleResponsePlatformBroker, logger, performanceClient, request.correlationId)(request, response.accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger, performanceClient, nativeMessageHandler);
    }
    const authCodeRequest = {
      ...request,
      code: response.code || "",
      codeVerifier
    };
    const interactionHandler = new InteractionHandler(authClient, browserStorage, authCodeRequest, logger, performanceClient);
    const result = await invokeAsync(interactionHandler.handleCodeResponse.bind(interactionHandler), PerformanceEvents.HandleCodeResponse, logger, performanceClient, request.correlationId)(response, request);
    return result;
  }
  async function handleResponseEAR(request, response, apiId, config, authority, browserStorage, nativeStorage, eventHandler, logger, performanceClient, nativeMessageHandler) {
    ThrottlingUtils.removeThrottle(browserStorage, config.auth.clientId, request);
    Authorize_exports.validateAuthorizationResponse(response, request.state);
    if (!response.ear_jwe) {
      throw createBrowserAuthError(earJweEmpty);
    }
    if (!request.earJwk) {
      throw createBrowserAuthError(earJwkEmpty);
    }
    const decryptedData = JSON.parse(await invokeAsync(decryptEarResponse, PerformanceEvents.DecryptEarResponse, logger, performanceClient, request.correlationId)(request.earJwk, response.ear_jwe));
    if (decryptedData.accountId) {
      return invokeAsync(handleResponsePlatformBroker, PerformanceEvents.HandleResponsePlatformBroker, logger, performanceClient, request.correlationId)(request, decryptedData.accountId, apiId, config, browserStorage, nativeStorage, eventHandler, logger, performanceClient, nativeMessageHandler);
    }
    const responseHandler = new ResponseHandler(config.auth.clientId, browserStorage, new CryptoOps(logger, performanceClient), logger, null, null, performanceClient);
    responseHandler.validateTokenResponse(decryptedData);
    const additionalData = {
      code: "",
      state: request.state,
      nonce: request.nonce,
      client_info: decryptedData.client_info,
      cloud_graph_host_name: decryptedData.cloud_graph_host_name,
      cloud_instance_host_name: decryptedData.cloud_instance_host_name,
      cloud_instance_name: decryptedData.cloud_instance_name,
      msgraph_host: decryptedData.msgraph_host
    };
    return await invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, logger, performanceClient, request.correlationId)(decryptedData, authority, TimeUtils_exports.nowSeconds(), request, additionalData, void 0, void 0, void 0, void 0);
  }

  // ../../node_modules/@azure/msal-browser/dist/crypto/PkceGenerator.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var RANDOM_BYTE_ARR_LENGTH = 32;
  async function generatePkceCodes(performanceClient, logger, correlationId) {
    performanceClient.addQueueMeasurement(PerformanceEvents.GeneratePkceCodes, correlationId);
    const codeVerifier = invoke(generateCodeVerifier, PerformanceEvents.GenerateCodeVerifier, logger, performanceClient, correlationId)(performanceClient, logger, correlationId);
    const codeChallenge = await invokeAsync(generateCodeChallengeFromVerifier, PerformanceEvents.GenerateCodeChallengeFromVerifier, logger, performanceClient, correlationId)(codeVerifier, performanceClient, logger, correlationId);
    return {
      verifier: codeVerifier,
      challenge: codeChallenge
    };
  }
  function generateCodeVerifier(performanceClient, logger, correlationId) {
    try {
      const buffer = new Uint8Array(RANDOM_BYTE_ARR_LENGTH);
      invoke(getRandomValues2, PerformanceEvents.GetRandomValues, logger, performanceClient, correlationId)(buffer);
      const pkceCodeVerifierB64 = urlEncodeArr(buffer);
      return pkceCodeVerifierB64;
    } catch (e) {
      throw createBrowserAuthError(pkceNotCreated);
    }
  }
  async function generateCodeChallengeFromVerifier(pkceCodeVerifier, performanceClient, logger, correlationId) {
    performanceClient.addQueueMeasurement(PerformanceEvents.GenerateCodeChallengeFromVerifier, correlationId);
    try {
      const pkceHashedCodeVerifier = await invokeAsync(sha256Digest, PerformanceEvents.Sha256Digest, logger, performanceClient, correlationId)(pkceCodeVerifier, performanceClient, correlationId);
      return urlEncodeArr(new Uint8Array(pkceHashedCodeVerifier));
    } catch (e) {
      throw createBrowserAuthError(pkceNotCreated);
    }
  }

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/PopupClient.mjs
  var PopupClient = class extends StandardInteractionClient {
    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
      super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);
      this.unloadWindow = this.unloadWindow.bind(this);
      this.nativeStorage = nativeStorageImpl;
      this.eventHandler = eventHandler;
    }
    /**
     * Acquires tokens by opening a popup window to the /authorize endpoint of the authority
     * @param request
     * @param pkceCodes
     */
    acquireToken(request, pkceCodes) {
      try {
        const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);
        const popupParams = {
          popupName,
          popupWindowAttributes: request.popupWindowAttributes || {},
          popupWindowParent: request.popupWindowParent ?? window
        };
        this.performanceClient.addFields({ isAsyncPopup: this.config.system.asyncPopups }, this.correlationId);
        if (this.config.system.asyncPopups) {
          this.logger.verbose("asyncPopups set to true, acquiring token");
          return this.acquireTokenPopupAsync(request, popupParams, pkceCodes);
        } else {
          this.logger.verbose("asyncPopup set to false, opening popup before acquiring token");
          popupParams.popup = this.openSizedPopup("about:blank", popupParams);
          return this.acquireTokenPopupAsync(request, popupParams, pkceCodes);
        }
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
     * @param logoutRequest
     */
    logout(logoutRequest) {
      try {
        this.logger.verbose("logoutPopup called");
        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
        const popupParams = {
          popupName: this.generateLogoutPopupName(validLogoutRequest),
          popupWindowAttributes: logoutRequest?.popupWindowAttributes || {},
          popupWindowParent: logoutRequest?.popupWindowParent ?? window
        };
        const authority = logoutRequest && logoutRequest.authority;
        const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;
        if (this.config.system.asyncPopups) {
          this.logger.verbose("asyncPopups set to true");
          return this.logoutPopupAsync(validLogoutRequest, popupParams, authority, mainWindowRedirectUri);
        } else {
          this.logger.verbose("asyncPopup set to false, opening popup");
          popupParams.popup = this.openSizedPopup("about:blank", popupParams);
          return this.logoutPopupAsync(validLogoutRequest, popupParams, authority, mainWindowRedirectUri);
        }
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Helper which obtains an access_token for your API via opening a popup window in the user's browser
     * @param request
     * @param popupParams
     * @param pkceCodes
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    async acquireTokenPopupAsync(request, popupParams, pkceCodes) {
      this.logger.verbose("acquireTokenPopupAsync called");
      const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Popup);
      if (popupParams.popup) {
        preconnect(validRequest.authority);
      }
      const isPlatformBroker = NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);
      validRequest.platformBroker = isPlatformBroker;
      if (this.config.auth.protocolMode === ProtocolMode.EAR) {
        return this.executeEarFlow(validRequest, popupParams);
      } else {
        return this.executeCodeFlow(validRequest, popupParams, pkceCodes);
      }
    }
    /**
     * Executes auth code + PKCE flow
     * @param request
     * @param popupParams
     * @param pkceCodes
     * @returns
     */
    async executeCodeFlow(request, popupParams, pkceCodes) {
      const correlationId = request.correlationId;
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);
      const pkce = pkceCodes || await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
      const popupRequest = {
        ...request,
        codeChallenge: pkce.challenge
      };
      try {
        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, correlationId)({
          serverTelemetryManager,
          requestAuthority: popupRequest.authority,
          requestAzureCloudOptions: popupRequest.azureCloudOptions,
          requestExtraQueryParameters: popupRequest.extraQueryParameters,
          account: popupRequest.account
        });
        const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, correlationId)(this.config, authClient.authority, popupRequest, this.logger, this.performanceClient);
        const popupWindow = this.initiateAuthRequest(navigateUrl, popupParams);
        this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);
        const responseString = await this.monitorPopupForHash(popupWindow, popupParams.popupWindowParent);
        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, this.correlationId)(responseString, this.config.auth.OIDCOptions.serverResponseType, this.logger);
        return await invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, correlationId)(request, serverParams, pkce.verifier, ApiId.acquireTokenPopup, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
      } catch (e) {
        popupParams.popup?.close();
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        throw e;
      }
    }
    /**
     * Executes EAR flow
     * @param request
     */
    async executeEarFlow(request, popupParams) {
      const correlationId = request.correlationId;
      const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
        requestAuthority: request.authority,
        requestAzureCloudOptions: request.azureCloudOptions,
        requestExtraQueryParameters: request.extraQueryParameters,
        account: request.account
      });
      const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
      const popupRequest = {
        ...request,
        earJwk
      };
      const popupWindow = popupParams.popup || this.openPopup("about:blank", popupParams);
      const form = await getEARForm(popupWindow.document, this.config, discoveredAuthority, popupRequest, this.logger, this.performanceClient);
      form.submit();
      const responseString = await invokeAsync(this.monitorPopupForHash.bind(this), PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(popupWindow, popupParams.popupWindowParent);
      const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, this.correlationId)(responseString, this.config.auth.OIDCOptions.serverResponseType, this.logger);
      return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, correlationId)(popupRequest, serverParams, ApiId.acquireTokenPopup, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
    }
    /**
     *
     * @param validRequest
     * @param popupName
     * @param requestAuthority
     * @param popup
     * @param mainWindowRedirectUri
     * @param popupWindowAttributes
     */
    async logoutPopupAsync(validRequest, popupParams, requestAuthority, mainWindowRedirectUri) {
      this.logger.verbose("logoutPopupAsync called");
      this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);
      try {
        await this.clearCacheOnLogout(validRequest.account);
        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
          serverTelemetryManager,
          requestAuthority,
          account: validRequest.account || void 0
        });
        try {
          authClient.authority.endSessionEndpoint;
        } catch {
          if (validRequest.account?.homeAccountId && validRequest.postLogoutRedirectUri && authClient.authority.protocolMode === ProtocolMode.OIDC) {
            void this.browserStorage.removeAccount(validRequest.account?.homeAccountId);
            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);
            if (mainWindowRedirectUri) {
              const navigationOptions = {
                apiId: ApiId.logoutPopup,
                timeout: this.config.system.redirectNavigationTimeout,
                noHistory: false
              };
              const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());
              await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);
            }
            popupParams.popup?.close();
            return;
          }
        }
        const logoutUri = authClient.getLogoutUri(validRequest);
        this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);
        const popupWindow = this.openPopup(logoutUri, popupParams);
        this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);
        await this.monitorPopupForHash(popupWindow, popupParams.popupWindowParent).catch(() => {
        });
        if (mainWindowRedirectUri) {
          const navigationOptions = {
            apiId: ApiId.logoutPopup,
            timeout: this.config.system.redirectNavigationTimeout,
            noHistory: false
          };
          const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());
          this.logger.verbose("Redirecting main window to url specified in the request");
          this.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);
          await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);
        } else {
          this.logger.verbose("No main window navigation requested");
        }
      } catch (e) {
        popupParams.popup?.close();
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);
        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
        throw e;
      }
      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
    }
    /**
     * Opens a popup window with given request Url.
     * @param requestUrl
     */
    initiateAuthRequest(requestUrl, params) {
      if (requestUrl) {
        this.logger.infoPii(`Navigate to: ${requestUrl}`);
        return this.openPopup(requestUrl, params);
      } else {
        this.logger.error("Navigate url is empty");
        throw createBrowserAuthError(emptyNavigateUri);
      }
    }
    /**
     * Monitors a window until it loads a url with the same origin.
     * @param popupWindow - window that is being monitored
     * @param timeout - timeout for processing hash once popup is redirected back to application
     */
    monitorPopupForHash(popupWindow, popupWindowParent) {
      return new Promise((resolve, reject) => {
        this.logger.verbose("PopupHandler.monitorPopupForHash - polling started");
        const intervalId = setInterval(() => {
          if (popupWindow.closed) {
            this.logger.error("PopupHandler.monitorPopupForHash - window closed");
            clearInterval(intervalId);
            reject(createBrowserAuthError(userCancelled));
            return;
          }
          let href2 = "";
          try {
            href2 = popupWindow.location.href;
          } catch (e) {
          }
          if (!href2 || href2 === "about:blank") {
            return;
          }
          clearInterval(intervalId);
          let responseString = "";
          const responseType = this.config.auth.OIDCOptions.serverResponseType;
          if (popupWindow) {
            if (responseType === ServerResponseType.QUERY) {
              responseString = popupWindow.location.search;
            } else {
              responseString = popupWindow.location.hash;
            }
          }
          this.logger.verbose("PopupHandler.monitorPopupForHash - popup window is on same origin as caller");
          resolve(responseString);
        }, this.config.system.pollIntervalMilliseconds);
      }).finally(() => {
        this.cleanPopup(popupWindow, popupWindowParent);
      });
    }
    /**
     * @hidden
     *
     * Configures popup window for login.
     *
     * @param urlNavigate
     * @param title
     * @param popUpWidth
     * @param popUpHeight
     * @param popupWindowAttributes
     * @ignore
     * @hidden
     */
    openPopup(urlNavigate, popupParams) {
      try {
        let popupWindow;
        if (popupParams.popup) {
          popupWindow = popupParams.popup;
          this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);
          popupWindow.location.assign(urlNavigate);
        } else if (typeof popupParams.popup === "undefined") {
          this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);
          popupWindow = this.openSizedPopup(urlNavigate, popupParams);
        }
        if (!popupWindow) {
          throw createBrowserAuthError(emptyWindowError);
        }
        if (popupWindow.focus) {
          popupWindow.focus();
        }
        this.currentWindow = popupWindow;
        popupParams.popupWindowParent.addEventListener("beforeunload", this.unloadWindow);
        return popupWindow;
      } catch (e) {
        this.logger.error("error opening popup " + e.message);
        throw createBrowserAuthError(popupWindowError);
      }
    }
    /**
     * Helper function to set popup window dimensions and position
     * @param urlNavigate
     * @param popupName
     * @param popupWindowAttributes
     * @returns
     */
    openSizedPopup(urlNavigate, { popupName, popupWindowAttributes, popupWindowParent }) {
      const winLeft = popupWindowParent.screenLeft ? popupWindowParent.screenLeft : popupWindowParent.screenX;
      const winTop = popupWindowParent.screenTop ? popupWindowParent.screenTop : popupWindowParent.screenY;
      const winWidth = popupWindowParent.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      const winHeight = popupWindowParent.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      let width = popupWindowAttributes.popupSize?.width;
      let height = popupWindowAttributes.popupSize?.height;
      let top = popupWindowAttributes.popupPosition?.top;
      let left = popupWindowAttributes.popupPosition?.left;
      if (!width || width < 0 || width > winWidth) {
        this.logger.verbose("Default popup window width used. Window width not configured or invalid.");
        width = BrowserConstants.POPUP_WIDTH;
      }
      if (!height || height < 0 || height > winHeight) {
        this.logger.verbose("Default popup window height used. Window height not configured or invalid.");
        height = BrowserConstants.POPUP_HEIGHT;
      }
      if (!top || top < 0 || top > winHeight) {
        this.logger.verbose("Default popup window top position used. Window top not configured or invalid.");
        top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);
      }
      if (!left || left < 0 || left > winWidth) {
        this.logger.verbose("Default popup window left position used. Window left not configured or invalid.");
        left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);
      }
      return popupWindowParent.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);
    }
    /**
     * Event callback to unload main window.
     */
    unloadWindow(e) {
      if (this.currentWindow) {
        this.currentWindow.close();
      }
      e.preventDefault();
    }
    /**
     * Closes popup, removes any state vars created during popup calls.
     * @param popupWindow
     */
    cleanPopup(popupWindow, popupWindowParent) {
      popupWindow.close();
      popupWindowParent.removeEventListener("beforeunload", this.unloadWindow);
    }
    /**
     * Generates the name for the popup based on the client id and request
     * @param clientId
     * @param request
     */
    generatePopupName(scopes, authority) {
      return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join("-")}.${authority}.${this.correlationId}`;
    }
    /**
     * Generates the name for the popup based on the client id and request for logouts
     * @param clientId
     * @param request
     */
    generateLogoutPopupName(request) {
      const homeAccountId = request.account && request.account.homeAccountId;
      return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/RedirectClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getNavigationType() {
    if (typeof window === "undefined" || typeof window.performance === "undefined" || typeof window.performance.getEntriesByType !== "function") {
      return void 0;
    }
    const navigationEntries = window.performance.getEntriesByType("navigation");
    const navigation = navigationEntries.length ? navigationEntries[0] : void 0;
    return navigation?.type;
  }
  var RedirectClient = class extends StandardInteractionClient {
    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
      super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);
      this.nativeStorage = nativeStorageImpl;
    }
    /**
     * Redirects the page to the /authorize endpoint of the IDP
     * @param request
     */
    async acquireToken(request) {
      const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Redirect);
      validRequest.platformBroker = NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);
      const handleBackButton = (event) => {
        if (event.persisted) {
          this.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache.");
          this.browserStorage.resetRequestCache();
          this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);
        }
      };
      const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);
      this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);
      this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, redirectStartPage, true);
      window.addEventListener("pageshow", handleBackButton);
      try {
        if (this.config.auth.protocolMode === ProtocolMode.EAR) {
          await this.executeEarFlow(validRequest);
        } else {
          await this.executeCodeFlow(validRequest, request.onRedirectNavigate);
        }
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
        }
        window.removeEventListener("pageshow", handleBackButton);
        throw e;
      }
    }
    /**
     * Executes auth code + PKCE flow
     * @param request
     * @returns
     */
    async executeCodeFlow(request, onRedirectNavigate) {
      const correlationId = request.correlationId;
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);
      const pkceCodes = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
      const redirectRequest = {
        ...request,
        codeChallenge: pkceCodes.challenge
      };
      this.browserStorage.cacheAuthorizeRequest(redirectRequest, pkceCodes.verifier);
      try {
        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
          serverTelemetryManager,
          requestAuthority: redirectRequest.authority,
          requestAzureCloudOptions: redirectRequest.azureCloudOptions,
          requestExtraQueryParameters: redirectRequest.extraQueryParameters,
          account: redirectRequest.account
        });
        const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, request.correlationId)(this.config, authClient.authority, redirectRequest, this.logger, this.performanceClient);
        return await this.initiateAuthRequest(navigateUrl, onRedirectNavigate);
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        throw e;
      }
    }
    /**
     * Executes EAR flow
     * @param request
     */
    async executeEarFlow(request) {
      const correlationId = request.correlationId;
      const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
        requestAuthority: request.authority,
        requestAzureCloudOptions: request.azureCloudOptions,
        requestExtraQueryParameters: request.extraQueryParameters,
        account: request.account
      });
      const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
      const redirectRequest = {
        ...request,
        earJwk
      };
      this.browserStorage.cacheAuthorizeRequest(redirectRequest);
      const form = await getEARForm(document, this.config, discoveredAuthority, redirectRequest, this.logger, this.performanceClient);
      form.submit();
    }
    /**
     * Checks if navigateToLoginRequestUrl is set, and:
     * - if true, performs logic to cache and navigate
     * - if false, handles hash string and parses response
     * @param hash {string} url hash
     * @param parentMeasurement {InProgressPerformanceEvent} parent measurement
     */
    async handleRedirectPromise(hash2 = "", request, pkceVerifier, parentMeasurement) {
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);
      try {
        const [serverParams, responseString] = this.getRedirectResponse(hash2 || "");
        if (!serverParams) {
          this.logger.info("handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.");
          this.browserStorage.resetRequestCache();
          if (getNavigationType() !== "back_forward") {
            parentMeasurement.event.errorCode = "no_server_response";
          } else {
            this.logger.verbose("Back navigation event detected. Muting no_server_response error");
          }
          return null;
        }
        const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;
        const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);
        const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);
        if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {
          this.logger.verbose("Current page is loginRequestUrl, handling response");
          if (loginRequestUrl.indexOf("#") > -1) {
            replaceHash(loginRequestUrl);
          }
          const handleHashResult = await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
          return handleHashResult;
        } else if (!this.config.auth.navigateToLoginRequestUrl) {
          this.logger.verbose("NavigateToLoginRequestUrl set to false, handling response");
          return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
        } else if (!isInIframe() || this.config.system.allowRedirectInIframe) {
          this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);
          const navigationOptions = {
            apiId: ApiId.handleRedirectPromise,
            timeout: this.config.system.redirectNavigationTimeout,
            noHistory: true
          };
          let processHashOnRedirect = true;
          if (!loginRequestUrl || loginRequestUrl === "null") {
            const homepage = getHomepage();
            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);
            this.logger.warning("Unable to get valid login request url from cache, redirecting to home page");
            processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);
          } else {
            this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);
            processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);
          }
          if (!processHashOnRedirect) {
            return await this.handleResponse(serverParams, request, pkceVerifier, serverTelemetryManager);
          }
        }
        return null;
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        throw e;
      }
    }
    /**
     * Gets the response hash for a redirect request
     * Returns null if interactionType in the state value is not "redirect" or the hash does not contain known properties
     * @param hash
     */
    getRedirectResponse(userProvidedResponse) {
      this.logger.verbose("getRedirectResponseHash called");
      let responseString = userProvidedResponse;
      if (!responseString) {
        if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {
          responseString = window.location.search;
        } else {
          responseString = window.location.hash;
        }
      }
      let response = UrlUtils_exports.getDeserializedResponse(responseString);
      if (response) {
        try {
          validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);
        } catch (e) {
          if (e instanceof AuthError) {
            this.logger.error(`Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`);
          }
          return [null, ""];
        }
        clearHash(window);
        this.logger.verbose("Hash contains known properties, returning response hash");
        return [response, responseString];
      }
      const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);
      this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));
      if (cachedHash) {
        response = UrlUtils_exports.getDeserializedResponse(cachedHash);
        if (response) {
          this.logger.verbose("Hash does not contain known properties, returning cached hash");
          return [response, cachedHash];
        }
      }
      return [null, ""];
    }
    /**
     * Checks if hash exists and handles in window.
     * @param hash
     * @param state
     */
    async handleResponse(serverParams, request, codeVerifier, serverTelemetryManager) {
      const state = serverParams.state;
      if (!state) {
        throw createBrowserAuthError(noStateInHash);
      }
      if (serverParams.ear_jwe) {
        const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, request.correlationId)({
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, request.correlationId)(request, serverParams, ApiId.acquireTokenRedirect, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
      }
      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({ serverTelemetryManager, requestAuthority: request.authority });
      return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, request.correlationId)(request, serverParams, codeVerifier, ApiId.acquireTokenRedirect, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
    }
    /**
     * Redirects window to given URL.
     * @param urlNavigate
     * @param onRedirectNavigateRequest - onRedirectNavigate callback provided on the request
     */
    async initiateAuthRequest(requestUrl, onRedirectNavigateRequest) {
      this.logger.verbose("RedirectHandler.initiateAuthRequest called");
      if (requestUrl) {
        this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);
        const navigationOptions = {
          apiId: ApiId.acquireTokenRedirect,
          timeout: this.config.system.redirectNavigationTimeout,
          noHistory: false
        };
        const onRedirectNavigate = onRedirectNavigateRequest || this.config.auth.onRedirectNavigate;
        if (typeof onRedirectNavigate === "function") {
          this.logger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback");
          const navigate = onRedirectNavigate(requestUrl);
          if (navigate !== false) {
            this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating");
            await this.navigationClient.navigateExternal(requestUrl, navigationOptions);
            return;
          } else {
            this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation");
            return;
          }
        } else {
          this.logger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url");
          await this.navigationClient.navigateExternal(requestUrl, navigationOptions);
          return;
        }
      } else {
        this.logger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty");
        throw createBrowserAuthError(emptyNavigateUri);
      }
    }
    /**
     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param logoutRequest
     */
    async logout(logoutRequest) {
      this.logger.verbose("logoutRedirect called");
      const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);
      try {
        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);
        await this.clearCacheOnLogout(validLogoutRequest.account);
        const navigationOptions = {
          apiId: ApiId.logout,
          timeout: this.config.system.redirectNavigationTimeout,
          noHistory: false
        };
        const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({
          serverTelemetryManager,
          requestAuthority: logoutRequest && logoutRequest.authority,
          requestExtraQueryParameters: logoutRequest?.extraQueryParameters,
          account: logoutRequest && logoutRequest.account || void 0
        });
        if (authClient.authority.protocolMode === ProtocolMode.OIDC) {
          try {
            authClient.authority.endSessionEndpoint;
          } catch {
            if (validLogoutRequest.account?.homeAccountId) {
              void this.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);
              this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);
              return;
            }
          }
        }
        const logoutUri = authClient.getLogoutUri(validLogoutRequest);
        this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);
        if (logoutRequest && typeof logoutRequest.onRedirectNavigate === "function") {
          const navigate = logoutRequest.onRedirectNavigate(logoutUri);
          if (navigate !== false) {
            this.logger.verbose("Logout onRedirectNavigate did not return false, navigating");
            if (!this.browserStorage.getInteractionInProgress()) {
              this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
            }
            await this.navigationClient.navigateExternal(logoutUri, navigationOptions);
            return;
          } else {
            this.browserStorage.setInteractionInProgress(false);
            this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation");
          }
        } else {
          if (!this.browserStorage.getInteractionInProgress()) {
            this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
          }
          await this.navigationClient.navigateExternal(logoutUri, navigationOptions);
          return;
        }
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);
        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
        throw e;
      }
      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
    }
    /**
     * Use to get the redirectStartPage either from request or use current window
     * @param requestStartPage
     */
    getRedirectStartPage(requestStartPage) {
      const redirectStartPage = requestStartPage || window.location.href;
      return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_handler/SilentHandler.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  async function initiateCodeRequest(requestUrl, performanceClient, logger, correlationId, navigateFrameWait) {
    performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, correlationId);
    if (!requestUrl) {
      logger.info("Navigate url is empty");
      throw createBrowserAuthError(emptyNavigateUri);
    }
    if (navigateFrameWait) {
      return invokeAsync(loadFrame, PerformanceEvents.SilentHandlerLoadFrame, logger, performanceClient, correlationId)(requestUrl, navigateFrameWait, performanceClient, correlationId);
    }
    return invoke(loadFrameSync, PerformanceEvents.SilentHandlerLoadFrameSync, logger, performanceClient, correlationId)(requestUrl);
  }
  async function initiateEarRequest(config, authority, request, logger, performanceClient) {
    const frame = createHiddenIframe();
    if (!frame.contentDocument) {
      throw "No document associated with iframe!";
    }
    const form = await getEARForm(frame.contentDocument, config, authority, request, logger, performanceClient);
    form.submit();
    return frame;
  }
  async function monitorIframeForHash(iframe, timeout, pollIntervalMilliseconds, performanceClient, logger, correlationId, responseType) {
    performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, correlationId);
    return new Promise((resolve, reject) => {
      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {
        logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);
      }
      const timeoutId = window.setTimeout(() => {
        window.clearInterval(intervalId);
        reject(createBrowserAuthError(monitorWindowTimeout));
      }, timeout);
      const intervalId = window.setInterval(() => {
        let href2 = "";
        const contentWindow = iframe.contentWindow;
        try {
          href2 = contentWindow ? contentWindow.location.href : "";
        } catch (e) {
        }
        if (!href2 || href2 === "about:blank") {
          return;
        }
        let responseString = "";
        if (contentWindow) {
          if (responseType === ServerResponseType.QUERY) {
            responseString = contentWindow.location.search;
          } else {
            responseString = contentWindow.location.hash;
          }
        }
        window.clearTimeout(timeoutId);
        window.clearInterval(intervalId);
        resolve(responseString);
      }, pollIntervalMilliseconds);
    }).finally(() => {
      invoke(removeHiddenIframe, PerformanceEvents.RemoveHiddenIframe, logger, performanceClient, correlationId)(iframe);
    });
  }
  function loadFrame(urlNavigate, navigateFrameWait, performanceClient, correlationId) {
    performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, correlationId);
    return new Promise((resolve, reject) => {
      const frameHandle = createHiddenIframe();
      window.setTimeout(() => {
        if (!frameHandle) {
          reject("Unable to load iframe");
          return;
        }
        frameHandle.src = urlNavigate;
        resolve(frameHandle);
      }, navigateFrameWait);
    });
  }
  function loadFrameSync(urlNavigate) {
    const frameHandle = createHiddenIframe();
    frameHandle.src = urlNavigate;
    return frameHandle;
  }
  function createHiddenIframe() {
    const authFrame = document.createElement("iframe");
    authFrame.className = "msalSilentIframe";
    authFrame.style.visibility = "hidden";
    authFrame.style.position = "absolute";
    authFrame.style.width = authFrame.style.height = "0";
    authFrame.style.border = "0";
    authFrame.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
    document.body.appendChild(authFrame);
    return authFrame;
  }
  function removeHiddenIframe(iframe) {
    if (document.body === iframe.parentNode) {
      document.body.removeChild(iframe);
    }
  }

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs
  var SilentIframeClient = class extends StandardInteractionClient {
    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
      super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);
      this.apiId = apiId;
      this.nativeStorage = nativeStorageImpl;
    }
    /**
     * Acquires a token silently by opening a hidden iframe to the /authorize endpoint with prompt=none or prompt=no_session
     * @param request
     */
    async acquireToken(request) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);
      if (!request.loginHint && !request.sid && (!request.account || !request.account.username)) {
        this.logger.warning("No user hint provided. The authorization server may need more information to complete this request.");
      }
      const inputRequest = { ...request };
      if (inputRequest.prompt) {
        if (inputRequest.prompt !== PromptValue.NONE && inputRequest.prompt !== PromptValue.NO_SESSION) {
          this.logger.warning(`SilentIframeClient. Replacing invalid prompt ${inputRequest.prompt} with ${PromptValue.NONE}`);
          inputRequest.prompt = PromptValue.NONE;
        }
      } else {
        inputRequest.prompt = PromptValue.NONE;
      }
      const silentRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, request.correlationId)(inputRequest, InteractionType.Silent);
      silentRequest.platformBroker = NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeMessageHandler, silentRequest.authenticationScheme);
      preconnect(silentRequest.authority);
      if (this.config.auth.protocolMode === ProtocolMode.EAR) {
        return this.executeEarFlow(silentRequest);
      } else {
        return this.executeCodeFlow(silentRequest);
      }
    }
    /**
     * Executes auth code + PKCE flow
     * @param request
     * @returns
     */
    async executeCodeFlow(request) {
      let authClient;
      const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
      try {
        authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, request.correlationId)({
          serverTelemetryManager,
          requestAuthority: request.authority,
          requestAzureCloudOptions: request.azureCloudOptions,
          requestExtraQueryParameters: request.extraQueryParameters,
          account: request.account
        });
        return await invokeAsync(this.silentTokenHelper.bind(this), PerformanceEvents.SilentIframeClientTokenHelper, this.logger, this.performanceClient, request.correlationId)(authClient, request);
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        if (!authClient || !(e instanceof AuthError) || e.errorCode !== BrowserConstants.INVALID_GRANT_ERROR) {
          throw e;
        }
        this.performanceClient.addFields({
          retryError: e.errorCode
        }, this.correlationId);
        return await invokeAsync(this.silentTokenHelper.bind(this), PerformanceEvents.SilentIframeClientTokenHelper, this.logger, this.performanceClient, this.correlationId)(authClient, request);
      }
    }
    /**
     * Executes EAR flow
     * @param request
     */
    async executeEarFlow(request) {
      const correlationId = request.correlationId;
      const discoveredAuthority = await invokeAsync(this.getDiscoveredAuthority.bind(this), PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.logger, this.performanceClient, correlationId)({
        requestAuthority: request.authority,
        requestAzureCloudOptions: request.azureCloudOptions,
        requestExtraQueryParameters: request.extraQueryParameters,
        account: request.account
      });
      const earJwk = await invokeAsync(generateEarKey, PerformanceEvents.GenerateEarKey, this.logger, this.performanceClient, correlationId)();
      const silentRequest = {
        ...request,
        earJwk
      };
      const msalFrame = await invokeAsync(initiateEarRequest, PerformanceEvents.SilentHandlerInitiateAuthRequest, this.logger, this.performanceClient, correlationId)(this.config, discoveredAuthority, silentRequest, this.logger, this.performanceClient);
      const responseType = this.config.auth.OIDCOptions.serverResponseType;
      const responseString = await invokeAsync(monitorIframeForHash, PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(msalFrame, this.config.system.iframeHashTimeout, this.config.system.pollIntervalMilliseconds, this.performanceClient, this.logger, correlationId, responseType);
      const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, correlationId)(responseString, responseType, this.logger);
      return invokeAsync(handleResponseEAR, PerformanceEvents.HandleResponseEar, this.logger, this.performanceClient, correlationId)(silentRequest, serverParams, this.apiId, this.config, discoveredAuthority, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
    }
    /**
     * Currently Unsupported
     */
    logout() {
      return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
    }
    /**
     * Helper which acquires an authorization code silently using a hidden iframe from given url
     * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.
     * @param navigateUrl
     * @param userRequestScopes
     */
    async silentTokenHelper(authClient, request) {
      const correlationId = request.correlationId;
      this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientTokenHelper, correlationId);
      const pkceCodes = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
      const silentRequest = {
        ...request,
        codeChallenge: pkceCodes.challenge
      };
      const navigateUrl = await invokeAsync(getAuthCodeRequestUrl, PerformanceEvents.GetAuthCodeUrl, this.logger, this.performanceClient, correlationId)(this.config, authClient.authority, silentRequest, this.logger, this.performanceClient);
      const msalFrame = await invokeAsync(initiateCodeRequest, PerformanceEvents.SilentHandlerInitiateAuthRequest, this.logger, this.performanceClient, correlationId)(navigateUrl, this.performanceClient, this.logger, correlationId, this.config.system.navigateFrameWait);
      const responseType = this.config.auth.OIDCOptions.serverResponseType;
      const responseString = await invokeAsync(monitorIframeForHash, PerformanceEvents.SilentHandlerMonitorIframeForHash, this.logger, this.performanceClient, correlationId)(msalFrame, this.config.system.iframeHashTimeout, this.config.system.pollIntervalMilliseconds, this.performanceClient, this.logger, correlationId, responseType);
      const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, this.logger, this.performanceClient, correlationId)(responseString, responseType, this.logger);
      return invokeAsync(handleResponseCode, PerformanceEvents.HandleResponseCode, this.logger, this.performanceClient, correlationId)(request, serverParams, pkceCodes.verifier, this.apiId, this.config, authClient, this.browserStorage, this.nativeStorage, this.eventHandler, this.logger, this.performanceClient, this.nativeMessageHandler);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentRefreshClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SilentRefreshClient = class extends StandardInteractionClient {
    /**
     * Exchanges the refresh token for new tokens
     * @param request
     */
    async acquireToken(request) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, request.correlationId);
      const baseRequest = await invokeAsync(initializeBaseRequest, PerformanceEvents.InitializeBaseRequest, this.logger, this.performanceClient, request.correlationId)(request, this.config, this.performanceClient, this.logger);
      const silentRequest = {
        ...request,
        ...baseRequest
      };
      if (request.redirectUri) {
        silentRequest.redirectUri = this.getRedirectUri(request.redirectUri);
      }
      const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
      const refreshTokenClient = await this.createRefreshTokenClient({
        serverTelemetryManager,
        authorityUrl: silentRequest.authority,
        azureCloudOptions: silentRequest.azureCloudOptions,
        account: silentRequest.account
      });
      return invokeAsync(refreshTokenClient.acquireTokenByRefreshToken.bind(refreshTokenClient), PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, this.logger, this.performanceClient, request.correlationId)(silentRequest).catch((e) => {
        e.setCorrelationId(this.correlationId);
        serverTelemetryManager.cacheFailedRequest(e);
        throw e;
      });
    }
    /**
     * Currently Unsupported
     */
    logout() {
      return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
    }
    /**
     * Creates a Refresh Client with the given authority, or the default authority.
     * @param params {
     *         serverTelemetryManager: ServerTelemetryManager;
     *         authorityUrl?: string;
     *         azureCloudOptions?: AzureCloudOptions;
     *         extraQueryParams?: StringDict;
     *         account?: AccountInfo;
     *        }
     */
    async createRefreshTokenClient(params) {
      const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, this.correlationId)({
        serverTelemetryManager: params.serverTelemetryManager,
        requestAuthority: params.authorityUrl,
        requestAzureCloudOptions: params.azureCloudOptions,
        requestExtraQueryParameters: params.extraQueryParameters,
        account: params.account
      });
      return new RefreshTokenClient(clientConfig, this.performanceClient);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/cache/TokenCache.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var TokenCache = class {
    constructor(configuration, storage, logger, cryptoObj) {
      this.isBrowserEnvironment = typeof window !== "undefined";
      this.config = configuration;
      this.storage = storage;
      this.logger = logger;
      this.cryptoObj = cryptoObj;
    }
    // Move getAllAccounts here and cache utility APIs
    /**
     * API to load tokens to msal-browser cache.
     * @param request
     * @param response
     * @param options
     * @returns `AuthenticationResult` for the response that was loaded.
     */
    async loadExternalTokens(request, response, options) {
      if (!this.isBrowserEnvironment) {
        throw createBrowserAuthError(nonBrowserEnvironment);
      }
      const correlationId = request.correlationId || createNewGuid();
      const idTokenClaims = response.id_token ? AuthToken_exports.extractTokenClaims(response.id_token, base64Decode) : void 0;
      const authorityOptions = {
        protocolMode: this.config.auth.protocolMode,
        knownAuthorities: this.config.auth.knownAuthorities,
        cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
        authorityMetadata: this.config.auth.authorityMetadata,
        skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
      };
      const authority = request.authority ? new Authority(Authority.generateAuthority(request.authority, request.azureCloudOptions), this.config.system.networkClient, this.storage, authorityOptions, this.logger, request.correlationId || createNewGuid()) : void 0;
      const cacheRecordAccount = await this.loadAccount(request, options.clientInfo || response.client_info || "", correlationId, idTokenClaims, authority);
      const idToken = await this.loadIdToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, correlationId);
      const accessToken = await this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, cacheRecordAccount.realm, options, correlationId);
      const refreshToken = await this.loadRefreshToken(response, cacheRecordAccount.homeAccountId, cacheRecordAccount.environment, correlationId);
      return this.generateAuthenticationResult(request, {
        account: cacheRecordAccount,
        idToken,
        accessToken,
        refreshToken
      }, idTokenClaims, authority);
    }
    /**
     * Helper function to load account to msal-browser cache
     * @param idToken
     * @param environment
     * @param clientInfo
     * @param authorityType
     * @param requestHomeAccountId
     * @returns `AccountEntity`
     */
    async loadAccount(request, clientInfo, correlationId, idTokenClaims, authority) {
      this.logger.verbose("TokenCache - loading account");
      if (request.account) {
        const accountEntity = AccountEntity.createFromAccountInfo(request.account);
        await this.storage.setAccount(accountEntity, correlationId);
        return accountEntity;
      } else if (!authority || !clientInfo && !idTokenClaims) {
        this.logger.error("TokenCache - if an account is not provided on the request, authority and either clientInfo or idToken must be provided instead.");
        throw createBrowserAuthError(unableToLoadToken);
      }
      const homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
      const claimsTenantId = idTokenClaims?.tid;
      const cachedAccount = buildAccountToCache(
        this.storage,
        authority,
        homeAccountId,
        base64Decode,
        idTokenClaims,
        clientInfo,
        authority.hostnameAndPort,
        claimsTenantId,
        void 0,
        // authCodePayload
        void 0,
        // nativeAccountId
        this.logger
      );
      await this.storage.setAccount(cachedAccount, correlationId);
      return cachedAccount;
    }
    /**
     * Helper function to load id tokens to msal-browser cache
     * @param idToken
     * @param homeAccountId
     * @param environment
     * @param tenantId
     * @returns `IdTokenEntity`
     */
    async loadIdToken(response, homeAccountId, environment, tenantId, correlationId) {
      if (!response.id_token) {
        this.logger.verbose("TokenCache - no id token found in response");
        return null;
      }
      this.logger.verbose("TokenCache - loading id token");
      const idTokenEntity = CacheHelpers_exports.createIdTokenEntity(homeAccountId, environment, response.id_token, this.config.auth.clientId, tenantId);
      await this.storage.setIdTokenCredential(idTokenEntity, correlationId);
      return idTokenEntity;
    }
    /**
     * Helper function to load access tokens to msal-browser cache
     * @param request
     * @param response
     * @param homeAccountId
     * @param environment
     * @param tenantId
     * @returns `AccessTokenEntity`
     */
    async loadAccessToken(request, response, homeAccountId, environment, tenantId, options, correlationId) {
      if (!response.access_token) {
        this.logger.verbose("TokenCache - no access token found in response");
        return null;
      } else if (!response.expires_in) {
        this.logger.error("TokenCache - no expiration set on the access token. Cannot add it to the cache.");
        return null;
      } else if (!response.scope && (!request.scopes || !request.scopes.length)) {
        this.logger.error("TokenCache - scopes not specified in the request or response. Cannot add token to the cache.");
        return null;
      }
      this.logger.verbose("TokenCache - loading access token");
      const scopes = response.scope ? ScopeSet.fromString(response.scope) : new ScopeSet(request.scopes);
      const expiresOn = options.expiresOn || response.expires_in + TimeUtils_exports.nowSeconds();
      const extendedExpiresOn = options.extendedExpiresOn || (response.ext_expires_in || response.expires_in) + TimeUtils_exports.nowSeconds();
      const accessTokenEntity = CacheHelpers_exports.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes.printScopes(), expiresOn, extendedExpiresOn, base64Decode);
      await this.storage.setAccessTokenCredential(accessTokenEntity, correlationId);
      return accessTokenEntity;
    }
    /**
     * Helper function to load refresh tokens to msal-browser cache
     * @param request
     * @param response
     * @param homeAccountId
     * @param environment
     * @returns `RefreshTokenEntity`
     */
    async loadRefreshToken(response, homeAccountId, environment, correlationId) {
      if (!response.refresh_token) {
        this.logger.verbose("TokenCache - no refresh token found in response");
        return null;
      }
      this.logger.verbose("TokenCache - loading refresh token");
      const refreshTokenEntity = CacheHelpers_exports.createRefreshTokenEntity(
        homeAccountId,
        environment,
        response.refresh_token,
        this.config.auth.clientId,
        response.foci,
        void 0,
        // userAssertionHash
        response.refresh_token_expires_in
      );
      await this.storage.setRefreshTokenCredential(refreshTokenEntity, correlationId);
      return refreshTokenEntity;
    }
    /**
     * Helper function to generate an `AuthenticationResult` for the result.
     * @param request
     * @param idTokenObj
     * @param cacheRecord
     * @param authority
     * @returns `AuthenticationResult`
     */
    generateAuthenticationResult(request, cacheRecord, idTokenClaims, authority) {
      let accessToken = "";
      let responseScopes = [];
      let expiresOn = null;
      let extExpiresOn;
      if (cacheRecord?.accessToken) {
        accessToken = cacheRecord.accessToken.secret;
        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
        expiresOn = TimeUtils_exports.toDateFromSeconds(cacheRecord.accessToken.expiresOn);
        extExpiresOn = TimeUtils_exports.toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
      }
      const accountEntity = cacheRecord.account;
      return {
        authority: authority ? authority.canonicalAuthority : "",
        uniqueId: cacheRecord.account.localAccountId,
        tenantId: cacheRecord.account.realm,
        scopes: responseScopes,
        account: accountEntity.getAccountInfo(),
        idToken: cacheRecord.idToken?.secret || "",
        idTokenClaims: idTokenClaims || {},
        accessToken,
        fromCache: true,
        expiresOn,
        correlationId: request.correlationId || "",
        requestId: "",
        extExpiresOn,
        familyId: cacheRecord.refreshToken?.familyId || "",
        tokenType: cacheRecord?.accessToken?.tokenType || "",
        state: request.state || "",
        cloudGraphHostName: accountEntity.cloudGraphHostName || "",
        msGraphHost: accountEntity.msGraphHost || "",
        fromNativeBroker: false
      };
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/HybridSpaAuthorizationCodeClient.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var HybridSpaAuthorizationCodeClient = class extends AuthorizationCodeClient {
    constructor(config) {
      super(config);
      this.includeRedirectUri = false;
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs
  var SilentAuthCodeClient = class extends StandardInteractionClient {
    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, nativeMessageHandler, correlationId) {
      super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);
      this.apiId = apiId;
    }
    /**
     * Acquires a token silently by redeeming an authorization code against the /token endpoint
     * @param request
     */
    async acquireToken(request) {
      if (!request.code) {
        throw createBrowserAuthError(authCodeRequired);
      }
      const silentRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, request.correlationId)(request, InteractionType.Silent);
      const serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
      try {
        const authCodeRequest = {
          ...silentRequest,
          code: request.code
        };
        const clientConfig = await invokeAsync(this.getClientConfiguration.bind(this), PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.logger, this.performanceClient, request.correlationId)({
          serverTelemetryManager,
          requestAuthority: silentRequest.authority,
          requestAzureCloudOptions: silentRequest.azureCloudOptions,
          requestExtraQueryParameters: silentRequest.extraQueryParameters,
          account: silentRequest.account
        });
        const authClient = new HybridSpaAuthorizationCodeClient(clientConfig);
        this.logger.verbose("Auth code client created");
        const interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);
        return await invokeAsync(interactionHandler.handleCodeResponseFromServer.bind(interactionHandler), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)({
          code: request.code,
          msgraph_host: request.msGraphHost,
          cloud_graph_host_name: request.cloudGraphHostName,
          cloud_instance_host_name: request.cloudInstanceHostName
        }, silentRequest, false);
      } catch (e) {
        if (e instanceof AuthError) {
          e.setCorrelationId(this.correlationId);
          serverTelemetryManager.cacheFailedRequest(e);
        }
        throw e;
      }
    }
    /**
     * Currently Unsupported
     */
    logout() {
      return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/utils/MsalFrameStatsUtils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function collectInstanceStats(currentClientId, performanceEvent, logger) {
    const frameInstances = (
      // @ts-ignore
      window.msal?.clientIds || []
    );
    const msalInstanceCount = frameInstances.length;
    const sameClientIdInstanceCount = frameInstances.filter((i) => i === currentClientId).length;
    if (sameClientIdInstanceCount > 1) {
      logger.warning("There is already an instance of MSAL.js in the window with the same client id.");
    }
    performanceEvent.add({
      msalInstanceCount,
      sameClientIdInstanceCount
    });
  }

  // ../../node_modules/@azure/msal-browser/dist/controllers/StandardController.mjs
  function getAccountType(account) {
    const idTokenClaims = account?.idTokenClaims;
    if (idTokenClaims?.tfp || idTokenClaims?.acr) {
      return "B2C";
    }
    if (!idTokenClaims?.tid) {
      return void 0;
    } else if (idTokenClaims?.tid === "9188040d-6c67-4c5b-b112-36a304b66dad") {
      return "MSA";
    }
    return "AAD";
  }
  function preflightCheck2(initialized, performanceEvent) {
    try {
      preflightCheck(initialized);
    } catch (e) {
      performanceEvent.end({ success: false }, e);
      throw e;
    }
  }
  var StandardController = class _StandardController {
    /**
     * @constructor
     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
     *
     * Important attributes in the Configuration object for auth are:
     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
     * - authority: the authority URL for your application.
     * - redirect_uri: the uri of your application registered in the portal.
     *
     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
     *
     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
     * Full B2C functionality will be available in this library in future versions.
     *
     * @param configuration Object for the MSAL PublicClientApplication instance
     */
    constructor(operatingContext) {
      this.operatingContext = operatingContext;
      this.isBrowserEnvironment = this.operatingContext.isBrowserEnvironment();
      this.config = operatingContext.getConfig();
      this.initialized = false;
      this.logger = this.operatingContext.getLogger();
      this.networkClient = this.config.system.networkClient;
      this.navigationClient = this.config.system.navigationClient;
      this.redirectResponse = /* @__PURE__ */ new Map();
      this.hybridAuthCodeResponses = /* @__PURE__ */ new Map();
      this.performanceClient = this.config.telemetry.client;
      this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;
      this.eventHandler = new EventHandler(this.logger);
      this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler, buildStaticAuthorityOptions(this.config.auth)) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger, this.performanceClient, this.eventHandler);
      const nativeCacheOptions = {
        cacheLocation: BrowserCacheLocation.MemoryStorage,
        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
        storeAuthStateInCookie: false,
        secureCookies: false,
        cacheMigrationEnabled: false,
        claimsBasedCachingEnabled: false
      };
      this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, nativeCacheOptions, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler);
      this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto);
      this.activeSilentTokenRequests = /* @__PURE__ */ new Map();
      this.trackPageVisibility = this.trackPageVisibility.bind(this);
      this.trackPageVisibilityWithMeasurement = this.trackPageVisibilityWithMeasurement.bind(this);
    }
    static async createController(operatingContext, request) {
      const controller = new _StandardController(operatingContext);
      await controller.initialize(request);
      return controller;
    }
    trackPageVisibility(correlationId) {
      if (!correlationId) {
        return;
      }
      this.logger.info("Perf: Visibility change detected");
      this.performanceClient.incrementFields({ visibilityChangeCount: 1 }, correlationId);
    }
    /**
     * Initializer function to perform async startup tasks such as connecting to WAM extension
     * @param request {?InitializeApplicationRequest} correlation id
     */
    async initialize(request, isBroker) {
      this.logger.trace("initialize called");
      if (this.initialized) {
        this.logger.info("initialize has already been called, exiting early.");
        return;
      }
      if (!this.isBrowserEnvironment) {
        this.logger.info("in non-browser environment, exiting early.");
        this.initialized = true;
        this.eventHandler.emitEvent(EventType.INITIALIZE_END);
        return;
      }
      const initCorrelationId = request?.correlationId || this.getRequestCorrelationId();
      const allowPlatformBroker = this.config.system.allowPlatformBroker;
      const initMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.InitializeClientApplication, initCorrelationId);
      this.eventHandler.emitEvent(EventType.INITIALIZE_START);
      if (!isBroker) {
        try {
          this.logMultipleInstances(initMeasurement);
        } catch {
        }
      }
      await invokeAsync(this.browserStorage.initialize.bind(this.browserStorage), PerformanceEvents.InitializeCache, this.logger, this.performanceClient, initCorrelationId)(initCorrelationId);
      if (allowPlatformBroker) {
        try {
          this.nativeExtensionProvider = await NativeMessageHandler.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout, this.performanceClient);
        } catch (e) {
          this.logger.verbose(e);
        }
      }
      if (!this.config.cache.claimsBasedCachingEnabled) {
        this.logger.verbose("Claims-based caching is disabled. Clearing the previous cache with claims");
        await invokeAsync(this.browserStorage.clearTokensAndKeysWithClaims.bind(this.browserStorage), PerformanceEvents.ClearTokensAndKeysWithClaims, this.logger, this.performanceClient, initCorrelationId)(this.performanceClient, initCorrelationId);
      }
      this.config.system.asyncPopups && await this.preGeneratePkceCodes(initCorrelationId);
      this.initialized = true;
      this.eventHandler.emitEvent(EventType.INITIALIZE_END);
      initMeasurement.end({
        allowPlatformBroker,
        success: true
      });
    }
    // #region Redirect Flow
    /**
     * Event handler function which allows users to fire events after the PublicClientApplication object
     * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
     * auth flows.
     * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
     * @returns Token response or null. If the return value is null, then no auth redirect was detected.
     */
    async handleRedirectPromise(hash2) {
      this.logger.verbose("handleRedirectPromise called");
      blockAPICallsBeforeInitialize(this.initialized);
      if (this.isBrowserEnvironment) {
        const redirectResponseKey = hash2 || "";
        let response = this.redirectResponse.get(redirectResponseKey);
        if (typeof response === "undefined") {
          response = this.handleRedirectPromiseInternal(hash2);
          this.redirectResponse.set(redirectResponseKey, response);
          this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise");
        } else {
          this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call");
        }
        return response;
      }
      this.logger.verbose("handleRedirectPromise returns null, not browser environment");
      return null;
    }
    /**
     * The internal details of handleRedirectPromise. This is separated out to a helper to allow handleRedirectPromise to memoize requests
     * @param hash
     * @returns
     */
    async handleRedirectPromiseInternal(hash2) {
      if (!this.browserStorage.isInteractionInProgress(true)) {
        this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
        return null;
      }
      const interactionType = this.browserStorage.getInteractionInProgress()?.type;
      if (interactionType === INTERACTION_TYPE.SIGNOUT) {
        this.logger.verbose("handleRedirectPromise removing interaction_in_progress flag and returning null after sign-out");
        this.browserStorage.setInteractionInProgress(false);
        return Promise.resolve(null);
      }
      const loggedInAccounts = this.getAllAccounts();
      const platformBrokerRequest = this.browserStorage.getCachedNativeRequest();
      const useNative = platformBrokerRequest && NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !hash2;
      let rootMeasurement;
      this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);
      let redirectResponse;
      try {
        if (useNative && this.nativeExtensionProvider) {
          rootMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenRedirect, platformBrokerRequest?.correlationId || "");
          this.logger.trace("handleRedirectPromise - acquiring token from native platform");
          const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, platformBrokerRequest.accountId, this.nativeInternalStorage, platformBrokerRequest.correlationId);
          redirectResponse = invokeAsync(nativeClient.handleRedirectPromise.bind(nativeClient), PerformanceEvents.HandleNativeRedirectPromiseMeasurement, this.logger, this.performanceClient, rootMeasurement.event.correlationId)(this.performanceClient, rootMeasurement.event.correlationId);
        } else {
          const [standardRequest, codeVerifier] = this.browserStorage.getCachedRequest();
          const correlationId = standardRequest.correlationId;
          rootMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenRedirect, correlationId);
          this.logger.trace("handleRedirectPromise - acquiring token from web flow");
          const redirectClient = this.createRedirectClient(correlationId);
          redirectResponse = invokeAsync(redirectClient.handleRedirectPromise.bind(redirectClient), PerformanceEvents.HandleRedirectPromiseMeasurement, this.logger, this.performanceClient, rootMeasurement.event.correlationId)(hash2, standardRequest, codeVerifier, rootMeasurement);
        }
      } catch (e) {
        this.browserStorage.resetRequestCache();
        throw e;
      }
      return redirectResponse.then((result) => {
        if (result) {
          this.browserStorage.resetRequestCache();
          const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;
          if (isLoggingIn) {
            this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);
            this.logger.verbose("handleRedirectResponse returned result, login success");
          } else {
            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);
            this.logger.verbose("handleRedirectResponse returned result, acquire token success");
          }
          rootMeasurement.end({
            success: true,
            accountType: getAccountType(result.account)
          });
        } else {
          if (rootMeasurement.event.errorCode) {
            rootMeasurement.end({ success: false });
          } else {
            rootMeasurement.discard();
          }
        }
        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
        return result;
      }).catch((e) => {
        this.browserStorage.resetRequestCache();
        const eventError = e;
        if (loggedInAccounts.length > 0) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, eventError);
        } else {
          this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, eventError);
        }
        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
        rootMeasurement.end({
          success: false
        }, eventError);
        throw e;
      });
    }
    /**
     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
     * the page, so any code that follows this function will not execute.
     *
     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
     *
     * @param request
     */
    async acquireTokenRedirect(request) {
      const correlationId = this.getRequestCorrelationId(request);
      this.logger.verbose("acquireTokenRedirect called", correlationId);
      const atrMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPreRedirect, correlationId);
      atrMeasurement.add({
        accountType: getAccountType(request.account),
        scenarioId: request.scenarioId
      });
      const onRedirectNavigateCb = request.onRedirectNavigate;
      if (onRedirectNavigateCb) {
        request.onRedirectNavigate = (url) => {
          const navigate = typeof onRedirectNavigateCb === "function" ? onRedirectNavigateCb(url) : void 0;
          if (navigate !== false) {
            atrMeasurement.end({ success: true });
          } else {
            atrMeasurement.discard();
          }
          return navigate;
        };
      } else {
        const configOnRedirectNavigateCb = this.config.auth.onRedirectNavigate;
        this.config.auth.onRedirectNavigate = (url) => {
          const navigate = typeof configOnRedirectNavigateCb === "function" ? configOnRedirectNavigateCb(url) : void 0;
          if (navigate !== false) {
            atrMeasurement.end({ success: true });
          } else {
            atrMeasurement.discard();
          }
          return navigate;
        };
      }
      const isLoggedIn = this.getAllAccounts().length > 0;
      try {
        redirectPreflightCheck(this.initialized, this.config);
        this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNIN);
        if (isLoggedIn) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);
        } else {
          this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);
        }
        let result;
        if (this.nativeExtensionProvider && this.canUsePlatformBroker(request)) {
          const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(request), this.nativeInternalStorage, correlationId);
          result = nativeClient.acquireTokenRedirect(request, atrMeasurement).catch((e) => {
            if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
              this.nativeExtensionProvider = void 0;
              const redirectClient = this.createRedirectClient(correlationId);
              return redirectClient.acquireToken(request);
            } else if (e instanceof InteractionRequiredAuthError) {
              this.logger.verbose("acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow");
              const redirectClient = this.createRedirectClient(correlationId);
              return redirectClient.acquireToken(request);
            }
            throw e;
          });
        } else {
          const redirectClient = this.createRedirectClient(correlationId);
          result = redirectClient.acquireToken(request);
        }
        return await result;
      } catch (e) {
        this.browserStorage.resetRequestCache();
        atrMeasurement.end({ success: false }, e);
        if (isLoggedIn) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);
        } else {
          this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);
        }
        throw e;
      }
    }
    // #endregion
    // #region Popup Flow
    /**
     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
     *
     * @param request
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    acquireTokenPopup(request) {
      const correlationId = this.getRequestCorrelationId(request);
      const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, correlationId);
      atPopupMeasurement.add({
        scenarioId: request.scenarioId,
        accountType: getAccountType(request.account)
      });
      try {
        this.logger.verbose("acquireTokenPopup called", correlationId);
        preflightCheck2(this.initialized, atPopupMeasurement);
        this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNIN);
      } catch (e) {
        return Promise.reject(e);
      }
      const loggedInAccounts = this.getAllAccounts();
      if (loggedInAccounts.length > 0) {
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);
      } else {
        this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, request);
      }
      let result;
      const pkce = this.getPreGeneratedPkceCodes(correlationId);
      if (this.canUsePlatformBroker(request)) {
        result = this.acquireTokenNative({
          ...request,
          correlationId
        }, ApiId.acquireTokenPopup).then((response) => {
          atPopupMeasurement.end({
            success: true,
            isNativeBroker: true,
            accountType: getAccountType(response.account)
          });
          return response;
        }).catch((e) => {
          if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
            this.nativeExtensionProvider = void 0;
            const popupClient = this.createPopupClient(correlationId);
            return popupClient.acquireToken(request, pkce);
          } else if (e instanceof InteractionRequiredAuthError) {
            this.logger.verbose("acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow");
            const popupClient = this.createPopupClient(correlationId);
            return popupClient.acquireToken(request, pkce);
          }
          throw e;
        });
      } else {
        const popupClient = this.createPopupClient(correlationId);
        result = popupClient.acquireToken(request, pkce);
      }
      return result.then((result2) => {
        const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;
        if (isLoggingIn) {
          this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result2);
        } else {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result2);
        }
        atPopupMeasurement.end({
          success: true,
          accessTokenSize: result2.accessToken.length,
          idTokenSize: result2.idToken.length,
          accountType: getAccountType(result2.account)
        });
        return result2;
      }).catch((e) => {
        if (loggedInAccounts.length > 0) {
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
        } else {
          this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);
        }
        atPopupMeasurement.end({
          success: false
        }, e);
        return Promise.reject(e);
      }).finally(async () => {
        this.browserStorage.setInteractionInProgress(false);
        if (this.config.system.asyncPopups) {
          await this.preGeneratePkceCodes(correlationId);
        }
      });
    }
    trackPageVisibilityWithMeasurement() {
      const measurement = this.ssoSilentMeasurement || this.acquireTokenByCodeAsyncMeasurement;
      if (!measurement) {
        return;
      }
      this.logger.info("Perf: Visibility change detected in ", measurement.event.name);
      measurement.increment({
        visibilityChangeCount: 1
      });
    }
    // #endregion
    // #region Silent Flow
    /**
     * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
     * - Any browser using a form of Intelligent Tracking Prevention
     * - If there is not an established session with the service
     *
     * In these cases, the request must be done inside a popup or full frame redirect.
     *
     * For the cases where interaction is required, you cannot send a request with prompt=none.
     *
     * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
     * you session on the server still exists.
     * @param request {@link SsoSilentRequest}
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    async ssoSilent(request) {
      const correlationId = this.getRequestCorrelationId(request);
      const validRequest = {
        ...request,
        // will be PromptValue.NONE or PromptValue.NO_SESSION
        prompt: request.prompt,
        correlationId
      };
      this.ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, correlationId);
      this.ssoSilentMeasurement?.add({
        scenarioId: request.scenarioId,
        accountType: getAccountType(request.account)
      });
      preflightCheck2(this.initialized, this.ssoSilentMeasurement);
      this.ssoSilentMeasurement?.increment({
        visibilityChangeCount: 0
      });
      document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
      this.logger.verbose("ssoSilent called", correlationId);
      this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, validRequest);
      let result;
      if (this.canUsePlatformBroker(validRequest)) {
        result = this.acquireTokenNative(validRequest, ApiId.ssoSilent).catch((e) => {
          if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
            this.nativeExtensionProvider = void 0;
            const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);
            return silentIframeClient.acquireToken(validRequest);
          }
          throw e;
        });
      } else {
        const silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);
        result = silentIframeClient.acquireToken(validRequest);
      }
      return result.then((response) => {
        this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, response);
        this.ssoSilentMeasurement?.end({
          success: true,
          isNativeBroker: response.fromNativeBroker,
          accessTokenSize: response.accessToken.length,
          idTokenSize: response.idToken.length,
          accountType: getAccountType(response.account)
        });
        return response;
      }).catch((e) => {
        this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);
        this.ssoSilentMeasurement?.end({
          success: false
        }, e);
        throw e;
      }).finally(() => {
        document.removeEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
      });
    }
    /**
     * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
     * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
     * This API is not indended for normal authorization code acquisition and redemption.
     *
     * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
     *
     * @param request {@link AuthorizationCodeRequest}
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    async acquireTokenByCode(request) {
      const correlationId = this.getRequestCorrelationId(request);
      this.logger.trace("acquireTokenByCode called", correlationId);
      const atbcMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, correlationId);
      preflightCheck2(this.initialized, atbcMeasurement);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, request);
      atbcMeasurement.add({ scenarioId: request.scenarioId });
      try {
        if (request.code && request.nativeAccountId) {
          throw createBrowserAuthError(spaCodeAndNativeAccountIdPresent);
        } else if (request.code) {
          const hybridAuthCode = request.code;
          let response = this.hybridAuthCodeResponses.get(hybridAuthCode);
          if (!response) {
            this.logger.verbose("Initiating new acquireTokenByCode request", correlationId);
            response = this.acquireTokenByCodeAsync({
              ...request,
              correlationId
            }).then((result) => {
              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, result);
              this.hybridAuthCodeResponses.delete(hybridAuthCode);
              atbcMeasurement.end({
                success: true,
                isNativeBroker: result.fromNativeBroker,
                accessTokenSize: result.accessToken.length,
                idTokenSize: result.idToken.length,
                accountType: getAccountType(result.account)
              });
              return result;
            }).catch((error) => {
              this.hybridAuthCodeResponses.delete(hybridAuthCode);
              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, error);
              atbcMeasurement.end({
                success: false
              }, error);
              throw error;
            });
            this.hybridAuthCodeResponses.set(hybridAuthCode, response);
          } else {
            this.logger.verbose("Existing acquireTokenByCode request found", correlationId);
            atbcMeasurement.discard();
          }
          return await response;
        } else if (request.nativeAccountId) {
          if (this.canUsePlatformBroker(request, request.nativeAccountId)) {
            const result = await this.acquireTokenNative({
              ...request,
              correlationId
            }, ApiId.acquireTokenByCode, request.nativeAccountId).catch((e) => {
              if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
                this.nativeExtensionProvider = void 0;
              }
              throw e;
            });
            atbcMeasurement.end({
              accountType: getAccountType(result.account),
              success: true
            });
            return result;
          } else {
            throw createBrowserAuthError(unableToAcquireTokenFromNativePlatform);
          }
        } else {
          throw createBrowserAuthError(authCodeOrNativeAccountIdRequired);
        }
      } catch (e) {
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e);
        atbcMeasurement.end({
          success: false
        }, e);
        throw e;
      }
    }
    /**
     * Creates a SilentAuthCodeClient to redeem an authorization code.
     * @param request
     * @returns Result of the operation to redeem the authorization code
     */
    async acquireTokenByCodeAsync(request) {
      this.logger.trace("acquireTokenByCodeAsync called", request.correlationId);
      this.acquireTokenByCodeAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCodeAsync, request.correlationId);
      this.acquireTokenByCodeAsyncMeasurement?.increment({
        visibilityChangeCount: 0
      });
      document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
      const silentAuthCodeClient = this.createSilentAuthCodeClient(request.correlationId);
      const silentTokenResult = await silentAuthCodeClient.acquireToken(request).then((response) => {
        this.acquireTokenByCodeAsyncMeasurement?.end({
          success: true,
          fromCache: response.fromCache,
          isNativeBroker: response.fromNativeBroker
        });
        return response;
      }).catch((tokenRenewalError) => {
        this.acquireTokenByCodeAsyncMeasurement?.end({
          success: false
        }, tokenRenewalError);
        throw tokenRenewalError;
      }).finally(() => {
        document.removeEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
      });
      return silentTokenResult;
    }
    /**
     * Attempt to acquire an access token from the cache
     * @param silentCacheClient SilentCacheClient
     * @param commonRequest CommonSilentFlowRequest
     * @param silentRequest SilentRequest
     * @returns A promise that, when resolved, returns the access token
     */
    async acquireTokenFromCache(commonRequest, cacheLookupPolicy) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenFromCache, commonRequest.correlationId);
      switch (cacheLookupPolicy) {
        case CacheLookupPolicy.Default:
        case CacheLookupPolicy.AccessToken:
        case CacheLookupPolicy.AccessTokenAndRefreshToken:
          const silentCacheClient = this.createSilentCacheClient(commonRequest.correlationId);
          return invokeAsync(silentCacheClient.acquireToken.bind(silentCacheClient), PerformanceEvents.SilentCacheClientAcquireToken, this.logger, this.performanceClient, commonRequest.correlationId)(commonRequest);
        default:
          throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
      }
    }
    /**
     * Attempt to acquire an access token via a refresh token
     * @param commonRequest CommonSilentFlowRequest
     * @param cacheLookupPolicy CacheLookupPolicy
     * @returns A promise that, when resolved, returns the access token
     */
    async acquireTokenByRefreshToken(commonRequest, cacheLookupPolicy) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenByRefreshToken, commonRequest.correlationId);
      switch (cacheLookupPolicy) {
        case CacheLookupPolicy.Default:
        case CacheLookupPolicy.AccessTokenAndRefreshToken:
        case CacheLookupPolicy.RefreshToken:
        case CacheLookupPolicy.RefreshTokenAndNetwork:
          const silentRefreshClient = this.createSilentRefreshClient(commonRequest.correlationId);
          return invokeAsync(silentRefreshClient.acquireToken.bind(silentRefreshClient), PerformanceEvents.SilentRefreshClientAcquireToken, this.logger, this.performanceClient, commonRequest.correlationId)(commonRequest);
        default:
          throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
      }
    }
    /**
     * Attempt to acquire an access token via an iframe
     * @param request CommonSilentFlowRequest
     * @returns A promise that, when resolved, returns the access token
     */
    async acquireTokenBySilentIframe(request) {
      this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenBySilentIframe, request.correlationId);
      const silentIframeClient = this.createSilentIframeClient(request.correlationId);
      return invokeAsync(silentIframeClient.acquireToken.bind(silentIframeClient), PerformanceEvents.SilentIframeClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(request);
    }
    // #endregion
    // #region Logout
    /**
     * Deprecated logout function. Use logoutRedirect or logoutPopup instead
     * @param logoutRequest
     * @deprecated
     */
    async logout(logoutRequest) {
      const correlationId = this.getRequestCorrelationId(logoutRequest);
      this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.", correlationId);
      return this.logoutRedirect({
        correlationId,
        ...logoutRequest
      });
    }
    /**
     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param logoutRequest
     */
    async logoutRedirect(logoutRequest) {
      const correlationId = this.getRequestCorrelationId(logoutRequest);
      redirectPreflightCheck(this.initialized, this.config);
      this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
      const redirectClient = this.createRedirectClient(correlationId);
      return redirectClient.logout(logoutRequest);
    }
    /**
     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
     * @param logoutRequest
     */
    logoutPopup(logoutRequest) {
      try {
        const correlationId = this.getRequestCorrelationId(logoutRequest);
        preflightCheck(this.initialized);
        this.browserStorage.setInteractionInProgress(true, INTERACTION_TYPE.SIGNOUT);
        const popupClient = this.createPopupClient(correlationId);
        return popupClient.logout(logoutRequest).finally(() => {
          this.browserStorage.setInteractionInProgress(false);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Creates a cache interaction client to clear broswer cache.
     * @param logoutRequest
     */
    async clearCache(logoutRequest) {
      if (!this.isBrowserEnvironment) {
        this.logger.info("in non-browser environment, returning early.");
        return;
      }
      const correlationId = this.getRequestCorrelationId(logoutRequest);
      const cacheClient = this.createSilentCacheClient(correlationId);
      return cacheClient.logout(logoutRequest);
    }
    // #endregion
    // #region Account APIs
    /**
     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
     * @param accountFilter - (Optional) filter to narrow down the accounts returned
     * @returns Array of AccountInfo objects in cache
     */
    getAllAccounts(accountFilter) {
      return getAllAccounts(this.logger, this.browserStorage, this.isBrowserEnvironment, accountFilter);
    }
    /**
     * Returns the first account found in the cache that matches the account filter passed in.
     * @param accountFilter
     * @returns The first account found in the cache matching the provided filter or null if no account could be found.
     */
    getAccount(accountFilter) {
      return getAccount(accountFilter, this.logger, this.browserStorage);
    }
    /**
     * Returns the signed in account matching username.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found.
     * This API is provided for convenience but getAccountById should be used for best reliability
     * @param username
     * @returns The account object stored in MSAL
     */
    getAccountByUsername(username) {
      return getAccountByUsername(username, this.logger, this.browserStorage);
    }
    /**
     * Returns the signed in account matching homeAccountId.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found
     * @param homeAccountId
     * @returns The account object stored in MSAL
     */
    getAccountByHomeId(homeAccountId) {
      return getAccountByHomeId(homeAccountId, this.logger, this.browserStorage);
    }
    /**
     * Returns the signed in account matching localAccountId.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found
     * @param localAccountId
     * @returns The account object stored in MSAL
     */
    getAccountByLocalId(localAccountId) {
      return getAccountByLocalId(localAccountId, this.logger, this.browserStorage);
    }
    /**
     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
     * @param account
     */
    setActiveAccount(account) {
      setActiveAccount(account, this.browserStorage);
    }
    /**
     * Gets the currently active account
     */
    getActiveAccount() {
      return getActiveAccount(this.browserStorage);
    }
    // #endregion
    /**
     * Hydrates the cache with the tokens from an AuthenticationResult
     * @param result
     * @param request
     * @returns
     */
    async hydrateCache(result, request) {
      this.logger.verbose("hydrateCache called");
      const accountEntity = AccountEntity.createFromAccountInfo(result.account, result.cloudGraphHostName, result.msGraphHost);
      await this.browserStorage.setAccount(accountEntity, result.correlationId);
      if (result.fromNativeBroker) {
        this.logger.verbose("Response was from native broker, storing in-memory");
        return this.nativeInternalStorage.hydrateCache(result, request);
      } else {
        return this.browserStorage.hydrateCache(result, request);
      }
    }
    // #region Helpers
    /**
     * Acquire a token from native device (e.g. WAM)
     * @param request
     */
    async acquireTokenNative(request, apiId, accountId, cacheLookupPolicy) {
      this.logger.trace("acquireTokenNative called");
      if (!this.nativeExtensionProvider) {
        throw createBrowserAuthError(nativeConnectionNotEstablished);
      }
      const nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, apiId, this.performanceClient, this.nativeExtensionProvider, accountId || this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);
      return nativeClient.acquireToken(request, cacheLookupPolicy);
    }
    /**
     * Returns boolean indicating if this request can use the platform broker
     * @param request
     */
    canUsePlatformBroker(request, accountId) {
      this.logger.trace("canUsePlatformBroker called");
      if (!NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeExtensionProvider, request.authenticationScheme)) {
        this.logger.trace("canUsePlatformBroker: isPlatformBrokerAvailable returned false, returning false");
        return false;
      }
      if (request.prompt) {
        switch (request.prompt) {
          case PromptValue.NONE:
          case PromptValue.CONSENT:
          case PromptValue.LOGIN:
            this.logger.trace("canUsePlatformBroker: prompt is compatible with platform broker flow");
            break;
          default:
            this.logger.trace(`canUsePlatformBroker: prompt = ${request.prompt} is not compatible with platform broker flow, returning false`);
            return false;
        }
      }
      if (!accountId && !this.getNativeAccountId(request)) {
        this.logger.trace("canUsePlatformBroker: nativeAccountId is not available, returning false");
        return false;
      }
      return true;
    }
    /**
     * Get the native accountId from the account
     * @param request
     * @returns
     */
    getNativeAccountId(request) {
      const account = request.account || this.getAccount({
        loginHint: request.loginHint,
        sid: request.sid
      }) || this.getActiveAccount();
      return account && account.nativeAccountId || "";
    }
    /**
     * Returns new instance of the Popup Interaction Client
     * @param correlationId
     */
    createPopupClient(correlationId) {
      return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Returns new instance of the Redirect Interaction Client
     * @param correlationId
     */
    createRedirectClient(correlationId) {
      return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Returns new instance of the Silent Iframe Interaction Client
     * @param correlationId
     */
    createSilentIframeClient(correlationId) {
      return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Returns new instance of the Silent Cache Interaction Client
     */
    createSilentCacheClient(correlationId) {
      return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Returns new instance of the Silent Refresh Interaction Client
     */
    createSilentRefreshClient(correlationId) {
      return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Returns new instance of the Silent AuthCode Interaction Client
     */
    createSilentAuthCodeClient(correlationId) {
      return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, correlationId);
    }
    /**
     * Adds event callbacks to array
     * @param callback
     */
    addEventCallback(callback, eventTypes) {
      return this.eventHandler.addEventCallback(callback, eventTypes);
    }
    /**
     * Removes callback with provided id from callback array
     * @param callbackId
     */
    removeEventCallback(callbackId) {
      this.eventHandler.removeEventCallback(callbackId);
    }
    /**
     * Registers a callback to receive performance events.
     *
     * @param {PerformanceCallbackFunction} callback
     * @returns {string}
     */
    addPerformanceCallback(callback) {
      blockNonBrowserEnvironment();
      return this.performanceClient.addPerformanceCallback(callback);
    }
    /**
     * Removes a callback registered with addPerformanceCallback.
     *
     * @param {string} callbackId
     * @returns {boolean}
     */
    removePerformanceCallback(callbackId) {
      return this.performanceClient.removePerformanceCallback(callbackId);
    }
    /**
     * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
     * @deprecated These events will be raised by default and this method will be removed in a future major version.
     */
    enableAccountStorageEvents() {
      if (this.config.cache.cacheLocation !== BrowserCacheLocation.LocalStorage) {
        this.logger.info("Account storage events are only available when cacheLocation is set to localStorage");
        return;
      }
      this.eventHandler.subscribeCrossTab();
    }
    /**
     * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
     * @deprecated These events will be raised by default and this method will be removed in a future major version.
     */
    disableAccountStorageEvents() {
      if (this.config.cache.cacheLocation !== BrowserCacheLocation.LocalStorage) {
        this.logger.info("Account storage events are only available when cacheLocation is set to localStorage");
        return;
      }
      this.eventHandler.unsubscribeCrossTab();
    }
    /**
     * Gets the token cache for the application.
     */
    getTokenCache() {
      return this.tokenCache;
    }
    /**
     * Returns the logger instance
     */
    getLogger() {
      return this.logger;
    }
    /**
     * Replaces the default logger set in configurations with new Logger with new configurations
     * @param logger Logger instance
     */
    setLogger(logger) {
      this.logger = logger;
    }
    /**
     * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
     * @param sku
     * @param version
     */
    initializeWrapperLibrary(sku, version5) {
      this.browserStorage.setWrapperMetadata(sku, version5);
    }
    /**
     * Sets navigation client
     * @param navigationClient
     */
    setNavigationClient(navigationClient) {
      this.navigationClient = navigationClient;
    }
    /**
     * Returns the configuration object
     */
    getConfiguration() {
      return this.config;
    }
    /**
     * Returns the performance client
     */
    getPerformanceClient() {
      return this.performanceClient;
    }
    /**
     * Returns the browser env indicator
     */
    isBrowserEnv() {
      return this.isBrowserEnvironment;
    }
    /**
     * Generates a correlation id for a request if none is provided.
     *
     * @protected
     * @param {?Partial<BaseAuthRequest>} [request]
     * @returns {string}
     */
    getRequestCorrelationId(request) {
      if (request?.correlationId) {
        return request.correlationId;
      }
      if (this.isBrowserEnvironment) {
        return createNewGuid();
      }
      return Constants.EMPTY_STRING;
    }
    // #endregion
    /**
     * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
     * any code that follows this function will not execute.
     *
     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
     *
     * @param request
     */
    async loginRedirect(request) {
      const correlationId = this.getRequestCorrelationId(request);
      this.logger.verbose("loginRedirect called", correlationId);
      return this.acquireTokenRedirect({
        correlationId,
        ...request || DEFAULT_REQUEST
      });
    }
    /**
     * Use when initiating the login process via opening a popup window in the user's browser
     *
     * @param request
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    loginPopup(request) {
      const correlationId = this.getRequestCorrelationId(request);
      this.logger.verbose("loginPopup called", correlationId);
      return this.acquireTokenPopup({
        correlationId,
        ...request || DEFAULT_REQUEST
      });
    }
    /**
     * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
     *
     * @param {@link (SilentRequest:type)}
     * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object
     */
    async acquireTokenSilent(request) {
      const correlationId = this.getRequestCorrelationId(request);
      const atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, correlationId);
      atsMeasurement.add({
        cacheLookupPolicy: request.cacheLookupPolicy,
        scenarioId: request.scenarioId
      });
      preflightCheck2(this.initialized, atsMeasurement);
      this.logger.verbose("acquireTokenSilent called", correlationId);
      const account = request.account || this.getActiveAccount();
      if (!account) {
        throw createBrowserAuthError(noAccountError);
      }
      atsMeasurement.add({ accountType: getAccountType(account) });
      return this.acquireTokenSilentDeduped(request, account, correlationId).then((result) => {
        atsMeasurement.end({
          success: true,
          fromCache: result.fromCache,
          isNativeBroker: result.fromNativeBroker,
          accessTokenSize: result.accessToken.length,
          idTokenSize: result.idToken.length
        });
        return {
          ...result,
          state: request.state,
          correlationId
          // Ensures PWB scenarios can correctly match request to response
        };
      }).catch((error) => {
        if (error instanceof AuthError) {
          error.setCorrelationId(correlationId);
        }
        atsMeasurement.end({
          success: false
        }, error);
        throw error;
      });
    }
    /**
     * Checks if identical request is already in flight and returns reference to the existing promise or fires off a new one if this is the first
     * @param request
     * @param account
     * @param correlationId
     * @returns
     */
    async acquireTokenSilentDeduped(request, account, correlationId) {
      const thumbprint = getRequestThumbprint(this.config.auth.clientId, {
        ...request,
        authority: request.authority || this.config.auth.authority,
        correlationId
      }, account.homeAccountId);
      const silentRequestKey = JSON.stringify(thumbprint);
      const inProgressRequest = this.activeSilentTokenRequests.get(silentRequestKey);
      if (typeof inProgressRequest === "undefined") {
        this.logger.verbose("acquireTokenSilent called for the first time, storing active request", correlationId);
        this.performanceClient.addFields({ deduped: false }, correlationId);
        const activeRequest = invokeAsync(this.acquireTokenSilentAsync.bind(this), PerformanceEvents.AcquireTokenSilentAsync, this.logger, this.performanceClient, correlationId)({
          ...request,
          correlationId
        }, account);
        this.activeSilentTokenRequests.set(silentRequestKey, activeRequest);
        return activeRequest.finally(() => {
          this.activeSilentTokenRequests.delete(silentRequestKey);
        });
      } else {
        this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", correlationId);
        this.performanceClient.addFields({ deduped: true }, correlationId);
        return inProgressRequest;
      }
    }
    /**
     * Silently acquire an access token for a given set of scopes. Will use cached token if available, otherwise will attempt to acquire a new token from the network via refresh token.
     * @param {@link (SilentRequest:type)}
     * @param {@link (AccountInfo:type)}
     * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse}
     */
    async acquireTokenSilentAsync(request, account) {
      const trackPageVisibility = () => this.trackPageVisibility(request.correlationId);
      this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenSilentAsync, request.correlationId);
      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, request);
      if (request.correlationId) {
        this.performanceClient.incrementFields({ visibilityChangeCount: 0 }, request.correlationId);
      }
      document.addEventListener("visibilitychange", trackPageVisibility);
      const silentRequest = await invokeAsync(initializeSilentRequest, PerformanceEvents.InitializeSilentRequest, this.logger, this.performanceClient, request.correlationId)(request, account, this.config, this.performanceClient, this.logger);
      const cacheLookupPolicy = request.cacheLookupPolicy || CacheLookupPolicy.Default;
      const result = this.acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy).catch(async (refreshTokenError) => {
        const shouldTryToResolveSilently = checkIfRefreshTokenErrorCanBeResolvedSilently(refreshTokenError, cacheLookupPolicy);
        if (shouldTryToResolveSilently) {
          if (!this.activeIframeRequest) {
            let _resolve;
            this.activeIframeRequest = [
              new Promise((resolve) => {
                _resolve = resolve;
              }),
              silentRequest.correlationId
            ];
            this.logger.verbose("Refresh token expired/invalid or CacheLookupPolicy is set to Skip, attempting acquire token by iframe.", silentRequest.correlationId);
            return invokeAsync(this.acquireTokenBySilentIframe.bind(this), PerformanceEvents.AcquireTokenBySilentIframe, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest).then((iframeResult) => {
              _resolve(true);
              return iframeResult;
            }).catch((e) => {
              _resolve(false);
              throw e;
            }).finally(() => {
              this.activeIframeRequest = void 0;
            });
          } else if (cacheLookupPolicy !== CacheLookupPolicy.Skip) {
            const [activePromise, activeCorrelationId] = this.activeIframeRequest;
            this.logger.verbose(`Iframe request is already in progress, awaiting resolution for request with correlationId: ${activeCorrelationId}`, silentRequest.correlationId);
            const awaitConcurrentIframeMeasure = this.performanceClient.startMeasurement(PerformanceEvents.AwaitConcurrentIframe, silentRequest.correlationId);
            awaitConcurrentIframeMeasure.add({
              awaitIframeCorrelationId: activeCorrelationId
            });
            const activePromiseResult = await activePromise;
            awaitConcurrentIframeMeasure.end({
              success: activePromiseResult
            });
            if (activePromiseResult) {
              this.logger.verbose(`Parallel iframe request with correlationId: ${activeCorrelationId} succeeded. Retrying cache and/or RT redemption`, silentRequest.correlationId);
              return this.acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy);
            } else {
              this.logger.info(`Iframe request with correlationId: ${activeCorrelationId} failed. Interaction is required.`);
              throw refreshTokenError;
            }
          } else {
            this.logger.warning("Another iframe request is currently in progress and CacheLookupPolicy is set to Skip. This may result in degraded performance and/or reliability for both calls. Please consider changing the CacheLookupPolicy to take advantage of request queuing and token cache.", silentRequest.correlationId);
            return invokeAsync(this.acquireTokenBySilentIframe.bind(this), PerformanceEvents.AcquireTokenBySilentIframe, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest);
          }
        } else {
          throw refreshTokenError;
        }
      });
      return result.then((response) => {
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, response);
        if (request.correlationId) {
          this.performanceClient.addFields({
            fromCache: response.fromCache,
            isNativeBroker: response.fromNativeBroker
          }, request.correlationId);
        }
        return response;
      }).catch((tokenRenewalError) => {
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, tokenRenewalError);
        throw tokenRenewalError;
      }).finally(() => {
        document.removeEventListener("visibilitychange", trackPageVisibility);
      });
    }
    /**
     * AcquireTokenSilent without the iframe fallback. This is used to enable the correct fallbacks in cases where there's a potential for multiple silent requests to be made in parallel and prevent those requests from making concurrent iframe requests.
     * @param silentRequest
     * @param cacheLookupPolicy
     * @returns
     */
    async acquireTokenSilentNoIframe(silentRequest, cacheLookupPolicy) {
      if (NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeExtensionProvider, silentRequest.authenticationScheme) && silentRequest.account.nativeAccountId) {
        this.logger.verbose("acquireTokenSilent - attempting to acquire token from native platform");
        return this.acquireTokenNative(silentRequest, ApiId.acquireTokenSilent_silentFlow, silentRequest.account.nativeAccountId, cacheLookupPolicy).catch(async (e) => {
          if (e instanceof NativeAuthError && isFatalNativeAuthError(e)) {
            this.logger.verbose("acquireTokenSilent - native platform unavailable, falling back to web flow");
            this.nativeExtensionProvider = void 0;
            throw createClientAuthError(ClientAuthErrorCodes_exports.tokenRefreshRequired);
          }
          throw e;
        });
      } else {
        this.logger.verbose("acquireTokenSilent - attempting to acquire token from web flow");
        if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
          this.logger.verbose("acquireTokenSilent - cache lookup policy set to AccessToken, attempting to acquire token from local cache");
        }
        return invokeAsync(this.acquireTokenFromCache.bind(this), PerformanceEvents.AcquireTokenFromCache, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest, cacheLookupPolicy).catch((cacheError) => {
          if (cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
            throw cacheError;
          }
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, silentRequest);
          return invokeAsync(this.acquireTokenByRefreshToken.bind(this), PerformanceEvents.AcquireTokenByRefreshToken, this.logger, this.performanceClient, silentRequest.correlationId)(silentRequest, cacheLookupPolicy);
        });
      }
    }
    /**
     * Pre-generates PKCE codes and stores it in local variable
     * @param correlationId
     */
    async preGeneratePkceCodes(correlationId) {
      this.logger.verbose("Generating new PKCE codes");
      this.pkceCode = await invokeAsync(generatePkceCodes, PerformanceEvents.GeneratePkceCodes, this.logger, this.performanceClient, correlationId)(this.performanceClient, this.logger, correlationId);
      return Promise.resolve();
    }
    /**
     * Provides pre-generated PKCE codes, if any
     * @param correlationId
     */
    getPreGeneratedPkceCodes(correlationId) {
      this.logger.verbose("Attempting to pick up pre-generated PKCE codes");
      const res = this.pkceCode ? { ...this.pkceCode } : void 0;
      this.pkceCode = void 0;
      this.logger.verbose(`${res ? "Found" : "Did not find"} pre-generated PKCE codes`);
      this.performanceClient.addFields({ usePreGeneratedPkce: !!res }, correlationId);
      return res;
    }
    logMultipleInstances(performanceEvent) {
      const clientId = this.config.auth.clientId;
      if (!window)
        return;
      window.msal = window.msal || {};
      window.msal.clientIds = window.msal.clientIds || [];
      const clientIds = window.msal.clientIds;
      if (clientIds.length > 0) {
        this.logger.verbose("There is already an instance of MSAL.js in the window.");
      }
      window.msal.clientIds.push(clientId);
      collectInstanceStats(clientId, performanceEvent, this.logger);
    }
  };
  function checkIfRefreshTokenErrorCanBeResolvedSilently(refreshTokenError, cacheLookupPolicy) {
    const noInteractionRequired = !(refreshTokenError instanceof InteractionRequiredAuthError && // For refresh token errors, bad_token does not always require interaction (silently resolvable)
    refreshTokenError.subError !== InteractionRequiredAuthErrorCodes_exports.badToken);
    const refreshTokenRefreshRequired = refreshTokenError.errorCode === BrowserConstants.INVALID_GRANT_ERROR || refreshTokenError.errorCode === ClientAuthErrorCodes_exports.tokenRefreshRequired;
    const isSilentlyResolvable = noInteractionRequired && refreshTokenRefreshRequired || refreshTokenError.errorCode === InteractionRequiredAuthErrorCodes_exports.noTokensFound || refreshTokenError.errorCode === InteractionRequiredAuthErrorCodes_exports.refreshTokenExpired;
    const tryIframeRenewal = iFrameRenewalPolicies.includes(cacheLookupPolicy);
    return isSilentlyResolvable && tryIframeRenewal;
  }

  // ../../node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs
  async function createV3Controller(config, request) {
    const standard = new StandardOperatingContext(config);
    await standard.initialize();
    return StandardController.createController(standard, request);
  }

  // ../../node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs
  var PublicClientApplication = class _PublicClientApplication {
    /**
     * Creates StandardController and passes it to the PublicClientApplication
     *
     * @param configuration {Configuration}
     */
    static async createPublicClientApplication(configuration) {
      const controller = await createV3Controller(configuration);
      const pca = new _PublicClientApplication(configuration, controller);
      return pca;
    }
    /**
     * @constructor
     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
     *
     * Important attributes in the Configuration object for auth are:
     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
     * - authority: the authority URL for your application.
     * - redirect_uri: the uri of your application registered in the portal.
     *
     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
     *
     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
     * Full B2C functionality will be available in this library in future versions.
     *
     * @param configuration Object for the MSAL PublicClientApplication instance
     * @param IController Optional parameter to explictly set the controller. (Will be removed when we remove public constructor)
     */
    constructor(configuration, controller) {
      this.isBroker = false;
      this.controller = controller || new StandardController(new StandardOperatingContext(configuration));
    }
    /**
     * Initializer function to perform async startup tasks such as connecting to WAM extension
     * @param request {?InitializeApplicationRequest}
     */
    async initialize(request) {
      return this.controller.initialize(request, this.isBroker);
    }
    /**
     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
     *
     * @param request
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    async acquireTokenPopup(request) {
      return this.controller.acquireTokenPopup(request);
    }
    /**
     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
     * the page, so any code that follows this function will not execute.
     *
     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
     *
     * @param request
     */
    acquireTokenRedirect(request) {
      return this.controller.acquireTokenRedirect(request);
    }
    /**
     * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
     *
     * @param {@link (SilentRequest:type)}
     * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthenticationResult} object
     */
    acquireTokenSilent(silentRequest) {
      return this.controller.acquireTokenSilent(silentRequest);
    }
    /**
     * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
     * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
     * This API is not indended for normal authorization code acquisition and redemption.
     *
     * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
     *
     * @param request {@link AuthorizationCodeRequest}
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    acquireTokenByCode(request) {
      return this.controller.acquireTokenByCode(request);
    }
    /**
     * Adds event callbacks to array
     * @param callback
     * @param eventTypes
     */
    addEventCallback(callback, eventTypes) {
      return this.controller.addEventCallback(callback, eventTypes);
    }
    /**
     * Removes callback with provided id from callback array
     * @param callbackId
     */
    removeEventCallback(callbackId) {
      return this.controller.removeEventCallback(callbackId);
    }
    /**
     * Registers a callback to receive performance events.
     *
     * @param {PerformanceCallbackFunction} callback
     * @returns {string}
     */
    addPerformanceCallback(callback) {
      return this.controller.addPerformanceCallback(callback);
    }
    /**
     * Removes a callback registered with addPerformanceCallback.
     *
     * @param {string} callbackId
     * @returns {boolean}
     */
    removePerformanceCallback(callbackId) {
      return this.controller.removePerformanceCallback(callbackId);
    }
    /**
     * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
     */
    enableAccountStorageEvents() {
      this.controller.enableAccountStorageEvents();
    }
    /**
     * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
     */
    disableAccountStorageEvents() {
      this.controller.disableAccountStorageEvents();
    }
    /**
     * Returns the first account found in the cache that matches the account filter passed in.
     * @param accountFilter
     * @returns The first account found in the cache matching the provided filter or null if no account could be found.
     */
    getAccount(accountFilter) {
      return this.controller.getAccount(accountFilter);
    }
    /**
     * Returns the signed in account matching homeAccountId.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found
     * @param homeAccountId
     * @returns The account object stored in MSAL
     * @deprecated - Use getAccount instead
     */
    getAccountByHomeId(homeAccountId) {
      return this.controller.getAccountByHomeId(homeAccountId);
    }
    /**
     * Returns the signed in account matching localAccountId.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found
     * @param localAccountId
     * @returns The account object stored in MSAL
     * @deprecated - Use getAccount instead
     */
    getAccountByLocalId(localId) {
      return this.controller.getAccountByLocalId(localId);
    }
    /**
     * Returns the signed in account matching username.
     * (the account object is created at the time of successful login)
     * or null when no matching account is found.
     * This API is provided for convenience but getAccountById should be used for best reliability
     * @param userName
     * @returns The account object stored in MSAL
     * @deprecated - Use getAccount instead
     */
    getAccountByUsername(userName) {
      return this.controller.getAccountByUsername(userName);
    }
    /**
     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
     * @param accountFilter - (Optional) filter to narrow down the accounts returned
     * @returns Array of AccountInfo objects in cache
     */
    getAllAccounts(accountFilter) {
      return this.controller.getAllAccounts(accountFilter);
    }
    /**
     * Event handler function which allows users to fire events after the PublicClientApplication object
     * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
     * auth flows.
     * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
     * @returns Token response or null. If the return value is null, then no auth redirect was detected.
     */
    handleRedirectPromise(hash2) {
      return this.controller.handleRedirectPromise(hash2);
    }
    /**
     * Use when initiating the login process via opening a popup window in the user's browser
     *
     * @param request
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    loginPopup(request) {
      return this.controller.loginPopup(request);
    }
    /**
     * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
     * any code that follows this function will not execute.
     *
     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
     *
     * @param request
     */
    loginRedirect(request) {
      return this.controller.loginRedirect(request);
    }
    /**
     * Deprecated logout function. Use logoutRedirect or logoutPopup instead
     * @param logoutRequest
     * @deprecated
     */
    logout(logoutRequest) {
      return this.controller.logout(logoutRequest);
    }
    /**
     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
     * Default behaviour is to redirect the user to `window.location.href`.
     * @param logoutRequest
     */
    logoutRedirect(logoutRequest) {
      return this.controller.logoutRedirect(logoutRequest);
    }
    /**
     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
     * @param logoutRequest
     */
    logoutPopup(logoutRequest) {
      return this.controller.logoutPopup(logoutRequest);
    }
    /**
     * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
     * - Any browser using a form of Intelligent Tracking Prevention
     * - If there is not an established session with the service
     *
     * In these cases, the request must be done inside a popup or full frame redirect.
     *
     * For the cases where interaction is required, you cannot send a request with prompt=none.
     *
     * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
     * you session on the server still exists.
     * @param request {@link SsoSilentRequest}
     *
     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
     */
    ssoSilent(request) {
      return this.controller.ssoSilent(request);
    }
    /**
     * Gets the token cache for the application.
     */
    getTokenCache() {
      return this.controller.getTokenCache();
    }
    /**
     * Returns the logger instance
     */
    getLogger() {
      return this.controller.getLogger();
    }
    /**
     * Replaces the default logger set in configurations with new Logger with new configurations
     * @param logger Logger instance
     */
    setLogger(logger) {
      this.controller.setLogger(logger);
    }
    /**
     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
     * @param account
     */
    setActiveAccount(account) {
      this.controller.setActiveAccount(account);
    }
    /**
     * Gets the currently active account
     */
    getActiveAccount() {
      return this.controller.getActiveAccount();
    }
    /**
     * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
     * @param sku
     * @param version
     */
    initializeWrapperLibrary(sku, version5) {
      return this.controller.initializeWrapperLibrary(sku, version5);
    }
    /**
     * Sets navigation client
     * @param navigationClient
     */
    setNavigationClient(navigationClient) {
      this.controller.setNavigationClient(navigationClient);
    }
    /**
     * Returns the configuration object
     * @internal
     */
    getConfiguration() {
      return this.controller.getConfiguration();
    }
    /**
     * Hydrates cache with the tokens and account in the AuthenticationResult object
     * @param result
     * @param request - The request object that was used to obtain the AuthenticationResult
     * @returns
     */
    async hydrateCache(result, request) {
      return this.controller.hydrateCache(result, request);
    }
    /**
     * Clears tokens and account from the browser cache.
     * @param logoutRequest
     */
    clearCache(logoutRequest) {
      return this.controller.clearCache(logoutRequest);
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/app/IPublicClientApplication.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var stubbedPublicClientApplication = {
    initialize: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    acquireTokenPopup: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    acquireTokenRedirect: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    acquireTokenSilent: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    acquireTokenByCode: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    getAllAccounts: () => {
      return [];
    },
    getAccount: () => {
      return null;
    },
    getAccountByHomeId: () => {
      return null;
    },
    getAccountByUsername: () => {
      return null;
    },
    getAccountByLocalId: () => {
      return null;
    },
    handleRedirectPromise: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    loginPopup: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    loginRedirect: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    logout: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    logoutRedirect: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    logoutPopup: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    ssoSilent: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    addEventCallback: () => {
      return null;
    },
    removeEventCallback: () => {
      return;
    },
    addPerformanceCallback: () => {
      return "";
    },
    removePerformanceCallback: () => {
      return false;
    },
    enableAccountStorageEvents: () => {
      return;
    },
    disableAccountStorageEvents: () => {
      return;
    },
    getTokenCache: () => {
      throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
    },
    getLogger: () => {
      throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
    },
    setLogger: () => {
      return;
    },
    setActiveAccount: () => {
      return;
    },
    getActiveAccount: () => {
      return null;
    },
    initializeWrapperLibrary: () => {
      return;
    },
    setNavigationClient: () => {
      return;
    },
    getConfiguration: () => {
      throw createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled);
    },
    hydrateCache: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    },
    clearCache: () => {
      return Promise.reject(createBrowserConfigurationAuthError(stubbedPublicClientApplicationCalled));
    }
  };

  // ../../node_modules/@azure/msal-browser/dist/event/EventMessage.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var EventMessageUtils = class {
    /**
     * Gets interaction status from event message
     * @param message
     * @param currentStatus
     */
    static getInteractionStatusFromEvent(message, currentStatus) {
      switch (message.eventType) {
        case EventType.LOGIN_START:
          return InteractionStatus.Login;
        case EventType.SSO_SILENT_START:
          return InteractionStatus.SsoSilent;
        case EventType.ACQUIRE_TOKEN_START:
          if (message.interactionType === InteractionType.Redirect || message.interactionType === InteractionType.Popup) {
            return InteractionStatus.AcquireToken;
          }
          break;
        case EventType.HANDLE_REDIRECT_START:
          return InteractionStatus.HandleRedirect;
        case EventType.LOGOUT_START:
          return InteractionStatus.Logout;
        case EventType.SSO_SILENT_SUCCESS:
        case EventType.SSO_SILENT_FAILURE:
          if (currentStatus && currentStatus !== InteractionStatus.SsoSilent) {
            break;
          }
          return InteractionStatus.None;
        case EventType.LOGOUT_END:
          if (currentStatus && currentStatus !== InteractionStatus.Logout) {
            break;
          }
          return InteractionStatus.None;
        case EventType.HANDLE_REDIRECT_END:
          if (currentStatus && currentStatus !== InteractionStatus.HandleRedirect) {
            break;
          }
          return InteractionStatus.None;
        case EventType.LOGIN_SUCCESS:
        case EventType.LOGIN_FAILURE:
        case EventType.ACQUIRE_TOKEN_SUCCESS:
        case EventType.ACQUIRE_TOKEN_FAILURE:
        case EventType.RESTORE_FROM_BFCACHE:
          if (message.interactionType === InteractionType.Redirect || message.interactionType === InteractionType.Popup) {
            if (currentStatus && currentStatus !== InteractionStatus.Login && currentStatus !== InteractionStatus.AcquireToken) {
              break;
            }
            return InteractionStatus.None;
          }
          break;
      }
      return null;
    }
  };

  // ../../node_modules/@azure/msal-react/dist/MsalContext.js
  var defaultMsalContext = {
    instance: stubbedPublicClientApplication,
    inProgress: InteractionStatus.None,
    accounts: [],
    logger: new Logger({})
  };
  var MsalContext = React14.createContext(defaultMsalContext);
  var MsalConsumer = MsalContext.Consumer;

  // ../../node_modules/@azure/msal-react/dist/MsalProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react10 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-react/dist/utils/utilities.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getChildrenOrFunction(children2, args) {
    if (typeof children2 === "function") {
      return children2(args);
    }
    return children2;
  }
  function accountArraysAreEqual(arrayA, arrayB) {
    if (arrayA.length !== arrayB.length) {
      return false;
    }
    const comparisonArray = [...arrayB];
    return arrayA.every((elementA) => {
      const elementB = comparisonArray.shift();
      if (!elementA || !elementB) {
        return false;
      }
      return elementA.homeAccountId === elementB.homeAccountId && elementA.localAccountId === elementB.localAccountId && elementA.username === elementB.username;
    });
  }
  function getAccountByIdentifiers(allAccounts, accountIdentifiers) {
    if (allAccounts.length > 0 && (accountIdentifiers.homeAccountId || accountIdentifiers.localAccountId || accountIdentifiers.username)) {
      const matchedAccounts = allAccounts.filter((accountObj) => {
        if (accountIdentifiers.username && accountIdentifiers.username.toLowerCase() !== accountObj.username.toLowerCase()) {
          return false;
        }
        if (accountIdentifiers.homeAccountId && accountIdentifiers.homeAccountId.toLowerCase() !== accountObj.homeAccountId.toLowerCase()) {
          return false;
        }
        if (accountIdentifiers.localAccountId && accountIdentifiers.localAccountId.toLowerCase() !== accountObj.localAccountId.toLowerCase()) {
          return false;
        }
        return true;
      });
      return matchedAccounts[0] || null;
    } else {
      return null;
    }
  }

  // ../../node_modules/@azure/msal-react/dist/packageMetadata.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var name19 = "@azure/msal-react";
  var version3 = "3.0.12";

  // ../../node_modules/@azure/msal-react/dist/MsalProvider.js
  var MsalProviderActionType = {
    UNBLOCK_INPROGRESS: "UNBLOCK_INPROGRESS",
    EVENT: "EVENT"
  };
  var reducer = (previousState, action) => {
    const { type, payload } = action;
    let newInProgress = previousState.inProgress;
    switch (type) {
      case MsalProviderActionType.UNBLOCK_INPROGRESS:
        if (previousState.inProgress === InteractionStatus.Startup) {
          newInProgress = InteractionStatus.None;
          payload.logger.info("MsalProvider - handleRedirectPromise resolved, setting inProgress to 'none'");
        }
        break;
      case MsalProviderActionType.EVENT:
        const message = payload.message;
        const status = EventMessageUtils.getInteractionStatusFromEvent(message, previousState.inProgress);
        if (status) {
          payload.logger.info(`MsalProvider - ${message.eventType} results in setting inProgress from ${previousState.inProgress} to ${status}`);
          newInProgress = status;
        }
        break;
      default:
        throw new Error(`Unknown action type: ${type}`);
    }
    if (newInProgress === InteractionStatus.Startup) {
      return previousState;
    }
    const currentAccounts = payload.instance.getAllAccounts();
    if (newInProgress !== previousState.inProgress && !accountArraysAreEqual(currentAccounts, previousState.accounts)) {
      return {
        ...previousState,
        inProgress: newInProgress,
        accounts: currentAccounts
      };
    } else if (newInProgress !== previousState.inProgress) {
      return {
        ...previousState,
        inProgress: newInProgress
      };
    } else if (!accountArraysAreEqual(currentAccounts, previousState.accounts)) {
      return {
        ...previousState,
        accounts: currentAccounts
      };
    } else {
      return previousState;
    }
  };
  function MsalProvider({ instance, children: children2 }) {
    (0, import_react10.useEffect)(() => {
      instance.initializeWrapperLibrary(WrapperSKU.React, version3);
    }, [instance]);
    const logger = (0, import_react10.useMemo)(() => {
      return instance.getLogger().clone(name19, version3);
    }, [instance]);
    const [state, updateState] = (0, import_react10.useReducer)(reducer, void 0, () => {
      return {
        inProgress: InteractionStatus.Startup,
        accounts: []
      };
    });
    (0, import_react10.useEffect)(() => {
      const callbackId = instance.addEventCallback((message) => {
        updateState({
          payload: {
            instance,
            logger,
            message
          },
          type: MsalProviderActionType.EVENT
        });
      });
      logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);
      instance.initialize().then(() => {
        instance.handleRedirectPromise().catch(() => {
          return;
        }).finally(() => {
          updateState({
            payload: {
              instance,
              logger
            },
            type: MsalProviderActionType.UNBLOCK_INPROGRESS
          });
        });
      }).catch(() => {
        return;
      });
      return () => {
        if (callbackId) {
          logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);
          instance.removeEventCallback(callbackId);
        }
      };
    }, [instance, logger]);
    const contextValue = {
      instance,
      inProgress: state.inProgress,
      accounts: state.accounts,
      logger
    };
    return import_react10.default.createElement(MsalContext.Provider, { value: contextValue }, children2);
  }

  // ../../node_modules/@azure/msal-react/dist/components/AuthenticatedTemplate.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react13 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-react/dist/hooks/useMsal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react11 = __toESM(require_react(), 1);
  var useMsal = () => (0, import_react11.useContext)(MsalContext);

  // ../../node_modules/@azure/msal-react/dist/hooks/useIsAuthenticated.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react12 = __toESM(require_react(), 1);
  function isAuthenticated(allAccounts, matchAccount) {
    if (matchAccount && (matchAccount.username || matchAccount.homeAccountId || matchAccount.localAccountId)) {
      return !!getAccountByIdentifiers(allAccounts, matchAccount);
    }
    return allAccounts.length > 0;
  }
  function useIsAuthenticated(matchAccount) {
    const { accounts: allAccounts, inProgress } = useMsal();
    const isUserAuthenticated = (0, import_react12.useMemo)(() => {
      if (inProgress === InteractionStatus.Startup) {
        return false;
      }
      return isAuthenticated(allAccounts, matchAccount);
    }, [allAccounts, inProgress, matchAccount]);
    return isUserAuthenticated;
  }

  // ../../node_modules/@azure/msal-react/dist/components/UnauthenticatedTemplate.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react14 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-react/dist/components/MsalAuthenticationTemplate.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react17 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-react/dist/hooks/useMsalAuthentication.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react16 = __toESM(require_react(), 1);

  // ../../node_modules/@azure/msal-react/dist/hooks/useAccount.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react15 = __toESM(require_react(), 1);
  function getAccount2(instance, accountIdentifiers) {
    if (!accountIdentifiers || !accountIdentifiers.homeAccountId && !accountIdentifiers.localAccountId && !accountIdentifiers.username) {
      return instance.getActiveAccount();
    }
    return getAccountByIdentifiers(instance.getAllAccounts(), accountIdentifiers);
  }
  function useAccount(accountIdentifiers) {
    const { instance, inProgress, logger } = useMsal();
    const [account, setAccount] = (0, import_react15.useState)(() => {
      if (inProgress === InteractionStatus.Startup) {
        return null;
      } else {
        return getAccount2(instance, accountIdentifiers);
      }
    });
    (0, import_react15.useEffect)(() => {
      if (inProgress !== InteractionStatus.Startup) {
        setAccount((currentAccount) => {
          const nextAccount = getAccount2(instance, accountIdentifiers);
          if (!AccountEntity.accountInfoIsEqual(currentAccount, nextAccount, true)) {
            logger.info("useAccount - Updating account");
            return nextAccount;
          }
          return currentAccount;
        });
      }
    }, [inProgress, accountIdentifiers, instance, logger]);
    return account;
  }

  // ../../node_modules/@azure/msal-react/dist/error/ReactAuthError.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ReactAuthErrorMessage = {
    invalidInteractionType: {
      code: "invalid_interaction_type",
      desc: "The provided interaction type is invalid."
    },
    unableToFallbackToInteraction: {
      code: "unable_to_fallback_to_interaction",
      desc: "Interaction is required but another interaction is already in progress. Please try again when the current interaction is complete."
    }
  };
  var ReactAuthError = class _ReactAuthError extends AuthError {
    constructor(errorCode, errorMessage) {
      super(errorCode, errorMessage);
      Object.setPrototypeOf(this, _ReactAuthError.prototype);
      this.name = "ReactAuthError";
    }
    static createInvalidInteractionTypeError() {
      return new _ReactAuthError(ReactAuthErrorMessage.invalidInteractionType.code, ReactAuthErrorMessage.invalidInteractionType.desc);
    }
    static createUnableToFallbackToInteractionError() {
      return new _ReactAuthError(ReactAuthErrorMessage.unableToFallbackToInteraction.code, ReactAuthErrorMessage.unableToFallbackToInteraction.desc);
    }
  };

  // ../../node_modules/@azure/msal-react/dist/hooks/useMsalAuthentication.js
  function useMsalAuthentication(interactionType, authenticationRequest, accountIdentifiers) {
    const { instance, inProgress, logger } = useMsal();
    const isAuthenticated2 = useIsAuthenticated(accountIdentifiers);
    const account = useAccount(accountIdentifiers);
    const [[result, error], setResponse] = (0, import_react16.useState)([null, null]);
    const mounted = (0, import_react16.useRef)(true);
    (0, import_react16.useEffect)(() => {
      return () => {
        mounted.current = false;
      };
    }, []);
    const interactionInProgress2 = (0, import_react16.useRef)(inProgress !== InteractionStatus.None);
    (0, import_react16.useEffect)(() => {
      interactionInProgress2.current = inProgress !== InteractionStatus.None;
    }, [inProgress]);
    const shouldAcquireToken = (0, import_react16.useRef)(true);
    (0, import_react16.useEffect)(() => {
      if (!!error) {
        shouldAcquireToken.current = false;
        return;
      }
      if (!!result) {
        shouldAcquireToken.current = false;
        return;
      }
    }, [error, result]);
    const login = (0, import_react16.useCallback)(async (callbackInteractionType, callbackRequest) => {
      const loginType = callbackInteractionType || interactionType;
      const loginRequest2 = callbackRequest || authenticationRequest;
      switch (loginType) {
        case InteractionType.Popup:
          logger.verbose("useMsalAuthentication - Calling loginPopup");
          return instance.loginPopup(loginRequest2);
        case InteractionType.Redirect:
          logger.verbose("useMsalAuthentication - Calling loginRedirect");
          return instance.loginRedirect(loginRequest2).then(null);
        case InteractionType.Silent:
          logger.verbose("useMsalAuthentication - Calling ssoSilent");
          return instance.ssoSilent(loginRequest2);
        default:
          throw ReactAuthError.createInvalidInteractionTypeError();
      }
    }, [instance, interactionType, authenticationRequest, logger]);
    const acquireToken = (0, import_react16.useCallback)(async (callbackInteractionType, callbackRequest) => {
      const fallbackInteractionType = callbackInteractionType || interactionType;
      let tokenRequest;
      if (callbackRequest) {
        logger.trace("useMsalAuthentication - acquireToken - Using request provided in the callback");
        tokenRequest = {
          ...callbackRequest
        };
      } else if (authenticationRequest) {
        logger.trace("useMsalAuthentication - acquireToken - Using request provided in the hook");
        tokenRequest = {
          ...authenticationRequest,
          scopes: authenticationRequest.scopes || OIDC_DEFAULT_SCOPES
        };
      } else {
        logger.trace("useMsalAuthentication - acquireToken - No request object provided, using default request.");
        tokenRequest = {
          scopes: OIDC_DEFAULT_SCOPES
        };
      }
      if (!tokenRequest.account && account) {
        logger.trace("useMsalAuthentication - acquireToken - Attaching account to request");
        tokenRequest.account = account;
      }
      const getToken = async () => {
        logger.verbose("useMsalAuthentication - Calling acquireTokenSilent");
        return instance.acquireTokenSilent(tokenRequest).catch(async (e) => {
          if (e instanceof InteractionRequiredAuthError) {
            if (!interactionInProgress2.current) {
              logger.error("useMsalAuthentication - Interaction required, falling back to interaction");
              return login(fallbackInteractionType, tokenRequest);
            } else {
              logger.error("useMsalAuthentication - Interaction required but is already in progress. Please try again, if needed, after interaction completes.");
              throw ReactAuthError.createUnableToFallbackToInteractionError();
            }
          }
          throw e;
        });
      };
      return getToken().then((response) => {
        if (mounted.current) {
          setResponse([response, null]);
        }
        return response;
      }).catch((e) => {
        if (mounted.current) {
          setResponse([null, e]);
        }
        throw e;
      });
    }, [
      instance,
      interactionType,
      authenticationRequest,
      logger,
      account,
      login
    ]);
    (0, import_react16.useEffect)(() => {
      const callbackId = instance.addEventCallback((message) => {
        switch (message.eventType) {
          case EventType.LOGIN_SUCCESS:
          case EventType.SSO_SILENT_SUCCESS:
            if (message.payload) {
              setResponse([
                message.payload,
                null
              ]);
            }
            break;
          case EventType.LOGIN_FAILURE:
          case EventType.SSO_SILENT_FAILURE:
            if (message.error) {
              setResponse([null, message.error]);
            }
            break;
        }
      });
      logger.verbose(`useMsalAuthentication - Registered event callback with id: ${callbackId}`);
      return () => {
        if (callbackId) {
          logger.verbose(`useMsalAuthentication - Removing event callback ${callbackId}`);
          instance.removeEventCallback(callbackId);
        }
      };
    }, [instance, logger]);
    (0, import_react16.useEffect)(() => {
      if (shouldAcquireToken.current && inProgress === InteractionStatus.None) {
        if (!isAuthenticated2) {
          shouldAcquireToken.current = false;
          logger.info("useMsalAuthentication - No user is authenticated, attempting to login");
          login().catch(() => {
            return;
          });
        } else if (account) {
          shouldAcquireToken.current = false;
          logger.info("useMsalAuthentication - User is authenticated, attempting to acquire token");
          acquireToken().catch(() => {
            return;
          });
        }
      }
    }, [isAuthenticated2, account, inProgress, login, acquireToken, logger]);
    return {
      login,
      acquireToken,
      result,
      error
    };
  }

  // ../../node_modules/@azure/msal-react/dist/components/MsalAuthenticationTemplate.js
  function MsalAuthenticationTemplate({ interactionType, username, homeAccountId, localAccountId, authenticationRequest, loadingComponent: LoadingComponent, errorComponent: ErrorComponent, children: children2 }) {
    const accountIdentifier = (0, import_react17.useMemo)(() => {
      return {
        username,
        homeAccountId,
        localAccountId
      };
    }, [username, homeAccountId, localAccountId]);
    const context = useMsal();
    const msalAuthResult = useMsalAuthentication(interactionType, authenticationRequest, accountIdentifier);
    const isAuthenticated2 = useIsAuthenticated(accountIdentifier);
    if (msalAuthResult.error && context.inProgress === InteractionStatus.None) {
      if (!!ErrorComponent) {
        return import_react17.default.createElement(ErrorComponent, { ...msalAuthResult });
      }
      throw msalAuthResult.error;
    }
    if (isAuthenticated2) {
      return import_react17.default.createElement(import_react17.default.Fragment, null, getChildrenOrFunction(children2, msalAuthResult));
    }
    if (!!LoadingComponent && context.inProgress !== InteractionStatus.None) {
      return import_react17.default.createElement(LoadingComponent, { ...context });
    }
    return null;
  }

  // ../../node_modules/@azure/msal-react/dist/components/withMsal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react18 = __toESM(require_react(), 1);

  // ../../packages/aihappey-auth/dist/msal/provider.js
  var createMsalInstance = (config) => new PublicClientApplication({
    auth: {
      clientId: config.clientId,
      authority: config.authority,
      redirectUri: config.redirectUri
    },
    cache: {
      cacheLocation: "localStorage"
    }
  });
  var MsalAuthProvider = ({ instance, children: children2 }) => (0, import_jsx_runtime3.jsx)(MsalProvider, { instance, children: children2 });

  // ../../packages/aihappey-auth/dist/initAuth.js
  var _authConfig = null;
  var _msalInstance = null;
  var _storage = localStorageAuth;
  function initAuth(config) {
    _authConfig = config;
    _storage = config.storage || localStorageAuth;
    _msalInstance = createMsalInstance(config.msal);
    return _msalInstance;
  }
  function getAuthConfig() {
    return _authConfig;
  }
  function getMsalInstance() {
    return _msalInstance;
  }

  // ../../packages/aihappey-auth/dist/msal/acquireToken.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  async function acquireAccessToken(scopes) {
    const msal = getMsalInstance();
    if (!msal)
      throw new Error("MSAL not initialised \u2013 did you call initAuth()?");
    const accounts = msal.getAllAccounts();
    if (!accounts.length)
      throw new Error("No signed-in account");
    const req = { scopes: scopes ?? getAuthConfig()?.msal.scopes ?? [], account: accounts[0] };
    try {
      const res = await msal.acquireTokenSilent(req);
      return res.accessToken;
    } catch {
      const res = await msal.acquireTokenPopup(req);
      return res.accessToken;
    }
  }

  // ../../packages/aihappey-mcp/dist/connect.js
  var needsOAuth = (err) => {
    if (!err)
      return false;
    if (err.toString() == "Error: Error POSTing to endpoint (HTTP 401): Invalid or missing token")
      return true;
    if (err.toString() == "Error: SSE error: Non-200 status code (401)")
      return true;
    if (err.status === 401 || err.status === 403)
      return true;
    if (typeof err === "object" && (err.error === "oauth_required" || err.code === "oauth_required"))
      return true;
    if (err.headers && typeof err.headers.get === "function") {
      const www = err.headers.get("WWW-Authenticate");
      if (www && www.includes("Bearer"))
        return true;
    }
    return false;
  };
  async function connectMcpServer(url, opts) {
    const headers = { ...opts?.headers };
    let token2 = opts?.token || getMcpAccessToken(url);
    if (token2)
      headers["Authorization"] = `Bearer ${token2}`;
    const client = new Client({
      name: "web-client",
      version: "1.0.0",
      headers
    }, {
      capabilities: {
        sampling: opts?.onSample ? {} : void 0
      }
    });
    const baseUrl = new URL(url);
    const transport = new StreamableHTTPClientTransport(baseUrl, {
      requestInit: { headers }
    });
    if (opts?.onSample) {
      client.setRequestHandler(CreateMessageRequestSchema, async ({ params }) => await opts.onSample(params));
    }
    if (opts?.onLogging) {
      client.setNotificationHandler(LoggingMessageNotificationSchema, async ({ params }) => await opts?.onLogging(params));
    }
    if (opts?.onProgress) {
      client.setNotificationHandler(ProgressNotificationSchema, async ({ params }) => await opts?.onProgress(params));
    }
    try {
      await client.connect(transport);
    } catch (err) {
      if (needsOAuth(err)) {
        await initiateMcpOAuthFlow(url);
        throw new Error("Redirecting for OAuth");
      }
      throw err;
    }
    const capabilities = client.getServerCapabilities?.() ?? null;
    let tools = void 0;
    if (capabilities?.tools) {
      const res = await client.listTools();
      tools = res.tools;
    }
    let resources = void 0;
    if (capabilities?.resources) {
      const res = await client.listResources();
      resources = res.resources;
    }
    let prompts = void 0;
    if (capabilities?.prompts) {
      const res = await client.listPrompts();
      prompts = res.prompts;
    }
    return { client, capabilities, tools, prompts, resources };
  }

  // ../../packages/aihappey-state/dist/slices/mcpSlice.js
  var createMcpSlice = (set, get, store2) => ({
    clients: {},
    status: {},
    errors: {},
    capabilities: {},
    tools: {},
    prompts: {},
    resources: {},
    resourceResults: [],
    notifications: [],
    sampling: {},
    progress: [],
    addSamplingRequest: (id, notif) => set((state) => ({
      sampling: { ...state.sampling, [id]: [notif] }
    })),
    addSamplingResponse: (id, notif) => set((state) => ({
      sampling: {
        ...state.sampling,
        [id]: state.sampling[id] ? [state.sampling[id][0], notif] : [void 0, notif]
      }
    })),
    clearSampling: () => set((state) => ({
      sampling: {}
    })),
    addNotification: (notif) => set((state) => ({
      notifications: [...state.notifications, notif]
    })),
    clearNotifications: () => set((state) => {
      return { notifications: [] };
    }),
    addProgress: (notif) => set((state) => ({
      progress: [...state.progress, notif]
    })),
    clearProgress: () => set((state) => {
      return { progress: [] };
    }),
    tokens: {},
    setToken: (url, token2) => {
      set((state) => ({
        tokens: { ...state.tokens, [url]: token2 }
      }));
    },
    clearToken: (url) => {
      set((state) => {
        const newTokens = { ...state.tokens };
        delete newTokens[url];
        return { tokens: newTokens };
      });
    },
    readResource: async (uri) => {
      const { resources, clients, resourceResults } = get();
      const url = Object.keys(resources).find((url2) => (resources[url2] || []).some((r) => r.uri === uri));
      if (!url)
        return;
      const client = clients[url];
      if (!client?.readResource)
        return;
      if (resourceResults.some((r) => r.uri === uri))
        return;
      try {
        const res = await client.readResource({ uri });
        console.log(res);
        set((state) => ({
          resourceResults: [...state.resourceResults, { uri, data: res }]
        }));
      } catch (e) {
        set((state) => ({
          errors: { ...state.errors, [url]: "Failed to read resource: " + (e?.message || String(e)) }
        }));
      }
    },
    callTool: async (toolCallId, name21, parameters) => {
      const { resources, clients, tools } = get();
      const url = Object.keys(resources).find((url2) => (tools[url2] || []).some((r) => r.name === name21));
      if (!url)
        return;
      const client = clients[url];
      if (!client?.callTool)
        return;
      try {
        const res = await client.callTool({
          name: name21,
          arguments: JSON.parse(parameters),
          resetTimeoutOnProgress: true,
          _meta: {
            progressToken: toolCallId
          }
        });
        return res;
      } catch (e) {
        set((state) => ({
          errors: { ...state.errors, [url]: "Failed to call tool: " + (e?.message || String(e)) }
        }));
      }
      return void 0;
    },
    removeResourceResult: (uri) => {
      set((state) => ({
        resourceResults: state.resourceResults.filter((r) => r.uri !== uri)
      }));
    },
    clearResourceResults: () => {
      set((state) => ({
        resourceResults: []
      }));
    },
    connect: async (url, opts) => {
      const { status, tokens: tokens2 } = get();
      if (status[url] === "connecting" || status[url] === "connected")
        return;
      set((state) => ({
        status: { ...state.status, [url]: "connecting" },
        errors: { ...state.errors, [url]: null }
      }));
      try {
        const token2 = opts?.token ?? tokens2[url];
        const connectOpts = {
          ...opts,
          token: token2,
          onSample: opts?.onSample,
          onLogging: opts?.onLogging,
          onProgress: opts?.onProgress
        };
        const { client, capabilities, tools, prompts, resources } = await connectMcpServer(url, connectOpts);
        set((state) => ({
          clients: { ...state.clients, [url]: client },
          status: { ...state.status, [url]: "connected" },
          capabilities: { ...state.capabilities, [url]: capabilities },
          tools: { ...state.tools, [url]: tools ?? [] },
          prompts: { ...state.prompts, [url]: prompts ?? [] },
          resources: { ...state.resources, [url]: resources ?? [] }
        }));
      } catch (err) {
        set((state) => ({
          status: { ...state.status, [url]: "error" },
          errors: { ...state.errors, [url]: err?.message || String(err) }
        }));
      }
    },
    disconnect: (url) => {
      const { clients } = get();
      if (clients[url]) {
        clients[url].close?.();
        const newClients = { ...clients };
        delete newClients[url];
        set((state) => ({
          clients: newClients,
          status: { ...state.status, [url]: "idle" },
          capabilities: { ...state.capabilities, [url]: null },
          tools: { ...state.tools, [url]: [] },
          prompts: { ...state.prompts, [url]: [] },
          resources: { ...state.resources, [url]: [] }
        }));
      }
    },
    refreshTools: async (url) => {
      const { clients } = get();
      const client = clients[url];
      if (!client)
        return;
      try {
        const res = await client.listTools();
        set((state) => ({
          tools: { ...state.tools, [url]: res.tools }
        }));
      } catch (e) {
        set((state) => ({
          errors: { ...state.errors, [url]: "Failed to fetch tools" }
        }));
      }
    },
    refreshPrompts: async (url) => {
      const { clients } = get();
      const client = clients[url];
      if (!client)
        return;
      try {
        const res = await client.listPrompts();
        set((state) => ({
          prompts: { ...state.prompts, [url]: res.prompts }
        }));
      } catch (e) {
        set((state) => ({
          errors: { ...state.errors, [url]: "Failed to fetch prompts" }
        }));
      }
    },
    refreshResources: async (url) => {
      const { clients } = get();
      const client = clients[url];
      if (!client)
        return;
      try {
        const res = await client.listResources();
        set((state) => ({
          resources: { ...state.resources, [url]: res.resources }
        }));
      } catch (e) {
        set((state) => ({
          errors: { ...state.errors, [url]: "Failed to fetch resources" }
        }));
      }
    }
  });

  // ../../packages/aihappey-state/dist/slices/uiSlice.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var createUiSlice = (set, get, store2) => ({
    showActivities: false,
    toggleActivities: () => set((s) => ({
      showActivities: !s.showActivities
    })),
    setActivities: (open) => set(() => ({
      showActivities: open
    }))
  });

  // ../../packages/aihappey-state/dist/persist.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/zustand/esm/middleware.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_meta4 = {};
  function createJSONStorage(getStorage, options) {
    let storage;
    try {
      storage = getStorage();
    } catch (_e) {
      return;
    }
    const persistStorage = {
      getItem: (name21) => {
        var _a17;
        const parse4 = (str2) => {
          if (str2 === null) {
            return null;
          }
          return JSON.parse(str2, options == null ? void 0 : options.reviver);
        };
        const str = (_a17 = storage.getItem(name21)) != null ? _a17 : null;
        if (str instanceof Promise) {
          return str.then(parse4);
        }
        return parse4(str);
      },
      setItem: (name21, newValue) => storage.setItem(
        name21,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      ),
      removeItem: (name21) => storage.removeItem(name21)
    };
    return persistStorage;
  }
  var toThenable = (fn) => (input) => {
    try {
      const result = fn(input);
      if (result instanceof Promise) {
        return result;
      }
      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },
        catch(_onRejected) {
          return this;
        }
      };
    } catch (e) {
      return {
        then(_onFulfilled) {
          return this;
        },
        catch(onRejected) {
          return toThenable(onRejected)(e);
        }
      };
    }
  };
  var oldImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      getStorage: () => localStorage,
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage;
    try {
      storage = options.getStorage();
    } catch (_e) {
    }
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const thenableSerialize = toThenable(options.serialize);
    const setItem = () => {
      const state = options.partialize({ ...get() });
      let errorInSync;
      const thenable = thenableSerialize({ state, version: options.version }).then(
        (serializedValue) => storage.setItem(options.name, serializedValue)
      ).catch((e) => {
        errorInSync = e;
      });
      if (errorInSync) {
        throw errorInSync;
      }
      return thenable;
    };
    const savedSetState = api.setState;
    api.setState = (state, replace4) => {
      savedSetState(state, replace4);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    let stateFromStorage;
    const hydrate = () => {
      var _a17;
      if (!storage) return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => cb(get()));
      const postRehydrationCallback = ((_a17 = options.onRehydrateStorage) == null ? void 0 : _a17.call(options, get())) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
        if (storageValue) {
          return options.deserialize(storageValue);
        }
      }).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a23;
        stateFromStorage = options.merge(
          migratedState,
          (_a23 = get()) != null ? _a23 : configResult
        );
        set(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.getStorage) {
          storage = newOptions.getStorage();
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    hydrate();
    return stateFromStorage || configResult;
  };
  var newImpl = (config, baseOptions) => (set, get, api) => {
    let options = {
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage = options.storage;
    if (!storage) {
      return config(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
          );
          set(...args);
        },
        get,
        api
      );
    }
    const setItem = () => {
      const state = options.partialize({ ...get() });
      return storage.setItem(options.name, {
        state,
        version: options.version
      });
    };
    const savedSetState = api.setState;
    api.setState = (state, replace4) => {
      savedSetState(state, replace4);
      void setItem();
    };
    const configResult = config(
      (...args) => {
        set(...args);
        void setItem();
      },
      get,
      api
    );
    api.getInitialState = () => configResult;
    let stateFromStorage;
    const hydrate = () => {
      var _a17, _b;
      if (!storage) return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => {
        var _a23;
        return cb((_a23 = get()) != null ? _a23 : configResult);
      });
      const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a17 = get()) != null ? _a17 : configResult)) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return [
                true,
                options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                )
              ];
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return [false, deserializedStorageValue.state];
          }
        }
        return [false, void 0];
      }).then((migrationResult) => {
        var _a23;
        const [migrated, migratedState] = migrationResult;
        stateFromStorage = options.merge(
          migratedState,
          (_a23 = get()) != null ? _a23 : configResult
        );
        set(stateFromStorage, true);
        if (migrated) {
          return setItem();
        }
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        stateFromStorage = get();
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.storage) {
          storage = newOptions.storage;
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    if (!options.skipHydration) {
      hydrate();
    }
    return stateFromStorage || configResult;
  };
  var persistImpl = (config, baseOptions) => {
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
      if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
        );
      }
      return oldImpl(config, baseOptions);
    }
    return newImpl(config, baseOptions);
  };
  var persist = persistImpl;

  // ../../packages/aihappey-state/dist/persist.js
  var withPersist = (creator) => persist(creator, {
    name: "aihappey_store_v3",
    partialize: (s) => ({
      servers: s.servers,
      selected: s.selected,
      selectedServers: s.selectedServers,
      conversations: s.conversations,
      selectedConversationId: s.selectedConversationId
    }),
    merge: (persisted, current) => ({
      ...current,
      ...persisted
    })
  });

  // ../../packages/aihappey-state/dist/createAppStore.js
  var createAppStore = () => create()(withPersist((set, get, store2) => ({
    ...createServersSlice(set, get, store2),
    ...createChatSlice(set, get, store2),
    ...createMcpSlice(set, get, store2),
    ...createUiSlice(set, get, store2)
  })));

  // ../../packages/aihappey-state/dist/index.js
  var store = createAppStore();
  var useAppStore = (selector) => useStore(store, selector);
  var useUi = () => useAppStore((s) => ({
    showActivities: s.showActivities,
    toggleActivities: s.toggleActivities,
    setActivities: s.setActivities
  }));

  // ../../packages/aihappey-core/dist/components/chat/useConversations.js
  var useConversations = () => {
    const conversations = useAppStore((s) => s.conversations);
    const selectedConversationId = useAppStore((s) => s.selectedConversationId);
    const createConversation = useAppStore((s) => s.createConversation);
    const updateConversationName = useAppStore((s) => s.updateConversationName);
    const removeConversation = useAppStore((s) => s.removeConversation);
    const selectConversation = useAppStore((s) => s.selectConversation);
    const getConversation = useAppStore((s) => s.getConversation);
    const addMessage = useAppStore((s) => s.addMessage);
    const updateMessage = useAppStore((s) => s.updateMessage);
    return {
      conversations,
      selectedConversationId,
      createConversation,
      updateConversationName,
      removeConversation,
      selectConversation,
      getConversation,
      addMessage,
      updateMessage
    };
  };

  // ../../packages/aihappey-core/dist/components/chat/useChatStore.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useChatStore = () => {
    const { chatStore, config } = useChatContext();
    const { selectedConversationId } = useConversations();
    const callTool = useAppStore((s) => s.callTool);
    return useChat({
      chatStore,
      onFinish: (opts) => console.log(opts),
      // SAVE ASSISTANT MESSAGE TO LOCALSTORE HERE
      onError: (err) => console.error(err),
      onToolCall: async ({ toolCall }) => {
        const result = await callTool(toolCall.toolCallId, toolCall.toolName, toolCall.args);
        await chatStore.addToolResult({
          chatId: selectedConversationId,
          toolCallId: toolCall.toolCallId,
          result: result ?? "something went wrong. Please try your tool call again"
        });
        return result;
      },
      id: selectedConversationId ?? void 0
    });
  };

  // ../../packages/aihappey-core/dist/components/pages/ChatPage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var import_react32 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/chat/ConversationSidebar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var import_react19 = __toESM(require_react());
  var ConversationSidebar = () => {
    const { conversations, selectedConversationId, createConversation, removeConversation, selectConversation } = useConversations();
    const { Button: Button3, Input: Input3 } = useTheme();
    const [editingId, setEditingId] = (0, import_react19.useState)(null);
    const [editValue, setEditValue] = (0, import_react19.useState)("");
    const { config } = useChatContext();
    const startEdit = (id, name21) => {
      setEditingId(id);
      setEditValue(name21);
    };
    const handleEditSubmit = (id) => {
      if (editValue.trim()) {
      }
      setEditingId(null);
    };
    return (0, import_jsx_runtime4.jsxs)("div", { style: { display: "flex", flexDirection: "column", height: "100%" }, children: [(0, import_jsx_runtime4.jsxs)("div", { style: {
      padding: 8,
      borderBottom: "1px solid #444",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    }, children: [(0, import_jsx_runtime4.jsx)("span", { style: { fontWeight: "bold" }, children: config.appName }), (0, import_jsx_runtime4.jsx)(Button3, { size: "sm", icon: "add", onClick: () => createConversation("New chat") })] }), (0, import_jsx_runtime4.jsx)("div", { style: { flex: 1, overflowY: "auto" }, children: conversations.map((conv) => (0, import_jsx_runtime4.jsx)("div", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      padding: "6px 12px",
      background: conv.id === selectedConversationId ? "#e6f0ff" : void 0,
      cursor: "pointer",
      borderBottom: "1px solid #eee"
    }, onClick: () => selectConversation(conv.id), children: editingId === conv.id ? (0, import_jsx_runtime4.jsx)(Input3, { value: editValue, autoFocus: true, onChange: (e) => setEditValue(e.target.value), onBlur: () => handleEditSubmit(conv.id), onKeyDown: (e) => {
      if (e.key === "Enter")
        handleEditSubmit(conv.id);
    }, style: { maxWidth: 120 } }) : (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [(0, import_jsx_runtime4.jsx)("span", { style: {
      maxWidth: 120,
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, children: conv.name }), (0, import_jsx_runtime4.jsxs)("span", { children: [(0, import_jsx_runtime4.jsx)(Button3, { size: "sm", variant: "subtle", icon: "edit", onClick: (e) => {
      e.stopPropagation();
      startEdit(conv.id, conv.name);
    } }), (0, import_jsx_runtime4.jsx)(Button3, { size: "sm", variant: "danger", icon: "delete", onClick: (e) => {
      e.stopPropagation();
      removeConversation(conv.id);
    } })] })] }) }, conv.id)) })] });
  };

  // ../../packages/aihappey-core/dist/components/chat/ChatPanel.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/components/chat/MessageInput.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var import_react25 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/prompt/PromptSelectButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var import_react21 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/prompt/PromptArgumentsModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var import_react20 = __toESM(require_react());
  var PromptArgumentsModal = ({ prompt, onHide, model }) => {
    const { Modal: Modal2, Button: Button3, Input: Input3, Spinner: Spinner3, Alert: Alert3 } = useTheme();
    const initialValues = Object.fromEntries((prompt.arguments ?? []).map((a) => [a.name, ""]));
    const [values, setValues] = (0, import_react20.useState)(initialValues);
    const [pending, setPending] = (0, import_react20.useState)(false);
    const [error, setError] = (0, import_react20.useState)(null);
    const client = useAppStore((s) => s.clients?.[prompt._url]);
    const { append: append2 } = useChatStore();
    const serializeContent = (c) => {
      if (!c)
        return "";
      if (typeof c === "string")
        return c;
      if (c.type === "text" && typeof c.text === "string")
        return c.text;
      return JSON.stringify(c);
    };
    const appendPromptMessages = async (messages) => {
      const parts = messages.map((m) => ({
        type: "text",
        text: m.content.text ?? JSON.stringify(m.content.resource.text)
      }));
      await append2({
        id: crypto.randomUUID(),
        role: "user",
        parts
      }, {
        body: {
          model
        }
      });
    };
    const missingRequired = (prompt.arguments ?? []).some((a) => a.required && !values[a.name]?.trim());
    const handleChange = (name21, value) => setValues((v) => ({ ...v, [name21]: value }));
    const handleOk = async () => {
      if (missingRequired || pending)
        return;
      if (!client || typeof client.getPrompt !== "function") {
        setError("Server client not available.");
        return;
      }
      setPending(true);
      setError(null);
      try {
        const result = await client.getPrompt({
          name: prompt.name,
          arguments: values
        });
        onHide();
        await appendPromptMessages(result.messages ?? []);
      } catch (err) {
        setError(err?.message ?? String(err));
      } finally {
        setPending(false);
      }
    };
    return (0, import_jsx_runtime5.jsxs)(Modal2, { show: true, onHide, title: `Fill arguments \u2013 ${prompt.name}`, children: [(0, import_jsx_runtime5.jsxs)("div", { style: { minWidth: 320, maxHeight: 400, overflowY: "auto" }, children: [(prompt.arguments ?? []).map((arg) => (0, import_jsx_runtime5.jsxs)("div", { style: { marginBottom: 12 }, children: [(0, import_jsx_runtime5.jsxs)("label", { style: { display: "block", fontWeight: 500, marginBottom: 4 }, children: [arg.name, arg.required && (0, import_jsx_runtime5.jsx)("span", { style: { color: "red" }, children: " *" })] }), arg.description && (0, import_jsx_runtime5.jsx)("div", { style: { fontSize: 12, color: "#666", marginBottom: 4 }, children: arg.description }), (0, import_jsx_runtime5.jsx)(Input3, { value: values[arg.name] ?? "", onChange: (e) => handleChange(arg.name, e.target.value), disabled: pending })] }, arg.name)), error && (0, import_jsx_runtime5.jsx)("div", { style: { marginTop: 4 }, children: (0, import_jsx_runtime5.jsx)(Alert3, { variant: "danger", children: error }) })] }), (0, import_jsx_runtime5.jsxs)("div", { style: {
      display: "flex",
      justifyContent: "flex-end",
      gap: 8,
      marginTop: 16
    }, children: [(0, import_jsx_runtime5.jsx)(Button3, { type: "button", onClick: onHide, disabled: pending, style: { minWidth: 80 }, children: "Cancel" }), (0, import_jsx_runtime5.jsx)(Button3, { type: "button", onClick: handleOk, disabled: pending || missingRequired, style: { minWidth: 80 }, children: pending ? (0, import_jsx_runtime5.jsx)(Spinner3, { size: "sm" }) : "OK" })] })] });
  };

  // ../../packages/aihappey-core/dist/components/prompt/PromptSelectButton.js
  var PromptSelectButton = ({ model }) => {
    const { Button: Button3 } = useTheme();
    const selected = useAppStore((s) => s.selected);
    const servers = useAppStore((s) => s.servers || {});
    const prompts = useAppStore((s) => s.prompts);
    const allPrompts = (0, import_react21.useMemo)(() => selected.flatMap((name21) => {
      const url = servers[name21]?.url;
      return url && Array.isArray(prompts[url]) ? prompts[url].map((p) => ({ ...p, _url: url })) : [];
    }), [selected, servers, prompts]);
    const [open, setOpen] = (0, import_react21.useState)(false);
    const [argumentPrompt, setArgumentPrompt] = (0, import_react21.useState)(null);
    if (allPrompts.length === 0)
      return null;
    return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)(Button3, { type: "button", icon: "prompts", onClick: () => setOpen(true), title: "Insert Prompt" }), open && (0, import_jsx_runtime6.jsx)(PromptSelectModal, { prompts: allPrompts, onPromptClick: (p) => {
      if (p.arguments && p.arguments.length > 0) {
        setArgumentPrompt(p);
      }
      setOpen(false);
    }, onHide: () => setOpen(false) }), argumentPrompt && (0, import_jsx_runtime6.jsx)(PromptArgumentsModal, { prompt: argumentPrompt, model, onHide: () => setArgumentPrompt(null) })] });
  };
  var PromptSelectModal = ({ prompts, onPromptClick, onHide }) => {
    const { Modal: Modal2, Button: Button3 } = useTheme();
    return (0, import_jsx_runtime6.jsxs)(Modal2, { show: true, onHide, title: "Select Prompt", children: [(0, import_jsx_runtime6.jsxs)("div", { style: {
      minWidth: 320,
      maxHeight: 400,
      overflowY: "auto",
      marginBottom: 16
    }, children: [prompts.length === 0 && (0, import_jsx_runtime6.jsx)("div", { style: { color: "#888" }, children: "No prompts available." }), prompts.map((prompt, idx) => (0, import_jsx_runtime6.jsxs)("div", { style: {
      border: "1px solid #eee",
      borderRadius: 6,
      padding: 8,
      marginBottom: 8,
      cursor: "pointer"
    }, onClick: () => onPromptClick(prompt), title: prompt.description || prompt.text || prompt.name, children: [(0, import_jsx_runtime6.jsx)("div", { style: { fontWeight: 500 }, children: prompt.name }), prompt.description && (0, import_jsx_runtime6.jsx)("div", { style: { color: "#888", fontSize: 13 }, children: prompt.description }), prompt.text && (0, import_jsx_runtime6.jsx)("div", { style: {
      color: "#444",
      fontSize: 13,
      marginTop: 4,
      whiteSpace: "pre-wrap"
    }, children: prompt.text })] }, prompt.name + idx))] }), (0, import_jsx_runtime6.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8 }, children: (0, import_jsx_runtime6.jsx)(Button3, { onClick: onHide, type: "button", style: { minWidth: 80 }, children: "Cancel" }) })] });
  };

  // ../../packages/aihappey-core/dist/components/resource/ResourceSelectButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var import_react22 = __toESM(require_react());
  var ResourceSelectButton = ({}) => {
    const { Button: Button3 } = useTheme();
    const selected = useAppStore((s) => s.selected);
    const servers = useAppStore((s) => s.servers || {});
    const resources = useAppStore((s) => s.resources);
    const readResource = useAppStore((s) => s.readResource);
    const allResources = (0, import_react22.useMemo)(() => selected.flatMap((name21) => {
      const url = servers[name21]?.url;
      return url && Array.isArray(resources[url]) ? resources[url].map((r) => ({ ...r, serverUrl: url })) : [];
    }), [selected, servers, resources]);
    const [open, setOpen] = (0, import_react22.useState)(false);
    if (allResources.length === 0)
      return null;
    return (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [(0, import_jsx_runtime7.jsx)(Button3, { type: "button", icon: "resources", onClick: () => setOpen(true), title: "Insert Resource" }), open && (0, import_jsx_runtime7.jsx)(ResourceSelectModal, { resources: allResources, onSelect: async (uri) => {
      setOpen(false);
      await readResource(uri);
    }, onHide: () => setOpen(false) })] });
  };
  var ResourceSelectModal = ({ resources, onSelect, onHide }) => {
    const { Modal: Modal2, Button: Button3 } = useTheme();
    return (0, import_jsx_runtime7.jsxs)(Modal2, { show: true, onHide, title: "Select Resource", children: [(0, import_jsx_runtime7.jsxs)("div", { style: {
      minWidth: 320,
      maxHeight: 400,
      overflowY: "auto",
      marginBottom: 16
    }, children: [resources.length === 0 && (0, import_jsx_runtime7.jsx)("div", { style: { color: "#888" }, children: "No resources available." }), resources.map((resource, idx) => (0, import_jsx_runtime7.jsxs)("div", { style: {
      border: "1px solid #eee",
      borderRadius: 6,
      padding: 8,
      marginBottom: 8,
      cursor: "pointer"
    }, onClick: () => onSelect(resource.uri), title: resource.description || resource.uri, children: [(0, import_jsx_runtime7.jsx)("div", { style: { fontWeight: 500 }, children: resource.name }), resource.description && (0, import_jsx_runtime7.jsx)("div", { style: { color: "#888", fontSize: 13 }, children: resource.description }), (0, import_jsx_runtime7.jsx)("div", { style: {
      color: "#444",
      fontSize: 13,
      marginTop: 4,
      wordBreak: "break-all"
    }, children: resource.uri })] }, resource.name + idx))] }), (0, import_jsx_runtime7.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8 }, children: (0, import_jsx_runtime7.jsx)(Button3, { onClick: onHide, type: "button", style: { minWidth: 80 }, children: "Cancel" }) })] });
  };

  // ../../packages/aihappey-core/dist/components/server/ServerSelectButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var import_react24 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/server/ServerSelectModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var import_react23 = __toESM(require_react());
  var ServerSelectModal = ({ show, onHide }) => {
    const { Modal: Modal2, Button: Button3 } = useTheme();
    const servers = useAppStore((s) => s.servers);
    const selected = useAppStore((s) => s.selected);
    const selectServers = useAppStore((s) => s.selectServers);
    const [checked, setChecked] = (0, import_react23.useState)(new Set(selected));
    const handleToggle = (name21) => {
      setChecked((prev2) => {
        const next2 = new Set(prev2);
        if (next2.has(name21))
          next2.delete(name21);
        else
          next2.add(name21);
        return next2;
      });
    };
    const handleOk = () => {
      selectServers(Array.from(checked));
      onHide();
    };
    const handleCancel = () => {
      setChecked(new Set(selected));
      onHide();
    };
    return (0, import_jsx_runtime8.jsxs)(Modal2, { show, onHide: handleCancel, title: "Select MCP Servers", children: [(0, import_jsx_runtime8.jsxs)("div", { style: {
      minWidth: 320,
      maxHeight: 400,
      overflowY: "auto",
      marginBottom: 16
    }, children: [Object.entries(servers).length === 0 && (0, import_jsx_runtime8.jsx)("div", { style: { color: "#888" }, children: "No servers available." }), Object.entries(servers).map(([name21, cfg]) => (0, import_jsx_runtime8.jsxs)("label", { style: {
      display: "flex",
      alignItems: "center",
      gap: 8,
      marginBottom: 8
    }, children: [(0, import_jsx_runtime8.jsx)("input", { type: "checkbox", checked: checked.has(name21), onChange: () => handleToggle(name21) }), (0, import_jsx_runtime8.jsx)("span", { children: name21 }), (0, import_jsx_runtime8.jsx)("span", { style: { color: "#888", fontSize: 12 }, children: cfg?.url })] }, name21))] }), (0, import_jsx_runtime8.jsxs)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8 }, children: [(0, import_jsx_runtime8.jsx)(Button3, { onClick: handleCancel, type: "button", style: { minWidth: 80 }, children: "Cancel" }), (0, import_jsx_runtime8.jsx)(Button3, { onClick: handleOk, type: "button", style: { minWidth: 80 }, children: "OK" })] })] });
  };

  // ../../packages/aihappey-core/dist/components/server/ServerSelectButton.js
  var ServerSelectButton = () => {
    const { Button: Button3 } = useTheme();
    const [open, setOpen] = (0, import_react24.useState)(false);
    return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [(0, import_jsx_runtime9.jsx)(Button3, { type: "button", icon: "mcpServer", onClick: () => setOpen(true), title: "Select MCP Servers" }), (0, import_jsx_runtime9.jsx)(ServerSelectModal, { show: open, onHide: () => setOpen(false) })] });
  };

  // ../../packages/aihappey-core/dist/components/chat/MessageInput.js
  var MessageInput = ({ onSend, disabled, model }) => {
    const { Input: Input3, Button: Button3 } = useTheme();
    const [value, setValue] = (0, import_react25.useState)("");
    const textareaRef = (0, import_react25.useRef)(null);
    const resourceResults = useAppStore((s) => s.resourceResults);
    const removeResourceResult = useAppStore((s) => s.removeResourceResult);
    const resources = useAppStore((s) => s.resources);
    const handleChange = (e) => {
      setValue(e.target.value);
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
        textareaRef.current.style.height = textareaRef.current.scrollHeight + "px";
      }
    };
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    };
    const handleSend = () => {
      const trimmed = value.trim();
      if (trimmed) {
        onSend(trimmed);
        setValue("");
        if (textareaRef.current) {
          textareaRef.current.style.height = "auto";
        }
      }
    };
    const insertText = (text9) => {
      if (textareaRef.current && document.activeElement === textareaRef.current) {
        const input = textareaRef.current;
        const start2 = input.selectionStart ?? value.length;
        const end = input.selectionEnd ?? value.length;
        const newValue = value.slice(0, start2) + text9 + value.slice(end);
        setValue(newValue);
        setTimeout(() => {
          input.selectionStart = input.selectionEnd = start2 + text9.length;
          input.focus();
        }, 0);
      } else {
        setValue((v) => v ? v + " " + text9 : text9);
      }
    };
    function getResourceName(uri) {
      for (const url of Object.keys(resources)) {
        const found = (resources[url] || []).find((r) => r.uri === uri);
        if (found)
          return found.name;
      }
      return uri;
    }
    return (0, import_jsx_runtime10.jsxs)("form", { onSubmit: (e) => {
      e.preventDefault();
      handleSend();
    }, style: {
      display: "flex",
      gap: 8,
      alignItems: "flex-end",
      flexDirection: "column"
    }, children: [resourceResults.length > 0 && (0, import_jsx_runtime10.jsx)("div", { style: { display: "flex", gap: 8, marginBottom: 4, width: "100%" }, children: resourceResults.map((r) => (0, import_jsx_runtime10.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      background: "#e6f0fa",
      borderRadius: 12,
      padding: "2px 10px",
      fontSize: 13,
      border: "1px solid #b3d1f7",
      color: "#1a3a5d",
      maxWidth: 220,
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, title: r.uri, children: [getResourceName(r.uri), (0, import_jsx_runtime10.jsx)("span", { style: {
      marginLeft: 8,
      cursor: "pointer",
      color: "#888",
      fontWeight: "bold",
      fontSize: 15,
      lineHeight: 1
    }, onClick: () => removeResourceResult(r.uri), title: "Remove", children: "\xD7" })] }, r.uri)) }), (0, import_jsx_runtime10.jsxs)("div", { style: {
      display: "flex",
      gap: 8,
      alignItems: "flex-end",
      width: "100%"
    }, children: [(0, import_jsx_runtime10.jsx)(ServerSelectButton, {}), (0, import_jsx_runtime10.jsx)(PromptSelectButton, { model }), (0, import_jsx_runtime10.jsx)(ResourceSelectButton, {}), (0, import_jsx_runtime10.jsx)(
      Input3,
      {
        //as="textarea"
        ref: textareaRef,
        //        rows={1}
        value,
        onChange: handleChange,
        onKeyDown: handleKeyDown,
        placeholder: "Ask anything",
        disabled,
        style: { resize: "none", minHeight: 38, maxHeight: 120, flex: 1 }
      }
    ), (0, import_jsx_runtime10.jsx)(Button3, { type: "submit", disabled: disabled || !value.trim(), icon: "send" })] })] });
  };

  // ../../packages/aihappey-core/dist/components/chat/MessageList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var MessageList = () => {
    const { messages } = useChatStore();
    const { Chat: Chat3 } = useTheme();
    const chatMessages = messages.flatMap((r) => r.parts.filter((a) => a.type == "text" || a.type == "reasoning").map((z) => ({
      content: z.text,
      role: r.role,
      id: r.id,
      createdAt: ""
    })));
    console.log(messages);
    return (0, import_jsx_runtime11.jsx)("div", { style: { flex: 1, overflowY: "auto", padding: 12 }, children: chatMessages.length > 0 && (0, import_jsx_runtime11.jsx)(Chat3, { messages: chatMessages }) });
  };

  // ../../packages/aihappey-core/dist/components/chat/ChatPanel.js
  var ChatPanel = ({ model }) => {
    const { append: append2, status } = useChatStore();
    const { Spinner: Spinner3 } = useTheme();
    const pending = status == "submitted" || status == "streaming";
    const resourceResults = useAppStore((s) => s.resourceResults);
    const tools = useAppStore((s) => s.tools);
    const clearResourceResults = useAppStore((s) => s.clearResourceResults);
    const handleSend = async (content3) => {
      const parts = [
        ...resourceResults.flatMap((r) => r.data.contents.map((z) => ({
          type: "text",
          text: toMarkdownLinkSmart(z.uri, z.text, z.mimeType)
        }))),
        { type: "text", text: content3 }
      ];
      await append2({
        id: crypto.randomUUID(),
        role: "user",
        parts
      }, {
        body: {
          model,
          tools: Object.values(tools).flat()
        }
      });
      clearResourceResults();
    };
    return (0, import_jsx_runtime12.jsxs)("div", { style: { display: "flex", flexDirection: "column", height: "100%" }, children: [(0, import_jsx_runtime12.jsx)(MessageList, {}), (0, import_jsx_runtime12.jsxs)("div", { style: { padding: 12, borderTop: "1px solid #eee" }, children: [pending && (0, import_jsx_runtime12.jsx)("div", { style: { marginTop: 8, textAlign: "center" }, children: (0, import_jsx_runtime12.jsx)(Spinner3, { size: "sm" }) }), (0, import_jsx_runtime12.jsx)(MessageInput, { model, onSend: handleSend, disabled: pending })] })] });
  };
  var toMarkdownLinkSmart = (uri, text9, mimeType = "text/plain") => {
    if (mimeType === "application/json") {
      try {
        const pretty = JSON.stringify(JSON.parse(text9), null, 2);
        return `[${uri}](${uri})

\`\`\`json
${pretty}
\`\`\``;
      } catch {
      }
    }
    if (mimeType === "text/markdown") {
      return `[${uri}](${uri})

${text9}`;
    }
    if (mimeType.startsWith("text/") || mimeType === "text/plain") {
      return `[${uri}](${uri})

${text9}`;
    }
    if (mimeType === "application/xml" || mimeType === "text/xml") {
      return `[${uri}](${uri})

\`\`\`xml
${text9}
\`\`\``;
    }
    return `[${uri}](${uri})

\`\`\`
${text9}
\`\`\``;
  };

  // ../../packages/aihappey-core/dist/components/chat/ChatHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var import_react27 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/chat/ModelSelect.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var ModelSelect = ({ models, value, onChange, disabled }) => {
    const { Select: Select3 } = useTheme();
    const SelectComponent = Select3 || "select";
    return (0, import_jsx_runtime13.jsx)(SelectComponent, { value, onChange: (e) => {
      const selectedValue = e?.target?.value ?? e?.currentTarget?.value ?? e;
      onChange(selectedValue);
    }, disabled, size: "large", style: { minWidth: 160, maxWidth: 240 }, "aria-label": "Model", children: models.map((model) => (0, import_jsx_runtime13.jsx)("option", { value: model.id, children: model.displayName }, model.id)) });
  };

  // ../../packages/aihappey-core/dist/components/chat/useModels.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react26 = __toESM(require_react());

  // ../../packages/aihappey-http/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var createHttpClient = (cfg = {}) => {
    const doFetch = async (input, init = {}) => {
      let headers = { ...cfg.headers || {} };
      if (cfg.getAccessToken) {
        const token2 = await cfg.getAccessToken();
        headers["Authorization"] = `Bearer ${token2}`;
      }
      if (init.headers)
        headers = { ...headers, ...init.headers };
      return (cfg.fetch || fetch)(input, { ...init, headers });
    };
    return {
      get: (url) => doFetch(url).then((r) => r.json())
      // put/post/delete helpers could be added here later
    };
  };

  // ../../packages/aihappey-core/dist/components/chat/useModels.js
  var useModels = (modelsApi, getAccessToken2) => {
    const [models, setModels] = (0, import_react26.useState)([]);
    const [loading, setLoading] = (0, import_react26.useState)(true);
    (0, import_react26.useEffect)(() => {
      const client = createHttpClient({ getAccessToken: getAccessToken2 });
      client.get(modelsApi).then(setModels).finally(() => setLoading(false));
    }, [modelsApi, getAccessToken2]);
    return { models, loading };
  };

  // ../../packages/aihappey-core/dist/components/chat/ChatHeader.js
  var ChatHeader = ({ value, onChange }) => {
    const { config } = useChatContext();
    const { models, loading } = useModels(config.modelsApi, config.getAccessToken);
    const { toggleActivities, showActivities } = useUi();
    const { Switch: Switch3 } = useTheme();
    (0, import_react27.useEffect)(() => {
      if (!loading && models.length && !value) {
        onChange(models[0].id);
      }
    }, [loading, models, value, onChange]);
    return (0, import_jsx_runtime14.jsxs)("div", { style: {
      position: "sticky",
      top: 0,
      zIndex: 10,
      height: 48,
      display: "flex",
      alignItems: "center",
      borderBottom: "1px solid #ddd",
      padding: "0 12px",
      gap: 16
    }, children: [(0, import_jsx_runtime14.jsx)(ModelSelect, { models, value: value ?? "", onChange, disabled: loading }), (0, import_jsx_runtime14.jsx)("div", { style: { flex: 1 } }), (0, import_jsx_runtime14.jsx)(Switch3, { onChange: toggleActivities, label: "Show Activities", id: "", checked: showActivities })] });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolInvocationsActivity.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/components/activity/tools/useToolInvocations.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useToolInvocations = () => {
    const { messages } = useChatStore();
    return messages.flatMap((m) => (m.parts || []).filter((p) => p.type === "tool-invocation" && p.toolInvocation).map((p) => ({
      msgId: m.id,
      role: m.role,
      ...p.toolInvocation
    })));
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolInvocationCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var import_react28 = __toESM(require_react());

  // ../../packages/aihappey-core/dist/components/activity/ShowJsonModal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var ShowJsonModal = ({ open, onClose, title, json }) => {
    const theme = useTheme();
    const jsonString = typeof json === "string" ? json : JSON.stringify(json, null, 2);
    if (!open)
      return null;
    const content3 = theme.TextArea ? theme.TextArea({ value: jsonString, readOnly: true, style: { width: "100%", minHeight: 180 } }) : (0, import_jsx_runtime15.jsx)("textarea", { value: jsonString, readOnly: true, style: { width: "100%", minHeight: 180, fontFamily: "monospace", fontSize: 13 } });
    return theme.Modal ? theme.Modal({
      show: open,
      onHide: onClose,
      title,
      children: (0, import_jsx_runtime15.jsxs)("div", { children: [content3, (0, import_jsx_runtime15.jsx)("div", { style: { marginTop: 16, textAlign: "right" }, children: theme.Button ? theme.Button({ children: "Close", onClick: onClose, size: "sm" }) : (0, import_jsx_runtime15.jsx)("button", { onClick: onClose, children: "Close" }) })] })
    }) : (0, import_jsx_runtime15.jsx)("div", { style: {
      position: "fixed",
      left: 0,
      top: 0,
      width: "100vw",
      height: "100vh",
      background: "rgba(0,0,0,0.3)",
      zIndex: 1e3,
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }, onClick: onClose, children: (0, import_jsx_runtime15.jsxs)("div", { style: {
      background: "#fff",
      borderRadius: 8,
      minWidth: 320,
      maxWidth: 520,
      padding: 24,
      boxShadow: "0 2px 16px rgba(0,0,0,0.18)"
    }, onClick: (e) => e.stopPropagation(), children: [(0, import_jsx_runtime15.jsx)("div", { style: { fontWeight: 600, fontSize: 16, marginBottom: 12 }, children: title }), content3, (0, import_jsx_runtime15.jsx)("div", { style: { marginTop: 16, textAlign: "right" }, children: (0, import_jsx_runtime15.jsx)("button", { onClick: onClose, children: "Close" }) })] }) });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolInvocationCard.js
  var ToolInvocationCard = ({ invocation }) => {
    const theme = useTheme();
    const [showArgs, setShowArgs] = (0, import_react28.useState)(false);
    let argsObj = {};
    try {
      argsObj = invocation.args ? JSON.parse(invocation.args) : {};
    } catch {
      argsObj = invocation.args || {};
    }
    const argsPreview = JSON.stringify(argsObj, null, 2);
    const truncatedArgs = argsPreview.length > 120 ? argsPreview.slice(0, 120) + "..." : argsPreview;
    return theme.Card({
      title: invocation.toolName,
      children: (0, import_jsx_runtime16.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 }, children: [(0, import_jsx_runtime16.jsx)("div", { children: (0, import_jsx_runtime16.jsx)("pre", { style: {
        maxWidth: 340,
        whiteSpace: "pre-wrap",
        wordBreak: "break-all",
        margin: 0,
        fontSize: 13
      }, children: truncatedArgs }) }), (0, import_jsx_runtime16.jsx)("div", { style: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        marginTop: 4
      }, children: argsPreview.length > 120 && (theme.Button ? theme.Button({
        size: "sm",
        children: "View raw",
        onClick: () => setShowArgs(true)
      }) : (0, import_jsx_runtime16.jsx)("button", { style: { fontSize: 12 }, onClick: () => setShowArgs(true), children: "View raw" })) }), showArgs && (0, import_jsx_runtime16.jsx)(ShowJsonModal, { open: showArgs, onClose: () => setShowArgs(false), title: "Tool Arguments", json: argsObj })] })
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolResultTextCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var import_react29 = __toESM(require_react());
  var ToolResultTextCard = ({ invocation, item, isError }) => {
    const theme = useTheme();
    const [showText, setShowText] = (0, import_react29.useState)(false);
    const preview = item.text.length > 120 ? item.text.slice(0, 120) + "..." : item.text;
    return theme.Card({
      title: "",
      children: (0, import_jsx_runtime17.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 }, children: [(0, import_jsx_runtime17.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [(0, import_jsx_runtime17.jsx)("b", { children: invocation.toolName }), theme.Badge ? theme.Badge({
        children: "text result"
      }) : (0, import_jsx_runtime17.jsx)("span", { style: {
        background: isError ? "#f8d7da" : "#d1e7dd",
        color: isError ? "#842029" : "#0f5132",
        borderRadius: 4,
        padding: "0 6px",
        fontSize: 12
      }, children: "text result" })] }), (0, import_jsx_runtime17.jsxs)("div", { children: [(0, import_jsx_runtime17.jsx)("div", { style: { fontSize: 13, color: "#666", marginBottom: 2 }, children: "Result (preview):" }), (0, import_jsx_runtime17.jsx)("pre", { style: {
        maxWidth: 340,
        whiteSpace: "pre-wrap",
        wordBreak: "break-all",
        margin: 0,
        fontSize: 13
      }, children: preview })] }), (0, import_jsx_runtime17.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", marginTop: 4 }, children: item.text.length > 0 && (theme.Button ? theme.Button({
        size: "sm",
        children: "Show full text",
        onClick: () => setShowText(true)
      }) : (0, import_jsx_runtime17.jsx)("button", { style: { fontSize: 12 }, onClick: () => setShowText(true), children: "Show full text" })) }), showText && (0, import_jsx_runtime17.jsx)(ShowJsonModal, { open: showText, onClose: () => setShowText(false), title: "Tool Result Text", json: item.text })] })
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolResultResourceCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var import_react30 = __toESM(require_react());
  var ToolResultResourceCard = ({ invocation, item, isError }) => {
    const theme = useTheme();
    const [showResource, setShowResource] = (0, import_react30.useState)(false);
    const [copied, setCopied] = (0, import_react30.useState)(false);
    const handleCopy = () => {
      navigator.clipboard.writeText(item.resource.uri);
      setCopied(true);
      setTimeout(() => setCopied(false), 1200);
    };
    return (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [theme.Card({
      title: invocation.toolName,
      text: item.resource.uri,
      actions: (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [theme.Button({
        size: "sm",
        children: "Open",
        onClick: () => window.open(item.resource.uri, "_blank")
      }), item.resource.text && theme.Button({
        size: "sm",
        children: "View",
        onClick: () => setShowResource(true)
      })] })
    }), showResource && (0, import_jsx_runtime18.jsx)(ShowJsonModal, { open: showResource, onClose: () => setShowResource(false), title: "Resource Content", json: item.resource.text })] });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolResultImageCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var ToolResultImageCard = ({ invocation, item, isError }) => {
    const theme = useTheme();
    const src = `data:${item.mimeType};base64,${item.data}`;
    return theme.Card({
      title: invocation.toolName,
      children: (0, import_jsx_runtime19.jsx)(theme.Image, { src })
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolResultAudioCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var ToolResultAudioCard = ({ invocation, item, isError }) => {
    const theme = useTheme();
    const src = `data:${item.mimeType};base64,${item.data}`;
    return theme.Card({
      title: invocation.toolName,
      children: (0, import_jsx_runtime20.jsxs)("audio", { controls: true, preload: "metadata", style: { width: "100%", outline: "none" }, children: [(0, import_jsx_runtime20.jsx)("source", { src, type: item.mimeType }), "Your browser does not support the HTML\xA0audio element."] })
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/tools/ToolInvocationsActivity.js
  var ToolInvocationsActivity = () => {
    const invocations = useToolInvocations();
    if (!invocations.length) {
      return (0, import_jsx_runtime21.jsx)("div", { style: { padding: 16, color: "#888" }, children: "No tool invocations found in this conversation." });
    }
    invocations.reverse();
    return (0, import_jsx_runtime21.jsx)("div", { style: { padding: 8, display: "flex", flexDirection: "column", gap: 12 }, children: invocations.flatMap((inv, i) => {
      const cards = [
        (0, import_jsx_runtime21.jsx)(ToolInvocationCard, { invocation: inv }, (inv.toolCallId || inv.msgId || i) + "-inv")
      ];
      if (inv.result?.content && Array.isArray(inv.result.content)) {
        inv.result.content.forEach((c, idx) => {
          if (c.type === "resource") {
            cards.push((0, import_jsx_runtime21.jsx)(ToolResultResourceCard, { invocation: inv, item: c, isError: inv.result.isError }, (inv.toolCallId || inv.msgId || i) + "-res-" + idx));
          } else if (c.type === "text") {
            cards.push((0, import_jsx_runtime21.jsx)(ToolResultTextCard, { invocation: inv, item: c, isError: inv.result.isError }, (inv.toolCallId || inv.msgId || i) + "-txt-" + idx));
          } else if (c.type === "image") {
            cards.push((0, import_jsx_runtime21.jsx)(ToolResultImageCard, { invocation: inv, item: c, isError: inv.result.isError }, (inv.toolCallId || inv.msgId || i) + "-img-" + idx));
          } else if (c.type === "audio") {
            cards.push((0, import_jsx_runtime21.jsx)(ToolResultAudioCard, { invocation: inv, item: c, isError: inv.result.isError }, (inv.toolCallId || inv.msgId || i) + "-audio-" + idx));
          }
        });
      }
      return cards;
    }) });
  };

  // ../../packages/aihappey-core/dist/components/activity/logging/LoggingNotificationsActivity.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/components/activity/logging/LoggingNotificationCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var LoggingNotificationCard = ({ notif }) => {
    const theme = useTheme();
    const level = String(notif.level || notif.type || "Notification");
    const message = String(notif.data || "");
    return theme.Card({
      title: notif.level,
      text: message
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/logging/LoggingNotificationsActivity.js
  var LoggingNotificationsActivity = () => {
    const notifications = useAppStore((s) => s.notifications);
    if (!notifications.length) {
      return (0, import_jsx_runtime22.jsx)("div", { className: "p-3 text-muted", children: "No notifications" });
    }
    notifications.reverse();
    return (0, import_jsx_runtime22.jsx)("div", { className: "p-3", style: { display: "flex", flexDirection: "column", gap: 8 }, children: notifications.map((n, i) => (0, import_jsx_runtime22.jsx)(LoggingNotificationCard, { notif: n }, i)) });
  };

  // ../../packages/aihappey-core/dist/components/activity/progress/ProgressNotificationsActivity.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/components/activity/progress/ProgressNotificationCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());

  // ../../node_modules/react-markdown/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/react-markdown/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/devlop/lib/default.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function ok() {
  }
  function unreachable() {
  }

  // ../../node_modules/hast-util-to-jsx-runtime/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/hast-util-to-jsx-runtime/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/comma-separated-tokens/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function stringify(values, options) {
    const settings = options || {};
    const input = values[values.length - 1] === "" ? [...values, ""] : values;
    return input.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }

  // ../../node_modules/estree-util-is-identifier-name/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/estree-util-is-identifier-name/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
  var nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
  var emptyOptions = {};
  function name20(name21, options) {
    const settings = options || emptyOptions;
    const re2 = settings.jsx ? nameReJsx : nameRe;
    return re2.test(name21);
  }

  // ../../node_modules/hast-util-whitespace/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/hast-util-whitespace/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var re = /[ \t\n\f\r]/g;
  function whitespace(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
  }
  function empty(value) {
    return value.replace(re, "") === "";
  }

  // ../../node_modules/property-information/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/merge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/schema.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Schema = class {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(property, normal, space2) {
      this.normal = normal;
      this.property = property;
      if (space2) {
        this.space = space2;
      }
    }
  };
  Schema.prototype.normal = {};
  Schema.prototype.property = {};
  Schema.prototype.space = void 0;

  // ../../node_modules/property-information/lib/util/merge.js
  function merge(definitions, space2) {
    const property = {};
    const normal = {};
    for (const definition3 of definitions) {
      Object.assign(property, definition3.property);
      Object.assign(normal, definition3.normal);
    }
    return new Schema(property, normal, space2);
  }

  // ../../node_modules/property-information/lib/aria.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/create.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/normalize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function normalize(value) {
    return value.toLowerCase();
  }

  // ../../node_modules/property-information/lib/util/defined-info.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/info.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Info = class {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(property, attribute) {
      this.attribute = attribute;
      this.property = property;
    }
  };
  Info.prototype.attribute = "";
  Info.prototype.booleanish = false;
  Info.prototype.boolean = false;
  Info.prototype.commaOrSpaceSeparated = false;
  Info.prototype.commaSeparated = false;
  Info.prototype.defined = false;
  Info.prototype.mustUseProperty = false;
  Info.prototype.number = false;
  Info.prototype.overloadedBoolean = false;
  Info.prototype.property = "";
  Info.prototype.spaceSeparated = false;
  Info.prototype.space = void 0;

  // ../../node_modules/property-information/lib/util/types.js
  var types_exports = {};
  __export(types_exports, {
    boolean: () => boolean,
    booleanish: () => booleanish,
    commaOrSpaceSeparated: () => commaOrSpaceSeparated,
    commaSeparated: () => commaSeparated,
    number: () => number,
    overloadedBoolean: () => overloadedBoolean,
    spaceSeparated: () => spaceSeparated
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var powers = 0;
  var boolean = increment();
  var booleanish = increment();
  var overloadedBoolean = increment();
  var number = increment();
  var spaceSeparated = increment();
  var commaSeparated = increment();
  var commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }

  // ../../node_modules/property-information/lib/util/defined-info.js
  var checks = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(types_exports)
  );
  var DefinedInfo = class extends Info {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(property, attribute, mask, space2) {
      let index2 = -1;
      super(property, attribute);
      mark(this, "space", space2);
      if (typeof mask === "number") {
        while (++index2 < checks.length) {
          const check = checks[index2];
          mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
        }
      }
    }
  };
  DefinedInfo.prototype.defined = true;
  function mark(values, key, value) {
    if (value) {
      values[key] = value;
    }
  }

  // ../../node_modules/property-information/lib/util/create.js
  function create2(definition3) {
    const properties2 = {};
    const normals = {};
    for (const [property, value] of Object.entries(definition3.properties)) {
      const info = new DefinedInfo(
        property,
        definition3.transform(definition3.attributes || {}, property),
        value,
        definition3.space
      );
      if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
        info.mustUseProperty = true;
      }
      properties2[property] = info;
      normals[normalize(property)] = property;
      normals[normalize(info.attribute)] = property;
    }
    return new Schema(properties2, normals, definition3.space);
  }

  // ../../node_modules/property-information/lib/aria.js
  var aria = create2({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number,
      ariaColIndex: number,
      ariaColSpan: number,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number,
      ariaRowIndex: number,
      ariaRowSpan: number,
      ariaSelected: booleanish,
      ariaSetSize: number,
      ariaSort: null,
      ariaValueMax: number,
      ariaValueMin: number,
      ariaValueNow: number,
      ariaValueText: null,
      role: null
    },
    transform(_, property) {
      return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
    }
  });

  // ../../node_modules/property-information/lib/html.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/case-insensitive-transform.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/property-information/lib/util/case-sensitive-transform.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }

  // ../../node_modules/property-information/lib/util/case-insensitive-transform.js
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }

  // ../../node_modules/property-information/lib/html.js
  var html = create2({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number,
      hidden: overloadedBoolean,
      high: number,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number,
      manifest: null,
      max: null,
      maxLength: number,
      media: null,
      method: null,
      min: null,
      minLength: number,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number,
      rowSpan: number,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootClonable: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number,
      sizes: null,
      slot: null,
      span: number,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number,
      step: null,
      style: null,
      tabIndex: number,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number,
      // `<img>` and `<object>`
      leftMargin: number,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number,
      // `<body>`
      marginWidth: number,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: caseInsensitiveTransform
  });

  // ../../node_modules/property-information/lib/svg.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var svg = create2({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number,
      amplitude: number,
      arabicForm: null,
      ascent: number,
      attributeName: null,
      attributeType: null,
      azimuth: number,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number,
      by: null,
      calcMode: null,
      capHeight: number,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number,
      diffuseConstant: number,
      direction: null,
      display: null,
      dur: null,
      divisor: number,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number,
      horizOriginX: number,
      horizOriginY: number,
      id: null,
      ideographic: number,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number,
      k: number,
      k1: number,
      k2: number,
      k3: number,
      k4: number,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number,
      overlineThickness: number,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number,
      pointsAtY: number,
      pointsAtZ: number,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number,
      specularExponent: number,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number,
      strikethroughThickness: number,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number,
      strokeOpacity: number,
      strokeWidth: null,
      style: null,
      surfaceScale: number,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number,
      tableValues: null,
      target: null,
      targetX: number,
      targetY: number,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number,
      underlineThickness: number,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number,
      values: null,
      vAlphabetic: number,
      vMathematical: number,
      vectorEffect: null,
      vHanging: number,
      vIdeographic: number,
      version: null,
      vertAdvY: number,
      vertOriginX: number,
      vertOriginY: number,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: caseSensitiveTransform
  });

  // ../../node_modules/property-information/lib/xlink.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var xlink = create2({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(_, property) {
      return "xlink:" + property.slice(5).toLowerCase();
    }
  });

  // ../../node_modules/property-information/lib/xmlns.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var xmlns = create2({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: caseInsensitiveTransform
  });

  // ../../node_modules/property-information/lib/xml.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var xml = create2({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(_, property) {
      return "xml:" + property.slice(3).toLowerCase();
    }
  });

  // ../../node_modules/property-information/lib/hast-to-react.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var hastToReact = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  };

  // ../../node_modules/property-information/lib/find.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cap = /[A-Z]/g;
  var dash = /-[a-z]/g;
  var valid = /^data[-\w.:]+$/i;
  function find(schema, value) {
    const normal = normalize(value);
    let property = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase);
        property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(property, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }

  // ../../node_modules/property-information/index.js
  var html2 = merge([aria, html, xlink, xmlns, xml], "html");
  var svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");

  // ../../node_modules/space-separated-tokens/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function stringify2(values) {
    return values.join(" ").trim();
  }

  // ../../node_modules/hast-util-to-jsx-runtime/lib/index.js
  var import_style_to_js = __toESM(require_cjs2(), 1);

  // ../../node_modules/unist-util-position/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-position/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var pointEnd = point("end");
  var pointStart = point("start");
  function point(type) {
    return point4;
    function point4(node3) {
      const point5 = node3 && node3.position && node3.position[type] || {};
      if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
        return {
          line: point5.line,
          column: point5.column,
          offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
        };
      }
    }
  }
  function position(node3) {
    const start2 = pointStart(node3);
    const end = pointEnd(node3);
    if (start2 && end) {
      return { start: start2, end };
    }
  }

  // ../../node_modules/vfile-message/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/vfile-message/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-stringify-position/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-stringify-position/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position2(value.position);
    }
    if ("start" in value || "end" in value) {
      return position2(value);
    }
    if ("line" in value || "column" in value) {
      return point2(value);
    }
    return "";
  }
  function point2(point4) {
    return index(point4 && point4.line) + ":" + index(point4 && point4.column);
  }
  function position2(pos) {
    return point2(pos && pos.start) + "-" + point2(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }

  // ../../node_modules/vfile-message/lib/index.js
  var VFileMessage = class extends Error {
    /**
     * Create a message for `reason`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(causeOrReason, optionsOrParentOrPlace, origin) {
      super();
      if (typeof optionsOrParentOrPlace === "string") {
        origin = optionsOrParentOrPlace;
        optionsOrParentOrPlace = void 0;
      }
      let reason = "";
      let options = {};
      let legacyCause = false;
      if (optionsOrParentOrPlace) {
        if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
          options = { place: optionsOrParentOrPlace };
        } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
          options = { place: optionsOrParentOrPlace };
        } else if ("type" in optionsOrParentOrPlace) {
          options = {
            ancestors: [optionsOrParentOrPlace],
            place: optionsOrParentOrPlace.position
          };
        } else {
          options = { ...optionsOrParentOrPlace };
        }
      }
      if (typeof causeOrReason === "string") {
        reason = causeOrReason;
      } else if (!options.cause && causeOrReason) {
        legacyCause = true;
        reason = causeOrReason.message;
        options.cause = causeOrReason;
      }
      if (!options.ruleId && !options.source && typeof origin === "string") {
        const index2 = origin.indexOf(":");
        if (index2 === -1) {
          options.ruleId = origin;
        } else {
          options.source = origin.slice(0, index2);
          options.ruleId = origin.slice(index2 + 1);
        }
      }
      if (!options.place && options.ancestors && options.ancestors) {
        const parent = options.ancestors[options.ancestors.length - 1];
        if (parent) {
          options.place = parent.position;
        }
      }
      const start2 = options.place && "start" in options.place ? options.place.start : options.place;
      this.ancestors = options.ancestors || void 0;
      this.cause = options.cause || void 0;
      this.column = start2 ? start2.column : void 0;
      this.fatal = void 0;
      this.file;
      this.message = reason;
      this.line = start2 ? start2.line : void 0;
      this.name = stringifyPosition(options.place) || "1:1";
      this.place = options.place || void 0;
      this.reason = this.message;
      this.ruleId = options.ruleId || void 0;
      this.source = options.source || void 0;
      this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
      this.actual;
      this.expected;
      this.note;
      this.url;
    }
  };
  VFileMessage.prototype.file = "";
  VFileMessage.prototype.name = "";
  VFileMessage.prototype.reason = "";
  VFileMessage.prototype.message = "";
  VFileMessage.prototype.stack = "";
  VFileMessage.prototype.column = void 0;
  VFileMessage.prototype.line = void 0;
  VFileMessage.prototype.ancestors = void 0;
  VFileMessage.prototype.cause = void 0;
  VFileMessage.prototype.fatal = void 0;
  VFileMessage.prototype.place = void 0;
  VFileMessage.prototype.ruleId = void 0;
  VFileMessage.prototype.source = void 0;

  // ../../node_modules/hast-util-to-jsx-runtime/lib/index.js
  var own = {}.hasOwnProperty;
  var emptyMap = /* @__PURE__ */ new Map();
  var cap2 = /[A-Z]/g;
  var tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
  var tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
  var docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function toJsxRuntime(tree, options) {
    if (!options || options.Fragment === void 0) {
      throw new TypeError("Expected `Fragment` in options");
    }
    const filePath = options.filePath || void 0;
    let create3;
    if (options.development) {
      if (typeof options.jsxDEV !== "function") {
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      }
      create3 = developmentCreate(filePath, options.jsxDEV);
    } else {
      if (typeof options.jsx !== "function") {
        throw new TypeError("Expected `jsx` in production options");
      }
      if (typeof options.jsxs !== "function") {
        throw new TypeError("Expected `jsxs` in production options");
      }
      create3 = productionCreate(filePath, options.jsx, options.jsxs);
    }
    const state = {
      Fragment: options.Fragment,
      ancestors: [],
      components: options.components || {},
      create: create3,
      elementAttributeNameCase: options.elementAttributeNameCase || "react",
      evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
      filePath,
      ignoreInvalidStyle: options.ignoreInvalidStyle || false,
      passKeys: options.passKeys !== false,
      passNode: options.passNode || false,
      schema: options.space === "svg" ? svg2 : html2,
      stylePropertyNameCase: options.stylePropertyNameCase || "dom",
      tableCellAlignToStyle: options.tableCellAlignToStyle !== false
    };
    const result = one(state, tree, void 0);
    if (result && typeof result !== "string") {
      return result;
    }
    return state.create(
      tree,
      state.Fragment,
      { children: result || void 0 },
      void 0
    );
  }
  function one(state, node3, key) {
    if (node3.type === "element") {
      return element(state, node3, key);
    }
    if (node3.type === "mdxFlowExpression" || node3.type === "mdxTextExpression") {
      return mdxExpression(state, node3);
    }
    if (node3.type === "mdxJsxFlowElement" || node3.type === "mdxJsxTextElement") {
      return mdxJsxElement(state, node3, key);
    }
    if (node3.type === "mdxjsEsm") {
      return mdxEsm(state, node3);
    }
    if (node3.type === "root") {
      return root(state, node3, key);
    }
    if (node3.type === "text") {
      return text2(state, node3);
    }
  }
  function element(state, node3, key) {
    const parentSchema = state.schema;
    let schema = parentSchema;
    if (node3.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
      schema = svg2;
      state.schema = schema;
    }
    state.ancestors.push(node3);
    const type = findComponentFromName(state, node3.tagName, false);
    const props = createElementProps(state, node3);
    let children2 = createChildren(state, node3);
    if (tableElements.has(node3.tagName)) {
      children2 = children2.filter(function(child) {
        return typeof child === "string" ? !whitespace(child) : true;
      });
    }
    addNode(state, props, type, node3);
    addChildren(props, children2);
    state.ancestors.pop();
    state.schema = parentSchema;
    return state.create(node3, type, props, key);
  }
  function mdxExpression(state, node3) {
    if (node3.data && node3.data.estree && state.evaluater) {
      const program = node3.data.estree;
      const expression = program.body[0];
      ok(expression.type === "ExpressionStatement");
      return (
        /** @type {Child | undefined} */
        state.evaluater.evaluateExpression(expression.expression)
      );
    }
    crashEstree(state, node3.position);
  }
  function mdxEsm(state, node3) {
    if (node3.data && node3.data.estree && state.evaluater) {
      return (
        /** @type {Child | undefined} */
        state.evaluater.evaluateProgram(node3.data.estree)
      );
    }
    crashEstree(state, node3.position);
  }
  function mdxJsxElement(state, node3, key) {
    const parentSchema = state.schema;
    let schema = parentSchema;
    if (node3.name === "svg" && parentSchema.space === "html") {
      schema = svg2;
      state.schema = schema;
    }
    state.ancestors.push(node3);
    const type = node3.name === null ? state.Fragment : findComponentFromName(state, node3.name, true);
    const props = createJsxElementProps(state, node3);
    const children2 = createChildren(state, node3);
    addNode(state, props, type, node3);
    addChildren(props, children2);
    state.ancestors.pop();
    state.schema = parentSchema;
    return state.create(node3, type, props, key);
  }
  function root(state, node3, key) {
    const props = {};
    addChildren(props, createChildren(state, node3));
    return state.create(node3, state.Fragment, props, key);
  }
  function text2(_, node3) {
    return node3.value;
  }
  function addNode(state, props, type, node3) {
    if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
      props.node = node3;
    }
  }
  function addChildren(props, children2) {
    if (children2.length > 0) {
      const value = children2.length > 1 ? children2 : children2[0];
      if (value) {
        props.children = value;
      }
    }
  }
  function productionCreate(_, jsx5, jsxs3) {
    return create3;
    function create3(_2, type, props, key) {
      const isStaticChildren = Array.isArray(props.children);
      const fn = isStaticChildren ? jsxs3 : jsx5;
      return key ? fn(type, props, key) : fn(type, props);
    }
  }
  function developmentCreate(filePath, jsxDEV) {
    return create3;
    function create3(node3, type, props, key) {
      const isStaticChildren = Array.isArray(props.children);
      const point4 = pointStart(node3);
      return jsxDEV(
        type,
        props,
        key,
        isStaticChildren,
        {
          columnNumber: point4 ? point4.column - 1 : void 0,
          fileName: filePath,
          lineNumber: point4 ? point4.line : void 0
        },
        void 0
      );
    }
  }
  function createElementProps(state, node3) {
    const props = {};
    let alignValue;
    let prop;
    for (prop in node3.properties) {
      if (prop !== "children" && own.call(node3.properties, prop)) {
        const result = createProperty(state, prop, node3.properties[prop]);
        if (result) {
          const [key, value] = result;
          if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node3.tagName)) {
            alignValue = value;
          } else {
            props[key] = value;
          }
        }
      }
    }
    if (alignValue) {
      const style = (
        /** @type {Style} */
        props.style || (props.style = {})
      );
      style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
    }
    return props;
  }
  function createJsxElementProps(state, node3) {
    const props = {};
    for (const attribute of node3.attributes) {
      if (attribute.type === "mdxJsxExpressionAttribute") {
        if (attribute.data && attribute.data.estree && state.evaluater) {
          const program = attribute.data.estree;
          const expression = program.body[0];
          ok(expression.type === "ExpressionStatement");
          const objectExpression = expression.expression;
          ok(objectExpression.type === "ObjectExpression");
          const property = objectExpression.properties[0];
          ok(property.type === "SpreadElement");
          Object.assign(
            props,
            state.evaluater.evaluateExpression(property.argument)
          );
        } else {
          crashEstree(state, node3.position);
        }
      } else {
        const name21 = attribute.name;
        let value;
        if (attribute.value && typeof attribute.value === "object") {
          if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
            const program = attribute.value.data.estree;
            const expression = program.body[0];
            ok(expression.type === "ExpressionStatement");
            value = state.evaluater.evaluateExpression(expression.expression);
          } else {
            crashEstree(state, node3.position);
          }
        } else {
          value = attribute.value === null ? true : attribute.value;
        }
        props[name21] = /** @type {Props[keyof Props]} */
        value;
      }
    }
    return props;
  }
  function createChildren(state, node3) {
    const children2 = [];
    let index2 = -1;
    const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
    while (++index2 < node3.children.length) {
      const child = node3.children[index2];
      let key;
      if (state.passKeys) {
        const name21 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
        if (name21) {
          const count = countsByName.get(name21) || 0;
          key = name21 + "-" + count;
          countsByName.set(name21, count + 1);
        }
      }
      const result = one(state, child, key);
      if (result !== void 0) children2.push(result);
    }
    return children2;
  }
  function createProperty(state, prop, value) {
    const info = find(state.schema, prop);
    if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
      return;
    }
    if (Array.isArray(value)) {
      value = info.commaSeparated ? stringify(value) : stringify2(value);
    }
    if (info.property === "style") {
      let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
      if (state.stylePropertyNameCase === "css") {
        styleObject = transformStylesToCssCasing(styleObject);
      }
      return ["style", styleObject];
    }
    return [
      state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
      value
    ];
  }
  function parseStyle(state, value) {
    try {
      return (0, import_style_to_js.default)(value, { reactCompat: true });
    } catch (error) {
      if (state.ignoreInvalidStyle) {
        return {};
      }
      const cause = (
        /** @type {Error} */
        error
      );
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: state.ancestors,
        cause,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      message.file = state.filePath || void 0;
      message.url = docs + "#cannot-parse-style-attribute";
      throw message;
    }
  }
  function findComponentFromName(state, name21, allowExpression) {
    let result;
    if (!allowExpression) {
      result = { type: "Literal", value: name21 };
    } else if (name21.includes(".")) {
      const identifiers = name21.split(".");
      let index2 = -1;
      let node3;
      while (++index2 < identifiers.length) {
        const prop = name20(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
        node3 = node3 ? {
          type: "MemberExpression",
          object: node3,
          property: prop,
          computed: Boolean(index2 && prop.type === "Literal"),
          optional: false
        } : prop;
      }
      ok(node3, "always a result");
      result = node3;
    } else {
      result = name20(name21) && !/^[a-z]/.test(name21) ? { type: "Identifier", name: name21 } : { type: "Literal", value: name21 };
    }
    if (result.type === "Literal") {
      const name23 = (
        /** @type {string | number} */
        result.value
      );
      return own.call(state.components, name23) ? state.components[name23] : name23;
    }
    if (state.evaluater) {
      return state.evaluater.evaluateExpression(result);
    }
    crashEstree(state);
  }
  function crashEstree(state, place) {
    const message = new VFileMessage(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: state.ancestors,
        place,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
      }
    );
    message.file = state.filePath || void 0;
    message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
    throw message;
  }
  function transformStylesToCssCasing(domCasing) {
    const cssCasing = {};
    let from2;
    for (from2 in domCasing) {
      if (own.call(domCasing, from2)) {
        cssCasing[transformStyleToCssCasing(from2)] = domCasing[from2];
      }
    }
    return cssCasing;
  }
  function transformStyleToCssCasing(from2) {
    let to = from2.replace(cap2, toDash);
    if (to.slice(0, 3) === "ms-") to = "-" + to;
    return to;
  }
  function toDash($0) {
    return "-" + $0.toLowerCase();
  }

  // ../../node_modules/html-url-attributes/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/html-url-attributes/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var urlAttributes = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: [
      "audio",
      "embed",
      "iframe",
      "img",
      "input",
      "script",
      "source",
      "track",
      "video"
    ]
  };

  // ../../node_modules/react-markdown/lib/index.js
  var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
  var import_react31 = __toESM(require_react(), 1);

  // ../../node_modules/remark-parse/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/remark-parse/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-from-markdown/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-from-markdown/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-string/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-string/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var emptyOptions2 = {};
  function toString(value, options) {
    const settings = options || emptyOptions2;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one2(value, includeImageAlt, includeHtml);
  }
  function one2(value, includeImageAlt, includeHtml) {
    if (node(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one2(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value) {
    return Boolean(value && typeof value === "object");
  }

  // ../../node_modules/micromark/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/decode-named-character-reference/index.dom.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var element2 = document.createElement("i");
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element2.innerHTML = characterReference2;
    const character2 = element2.textContent;
    if (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      character2.charCodeAt(character2.length - 1) === 59 && value !== "semi"
    ) {
      return false;
    }
    return character2 === characterReference2 ? false : character2;
  }

  // ../../node_modules/micromark-util-chunked/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function splice(list4, start2, remove, items) {
    const end = list4.length;
    let chunkStart = 0;
    let parameters;
    if (start2 < 0) {
      start2 = -start2 > end ? 0 : end + start2;
    } else {
      start2 = start2 > end ? end : start2;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start2, remove);
      list4.splice(...parameters);
    } else {
      if (remove) list4.splice(start2, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start2, 0);
        list4.splice(...parameters);
        chunkStart += 1e4;
        start2 += 1e4;
      }
    }
  }
  function push(list4, items) {
    if (list4.length > 0) {
      splice(list4, list4.length, 0, items);
      return list4;
    }
    return items;
  }

  // ../../node_modules/micromark-util-combine-extensions/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var hasOwnProperty = {}.hasOwnProperty;
  function combineExtensions(extensions) {
    const all2 = {};
    let index2 = -1;
    while (++index2 < extensions.length) {
      syntaxExtension(all2, extensions[index2]);
    }
    return all2;
  }
  function syntaxExtension(all2, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
      const left = maybe || (all2[hook] = {});
      const right = extension2[hook];
      let code4;
      if (right) {
        for (code4 in right) {
          if (!hasOwnProperty.call(left, code4)) left[code4] = [];
          const value = right[code4];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code4],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list4) {
    let index2 = -1;
    const before = [];
    while (++index2 < list4.length) {
      ;
      (list4[index2].add === "after" ? existing : before).push(list4[index2]);
    }
    splice(existing, 0, 0, before);
  }

  // ../../node_modules/micromark-util-decode-numeric-character-reference/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function decodeNumericCharacterReference(value, base) {
    const code4 = Number.parseInt(value, base);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code4 < 9 || code4 === 11 || code4 > 13 && code4 < 32 || // Control character (DEL) of C0, and C1 controls.
      code4 > 126 && code4 < 160 || // Lone high surrogates and low surrogates.
      code4 > 55295 && code4 < 57344 || // Noncharacters.
      code4 > 64975 && code4 < 65008 || /* eslint-disable no-bitwise */
      (code4 & 65535) === 65535 || (code4 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code4 > 1114111
    ) {
      return "\uFFFD";
    }
    return String.fromCodePoint(code4);
  }

  // ../../node_modules/micromark-util-normalize-identifier/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }

  // ../../node_modules/micromark-util-sanitize-uri/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-util-character/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var asciiAlpha = regexCheck(/[A-Za-z]/);
  var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  function asciiControl(code4) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code4 !== null && (code4 < 32 || code4 === 127)
    );
  }
  var asciiDigit = regexCheck(/\d/);
  var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
  var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  function markdownLineEnding(code4) {
    return code4 !== null && code4 < -2;
  }
  function markdownLineEndingOrSpace(code4) {
    return code4 !== null && (code4 < 0 || code4 === 32);
  }
  function markdownSpace(code4) {
    return code4 === -2 || code4 === -1 || code4 === 32;
  }
  var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
  var unicodeWhitespace = regexCheck(/\s/);
  function regexCheck(regex2) {
    return check;
    function check(code4) {
      return code4 !== null && code4 > -1 && regex2.test(String.fromCharCode(code4));
    }
  }

  // ../../node_modules/micromark-util-sanitize-uri/index.js
  function normalizeUri(value) {
    const result = [];
    let index2 = -1;
    let start2 = 0;
    let skip = 0;
    while (++index2 < value.length) {
      const code4 = value.charCodeAt(index2);
      let replace4 = "";
      if (code4 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
        skip = 2;
      } else if (code4 < 128) {
        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code4))) {
          replace4 = String.fromCharCode(code4);
        }
      } else if (code4 > 55295 && code4 < 57344) {
        const next2 = value.charCodeAt(index2 + 1);
        if (code4 < 56320 && next2 > 56319 && next2 < 57344) {
          replace4 = String.fromCharCode(code4, next2);
          skip = 1;
        } else {
          replace4 = "\uFFFD";
        }
      } else {
        replace4 = String.fromCharCode(code4);
      }
      if (replace4) {
        result.push(value.slice(start2, index2), encodeURIComponent(replace4));
        start2 = index2 + skip + 1;
        replace4 = "";
      }
      if (skip) {
        index2 += skip;
        skip = 0;
      }
    }
    return result.join("") + value.slice(start2);
  }

  // ../../node_modules/micromark/lib/parse.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark/lib/initialize/content.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-factory-space/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function factorySpace(effects, ok3, type, max2) {
    const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
    let size3 = 0;
    return start2;
    function start2(code4) {
      if (markdownSpace(code4)) {
        effects.enter(type);
        return prefix2(code4);
      }
      return ok3(code4);
    }
    function prefix2(code4) {
      if (markdownSpace(code4) && size3++ < limit) {
        effects.consume(code4);
        return prefix2;
      }
      effects.exit(type);
      return ok3(code4);
    }
  }

  // ../../node_modules/micromark/lib/initialize/content.js
  var content = {
    tokenize: initializeContent
  };
  function initializeContent(effects) {
    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
    let previous3;
    return contentStart;
    function afterContentStartConstruct(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code4) {
      effects.enter("paragraph");
      return lineStart(code4);
    }
    function lineStart(code4) {
      const token2 = effects.enter("chunkText", {
        contentType: "text",
        previous: previous3
      });
      if (previous3) {
        previous3.next = token2;
      }
      previous3 = token2;
      return data2(code4);
    }
    function data2(code4) {
      if (code4 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code4);
        return;
      }
      if (markdownLineEnding(code4)) {
        effects.consume(code4);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code4);
      return data2;
    }
  }

  // ../../node_modules/micromark/lib/initialize/document.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var document2 = {
    tokenize: initializeDocument
  };
  var containerConstruct = {
    tokenize: tokenizeContainer
  };
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start2;
    function start2(code4) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code4);
      }
      return checkNewContainers(code4);
    }
    function documentContinue(code4) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point4;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point4
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
        return checkNewContainers(code4);
      }
      return start2(code4);
    }
    function checkNewContainers(code4) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code4);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code4);
        }
        self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
      }
      self2.containerState = {};
      return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code4);
    }
    function thereIsANewContainer(code4) {
      if (childFlow) closeFlow();
      exitContainers(continued);
      return documentContinued(code4);
    }
    function thereIsNoNewContainer(code4) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code4);
    }
    function documentContinued(code4) {
      self2.containerState = {};
      return effects.attempt(containerConstruct, containerContinue, flowStart)(code4);
    }
    function containerContinue(code4) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code4);
    }
    function flowStart(code4) {
      if (code4 === null) {
        if (childFlow) closeFlow();
        exitContainers(0);
        effects.consume(code4);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        _tokenizer: childFlow,
        contentType: "flow",
        previous: childToken
      });
      return flowContinue(code4);
    }
    function flowContinue(code4) {
      if (code4 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code4);
        return;
      }
      if (markdownLineEnding(code4)) {
        effects.consume(code4);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start2;
      }
      effects.consume(code4);
      return flowContinue;
    }
    function writeToChild(token2, endOfFile) {
      const stream = self2.sliceStream(token2);
      if (endOfFile) stream.push(null);
      token2.previous = childToken;
      if (childToken) childToken.next = token2;
      childToken = token2;
      childFlow.defineSkip(token2.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token2.start.line]) {
        let index2 = childFlow.events.length;
        while (index2--) {
          if (
            // The token starts before the line ending…
            childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
            (!childFlow.events[index2][1].end || // …or ends after it.
            childFlow.events[index2][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point4;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point4 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point4
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
      }
    }
    function exitContainers(size3) {
      let index2 = stack.length;
      while (index2-- > size3) {
        const entry = stack[index2];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size3;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok3, nok) {
    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }

  // ../../node_modules/micromark/lib/initialize/flow.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-core-commonmark/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-core-commonmark/lib/attention.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-util-classify-character/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function classifyCharacter(code4) {
    if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return 1;
    }
    if (unicodePunctuation(code4)) {
      return 2;
    }
  }

  // ../../node_modules/micromark-util-resolve-all/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function resolveAll(constructs2, events, context) {
    const called = [];
    let index2 = -1;
    while (++index2 < constructs2.length) {
      const resolve = constructs2[index2].resolveAll;
      if (resolve && !called.includes(resolve)) {
        events = resolve(events, context);
        called.push(resolve);
      }
    }
    return events;
  }

  // ../../node_modules/micromark-core-commonmark/lib/attention.js
  var attention = {
    name: "attention",
    resolveAll: resolveAllAttention,
    tokenize: tokenizeAttention
  };
  function resolveAllAttention(events, context) {
    let index2 = -1;
    let open;
    let group;
    let text9;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset4;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
        open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
            const start2 = {
              ...events[open][1].end
            };
            const end = {
              ...events[index2][1].start
            };
            movePoint(start2, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: start2,
              end: {
                ...events[open][1].end
              }
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...events[index2][1].start
              },
              end
            };
            text9 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: {
                ...events[open][1].end
              },
              end: {
                ...events[index2][1].start
              }
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: {
                ...openingSequence.start
              },
              end: {
                ...closingSequence.end
              }
            };
            events[open][1].end = {
              ...openingSequence.start
            };
            events[index2][1].start = {
              ...closingSequence.end
            };
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
            }
            nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text9, context]]);
            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
            nextEvents = push(nextEvents, [["exit", text9, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
            if (events[index2][1].end.offset - events[index2][1].start.offset) {
              offset4 = 2;
              nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
            } else {
              offset4 = 0;
            }
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - offset4 - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "attentionSequence") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok3) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous3 = this.previous;
    const before = classifyCharacter(previous3);
    let marker17;
    return start2;
    function start2(code4) {
      marker17 = code4;
      effects.enter("attentionSequence");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker17) {
        effects.consume(code4);
        return inside;
      }
      const token2 = effects.exit("attentionSequence");
      const after = classifyCharacter(code4);
      const open = !after || after === 2 && before || attentionMarkers2.includes(code4);
      const close = !before || before === 2 && after || attentionMarkers2.includes(previous3);
      token2._open = Boolean(marker17 === 42 ? open : open && (before || !close));
      token2._close = Boolean(marker17 === 42 ? close : close && (after || !open));
      return ok3(code4);
    }
  }
  function movePoint(point4, offset4) {
    point4.column += offset4;
    point4.offset += offset4;
    point4._bufferIndex += offset4;
  }

  // ../../node_modules/micromark-core-commonmark/lib/autolink.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
  };
  function tokenizeAutolink(effects, ok3, nok) {
    let size3 = 0;
    return start2;
    function start2(code4) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code4);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return schemeOrEmailAtext;
      }
      if (code4 === 64) {
        return nok(code4);
      }
      return emailAtext(code4);
    }
    function schemeOrEmailAtext(code4) {
      if (code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) {
        size3 = 1;
        return schemeInsideOrEmailAtext(code4);
      }
      return emailAtext(code4);
    }
    function schemeInsideOrEmailAtext(code4) {
      if (code4 === 58) {
        effects.consume(code4);
        size3 = 0;
        return urlInside;
      }
      if ((code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) && size3++ < 32) {
        effects.consume(code4);
        return schemeInsideOrEmailAtext;
      }
      size3 = 0;
      return emailAtext(code4);
    }
    function urlInside(code4) {
      if (code4 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code4);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      if (code4 === null || code4 === 32 || code4 === 60 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return urlInside;
    }
    function emailAtext(code4) {
      if (code4 === 64) {
        effects.consume(code4);
        return emailAtSignOrDot;
      }
      if (asciiAtext(code4)) {
        effects.consume(code4);
        return emailAtext;
      }
      return nok(code4);
    }
    function emailAtSignOrDot(code4) {
      return asciiAlphanumeric(code4) ? emailLabel(code4) : nok(code4);
    }
    function emailLabel(code4) {
      if (code4 === 46) {
        effects.consume(code4);
        size3 = 0;
        return emailAtSignOrDot;
      }
      if (code4 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code4);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      return emailValue(code4);
    }
    function emailValue(code4) {
      if ((code4 === 45 || asciiAlphanumeric(code4)) && size3++ < 63) {
        const next2 = code4 === 45 ? emailValue : emailLabel;
        effects.consume(code4);
        return next2;
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/blank-line.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var blankLine = {
    partial: true,
    tokenize: tokenizeBlankLine
  };
  function tokenizeBlankLine(effects, ok3, nok) {
    return start2;
    function start2(code4) {
      return markdownSpace(code4) ? factorySpace(effects, after, "linePrefix")(code4) : after(code4);
    }
    function after(code4) {
      return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/block-quote.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var blockQuote = {
    continuation: {
      tokenize: tokenizeBlockQuoteContinuation
    },
    exit,
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart
  };
  function tokenizeBlockQuoteStart(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      if (code4 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code4);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      if (markdownSpace(code4)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code4);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok3;
      }
      effects.exit("blockQuotePrefix");
      return ok3(code4);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
    const self2 = this;
    return contStart;
    function contStart(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
      }
      return contBefore(code4);
    }
    function contBefore(code4) {
      return effects.attempt(blockQuote, ok3, nok)(code4);
    }
  }
  function exit(effects) {
    effects.exit("blockQuote");
  }

  // ../../node_modules/micromark-core-commonmark/lib/character-escape.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
  };
  function tokenizeCharacterEscape(effects, ok3, nok) {
    return start2;
    function start2(code4) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code4);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code4) {
      if (asciiPunctuation(code4)) {
        effects.enter("characterEscapeValue");
        effects.consume(code4);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok3;
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/character-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
  };
  function tokenizeCharacterReference(effects, ok3, nok) {
    const self2 = this;
    let size3 = 0;
    let max2;
    let test;
    return start2;
    function start2(code4) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code4);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code4) {
      if (code4 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code4);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric;
      }
      effects.enter("characterReferenceValue");
      max2 = 31;
      test = asciiAlphanumeric;
      return value(code4);
    }
    function numeric(code4) {
      if (code4 === 88 || code4 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code4);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max2 = 6;
        test = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max2 = 7;
      test = asciiDigit;
      return value(code4);
    }
    function value(code4) {
      if (code4 === 59 && size3) {
        const token2 = effects.exit("characterReferenceValue");
        if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
          return nok(code4);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code4);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok3;
      }
      if (test(code4) && size3++ < max2) {
        effects.consume(code4);
        return value;
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/code-fenced.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var nonLazyContinuation = {
    partial: true,
    tokenize: tokenizeNonLazyContinuation
  };
  var codeFenced = {
    concrete: true,
    name: "codeFenced",
    tokenize: tokenizeCodeFenced
  };
  function tokenizeCodeFenced(effects, ok3, nok) {
    const self2 = this;
    const closeStart = {
      partial: true,
      tokenize: tokenizeCloseStart
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker17;
    return start2;
    function start2(code4) {
      return beforeSequenceOpen(code4);
    }
    function beforeSequenceOpen(code4) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker17 = code4;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === marker17) {
        sizeOpen++;
        effects.consume(code4);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code4);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace(code4) ? factorySpace(effects, infoBefore, "whitespace")(code4) : infoBefore(code4);
    }
    function infoBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok3(code4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code4);
    }
    function info(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, metaBefore, "whitespace")(code4);
      }
      if (code4 === 96 && code4 === marker17) {
        return nok(code4);
      }
      effects.consume(code4);
      return info;
    }
    function metaBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return infoBefore(code4);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta(code4);
    }
    function meta(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code4);
      }
      if (code4 === 96 && code4 === marker17) {
        return nok(code4);
      }
      effects.consume(code4);
      return meta;
    }
    function atNonLazyBreak(code4) {
      return effects.attempt(closeStart, after, contentBefore)(code4);
    }
    function contentBefore(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code4) {
      return initialPrefix > 0 && markdownSpace(code4) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code4) : beforeContentChunk(code4);
    }
    function beforeContentChunk(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code4);
    }
    function contentChunk(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code4);
      }
      effects.consume(code4);
      return contentChunk;
    }
    function after(code4) {
      effects.exit("codeFenced");
      return ok3(code4);
    }
    function tokenizeCloseStart(effects2, ok4, nok2) {
      let size3 = 0;
      return startBefore;
      function startBefore(code4) {
        effects2.enter("lineEnding");
        effects2.consume(code4);
        effects2.exit("lineEnding");
        return start3;
      }
      function start3(code4) {
        effects2.enter("codeFencedFence");
        return markdownSpace(code4) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : beforeSequenceClose(code4);
      }
      function beforeSequenceClose(code4) {
        if (code4 === marker17) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code4);
        }
        return nok2(code4);
      }
      function sequenceClose(code4) {
        if (code4 === marker17) {
          size3++;
          effects2.consume(code4);
          return sequenceClose;
        }
        if (size3 >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace(code4) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code4) : sequenceCloseAfter(code4);
        }
        return nok2(code4);
      }
      function sequenceCloseAfter(code4) {
        if (code4 === null || markdownLineEnding(code4)) {
          effects2.exit("codeFencedFence");
          return ok4(code4);
        }
        return nok2(code4);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code4) {
      return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/code-indented.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
  };
  var furtherStart = {
    partial: true,
    tokenize: tokenizeFurtherStart
  };
  function tokenizeCodeIndented(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      effects.enter("codeIndented");
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
    }
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code4) : nok(code4);
    }
    function atBreak(code4) {
      if (code4 === null) {
        return after(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.attempt(furtherStart, atBreak, after)(code4);
      }
      effects.enter("codeFlowValue");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFlowValue");
        return atBreak(code4);
      }
      effects.consume(code4);
      return inside;
    }
    function after(code4) {
      effects.exit("codeIndented");
      return ok3(code4);
    }
  }
  function tokenizeFurtherStart(effects, ok3, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code4) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
    }
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code4) : markdownLineEnding(code4) ? furtherStart2(code4) : nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/code-text.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var codeText = {
    name: "codeText",
    previous,
    resolve: resolveCodeText,
    tokenize: tokenizeCodeText
  };
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index2;
    let enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index2 = headEnterIndex;
      while (++index2 < tailExitIndex) {
        if (events[index2][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index2 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index2 <= tailExitIndex) {
      if (enter === void 0) {
        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
          enter = index2;
        }
      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
        events[enter][1].type = "codeTextData";
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          tailExitIndex -= index2 - enter - 2;
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return events;
  }
  function previous(code4) {
    return code4 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok3, nok) {
    const self2 = this;
    let sizeOpen = 0;
    let size3;
    let token2;
    return start2;
    function start2(code4) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === 96) {
        effects.consume(code4);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between(code4);
    }
    function between(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 32) {
        effects.enter("space");
        effects.consume(code4);
        effects.exit("space");
        return between;
      }
      if (code4 === 96) {
        token2 = effects.enter("codeTextSequence");
        size3 = 0;
        return sequenceClose(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return between;
      }
      effects.enter("codeTextData");
      return data2(code4);
    }
    function data2(code4) {
      if (code4 === null || code4 === 32 || code4 === 96 || markdownLineEnding(code4)) {
        effects.exit("codeTextData");
        return between(code4);
      }
      effects.consume(code4);
      return data2;
    }
    function sequenceClose(code4) {
      if (code4 === 96) {
        effects.consume(code4);
        size3++;
        return sequenceClose;
      }
      if (size3 === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok3(code4);
      }
      token2.type = "codeTextData";
      return data2(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/content.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-util-subtokenize/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-util-subtokenize/lib/splice-buffer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SpliceBuffer = class {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(initial) {
      this.left = initial ? [...initial] : [];
      this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(index2) {
      if (index2 < 0 || index2 >= this.left.length + this.right.length) {
        throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      }
      if (index2 < this.left.length) return this.left[index2];
      return this.right[this.right.length - index2 + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      this.setCursor(0);
      return this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(start2, end) {
      const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
      if (stop < this.left.length) {
        return this.left.slice(start2, stop);
      }
      if (start2 > this.left.length) {
        return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start2 + this.left.length).reverse();
      }
      return this.left.slice(start2).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(start2, deleteCount, items) {
      const count = deleteCount || 0;
      this.setCursor(Math.trunc(start2));
      const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
      if (items) chunkedPush(this.left, items);
      return removed.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      this.setCursor(Number.POSITIVE_INFINITY);
      return this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(item) {
      this.setCursor(Number.POSITIVE_INFINITY);
      this.left.push(item);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(items) {
      this.setCursor(Number.POSITIVE_INFINITY);
      chunkedPush(this.left, items);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(item) {
      this.setCursor(0);
      this.right.push(item);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(items) {
      this.setCursor(0);
      chunkedPush(this.right, items.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(n) {
      if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;
      if (n < this.left.length) {
        const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, removed.reverse());
      } else {
        const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, removed.reverse());
      }
    }
  };
  function chunkedPush(list4, right) {
    let chunkStart = 0;
    if (right.length < 1e4) {
      list4.push(...right);
    } else {
      while (chunkStart < right.length) {
        list4.push(...right.slice(chunkStart, chunkStart + 1e4));
        chunkStart += 1e4;
      }
    }
  }

  // ../../node_modules/micromark-util-subtokenize/index.js
  function subtokenize(eventsArray) {
    const jumps = {};
    let index2 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    const events = new SpliceBuffer(eventsArray);
    while (++index2 < events.length) {
      while (index2 in jumps) {
        index2 = jumps[index2];
      }
      event = events.get(index2);
      if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index2));
          index2 = jumps[index2];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index2;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events.get(otherIndex);
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events.get(lineIndex)[1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") {
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = {
            ...events.get(lineIndex)[1].start
          };
          parameters = events.slice(lineIndex, index2);
          parameters.unshift(event);
          events.splice(lineIndex, index2 - lineIndex + 1, parameters);
        }
      }
    }
    splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token2 = events.get(eventIndex)[1];
    const context = events.get(eventIndex)[2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    let tokenizer2 = token2._tokenizer;
    if (!tokenizer2) {
      tokenizer2 = context.parser[token2.contentType](token2.start);
      if (token2._contentTypeTextTrailing) {
        tokenizer2._contentTypeTextTrailing = true;
      }
    }
    const childEvents = tokenizer2.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous3;
    let index2 = -1;
    let current = token2;
    let adjust = 0;
    let start2 = 0;
    const breaks = [start2];
    while (current) {
      while (events.get(++startPosition)[1] !== current) {
      }
      startPositions.push(startPosition);
      if (!current._tokenizer) {
        stream = context.sliceStream(current);
        if (!current.next) {
          stream.push(null);
        }
        if (previous3) {
          tokenizer2.defineSkip(current.start);
        }
        if (current._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer2.write(stream);
        if (current._isInFirstContentOfListItem) {
          tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous3 = current;
      current = current.next;
    }
    current = token2;
    while (++index2 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
      ) {
        start2 = index2 + 1;
        breaks.push(start2);
        current._tokenizer = void 0;
        current.previous = void 0;
        current = current.next;
      }
    }
    tokenizer2.events = [];
    if (current) {
      current._tokenizer = void 0;
      current.previous = void 0;
    } else {
      breaks.pop();
    }
    index2 = breaks.length;
    while (index2--) {
      const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
      const start3 = startPositions.pop();
      jumps.push([start3, start3 + slice2.length - 1]);
      events.splice(start3, 2, slice2);
    }
    jumps.reverse();
    index2 = -1;
    while (++index2 < jumps.length) {
      gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
      adjust += jumps[index2][1] - jumps[index2][0] - 1;
    }
    return gaps;
  }

  // ../../node_modules/micromark-core-commonmark/lib/content.js
  var content2 = {
    resolve: resolveContent,
    tokenize: tokenizeContent
  };
  var continuationConstruct = {
    partial: true,
    tokenize: tokenizeContinuation
  };
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok3) {
    let previous3;
    return chunkStart;
    function chunkStart(code4) {
      effects.enter("content");
      previous3 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code4);
    }
    function chunkInside(code4) {
      if (code4 === null) {
        return contentEnd(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code4);
      }
      effects.consume(code4);
      return chunkInside;
    }
    function contentEnd(code4) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok3(code4);
    }
    function contentContinue(code4) {
      effects.consume(code4);
      effects.exit("chunkContent");
      previous3.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous3
      });
      previous3 = previous3.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok3, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code4) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return nok(code4);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok3(code4);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/definition.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-factory-destination/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function factoryDestination(effects, ok3, nok, type, literalType2, literalMarkerType, rawType, stringType2, max2) {
    const limit = max2 || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start2;
    function start2(code4) {
      if (code4 === 60) {
        effects.enter(type);
        effects.enter(literalType2);
        effects.enter(literalMarkerType);
        effects.consume(code4);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code4 === null || code4 === 32 || code4 === 41 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType2);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw(code4);
    }
    function enclosedBefore(code4) {
      if (code4 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code4);
        effects.exit(literalMarkerType);
        effects.exit(literalType2);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType2);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code4);
    }
    function enclosed(code4) {
      if (code4 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType2);
        return enclosedBefore(code4);
      }
      if (code4 === null || code4 === 60 || markdownLineEnding(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code4) {
      if (code4 === 60 || code4 === 62 || code4 === 92) {
        effects.consume(code4);
        return enclosed;
      }
      return enclosed(code4);
    }
    function raw(code4) {
      if (!balance && (code4 === null || code4 === 41 || markdownLineEndingOrSpace(code4))) {
        effects.exit("chunkString");
        effects.exit(stringType2);
        effects.exit(rawType);
        effects.exit(type);
        return ok3(code4);
      }
      if (balance < limit && code4 === 40) {
        effects.consume(code4);
        balance++;
        return raw;
      }
      if (code4 === 41) {
        effects.consume(code4);
        balance--;
        return raw;
      }
      if (code4 === null || code4 === 32 || code4 === 40 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? rawEscape : raw;
    }
    function rawEscape(code4) {
      if (code4 === 40 || code4 === 41 || code4 === 92) {
        effects.consume(code4);
        return raw;
      }
      return raw(code4);
    }
  }

  // ../../node_modules/micromark-factory-label/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function factoryLabel(effects, ok3, nok, type, markerType, stringType2) {
    const self2 = this;
    let size3 = 0;
    let seen;
    return start2;
    function start2(code4) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.enter(stringType2);
      return atBreak;
    }
    function atBreak(code4) {
      if (size3 > 999 || code4 === null || code4 === 91 || code4 === 93 && !seen || // To do: remove in the future once we’ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesn’t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code4 === 94 && !size3 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit(stringType2);
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code4);
    }
    function labelInside(code4) {
      if (code4 === null || code4 === 91 || code4 === 93 || markdownLineEnding(code4) || size3++ > 999) {
        effects.exit("chunkString");
        return atBreak(code4);
      }
      effects.consume(code4);
      if (!seen) seen = !markdownSpace(code4);
      return code4 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size3++;
        return labelInside;
      }
      return labelInside(code4);
    }
  }

  // ../../node_modules/micromark-factory-title/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function factoryTitle(effects, ok3, nok, type, markerType, stringType2) {
    let marker17;
    return start2;
    function start2(code4) {
      if (code4 === 34 || code4 === 39 || code4 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        marker17 = code4 === 40 ? 41 : code4;
        return begin;
      }
      return nok(code4);
    }
    function begin(code4) {
      if (code4 === marker17) {
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType2);
      return atBreak(code4);
    }
    function atBreak(code4) {
      if (code4 === marker17) {
        effects.exit(stringType2);
        return begin(marker17);
      }
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return factorySpace(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker17 || code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        return atBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? escape : inside;
    }
    function escape(code4) {
      if (code4 === marker17 || code4 === 92) {
        effects.consume(code4);
        return inside;
      }
      return inside(code4);
    }
  }

  // ../../node_modules/micromark-factory-whitespace/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function factoryWhitespace(effects, ok3) {
    let seen;
    return start2;
    function start2(code4) {
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        seen = true;
        return start2;
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, start2, seen ? "linePrefix" : "lineSuffix")(code4);
      }
      return ok3(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/definition.js
  var definition = {
    name: "definition",
    tokenize: tokenizeDefinition
  };
  var titleBefore = {
    partial: true,
    tokenize: tokenizeTitleBefore
  };
  function tokenizeDefinition(effects, ok3, nok) {
    const self2 = this;
    let identifier2;
    return start2;
    function start2(code4) {
      effects.enter("definition");
      return before(code4);
    }
    function before(code4) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code4);
    }
    function labelAfter(code4) {
      identifier2 = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code4 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code4);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code4);
    }
    function markerAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, destinationBefore)(code4) : destinationBefore(code4);
    }
    function destinationBefore(code4) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we don’t need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code4);
    }
    function destinationAfter(code4) {
      return effects.attempt(titleBefore, after, after)(code4);
    }
    function after(code4) {
      return markdownSpace(code4) ? factorySpace(effects, afterWhitespace, "whitespace")(code4) : afterWhitespace(code4);
    }
    function afterWhitespace(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier2);
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  function tokenizeTitleBefore(effects, ok3, nok) {
    return titleBefore2;
    function titleBefore2(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, beforeMarker)(code4) : nok(code4);
    }
    function beforeMarker(code4) {
      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code4);
    }
    function titleAfter(code4) {
      return markdownSpace(code4) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code4) : titleAfterOptionalWhitespace(code4);
    }
    function titleAfterOptionalWhitespace(code4) {
      return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/hard-break-escape.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
  };
  function tokenizeHardBreakEscape(effects, ok3, nok) {
    return start2;
    function start2(code4) {
      effects.enter("hardBreakEscape");
      effects.consume(code4);
      return after;
    }
    function after(code4) {
      if (markdownLineEnding(code4)) {
        effects.exit("hardBreakEscape");
        return ok3(code4);
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/heading-atx.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var headingAtx = {
    name: "headingAtx",
    resolve: resolveHeadingAtx,
    tokenize: tokenizeHeadingAtx
  };
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content3;
    let text9;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content3 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text9 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text9, context], ["exit", text9, context], ["exit", content3, context]]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok3, nok) {
    let size3 = 0;
    return start2;
    function start2(code4) {
      effects.enter("atxHeading");
      return before(code4);
    }
    function before(code4) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === 35 && size3++ < 6) {
        effects.consume(code4);
        return sequenceOpen;
      }
      if (code4 === null || markdownLineEndingOrSpace(code4)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code4);
      }
      return nok(code4);
    }
    function atBreak(code4) {
      if (code4 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("atxHeading");
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, atBreak, "whitespace")(code4);
      }
      effects.enter("atxHeadingText");
      return data2(code4);
    }
    function sequenceFurther(code4) {
      if (code4 === 35) {
        effects.consume(code4);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code4);
    }
    function data2(code4) {
      if (code4 === null || code4 === 35 || markdownLineEndingOrSpace(code4)) {
        effects.exit("atxHeadingText");
        return atBreak(code4);
      }
      effects.consume(code4);
      return data2;
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/html-flow.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-util-html-tag-name/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var htmlBlockNames = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  var htmlRawNames = ["pre", "script", "style", "textarea"];

  // ../../node_modules/micromark-core-commonmark/lib/html-flow.js
  var htmlFlow = {
    concrete: true,
    name: "htmlFlow",
    resolveTo: resolveToHtmlFlow,
    tokenize: tokenizeHtmlFlow
  };
  var blankLineBefore = {
    partial: true,
    tokenize: tokenizeBlankLineBefore
  };
  var nonLazyContinuationStart = {
    partial: true,
    tokenize: tokenizeNonLazyContinuationStart
  };
  function resolveToHtmlFlow(events) {
    let index2 = events.length;
    while (index2--) {
      if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
        break;
      }
    }
    if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
      events[index2][1].start = events[index2 - 2][1].start;
      events[index2 + 1][1].start = events[index2 - 2][1].start;
      events.splice(index2 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok3, nok) {
    const self2 = this;
    let marker17;
    let closingTag;
    let buffer;
    let index2;
    let markerB;
    return start2;
    function start2(code4) {
      return before(code4);
    }
    function before(code4) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code4);
      return open;
    }
    function open(code4) {
      if (code4 === 33) {
        effects.consume(code4);
        return declarationOpen;
      }
      if (code4 === 47) {
        effects.consume(code4);
        closingTag = true;
        return tagCloseStart;
      }
      if (code4 === 63) {
        effects.consume(code4);
        marker17 = 3;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        buffer = String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function declarationOpen(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        marker17 = 2;
        return commentOpenInside;
      }
      if (code4 === 91) {
        effects.consume(code4);
        marker17 = 5;
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        marker17 = 4;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code4);
    }
    function commentOpenInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code4);
    }
    function cdataOpenInside(code4) {
      const value = "CDATA[";
      if (code4 === value.charCodeAt(index2++)) {
        effects.consume(code4);
        if (index2 === value.length) {
          return self2.interrupt ? ok3 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code4);
    }
    function tagCloseStart(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        buffer = String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function tagName(code4) {
      if (code4 === null || code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        const slash = code4 === 47;
        const name21 = buffer.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name21)) {
          marker17 = 1;
          return self2.interrupt ? ok3(code4) : continuation(code4);
        }
        if (htmlBlockNames.includes(buffer.toLowerCase())) {
          marker17 = 6;
          if (slash) {
            effects.consume(code4);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok3(code4) : continuation(code4);
        }
        marker17 = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code4) : closingTag ? completeClosingTagAfter(code4) : completeAttributeNameBefore(code4);
      }
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        buffer += String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function basicSelfClosing(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return self2.interrupt ? ok3 : continuation;
      }
      return nok(code4);
    }
    function completeClosingTagAfter(code4) {
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeClosingTagAfter;
      }
      return completeEnd(code4);
    }
    function completeAttributeNameBefore(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        return completeEnd;
      }
      if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
        effects.consume(code4);
        return completeAttributeName;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeNameBefore;
      }
      return completeEnd(code4);
    }
    function completeAttributeName(code4) {
      if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code4);
    }
    function completeAttributeNameAfter(code4) {
      if (code4 === 61) {
        effects.consume(code4);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code4);
    }
    function completeAttributeValueBefore(code4) {
      if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 34 || code4 === 39) {
        effects.consume(code4);
        markerB = code4;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code4);
    }
    function completeAttributeValueQuoted(code4) {
      if (code4 === markerB) {
        effects.consume(code4);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code4 === null || markdownLineEnding(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code4) {
      if (code4 === null || code4 === 34 || code4 === 39 || code4 === 47 || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96 || markdownLineEndingOrSpace(code4)) {
        return completeAttributeNameAfter(code4);
      }
      effects.consume(code4);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code4) {
      if (code4 === 47 || code4 === 62 || markdownSpace(code4)) {
        return completeAttributeNameBefore(code4);
      }
      return nok(code4);
    }
    function completeEnd(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return completeAfter;
      }
      return nok(code4);
    }
    function completeAfter(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return continuation(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAfter;
      }
      return nok(code4);
    }
    function continuation(code4) {
      if (code4 === 45 && marker17 === 2) {
        effects.consume(code4);
        return continuationCommentInside;
      }
      if (code4 === 60 && marker17 === 1) {
        effects.consume(code4);
        return continuationRawTagOpen;
      }
      if (code4 === 62 && marker17 === 4) {
        effects.consume(code4);
        return continuationClose;
      }
      if (code4 === 63 && marker17 === 3) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      if (code4 === 93 && marker17 === 5) {
        effects.consume(code4);
        return continuationCdataInside;
      }
      if (markdownLineEnding(code4) && (marker17 === 6 || marker17 === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(blankLineBefore, continuationAfter, continuationStart)(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("htmlFlowData");
        return continuationStart(code4);
      }
      effects.consume(code4);
      return continuation;
    }
    function continuationStart(code4) {
      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code4);
    }
    function continuationStartNonLazy(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return continuationStart(code4);
      }
      effects.enter("htmlFlowData");
      return continuation(code4);
    }
    function continuationCommentInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationRawTagOpen(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code4);
    }
    function continuationRawEndTag(code4) {
      if (code4 === 62) {
        const name21 = buffer.toLowerCase();
        if (htmlRawNames.includes(name21)) {
          effects.consume(code4);
          return continuationClose;
        }
        return continuation(code4);
      }
      if (asciiAlpha(code4) && buffer.length < 8) {
        effects.consume(code4);
        buffer += String.fromCharCode(code4);
        return continuationRawEndTag;
      }
      return continuation(code4);
    }
    function continuationCdataInside(code4) {
      if (code4 === 93) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationDeclarationInside(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return continuationClose;
      }
      if (code4 === 45 && marker17 === 2) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationClose(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code4);
      }
      effects.consume(code4);
      return continuationClose;
    }
    function continuationAfter(code4) {
      effects.exit("htmlFlow");
      return ok3(code4);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
    }
  }
  function tokenizeBlankLineBefore(effects, ok3, nok) {
    return start2;
    function start2(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return effects.attempt(blankLine, ok3, nok);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/html-text.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
  };
  function tokenizeHtmlText(effects, ok3, nok) {
    const self2 = this;
    let marker17;
    let index2;
    let returnState;
    return start2;
    function start2(code4) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code4);
      return open;
    }
    function open(code4) {
      if (code4 === 33) {
        effects.consume(code4);
        return declarationOpen;
      }
      if (code4 === 47) {
        effects.consume(code4);
        return tagCloseStart;
      }
      if (code4 === 63) {
        effects.consume(code4);
        return instruction;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return tagOpen;
      }
      return nok(code4);
    }
    function declarationOpen(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentOpenInside;
      }
      if (code4 === 91) {
        effects.consume(code4);
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return declaration2;
      }
      return nok(code4);
    }
    function commentOpenInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentEnd;
      }
      return nok(code4);
    }
    function comment3(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 45) {
        effects.consume(code4);
        return commentClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = comment3;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return comment3;
    }
    function commentClose(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentEnd;
      }
      return comment3(code4);
    }
    function commentEnd(code4) {
      return code4 === 62 ? end(code4) : code4 === 45 ? commentClose(code4) : comment3(code4);
    }
    function cdataOpenInside(code4) {
      const value = "CDATA[";
      if (code4 === value.charCodeAt(index2++)) {
        effects.consume(code4);
        return index2 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code4);
    }
    function cdata(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.consume(code4);
        return cdataClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = cdata;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return cdata;
    }
    function cdataClose(code4) {
      if (code4 === 93) {
        effects.consume(code4);
        return cdataEnd;
      }
      return cdata(code4);
    }
    function cdataEnd(code4) {
      if (code4 === 62) {
        return end(code4);
      }
      if (code4 === 93) {
        effects.consume(code4);
        return cdataEnd;
      }
      return cdata(code4);
    }
    function declaration2(code4) {
      if (code4 === null || code4 === 62) {
        return end(code4);
      }
      if (markdownLineEnding(code4)) {
        returnState = declaration2;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return declaration2;
    }
    function instruction(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 63) {
        effects.consume(code4);
        return instructionClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = instruction;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return instruction;
    }
    function instructionClose(code4) {
      return code4 === 62 ? end(code4) : instruction(code4);
    }
    function tagCloseStart(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return tagClose;
      }
      return nok(code4);
    }
    function tagClose(code4) {
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagClose;
      }
      return tagCloseBetween(code4);
    }
    function tagCloseBetween(code4) {
      if (markdownLineEnding(code4)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagCloseBetween;
      }
      return end(code4);
    }
    function tagOpen(code4) {
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagOpen;
      }
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      return nok(code4);
    }
    function tagOpenBetween(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        return end;
      }
      if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
        effects.consume(code4);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenBetween;
      }
      return end(code4);
    }
    function tagOpenAttributeName(code4) {
      if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code4);
    }
    function tagOpenAttributeNameAfter(code4) {
      if (code4 === 61) {
        effects.consume(code4);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code4);
    }
    function tagOpenAttributeValueBefore(code4) {
      if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 34 || code4 === 39) {
        effects.consume(code4);
        marker17 = code4;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code4);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code4) {
      if (code4 === marker17) {
        effects.consume(code4);
        marker17 = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code4) {
      if (code4 === null || code4 === 34 || code4 === 39 || code4 === 60 || code4 === 61 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      effects.consume(code4);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code4) {
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      return nok(code4);
    }
    function end(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok3;
      }
      return nok(code4);
    }
    function lineEndingBefore(code4) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code4) {
      return markdownSpace(code4) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : lineEndingAfterPrefix(code4);
    }
    function lineEndingAfterPrefix(code4) {
      effects.enter("htmlTextData");
      return returnState(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/label-end.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var labelEnd = {
    name: "labelEnd",
    resolveAll: resolveAllLabelEnd,
    resolveTo: resolveToLabelEnd,
    tokenize: tokenizeLabelEnd
  };
  var resourceConstruct = {
    tokenize: tokenizeResource
  };
  var referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
  };
  var referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
  };
  function resolveAllLabelEnd(events) {
    let index2 = -1;
    const newEvents = [];
    while (++index2 < events.length) {
      const token2 = events[index2][1];
      newEvents.push(events[index2]);
      if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
        const offset4 = token2.type === "labelImage" ? 4 : 2;
        token2.type = "data";
        index2 += offset4;
      }
    }
    if (events.length !== newEvents.length) {
      splice(events, 0, events.length, newEvents);
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index2 = events.length;
    let offset4 = 0;
    let token2;
    let open;
    let close;
    let media;
    while (index2--) {
      token2 = events[index2][1];
      if (open) {
        if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
          break;
        }
        if (events[index2][0] === "enter" && token2.type === "labelLink") {
          token2._inactive = true;
        }
      } else if (close) {
        if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
          open = index2;
          if (token2.type !== "labelLink") {
            offset4 = 2;
            break;
          }
        }
      } else if (token2.type === "labelEnd") {
        close = index2;
      }
    }
    const group = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    const label = {
      type: "label",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[close][1].end
      }
    };
    const text9 = {
      type: "labelText",
      start: {
        ...events[open + offset4 + 2][1].end
      },
      end: {
        ...events[close - 2][1].start
      }
    };
    media = [["enter", group, context], ["enter", label, context]];
    media = push(media, events.slice(open + 1, open + offset4 + 3));
    media = push(media, [["enter", text9, context]]);
    media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset4 + 4, close - 3), context));
    media = push(media, [["exit", text9, context], events[close - 2], events[close - 1], ["exit", label, context]]);
    media = push(media, events.slice(close + 1));
    media = push(media, [["exit", group, context]]);
    splice(events, open, events.length, media);
    return events;
  }
  function tokenizeLabelEnd(effects, ok3, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    let labelStart;
    let defined;
    while (index2--) {
      if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
        labelStart = self2.events[index2][1];
        break;
      }
    }
    return start2;
    function start2(code4) {
      if (!labelStart) {
        return nok(code4);
      }
      if (labelStart._inactive) {
        return labelEndNok(code4);
      }
      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })));
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code4);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code4) {
      if (code4 === 40) {
        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code4);
      }
      if (code4 === 91) {
        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code4);
      }
      return defined ? labelEndOk(code4) : labelEndNok(code4);
    }
    function referenceNotFull(code4) {
      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code4);
    }
    function labelEndOk(code4) {
      return ok3(code4);
    }
    function labelEndNok(code4) {
      labelStart._balanced = true;
      return nok(code4);
    }
  }
  function tokenizeResource(effects, ok3, nok) {
    return resourceStart;
    function resourceStart(code4) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code4);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceOpen)(code4) : resourceOpen(code4);
    }
    function resourceOpen(code4) {
      if (code4 === 41) {
        return resourceEnd(code4);
      }
      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code4);
    }
    function resourceDestinationAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceBetween)(code4) : resourceEnd(code4);
    }
    function resourceDestinationMissing(code4) {
      return nok(code4);
    }
    function resourceBetween(code4) {
      if (code4 === 34 || code4 === 39 || code4 === 40) {
        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code4);
      }
      return resourceEnd(code4);
    }
    function resourceTitleAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceEnd)(code4) : resourceEnd(code4);
    }
    function resourceEnd(code4) {
      if (code4 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code4);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok3;
      }
      return nok(code4);
    }
  }
  function tokenizeReferenceFull(effects, ok3, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code4) {
      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code4);
    }
    function referenceFullAfter(code4) {
      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code4) : nok(code4);
    }
    function referenceFullMissing(code4) {
      return nok(code4);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok3, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code4) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code4);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code4) {
      if (code4 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code4);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok3;
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/label-start-image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var labelStartImage = {
    name: "labelStartImage",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartImage
  };
  function tokenizeLabelStartImage(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code4);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code4) {
      if (code4 === 91) {
        effects.enter("labelMarker");
        effects.consume(code4);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/label-start-link.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var labelStartLink = {
    name: "labelStartLink",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartLink
  };
  function tokenizeLabelStartLink(effects, ok3, nok) {
    const self2 = this;
    return start2;
    function start2(code4) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code4);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code4) {
      return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/line-ending.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
  };
  function tokenizeLineEnding(effects, ok3) {
    return start2;
    function start2(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, ok3, "linePrefix");
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/list.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-core-commonmark/lib/thematic-break.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var thematicBreak = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
  };
  function tokenizeThematicBreak(effects, ok3, nok) {
    let size3 = 0;
    let marker17;
    return start2;
    function start2(code4) {
      effects.enter("thematicBreak");
      return before(code4);
    }
    function before(code4) {
      marker17 = code4;
      return atBreak(code4);
    }
    function atBreak(code4) {
      if (code4 === marker17) {
        effects.enter("thematicBreakSequence");
        return sequence(code4);
      }
      if (size3 >= 3 && (code4 === null || markdownLineEnding(code4))) {
        effects.exit("thematicBreak");
        return ok3(code4);
      }
      return nok(code4);
    }
    function sequence(code4) {
      if (code4 === marker17) {
        effects.consume(code4);
        size3++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace(code4) ? factorySpace(effects, atBreak, "whitespace")(code4) : atBreak(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/list.js
  var list = {
    continuation: {
      tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd,
    name: "list",
    tokenize: tokenizeListStart
  };
  var listItemPrefixWhitespaceConstruct = {
    partial: true,
    tokenize: tokenizeListItemPrefixWhitespace
  };
  var indentConstruct = {
    partial: true,
    tokenize: tokenizeIndent
  };
  function tokenizeListStart(effects, ok3, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size3 = 0;
    return start2;
    function start2(code4) {
      const kind = self2.containerState.type || (code4 === 42 || code4 === 43 || code4 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code4 === self2.containerState.marker : asciiDigit(code4)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code4 === 42 || code4 === 45 ? effects.check(thematicBreak, nok, atMarker)(code4) : atMarker(code4);
        }
        if (!self2.interrupt || code4 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code4);
        }
      }
      return nok(code4);
    }
    function inside(code4) {
      if (asciiDigit(code4) && ++size3 < 10) {
        effects.consume(code4);
        return inside;
      }
      if ((!self2.interrupt || size3 < 2) && (self2.containerState.marker ? code4 === self2.containerState.marker : code4 === 41 || code4 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code4);
      }
      return nok(code4);
    }
    function atMarker(code4) {
      effects.enter("listItemMarker");
      effects.consume(code4);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code4;
      return effects.check(
        blankLine,
        // Can’t be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
      );
    }
    function onBlank(code4) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code4);
    }
    function otherPrefix(code4) {
      if (markdownSpace(code4)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code4);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code4);
    }
    function endOfPrefix(code4) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok3(code4);
    }
  }
  function tokenizeListContinuation(effects, ok3, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine, onBlank, notBlank);
    function onBlank(code4) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code4);
    }
    function notBlank(code4) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code4)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code4);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code4);
    }
    function notInCurrentItem(code4) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace(effects, effects.attempt(list, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
    }
  }
  function tokenizeIndent(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code4) : nok(code4);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace(code4) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code4) : nok(code4);
    }
  }

  // ../../node_modules/micromark-core-commonmark/lib/setext-underline.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var setextUnderline = {
    name: "setextUnderline",
    resolveTo: resolveToSetextUnderline,
    tokenize: tokenizeSetextUnderline
  };
  function resolveToSetextUnderline(events, context) {
    let index2 = events.length;
    let content3;
    let text9;
    let definition3;
    while (index2--) {
      if (events[index2][0] === "enter") {
        if (events[index2][1].type === "content") {
          content3 = index2;
          break;
        }
        if (events[index2][1].type === "paragraph") {
          text9 = index2;
        }
      } else {
        if (events[index2][1].type === "content") {
          events.splice(index2, 1);
        }
        if (!definition3 && events[index2][1].type === "definition") {
          definition3 = index2;
        }
      }
    }
    const heading3 = {
      type: "setextHeading",
      start: {
        ...events[content3][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    events[text9][1].type = "setextHeadingText";
    if (definition3) {
      events.splice(text9, 0, ["enter", heading3, context]);
      events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
      events[content3][1].end = {
        ...events[definition3][1].end
      };
    } else {
      events[content3][1] = heading3;
    }
    events.push(["exit", heading3, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok3, nok) {
    const self2 = this;
    let marker17;
    return start2;
    function start2(code4) {
      let index2 = self2.events.length;
      let paragraph3;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph3 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
        effects.enter("setextHeadingLine");
        marker17 = code4;
        return before(code4);
      }
      return nok(code4);
    }
    function before(code4) {
      effects.enter("setextHeadingLineSequence");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker17) {
        effects.consume(code4);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace(code4) ? factorySpace(effects, after, "lineSuffix")(code4) : after(code4);
    }
    function after(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("setextHeadingLine");
        return ok3(code4);
      }
      return nok(code4);
    }
  }

  // ../../node_modules/micromark/lib/initialize/flow.js
  var flow = {
    tokenize: initializeFlow
  };
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix"))
    );
    return initial;
    function atBlankEnding(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code4);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }

  // ../../node_modules/micromark/lib/initialize/text.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var resolver = {
    resolveAll: createResolver()
  };
  var string = initializeFactory("string");
  var text3 = initializeFactory("text");
  function initializeFactory(field) {
    return {
      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
      tokenize: initializeText
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs2 = this.parser.constructs[field];
      const text9 = effects.attempt(constructs2, start2, notText);
      return start2;
      function start2(code4) {
        return atBreak(code4) ? text9(code4) : notText(code4);
      }
      function notText(code4) {
        if (code4 === null) {
          effects.consume(code4);
          return;
        }
        effects.enter("data");
        effects.consume(code4);
        return data2;
      }
      function data2(code4) {
        if (atBreak(code4)) {
          effects.exit("data");
          return text9(code4);
        }
        effects.consume(code4);
        return data2;
      }
      function atBreak(code4) {
        if (code4 === null) {
          return true;
        }
        const list4 = constructs2[code4];
        let index2 = -1;
        if (list4) {
          while (++index2 < list4.length) {
            const item = list4[index2];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index2 = -1;
      let enter;
      while (++index2 <= events.length) {
        if (enter === void 0) {
          if (events[index2] && events[index2][1].type === "data") {
            enter = index2;
            index2++;
          }
        } else if (!events[index2] || events[index2][1].type !== "data") {
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data2 = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data2);
        let index2 = chunks.length;
        let bufferIndex = -1;
        let size3 = 0;
        let tabs;
        while (index2--) {
          const chunk = chunks[index2];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size3++;
              bufferIndex--;
            }
            if (bufferIndex) break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size3++;
          } else if (chunk === -1) {
          } else {
            index2++;
            break;
          }
        }
        if (context._contentTypeTextTrailing && eventIndex === events.length) {
          size3 = 0;
        }
        if (size3) {
          const token2 = {
            type: eventIndex === events.length || tabs || size3 < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex,
              _index: data2.start._index + index2,
              line: data2.end.line,
              column: data2.end.column - size3,
              offset: data2.end.offset - size3
            },
            end: {
              ...data2.end
            }
          };
          data2.end = {
            ...token2.start
          };
          if (data2.start.offset === data2.end.offset) {
            Object.assign(data2, token2);
          } else {
            events.splice(eventIndex, 0, ["enter", token2, context], ["exit", token2, context]);
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }

  // ../../node_modules/micromark/lib/constructs.js
  var constructs_exports = {};
  __export(constructs_exports, {
    attentionMarkers: () => attentionMarkers,
    contentInitial: () => contentInitial,
    disable: () => disable,
    document: () => document3,
    flow: () => flow2,
    flowInitial: () => flowInitial,
    insideSpan: () => insideSpan,
    string: () => string2,
    text: () => text4
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var document3 = {
    [42]: list,
    [43]: list,
    [45]: list,
    [48]: list,
    [49]: list,
    [50]: list,
    [51]: list,
    [52]: list,
    [53]: list,
    [54]: list,
    [55]: list,
    [56]: list,
    [57]: list,
    [62]: blockQuote
  };
  var contentInitial = {
    [91]: definition
  };
  var flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    [32]: codeIndented
  };
  var flow2 = {
    [35]: headingAtx,
    [42]: thematicBreak,
    [45]: [setextUnderline, thematicBreak],
    [60]: htmlFlow,
    [61]: setextUnderline,
    [95]: thematicBreak,
    [96]: codeFenced,
    [126]: codeFenced
  };
  var string2 = {
    [38]: characterReference,
    [92]: characterEscape
  };
  var text4 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    [33]: labelStartImage,
    [38]: characterReference,
    [42]: attention,
    [60]: [autolink, htmlText],
    [91]: labelStartLink,
    [92]: [hardBreakEscape, characterEscape],
    [93]: labelEnd,
    [95]: attention,
    [96]: codeText
  };
  var insideSpan = {
    null: [attention, resolver]
  };
  var attentionMarkers = {
    null: [42, 95]
  };
  var disable = {
    null: []
  };

  // ../../node_modules/micromark/lib/create-tokenizer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createTokenizer(parser, initialize, from2) {
    let point4 = {
      _bufferIndex: -1,
      _index: 0,
      line: from2 && from2.line || 1,
      column: from2 && from2.column || 1,
      offset: from2 && from2.offset || 0
    };
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    let consumed = true;
    const effects = {
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      consume,
      enter,
      exit: exit3,
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      code: null,
      containerState: {},
      defineSkip,
      events: [],
      now: now2,
      parser,
      previous: null,
      sliceSerialize,
      sliceStream,
      write
    };
    let state = initialize.tokenize.call(context, effects);
    let expectedCode;
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    return context;
    function write(slice2) {
      chunks = push(chunks, slice2);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token2, expandTabs) {
      return serializeChunks(sliceStream(token2), expandTabs);
    }
    function sliceStream(token2) {
      return sliceChunks(chunks, token2);
    }
    function now2() {
      const {
        _bufferIndex,
        _index,
        line: line2,
        column: column2,
        offset: offset4
      } = point4;
      return {
        _bufferIndex,
        _index,
        line: line2,
        column: column2,
        offset: offset4
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      let chunkIndex;
      while (point4._index < chunks.length) {
        const chunk = chunks[point4._index];
        if (typeof chunk === "string") {
          chunkIndex = point4._index;
          if (point4._bufferIndex < 0) {
            point4._bufferIndex = 0;
          }
          while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point4._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code4) {
      consumed = void 0;
      expectedCode = code4;
      state = state(code4);
    }
    function consume(code4) {
      if (markdownLineEnding(code4)) {
        point4.line++;
        point4.column = 1;
        point4.offset += code4 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code4 !== -1) {
        point4.column++;
        point4.offset++;
      }
      if (point4._bufferIndex < 0) {
        point4._index++;
      } else {
        point4._bufferIndex++;
        if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
        // strings.
        /** @type {string} */
        chunks[point4._index].length) {
          point4._bufferIndex = -1;
          point4._index++;
        }
      }
      context.previous = code4;
      consumed = true;
    }
    function enter(type, fields) {
      const token2 = fields || {};
      token2.type = type;
      token2.start = now2();
      context.events.push(["enter", token2, context]);
      stack.push(token2);
      return token2;
    }
    function exit3(type) {
      const token2 = stack.pop();
      token2.end = now2();
      context.events.push(["exit", token2, context]);
      return token2;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs2, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs2) ? (
          /* c8 ignore next 1 */
          handleListOfConstructs(constructs2)
        ) : "tokenize" in constructs2 ? (
          // Looks like a construct.
          handleListOfConstructs([
            /** @type {Construct} */
            constructs2
          ])
        ) : handleMapOfConstructs(constructs2);
        function handleMapOfConstructs(map3) {
          return start2;
          function start2(code4) {
            const left = code4 !== null && map3[code4];
            const all2 = code4 !== null && map3.null;
            const list4 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(left) ? left : left ? [left] : [],
              ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
            ];
            return handleListOfConstructs(list4)(code4);
          }
        }
        function handleListOfConstructs(list4) {
          listOfConstructs = list4;
          constructIndex = 0;
          if (list4.length === 0) {
            return bogusState;
          }
          return handleConstruct(list4[constructIndex]);
        }
        function handleConstruct(construct) {
          return start2;
          function start2(code4) {
            info = store2();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok(code4);
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a “live binding”, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok3,
              nok
            )(code4);
          }
        }
        function ok3(code4) {
          consumed = true;
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code4) {
          consumed = true;
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from3) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice(context.events, from3, context.events.length - from3, construct.resolve(context.events.slice(from3), context));
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store2() {
      const startPoint = now2();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        from: startEventsIndex,
        restore
      };
      function restore() {
        point4 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point4.line in columnStart && point4.column < 2) {
        point4.column = columnStart[point4.line];
        point4.offset += columnStart[point4.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token2) {
    const startIndex = token2.start._index;
    const startBufferIndex = token2.start._bufferIndex;
    const endIndex = token2.end._index;
    const endBufferIndex = token2.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head = view[0];
        if (typeof head === "string") {
          view[0] = head.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks(chunks, expandTabs) {
    let index2 = -1;
    const result = [];
    let atTab;
    while (++index2 < chunks.length) {
      const chunk = chunks[index2];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }

  // ../../node_modules/micromark/lib/parse.js
  function parse2(options) {
    const settings = options || {};
    const constructs2 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions([constructs_exports, ...settings.extensions || []])
    );
    const parser = {
      constructs: constructs2,
      content: create3(content),
      defined: [],
      document: create3(document2),
      flow: create3(flow),
      lazy: {},
      string: create3(string),
      text: create3(text3)
    };
    return parser;
    function create3(initial) {
      return creator;
      function creator(from2) {
        return createTokenizer(parser, initial, from2);
      }
    }
  }

  // ../../node_modules/micromark/lib/postprocess.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }

  // ../../node_modules/micromark/lib/preprocess.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var search = /[\0\t\n\r]/g;
  function preprocess() {
    let column2 = 1;
    let buffer = "";
    let start2 = true;
    let atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      const chunks = [];
      let match2;
      let next2;
      let startPosition;
      let endPosition;
      let code4;
      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
      startPosition = 0;
      buffer = "";
      if (start2) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start2 = void 0;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match2 = search.exec(value);
        endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
        code4 = value.charCodeAt(endPosition);
        if (!match2) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code4 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column2 += endPosition - startPosition;
          }
          switch (code4) {
            case 0: {
              chunks.push(65533);
              column2++;
              break;
            }
            case 9: {
              next2 = Math.ceil(column2 / 4) * 4;
              chunks.push(-2);
              while (column2++ < next2) chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column2 = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column2 = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn) chunks.push(-5);
        if (buffer) chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }

  // ../../node_modules/micromark-util-decode-string/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head = $2.charCodeAt(0);
    if (head === 35) {
      const head2 = $2.charCodeAt(1);
      const hex = head2 === 120 || head2 === 88;
      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }

  // ../../node_modules/mdast-util-from-markdown/lib/index.js
  var own2 = {}.hasOwnProperty;
  function fromMarkdown(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(postprocess(parse2(options).document().write(preprocess()(value, encoding, true))));
  }
  function compiler(options) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link3),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading3),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition3),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis3),
        hardBreakEscape: opener(hardBreak3),
        hardBreakTrailing: opener(hardBreak3),
        htmlFlow: opener(html5, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html5, buffer),
        htmlTextData: onenterdata,
        image: opener(image3),
        label: buffer,
        link: opener(link3),
        listItem: opener(listItem3),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list4, onenterlistordered),
        listUnordered: opener(list4),
        paragraph: opener(paragraph3),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading3),
        strong: opener(strong3),
        thematicBreak: opener(thematicBreak4)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        characterReference: onexitcharacterreference,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure(config, (options || {}).mdastExtensions || []);
    const data2 = {};
    return compile2;
    function compile2(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter,
        exit: exit3,
        buffer,
        resume,
        data: data2
      };
      const listStack = [];
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
          if (events[index2][0] === "enter") {
            listStack.push(index2);
          } else {
            const tail = listStack.pop();
            index2 = prepareList(events, tail, index2);
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        const handler = config[events[index2][0]];
        if (own2.call(handler, events[index2][1].type)) {
          handler[events[index2][1].type].call(Object.assign({
            sliceSerialize: events[index2][2].sliceSerialize
          }, context), events[index2][1]);
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point3(events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: point3(events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      };
      index2 = -1;
      while (++index2 < config.transforms.length) {
        tree = config.transforms[index2](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start2, length2) {
      let index2 = start2 - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem4;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index2 <= length2) {
        const event = events[index2];
        switch (event[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter") {
              if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace": {
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem4) {
            let tailIndex = index2;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit") continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
              } else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem4._spread = true;
            }
            listItem4.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index2, 0, ["exit", listItem4, event[2]]);
            index2++;
            length2++;
          }
          if (event[1].type === "listItemPrefix") {
            const item = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: we’ll add `end` in a second.
              end: void 0
            };
            listItem4 = item;
            events.splice(index2, 0, ["enter", item, event[2]]);
            index2++;
            length2++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start2][1]._spread = listSpread;
      return length2;
    }
    function opener(create3, and) {
      return open;
      function open(token2) {
        enter.call(this, create3(token2), token2);
        if (and) and.call(this, token2);
      }
    }
    function buffer() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter(node3, token2, errorHandler) {
      const parent = this.stack[this.stack.length - 1];
      const siblings = parent.children;
      siblings.push(node3);
      this.stack.push(node3);
      this.tokenStack.push([token2, errorHandler || void 0]);
      node3.position = {
        start: point3(token2.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function closer(and) {
      return close;
      function close(token2) {
        if (and) and.call(this, token2);
        exit3.call(this, token2);
      }
    }
    function exit3(token2, onExitError) {
      const node3 = this.stack.pop();
      const open = this.tokenStack.pop();
      if (!open) {
        throw new Error("Cannot close `" + token2.type + "` (" + stringifyPosition({
          start: token2.start,
          end: token2.end
        }) + "): it\u2019s not open");
      } else if (open[0].type !== token2.type) {
        if (onExitError) {
          onExitError.call(this, token2, open[0]);
        } else {
          const handler = open[1] || defaultOnError;
          handler.call(this, token2, open[0]);
        }
      }
      node3.position.end = point3(token2.end);
    }
    function resume() {
      return toString(this.stack.pop());
    }
    function onenterlistordered() {
      this.data.expectingFirstListItemValue = true;
    }
    function onenterlistitemvalue(token2) {
      if (this.data.expectingFirstListItemValue) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
        this.data.expectingFirstListItemValue = void 0;
      }
    }
    function onexitcodefencedfenceinfo() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.lang = data3;
    }
    function onexitcodefencedfencemeta() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.meta = data3;
    }
    function onexitcodefencedfence() {
      if (this.data.flowCodeInside) return;
      this.buffer();
      this.data.flowCodeInside = true;
    }
    function onexitcodefenced() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      this.data.flowCodeInside = void 0;
    }
    function onexitcodeindented() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token2) {
      const label = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.label = label;
      node3.identifier = normalizeIdentifier(this.sliceSerialize(token2)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.title = data3;
    }
    function onexitdefinitiondestinationstring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.url = data3;
    }
    function onexitatxheadingsequence(token2) {
      const node3 = this.stack[this.stack.length - 1];
      if (!node3.depth) {
        const depth = this.sliceSerialize(token2).length;
        node3.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      this.data.setextHeadingSlurpLineEnding = true;
    }
    function onexitsetextheadinglinesequence(token2) {
      const node3 = this.stack[this.stack.length - 1];
      node3.depth = this.sliceSerialize(token2).codePointAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function onenterdata(token2) {
      const node3 = this.stack[this.stack.length - 1];
      const siblings = node3.children;
      let tail = siblings[siblings.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text9();
        tail.position = {
          start: point3(token2.start),
          // @ts-expect-error: we’ll add `end` later.
          end: void 0
        };
        siblings.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token2) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token2);
      tail.position.end = point3(token2.end);
    }
    function onexitlineending(token2) {
      const context = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point3(token2.end);
        this.data.atHardBreak = void 0;
        return;
      }
      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token2);
        onexitdata.call(this, token2);
      }
    }
    function onexithardbreak() {
      this.data.atHardBreak = true;
    }
    function onexithtmlflow() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexithtmltext() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexitcodetext() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.value = data3;
    }
    function onexitlink() {
      const node3 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node3.type += "Reference";
        node3.referenceType = referenceType;
        delete node3.url;
        delete node3.title;
      } else {
        delete node3.identifier;
        delete node3.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitimage() {
      const node3 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node3.type += "Reference";
        node3.referenceType = referenceType;
        delete node3.url;
        delete node3.title;
      } else {
        delete node3.identifier;
        delete node3.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitlabeltext(token2) {
      const string3 = this.sliceSerialize(token2);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string3);
      ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
    }
    function onexitlabel() {
      const fragment = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      this.data.inReference = true;
      if (node3.type === "link") {
        const children2 = fragment.children;
        node3.children = children2;
      } else {
        node3.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.url = data3;
    }
    function onexitresourcetitlestring() {
      const data3 = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.title = data3;
    }
    function onexitresource() {
      this.data.inReference = void 0;
    }
    function onenterreference() {
      this.data.referenceType = "collapsed";
    }
    function onexitreferencestring(token2) {
      const label = this.resume();
      const node3 = this.stack[this.stack.length - 1];
      node3.label = label;
      node3.identifier = normalizeIdentifier(this.sliceSerialize(token2)).toLowerCase();
      this.data.referenceType = "full";
    }
    function onexitcharacterreferencemarker(token2) {
      this.data.characterReferenceType = token2.type;
    }
    function onexitcharacterreferencevalue(token2) {
      const data3 = this.sliceSerialize(token2);
      const type = this.data.characterReferenceType;
      let value;
      if (type) {
        value = decodeNumericCharacterReference(data3, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        this.data.characterReferenceType = void 0;
      } else {
        const result = decodeNamedCharacterReference(data3);
        value = result;
      }
      const tail = this.stack[this.stack.length - 1];
      tail.value += value;
    }
    function onexitcharacterreference(token2) {
      const tail = this.stack.pop();
      tail.position.end = point3(token2.end);
    }
    function onexitautolinkprotocol(token2) {
      onexitdata.call(this, token2);
      const node3 = this.stack[this.stack.length - 1];
      node3.url = this.sliceSerialize(token2);
    }
    function onexitautolinkemail(token2) {
      onexitdata.call(this, token2);
      const node3 = this.stack[this.stack.length - 1];
      node3.url = "mailto:" + this.sliceSerialize(token2);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition3() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis3() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading3() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function hardBreak3() {
      return {
        type: "break"
      };
    }
    function html5() {
      return {
        type: "html",
        value: ""
      };
    }
    function image3() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link3() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list4(token2) {
      return {
        type: "list",
        ordered: token2.type === "listOrdered",
        start: null,
        spread: token2._spread,
        children: []
      };
    }
    function listItem3(token2) {
      return {
        type: "listItem",
        spread: token2._spread,
        checked: null,
        children: []
      };
    }
    function paragraph3() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong3() {
      return {
        type: "strong",
        children: []
      };
    }
    function text9() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak4() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point3(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure(combined, extensions) {
    let index2 = -1;
    while (++index2 < extensions.length) {
      const value = extensions[index2];
      if (Array.isArray(value)) {
        configure(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key;
    for (key in extension2) {
      if (own2.call(extension2, key)) {
        switch (key) {
          case "canContainEols": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "transforms": {
            const right = extension2[key];
            if (right) {
              combined[key].push(...right);
            }
            break;
          }
          case "enter":
          case "exit": {
            const right = extension2[key];
            if (right) {
              Object.assign(combined[key], right);
            }
            break;
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open");
    } else {
      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open");
    }
  }

  // ../../node_modules/remark-parse/lib/index.js
  function remarkParse(options) {
    const self2 = this;
    self2.parser = parser;
    function parser(doc) {
      return fromMarkdown(doc, {
        ...self2.data("settings"),
        ...options,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      });
    }
  }

  // ../../node_modules/remark-rehype/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-hast/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-hast/lib/handlers/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function blockquote(state, node3) {
    const result = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: state.wrap(state.all(node3), true)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/break.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function hardBreak(state, node3) {
    const result = { type: "element", tagName: "br", properties: {}, children: [] };
    state.patch(node3, result);
    return [state.applyData(node3, result), { type: "text", value: "\n" }];
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/code.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function code(state, node3) {
    const value = node3.value ? node3.value + "\n" : "";
    const properties2 = {};
    if (node3.lang) {
      properties2.className = ["language-" + node3.lang];
    }
    let result = {
      type: "element",
      tagName: "code",
      properties: properties2,
      children: [{ type: "text", value }]
    };
    if (node3.meta) {
      result.data = { meta: node3.meta };
    }
    state.patch(node3, result);
    result = state.applyData(node3, result);
    result = { type: "element", tagName: "pre", properties: {}, children: [result] };
    state.patch(node3, result);
    return result;
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/delete.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function strikethrough(state, node3) {
    const result = {
      type: "element",
      tagName: "del",
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function emphasis(state, node3) {
    const result = {
      type: "element",
      tagName: "em",
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function footnoteReference(state, node3) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const id = String(node3.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    const index2 = state.footnoteOrder.indexOf(id);
    let counter;
    let reuseCounter = state.footnoteCounts.get(id);
    if (reuseCounter === void 0) {
      reuseCounter = 0;
      state.footnoteOrder.push(id);
      counter = state.footnoteOrder.length;
    } else {
      counter = index2 + 1;
    }
    reuseCounter += 1;
    state.footnoteCounts.set(id, reuseCounter);
    const link3 = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + clobberPrefix + "fn-" + safeId,
        id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(counter) }]
    };
    state.patch(node3, link3);
    const sup = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [link3]
    };
    state.patch(node3, sup);
    return state.applyData(node3, sup);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/heading.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function heading(state, node3) {
    const result = {
      type: "element",
      tagName: "h" + node3.depth,
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/html.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function html3(state, node3) {
    if (state.options.allowDangerousHtml) {
      const result = { type: "raw", value: node3.value };
      state.patch(node3, result);
      return state.applyData(node3, result);
    }
    return void 0;
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-hast/lib/revert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function revert(state, node3) {
    const subtype = node3.referenceType;
    let suffix = "]";
    if (subtype === "collapsed") {
      suffix += "[]";
    } else if (subtype === "full") {
      suffix += "[" + (node3.label || node3.identifier) + "]";
    }
    if (node3.type === "imageReference") {
      return [{ type: "text", value: "![" + node3.alt + suffix }];
    }
    const contents = state.all(node3);
    const head = contents[0];
    if (head && head.type === "text") {
      head.value = "[" + head.value;
    } else {
      contents.unshift({ type: "text", value: "[" });
    }
    const tail = contents[contents.length - 1];
    if (tail && tail.type === "text") {
      tail.value += suffix;
    } else {
      contents.push({ type: "text", value: suffix });
    }
    return contents;
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
  function imageReference(state, node3) {
    const id = String(node3.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id);
    if (!definition3) {
      return revert(state, node3);
    }
    const properties2 = { src: normalizeUri(definition3.url || ""), alt: node3.alt };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties2.title = definition3.title;
    }
    const result = { type: "element", tagName: "img", properties: properties2, children: [] };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function image(state, node3) {
    const properties2 = { src: normalizeUri(node3.url) };
    if (node3.alt !== null && node3.alt !== void 0) {
      properties2.alt = node3.alt;
    }
    if (node3.title !== null && node3.title !== void 0) {
      properties2.title = node3.title;
    }
    const result = { type: "element", tagName: "img", properties: properties2, children: [] };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function inlineCode(state, node3) {
    const text9 = { type: "text", value: node3.value.replace(/\r?\n|\r/g, " ") };
    state.patch(node3, text9);
    const result = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [text9]
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function linkReference(state, node3) {
    const id = String(node3.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id);
    if (!definition3) {
      return revert(state, node3);
    }
    const properties2 = { href: normalizeUri(definition3.url || "") };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties2.title = definition3.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties: properties2,
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/link.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function link(state, node3) {
    const properties2 = { href: normalizeUri(node3.url) };
    if (node3.title !== null && node3.title !== void 0) {
      properties2.title = node3.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties: properties2,
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function listItem(state, node3, parent) {
    const results = state.all(node3);
    const loose = parent ? listLoose(parent) : listItemLoose(node3);
    const properties2 = {};
    const children2 = [];
    if (typeof node3.checked === "boolean") {
      const head = results[0];
      let paragraph3;
      if (head && head.type === "element" && head.tagName === "p") {
        paragraph3 = head;
      } else {
        paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
        results.unshift(paragraph3);
      }
      if (paragraph3.children.length > 0) {
        paragraph3.children.unshift({ type: "text", value: " " });
      }
      paragraph3.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: node3.checked, disabled: true },
        children: []
      });
      properties2.className = ["task-list-item"];
    }
    let index2 = -1;
    while (++index2 < results.length) {
      const child = results[index2];
      if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
        children2.push({ type: "text", value: "\n" });
      }
      if (child.type === "element" && child.tagName === "p" && !loose) {
        children2.push(...child.children);
      } else {
        children2.push(child);
      }
    }
    const tail = results[results.length - 1];
    if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
      children2.push({ type: "text", value: "\n" });
    }
    const result = { type: "element", tagName: "li", properties: properties2, children: children2 };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }
  function listLoose(node3) {
    let loose = false;
    if (node3.type === "list") {
      loose = node3.spread || false;
      const children2 = node3.children;
      let index2 = -1;
      while (!loose && ++index2 < children2.length) {
        loose = listItemLoose(children2[index2]);
      }
    }
    return loose;
  }
  function listItemLoose(node3) {
    const spread = node3.spread;
    return spread === null || spread === void 0 ? node3.children.length > 1 : spread;
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/list.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function list2(state, node3) {
    const properties2 = {};
    const results = state.all(node3);
    let index2 = -1;
    if (typeof node3.start === "number" && node3.start !== 1) {
      properties2.start = node3.start;
    }
    while (++index2 < results.length) {
      const child = results[index2];
      if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
        properties2.className = ["contains-task-list"];
        break;
      }
    }
    const result = {
      type: "element",
      tagName: node3.ordered ? "ol" : "ul",
      properties: properties2,
      children: state.wrap(results, true)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function paragraph(state, node3) {
    const result = {
      type: "element",
      tagName: "p",
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/root.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function root2(state, node3) {
    const result = { type: "root", children: state.wrap(state.all(node3)) };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/strong.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function strong(state, node3) {
    const result = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function table(state, node3) {
    const rows = state.all(node3);
    const firstRow = rows.shift();
    const tableContent = [];
    if (firstRow) {
      const head = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: state.wrap([firstRow], true)
      };
      state.patch(node3.children[0], head);
      tableContent.push(head);
    }
    if (rows.length > 0) {
      const body = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: state.wrap(rows, true)
      };
      const start2 = pointStart(node3.children[1]);
      const end = pointEnd(node3.children[node3.children.length - 1]);
      if (start2 && end) body.position = { start: start2, end };
      tableContent.push(body);
    }
    const result = {
      type: "element",
      tagName: "table",
      properties: {},
      children: state.wrap(tableContent, true)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/table-row.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function tableRow(state, node3, parent) {
    const siblings = parent ? parent.children : void 0;
    const rowIndex = siblings ? siblings.indexOf(node3) : 1;
    const tagName = rowIndex === 0 ? "th" : "td";
    const align = parent && parent.type === "table" ? parent.align : void 0;
    const length2 = align ? align.length : node3.children.length;
    let cellIndex = -1;
    const cells = [];
    while (++cellIndex < length2) {
      const cell = node3.children[cellIndex];
      const properties2 = {};
      const alignValue = align ? align[cellIndex] : void 0;
      if (alignValue) {
        properties2.align = alignValue;
      }
      let result2 = { type: "element", tagName, properties: properties2, children: [] };
      if (cell) {
        result2.children = state.all(cell);
        state.patch(cell, result2);
        result2 = state.applyData(cell, result2);
      }
      cells.push(result2);
    }
    const result = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: state.wrap(cells, true)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function tableCell(state, node3) {
    const result = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/text.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/trim-lines/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tab = 9;
  var space = 32;
  function trimLines(value) {
    const source = String(value);
    const search2 = /\r?\n|\r/g;
    let match2 = search2.exec(source);
    let last = 0;
    const lines = [];
    while (match2) {
      lines.push(
        trimLine(source.slice(last, match2.index), last > 0, true),
        match2[0]
      );
      last = match2.index + match2[0].length;
      match2 = search2.exec(source);
    }
    lines.push(trimLine(source.slice(last), last > 0, false));
    return lines.join("");
  }
  function trimLine(value, start2, end) {
    let startIndex = 0;
    let endIndex = value.length;
    if (start2) {
      let code4 = value.codePointAt(startIndex);
      while (code4 === tab || code4 === space) {
        startIndex++;
        code4 = value.codePointAt(startIndex);
      }
    }
    if (end) {
      let code4 = value.codePointAt(endIndex - 1);
      while (code4 === tab || code4 === space) {
        endIndex--;
        code4 = value.codePointAt(endIndex - 1);
      }
    }
    return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/text.js
  function text5(state, node3) {
    const result = { type: "text", value: trimLines(String(node3.value)) };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function thematicBreak2(state, node3) {
    const result = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }

  // ../../node_modules/mdast-util-to-hast/lib/handlers/index.js
  var handlers = {
    blockquote,
    break: hardBreak,
    code,
    delete: strikethrough,
    emphasis,
    footnoteReference,
    heading,
    html: html3,
    imageReference,
    image,
    inlineCode,
    linkReference,
    link,
    listItem,
    list: list2,
    paragraph,
    // @ts-expect-error: root is different, but hard to type.
    root: root2,
    strong,
    table,
    tableCell,
    tableRow,
    text: text5,
    thematicBreak: thematicBreak2,
    toml: ignore,
    yaml: ignore,
    definition: ignore,
    footnoteDefinition: ignore
  };
  function ignore() {
    return void 0;
  }

  // ../../node_modules/mdast-util-to-hast/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-hast/lib/footer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ungap/structured-clone/esm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ungap/structured-clone/esm/deserialize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@ungap/structured-clone/esm/types.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var VOID = -1;
  var PRIMITIVE = 0;
  var ARRAY = 1;
  var OBJECT = 2;
  var DATE = 3;
  var REGEXP = 4;
  var MAP = 5;
  var SET = 6;
  var ERROR2 = 7;
  var BIGINT = 8;

  // ../../node_modules/@ungap/structured-clone/esm/deserialize.js
  var env = typeof self === "object" ? self : globalThis;
  var deserializer = ($, _) => {
    const as = (out, index2) => {
      $.set(index2, out);
      return out;
    };
    const unpair = (index2) => {
      if ($.has(index2))
        return $.get(index2);
      const [type, value] = _[index2];
      switch (type) {
        case PRIMITIVE:
        case VOID:
          return as(value, index2);
        case ARRAY: {
          const arr = as([], index2);
          for (const index3 of value)
            arr.push(unpair(index3));
          return arr;
        }
        case OBJECT: {
          const object2 = as({}, index2);
          for (const [key, index3] of value)
            object2[unpair(key)] = unpair(index3);
          return object2;
        }
        case DATE:
          return as(new Date(value), index2);
        case REGEXP: {
          const { source, flags } = value;
          return as(new RegExp(source, flags), index2);
        }
        case MAP: {
          const map3 = as(/* @__PURE__ */ new Map(), index2);
          for (const [key, index3] of value)
            map3.set(unpair(key), unpair(index3));
          return map3;
        }
        case SET: {
          const set = as(/* @__PURE__ */ new Set(), index2);
          for (const index3 of value)
            set.add(unpair(index3));
          return set;
        }
        case ERROR2: {
          const { name: name21, message } = value;
          return as(new env[name21](message), index2);
        }
        case BIGINT:
          return as(BigInt(value), index2);
        case "BigInt":
          return as(Object(BigInt(value)), index2);
        case "ArrayBuffer":
          return as(new Uint8Array(value).buffer, value);
        case "DataView": {
          const { buffer } = new Uint8Array(value);
          return as(new DataView(buffer), value);
        }
      }
      return as(new env[type](value), index2);
    };
    return unpair;
  };
  var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

  // ../../node_modules/@ungap/structured-clone/esm/serialize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var EMPTY = "";
  var { toString: toString2 } = {};
  var { keys } = Object;
  var typeOf = (value) => {
    const type = typeof value;
    if (type !== "object" || !value)
      return [PRIMITIVE, type];
    const asString = toString2.call(value).slice(8, -1);
    switch (asString) {
      case "Array":
        return [ARRAY, EMPTY];
      case "Object":
        return [OBJECT, EMPTY];
      case "Date":
        return [DATE, EMPTY];
      case "RegExp":
        return [REGEXP, EMPTY];
      case "Map":
        return [MAP, EMPTY];
      case "Set":
        return [SET, EMPTY];
      case "DataView":
        return [ARRAY, asString];
    }
    if (asString.includes("Array"))
      return [ARRAY, asString];
    if (asString.includes("Error"))
      return [ERROR2, asString];
    return [OBJECT, asString];
  };
  var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
  var serializer = (strict, json, $, _) => {
    const as = (out, value) => {
      const index2 = _.push(out) - 1;
      $.set(value, index2);
      return index2;
    };
    const pair = (value) => {
      if ($.has(value))
        return $.get(value);
      let [TYPE, type] = typeOf(value);
      switch (TYPE) {
        case PRIMITIVE: {
          let entry = value;
          switch (type) {
            case "bigint":
              TYPE = BIGINT;
              entry = value.toString();
              break;
            case "function":
            case "symbol":
              if (strict)
                throw new TypeError("unable to serialize " + type);
              entry = null;
              break;
            case "undefined":
              return as([VOID], value);
          }
          return as([TYPE, entry], value);
        }
        case ARRAY: {
          if (type) {
            let spread = value;
            if (type === "DataView") {
              spread = new Uint8Array(value.buffer);
            } else if (type === "ArrayBuffer") {
              spread = new Uint8Array(value);
            }
            return as([type, [...spread]], value);
          }
          const arr = [];
          const index2 = as([TYPE, arr], value);
          for (const entry of value)
            arr.push(pair(entry));
          return index2;
        }
        case OBJECT: {
          if (type) {
            switch (type) {
              case "BigInt":
                return as([type, value.toString()], value);
              case "Boolean":
              case "Number":
              case "String":
                return as([type, value.valueOf()], value);
            }
          }
          if (json && "toJSON" in value)
            return pair(value.toJSON());
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const key of keys(value)) {
            if (strict || !shouldSkip(typeOf(value[key])))
              entries.push([pair(key), pair(value[key])]);
          }
          return index2;
        }
        case DATE:
          return as([TYPE, value.toISOString()], value);
        case REGEXP: {
          const { source, flags } = value;
          return as([TYPE, { source, flags }], value);
        }
        case MAP: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const [key, entry] of value) {
            if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
              entries.push([pair(key), pair(entry)]);
          }
          return index2;
        }
        case SET: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const entry of value) {
            if (strict || !shouldSkip(typeOf(entry)))
              entries.push(pair(entry));
          }
          return index2;
        }
      }
      const { message } = value;
      return as([TYPE, { name: type, message }], value);
    };
    return pair;
  };
  var serialize2 = (value, { json, lossy } = {}) => {
    const _ = [];
    return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
  };

  // ../../node_modules/@ungap/structured-clone/esm/index.js
  var esm_default2 = typeof structuredClone === "function" ? (
    /* c8 ignore start */
    (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize2(any, options)) : structuredClone(any)
  ) : (any, options) => deserialize(serialize2(any, options));

  // ../../node_modules/mdast-util-to-hast/lib/footer.js
  function defaultFootnoteBackContent(_, rereferenceIndex) {
    const result = [{ type: "text", value: "\u21A9" }];
    if (rereferenceIndex > 1) {
      result.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{ type: "text", value: String(rereferenceIndex) }]
      });
    }
    return result;
  }
  function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
    return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
  }
  function footer(state) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
    const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
    const footnoteLabel = state.options.footnoteLabel || "Footnotes";
    const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
    const footnoteLabelProperties = state.options.footnoteLabelProperties || {
      className: ["sr-only"]
    };
    const listItems = [];
    let referenceIndex = -1;
    while (++referenceIndex < state.footnoteOrder.length) {
      const definition3 = state.footnoteById.get(
        state.footnoteOrder[referenceIndex]
      );
      if (!definition3) {
        continue;
      }
      const content3 = state.all(definition3);
      const id = String(definition3.identifier).toUpperCase();
      const safeId = normalizeUri(id.toLowerCase());
      let rereferenceIndex = 0;
      const backReferences = [];
      const counts = state.footnoteCounts.get(id);
      while (counts !== void 0 && ++rereferenceIndex <= counts) {
        if (backReferences.length > 0) {
          backReferences.push({ type: "text", value: " " });
        }
        let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
        if (typeof children2 === "string") {
          children2 = { type: "text", value: children2 };
        }
        backReferences.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(children2) ? children2 : [children2]
        });
      }
      const tail = content3[content3.length - 1];
      if (tail && tail.type === "element" && tail.tagName === "p") {
        const tailTail = tail.children[tail.children.length - 1];
        if (tailTail && tailTail.type === "text") {
          tailTail.value += " ";
        } else {
          tail.children.push({ type: "text", value: " " });
        }
        tail.children.push(...backReferences);
      } else {
        content3.push(...backReferences);
      }
      const listItem3 = {
        type: "element",
        tagName: "li",
        properties: { id: clobberPrefix + "fn-" + safeId },
        children: state.wrap(content3, true)
      };
      state.patch(definition3, listItem3);
      listItems.push(listItem3);
    }
    if (listItems.length === 0) {
      return;
    }
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: footnoteLabelTagName,
          properties: {
            ...esm_default2(footnoteLabelProperties),
            id: "footnote-label"
          },
          children: [{ type: "text", value: footnoteLabel }]
        },
        { type: "text", value: "\n" },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, true)
        },
        { type: "text", value: "\n" }
      ]
    };
  }

  // ../../node_modules/mdast-util-to-hast/lib/state.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-visit/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-visit/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-visit-parents/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-visit-parents/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-is/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unist-util-is/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var convert = (
    // Note: overloads in JSDoc can’t yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(test) {
      if (test === null || test === void 0) {
        return ok2;
      }
      if (typeof test === "function") {
        return castFactory(test);
      }
      if (typeof test === "object") {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      throw new Error("Expected function, string, or object as test");
    }
  );
  function anyFactory(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert(tests[index2]);
    }
    return castFactory(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory(all2);
    function all2(node3) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node3
      );
      let key;
      for (key in check) {
        if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node3) {
      return node3 && node3.type === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value, index2, parent) {
      return Boolean(
        looksLikeANode(value) && testFunction.call(
          this,
          value,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok2() {
    return true;
  }
  function looksLikeANode(value) {
    return value !== null && typeof value === "object" && "type" in value;
  }

  // ../../node_modules/unist-util-visit-parents/lib/color.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function color(d) {
    return d;
  }

  // ../../node_modules/unist-util-visit-parents/lib/index.js
  var empty2 = [];
  var CONTINUE = true;
  var EXIT = false;
  var SKIP = "skip";
  function visitParents(tree, test, visitor, reverse) {
    let check;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
    } else {
      check = test;
    }
    const is2 = convert(check);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node3, index2, parents) {
      const value = (
        /** @type {Record<string, unknown>} */
        node3 && typeof node3 === "object" ? node3 : {}
      );
      if (typeof value.type === "string") {
        const name21 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node3.type + (name21 ? "<" + name21 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = empty2;
        let subresult;
        let offset4;
        let grandparents;
        if (!test || is2(node3, index2, parents[parents.length - 1] || void 0)) {
          result = toResult(visitor(node3, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if ("children" in node3 && node3.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node3
          );
          if (nodeAsParent.children && result[0] !== SKIP) {
            offset4 = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset4 > -1 && offset4 < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset4];
              subresult = factory(child, offset4, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset4 = typeof subresult[1] === "number" ? subresult[1] : offset4 + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return value === null || value === void 0 ? empty2 : [value];
  }

  // ../../node_modules/unist-util-visit/lib/index.js
  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test;
    let visitor;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test = void 0;
      visitor = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test = testOrVisitor;
      visitor = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node3, parents) {
      const parent = parents[parents.length - 1];
      const index2 = parent ? parent.children.indexOf(node3) : void 0;
      return visitor(node3, index2, parent);
    }
  }

  // ../../node_modules/mdast-util-to-hast/lib/state.js
  var own3 = {}.hasOwnProperty;
  var emptyOptions3 = {};
  function createState(tree, options) {
    const settings = options || emptyOptions3;
    const definitionById = /* @__PURE__ */ new Map();
    const footnoteById = /* @__PURE__ */ new Map();
    const footnoteCounts = /* @__PURE__ */ new Map();
    const handlers2 = { ...handlers, ...settings.handlers };
    const state = {
      all: all2,
      applyData,
      definitionById,
      footnoteById,
      footnoteCounts,
      footnoteOrder: [],
      handlers: handlers2,
      one: one3,
      options: settings,
      patch,
      wrap
    };
    visit(tree, function(node3) {
      if (node3.type === "definition" || node3.type === "footnoteDefinition") {
        const map3 = node3.type === "definition" ? definitionById : footnoteById;
        const id = String(node3.identifier).toUpperCase();
        if (!map3.has(id)) {
          map3.set(id, node3);
        }
      }
    });
    return state;
    function one3(node3, parent) {
      const type = node3.type;
      const handle2 = state.handlers[type];
      if (own3.call(state.handlers, type) && handle2) {
        return handle2(state, node3, parent);
      }
      if (state.options.passThrough && state.options.passThrough.includes(type)) {
        if ("children" in node3) {
          const { children: children2, ...shallow } = node3;
          const result = esm_default2(shallow);
          result.children = state.all(node3);
          return result;
        }
        return esm_default2(node3);
      }
      const unknown = state.options.unknownHandler || defaultUnknownHandler;
      return unknown(state, node3, parent);
    }
    function all2(parent) {
      const values = [];
      if ("children" in parent) {
        const nodes = parent.children;
        let index2 = -1;
        while (++index2 < nodes.length) {
          const result = state.one(nodes[index2], parent);
          if (result) {
            if (index2 && nodes[index2 - 1].type === "break") {
              if (!Array.isArray(result) && result.type === "text") {
                result.value = trimMarkdownSpaceStart(result.value);
              }
              if (!Array.isArray(result) && result.type === "element") {
                const head = result.children[0];
                if (head && head.type === "text") {
                  head.value = trimMarkdownSpaceStart(head.value);
                }
              }
            }
            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }
      return values;
    }
  }
  function patch(from2, to) {
    if (from2.position) to.position = position(from2);
  }
  function applyData(from2, to) {
    let result = to;
    if (from2 && from2.data) {
      const hName = from2.data.hName;
      const hChildren = from2.data.hChildren;
      const hProperties = from2.data.hProperties;
      if (typeof hName === "string") {
        if (result.type === "element") {
          result.tagName = hName;
        } else {
          const children2 = "children" in result ? result.children : [result];
          result = { type: "element", tagName: hName, properties: {}, children: children2 };
        }
      }
      if (result.type === "element" && hProperties) {
        Object.assign(result.properties, esm_default2(hProperties));
      }
      if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
        result.children = hChildren;
      }
    }
    return result;
  }
  function defaultUnknownHandler(state, node3) {
    const data2 = node3.data || {};
    const result = "value" in node3 && !(own3.call(data2, "hProperties") || own3.call(data2, "hChildren")) ? { type: "text", value: node3.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: state.all(node3)
    };
    state.patch(node3, result);
    return state.applyData(node3, result);
  }
  function wrap(nodes, loose) {
    const result = [];
    let index2 = -1;
    if (loose) {
      result.push({ type: "text", value: "\n" });
    }
    while (++index2 < nodes.length) {
      if (index2) result.push({ type: "text", value: "\n" });
      result.push(nodes[index2]);
    }
    if (loose && nodes.length > 0) {
      result.push({ type: "text", value: "\n" });
    }
    return result;
  }
  function trimMarkdownSpaceStart(value) {
    let index2 = 0;
    let code4 = value.charCodeAt(index2);
    while (code4 === 9 || code4 === 32) {
      index2++;
      code4 = value.charCodeAt(index2);
    }
    return value.slice(index2);
  }

  // ../../node_modules/mdast-util-to-hast/lib/index.js
  function toHast(tree, options) {
    const state = createState(tree, options);
    const node3 = state.one(tree, void 0);
    const foot = footer(state);
    const result = Array.isArray(node3) ? { type: "root", children: node3 } : node3 || { type: "root", children: [] };
    if (foot) {
      ok("children" in result);
      result.children.push({ type: "text", value: "\n" }, foot);
    }
    return result;
  }

  // ../../node_modules/remark-rehype/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function remarkRehype(destination, options) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const hastTree = (
          /** @type {HastRoot} */
          toHast(tree, { file, ...options })
        );
        await destination.run(hastTree, file);
      };
    }
    return function(tree, file) {
      return (
        /** @type {HastRoot} */
        toHast(tree, { file, ...destination || options })
      );
    };
  }

  // ../../node_modules/unified/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/unified/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/bail/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function bail(error) {
    if (error) {
      throw error;
    }
  }

  // ../../node_modules/unified/lib/index.js
  var import_extend = __toESM(require_extend(), 1);

  // ../../node_modules/is-plain-obj/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }

  // ../../node_modules/trough/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/trough/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function trough() {
    const fns = [];
    const pipeline = { run, use };
    return pipeline;
    function run(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next2(null, ...values);
      function next2(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index2 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index2 < values.length) {
          if (output[index2] === null || output[index2] === void 0) {
            output[index2] = values[index2];
          }
        }
        values = output;
        if (fn) {
          wrap2(fn, next2)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap2(middleware2, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware2.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware2.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }

  // ../../node_modules/vfile/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/vfile/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/vfile/lib/minpath.browser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var minpath = { basename, dirname, extname, join, sep: "/" };
  function basename(path2, extname2) {
    if (extname2 !== void 0 && typeof extname2 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path2);
    let start2 = 0;
    let end = -1;
    let index2 = path2.length;
    let seenNonSlash;
    if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
      while (index2--) {
        if (path2.codePointAt(index2) === 47) {
          if (seenNonSlash) {
            start2 = index2 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index2 + 1;
        }
      }
      return end < 0 ? "" : path2.slice(start2, end);
    }
    if (extname2 === path2) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname2.length - 1;
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start2 = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extnameIndex > -1) {
          if (path2.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end = index2;
            }
          } else {
            extnameIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start2 === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path2.length;
    }
    return path2.slice(start2, end);
  }
  function dirname(path2) {
    assertPath(path2);
    if (path2.length === 0) {
      return ".";
    }
    let end = -1;
    let index2 = path2.length;
    let unmatchedSlash;
    while (--index2) {
      if (path2.codePointAt(index2) === 47) {
        if (unmatchedSlash) {
          end = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
  }
  function extname(path2) {
    assertPath(path2);
    let index2 = path2.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code4 = path2.codePointAt(index2);
      if (code4 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index2 + 1;
      }
      if (code4 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  }
  function join(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize2(joined);
  }
  function normalize2(path2) {
    assertPath(path2);
    const absolute = path2.codePointAt(0) === 47;
    let value = normalizeString(path2, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString(path2, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code4;
    let lastSlashIndex;
    while (++index2 <= path2.length) {
      if (index2 < path2.length) {
        code4 = path2.codePointAt(index2);
      } else if (code4 === 47) {
        break;
      } else {
        code4 = 47;
      }
      if (code4 === 47) {
        if (lastSlash === index2 - 1 || dots === 1) {
        } else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path2.slice(lastSlash + 1, index2);
          } else {
            result = path2.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code4 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path2)
      );
    }
  }

  // ../../node_modules/vfile/lib/minproc.browser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var minproc = { cwd };
  function cwd() {
    return "/";
  }

  // ../../node_modules/vfile/lib/minurl.browser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/vfile/lib/minurl.shared.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }

  // ../../node_modules/vfile/lib/minurl.browser.js
  function urlToPath(path2) {
    if (typeof path2 === "string") {
      path2 = new URL(path2);
    } else if (!isUrl(path2)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path2.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path2);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
        const third = pathname.codePointAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }

  // ../../node_modules/vfile/lib/index.js
  var order = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  var VFile = class {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array` — `{value: options}`
     * *   `URL` — `{path: options}`
     * *   `VFile` — shallow copies its data over to the new file
     * *   `object` — all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(value) {
      let options;
      if (!value) {
        options = {};
      } else if (isUrl(value)) {
        options = { path: value };
      } else if (typeof value === "string" || isUint8Array(value)) {
        options = { value };
      } else {
        options = value;
      }
      this.cwd = "cwd" in options ? "" : minproc.cwd();
      this.data = {};
      this.history = [];
      this.messages = [];
      this.value;
      this.map;
      this.result;
      this.stored;
      let index2 = -1;
      while (++index2 < order.length) {
        const field2 = order[index2];
        if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
          this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
        }
      }
      let field;
      for (field in options) {
        if (!order.includes(field)) {
          this[field] = options[field];
        }
      }
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(basename2) {
      assertNonEmpty(basename2, "basename");
      assertPart(basename2, "basename");
      this.path = minpath.join(this.dirname || "", basename2);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if there’s no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(dirname2) {
      assertPath2(this.basename, "dirname");
      this.path = minpath.join(dirname2 || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if there’s no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(extname2) {
      assertPart(extname2, "extname");
      assertPath2(this.dirname, "extname");
      if (extname2) {
        if (extname2.codePointAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname2.includes(".", 1)) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(path2) {
      if (isUrl(path2)) {
        path2 = urlToPath(path2);
      }
      assertNonEmpty(path2, "path");
      if (this.path !== path2) {
        this.history.push(path2);
      }
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = true;
      throw message;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
      message.fatal = void 0;
      return message;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * > 🪦 **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(causeOrReason, optionsOrParentOrPlace, origin) {
      const message = new VFileMessage(
        // @ts-expect-error: the overloads are fine.
        causeOrReason,
        optionsOrParentOrPlace,
        origin
      );
      if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
      }
      message.fatal = false;
      this.messages.push(message);
      return message;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when it’s a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(encoding) {
      if (this.value === void 0) {
        return "";
      }
      if (typeof this.value === "string") {
        return this.value;
      }
      const decoder = new TextDecoder(encoding || void 0);
      return decoder.decode(this.value);
    }
  };
  function assertPart(part, name21) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name21 + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name21) {
    if (!part) {
      throw new Error("`" + name21 + "` cannot be empty");
    }
  }
  function assertPath2(path2, name21) {
    if (!path2) {
      throw new Error("Setting `" + name21 + "` requires `path` to be set too");
    }
  }
  function isUint8Array(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }

  // ../../node_modules/unified/lib/callable-instance.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var CallableInstance = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    function(property) {
      const self2 = this;
      const constr = self2.constructor;
      const proto = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        constr.prototype
      );
      const value = proto[property];
      const apply = function() {
        return value.apply(apply, arguments);
      };
      Object.setPrototypeOf(apply, proto);
      return apply;
    }
  );

  // ../../node_modules/unified/lib/index.js
  var own4 = {}.hasOwnProperty;
  var Processor = class _Processor extends CallableInstance {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy");
      this.Compiler = void 0;
      this.Parser = void 0;
      this.attachers = [];
      this.compiler = void 0;
      this.freezeIndex = -1;
      this.frozen = void 0;
      this.namespace = {};
      this.parser = void 0;
      this.transformers = trough();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const destination = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new _Processor()
      );
      let index2 = -1;
      while (++index2 < this.attachers.length) {
        const attacher = this.attachers[index2];
        destination.use(...attacher);
      }
      destination.data((0, import_extend.default)(true, {}, this.namespace));
      return destination;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(key, value) {
      if (typeof key === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", this.frozen);
          this.namespace[key] = value;
          return this;
        }
        return own4.call(this.namespace, key) && this.namespace[key] || void 0;
      }
      if (key) {
        assertUnfrozen("data", this.frozen);
        this.namespace = key;
        return this;
      }
      return this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * It’s possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen) {
        return this;
      }
      const self2 = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      while (++this.freezeIndex < this.attachers.length) {
        const [attacher, ...options] = this.attachers[this.freezeIndex];
        if (options[0] === false) {
          continue;
        }
        if (options[0] === true) {
          options[0] = void 0;
        }
        const transformer = attacher.call(self2, ...options);
        if (typeof transformer === "function") {
          this.transformers.use(transformer);
        }
      }
      this.frozen = true;
      this.freezeIndex = Number.POSITIVE_INFINITY;
      return this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(file) {
      this.freeze();
      const realFile = vfile(file);
      const parser = this.parser || this.Parser;
      assertParser("parse", parser);
      return parser(String(realFile), realFile);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(file, done) {
      const self2 = this;
      this.freeze();
      assertParser("process", this.parser || this.Parser);
      assertCompiler("process", this.compiler || this.Compiler);
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve, reject) {
        const realFile = vfile(file);
        const parseTree = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          self2.parse(realFile)
        );
        self2.run(parseTree, realFile, function(error, tree, file2) {
          if (error || !tree || !file2) {
            return realDone(error);
          }
          const compileTree = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            tree
          );
          const compileResult = self2.stringify(compileTree, file2);
          if (looksLikeAValue(compileResult)) {
            file2.value = compileResult;
          } else {
            file2.result = compileResult;
          }
          realDone(
            error,
            /** @type {VFileWithOutput<CompileResult>} */
            file2
          );
        });
        function realDone(error, file2) {
          if (error || !file2) {
            reject(error);
          } else if (resolve) {
            resolve(file2);
          } else {
            ok(done, "`done` is defined if `resolve` is not");
            done(void 0, file2);
          }
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(file) {
      let complete = false;
      let result;
      this.freeze();
      assertParser("processSync", this.parser || this.Parser);
      assertCompiler("processSync", this.compiler || this.Compiler);
      this.process(file, realDone);
      assertDone("processSync", "process", complete);
      ok(result, "we either bailed on an error or have a tree");
      return result;
      function realDone(error, file2) {
        complete = true;
        bail(error);
        result = file2;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(tree, file, done) {
      assertNode(tree);
      this.freeze();
      const transformers = this.transformers;
      if (!done && typeof file === "function") {
        done = file;
        file = void 0;
      }
      return done ? executor(void 0, done) : new Promise(executor);
      function executor(resolve, reject) {
        ok(
          typeof file !== "function",
          "`file` can\u2019t be a `done` anymore, we checked"
        );
        const realFile = vfile(file);
        transformers.run(tree, realFile, realDone);
        function realDone(error, outputTree, file2) {
          const resultingTree = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            outputTree || tree
          );
          if (error) {
            reject(error);
          } else if (resolve) {
            resolve(resultingTree);
          } else {
            ok(done, "`done` is defined if `resolve` is not");
            done(void 0, resultingTree, file2);
          }
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(tree, file) {
      let complete = false;
      let result;
      this.run(tree, file, realDone);
      assertDone("runSync", "run", complete);
      ok(result, "we either bailed on an error or have a tree");
      return result;
      function realDone(error, tree2) {
        bail(error);
        result = tree2;
        complete = true;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If you’re using a compiler that doesn’t serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(tree, file) {
      this.freeze();
      const realFile = vfile(file);
      const compiler2 = this.compiler || this.Compiler;
      assertCompiler("stringify", compiler2);
      assertNode(tree);
      return compiler2(tree, realFile);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(value, ...parameters) {
      const attachers = this.attachers;
      const namespace = this.namespace;
      assertUnfrozen("use", this.frozen);
      if (value === null || value === void 0) {
      } else if (typeof value === "function") {
        addPlugin(value, parameters);
      } else if (typeof value === "object") {
        if (Array.isArray(value)) {
          addList(value);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value + "`");
      }
      return this;
      function add(value2) {
        if (typeof value2 === "function") {
          addPlugin(value2, []);
        } else if (typeof value2 === "object") {
          if (Array.isArray(value2)) {
            const [plugin, ...parameters2] = (
              /** @type {PluginTuple<Array<unknown>>} */
              value2
            );
            addPlugin(plugin, parameters2);
          } else {
            addPreset(value2);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value2 + "`");
        }
      }
      function addPreset(result) {
        if (!("plugins" in result) && !("settings" in result)) {
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        }
        addList(result.plugins);
        if (result.settings) {
          namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
        }
      }
      function addList(plugins) {
        let index2 = -1;
        if (plugins === null || plugins === void 0) {
        } else if (Array.isArray(plugins)) {
          while (++index2 < plugins.length) {
            const thing = plugins[index2];
            add(thing);
          }
        } else {
          throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, parameters2) {
        let index2 = -1;
        let entryIndex = -1;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            entryIndex = index2;
            break;
          }
        }
        if (entryIndex === -1) {
          attachers.push([plugin, ...parameters2]);
        } else if (parameters2.length > 0) {
          let [primary, ...rest] = parameters2;
          const currentPrimary = attachers[entryIndex][1];
          if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
            primary = (0, import_extend.default)(true, currentPrimary, primary);
          }
          attachers[entryIndex] = [plugin, primary, ...rest];
        }
      }
    }
  };
  var unified = new Processor().freeze();
  function assertParser(name21, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name21 + "` without `parser`");
    }
  }
  function assertCompiler(name21, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name21 + "` without `compiler`");
    }
  }
  function assertUnfrozen(name21, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name21 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node3) {
    if (!isPlainObject(node3) || typeof node3.type !== "string") {
      throw new TypeError("Expected node, got `" + node3 + "`");
    }
  }
  function assertDone(name21, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name21 + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAValue(value) {
    return typeof value === "string" || isUint8Array2(value);
  }
  function isUint8Array2(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }

  // ../../node_modules/react-markdown/lib/index.js
  var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
  var emptyPlugins = [];
  var emptyRemarkRehypeOptions = { allowDangerousHtml: true };
  var safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
  var deprecations = [
    { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
    { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
    {
      from: "allowNode",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowElement"
    },
    {
      from: "allowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowedElements"
    },
    { from: "className", id: "remove-classname" },
    {
      from: "disallowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "disallowedElements"
    },
    { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
    { from: "includeElementIndex", id: "#remove-includeelementindex" },
    {
      from: "includeNodeIndex",
      id: "change-includenodeindex-to-includeelementindex"
    },
    { from: "linkTarget", id: "remove-linktarget" },
    { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
    { from: "rawSourcePos", id: "#remove-rawsourcepos" },
    { from: "renderers", id: "change-renderers-to-components", to: "components" },
    { from: "source", id: "change-source-to-children", to: "children" },
    { from: "sourcePos", id: "#remove-sourcepos" },
    { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
    { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
  ];
  function Markdown(options) {
    const processor = createProcessor(options);
    const file = createFile(options);
    return post(processor.runSync(processor.parse(file), file), options);
  }
  function createProcessor(options) {
    const rehypePlugins = options.rehypePlugins || emptyPlugins;
    const remarkPlugins = options.remarkPlugins || emptyPlugins;
    const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
    const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
    return processor;
  }
  function createFile(options) {
    const children2 = options.children || "";
    const file = new VFile();
    if (typeof children2 === "string") {
      file.value = children2;
    } else {
      unreachable(
        "Unexpected value `" + children2 + "` for `children` prop, expected `string`"
      );
    }
    return file;
  }
  function post(tree, options) {
    const allowedElements = options.allowedElements;
    const allowElement = options.allowElement;
    const components = options.components;
    const disallowedElements = options.disallowedElements;
    const skipHtml = options.skipHtml;
    const unwrapDisallowed = options.unwrapDisallowed;
    const urlTransform = options.urlTransform || defaultUrlTransform;
    for (const deprecation of deprecations) {
      if (Object.hasOwn(options, deprecation.from)) {
        unreachable(
          "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
        );
      }
    }
    if (allowedElements && disallowedElements) {
      unreachable(
        "Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other"
      );
    }
    visit(tree, transform3);
    return toJsxRuntime(tree, {
      Fragment: import_jsx_runtime23.Fragment,
      components,
      ignoreInvalidStyle: true,
      jsx: import_jsx_runtime23.jsx,
      jsxs: import_jsx_runtime23.jsxs,
      passKeys: true,
      passNode: true
    });
    function transform3(node3, index2, parent) {
      if (node3.type === "raw" && parent && typeof index2 === "number") {
        if (skipHtml) {
          parent.children.splice(index2, 1);
        } else {
          parent.children[index2] = { type: "text", value: node3.value };
        }
        return index2;
      }
      if (node3.type === "element") {
        let key;
        for (key in urlAttributes) {
          if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node3.properties, key)) {
            const value = node3.properties[key];
            const test = urlAttributes[key];
            if (test === null || test.includes(node3.tagName)) {
              node3.properties[key] = urlTransform(String(value || ""), key, node3);
            }
          }
        }
      }
      if (node3.type === "element") {
        let remove = allowedElements ? !allowedElements.includes(node3.tagName) : disallowedElements ? disallowedElements.includes(node3.tagName) : false;
        if (!remove && allowElement && typeof index2 === "number") {
          remove = !allowElement(node3, index2, parent);
        }
        if (remove && parent && typeof index2 === "number") {
          if (unwrapDisallowed && node3.children) {
            parent.children.splice(index2, 1, ...node3.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
      }
    }
  }
  function defaultUrlTransform(value) {
    const colon = value.indexOf(":");
    const questionMark = value.indexOf("?");
    const numberSign = value.indexOf("#");
    const slash = value.indexOf("/");
    if (
      // If there is no protocol, it’s relative.
      colon === -1 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
      slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || // It is a protocol, it should be allowed.
      safeProtocol.test(value.slice(0, colon))
    ) {
      return value;
    }
    return "";
  }

  // ../../node_modules/remark-gfm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/remark-gfm/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-autolink-literal/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-autolink-literal/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/ccount/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function ccount(value, character2) {
    const source = String(value);
    if (typeof character2 !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index2 = source.indexOf(character2);
    while (index2 !== -1) {
      count++;
      index2 = source.indexOf(character2, index2 + character2.length);
    }
    return count;
  }

  // ../../node_modules/mdast-util-find-and-replace/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-find-and-replace/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/escape-string-regexp/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function escapeStringRegexp(string3) {
    if (typeof string3 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }

  // ../../node_modules/mdast-util-find-and-replace/lib/index.js
  function findAndReplace(tree, list4, options) {
    const settings = options || {};
    const ignored = convert(settings.ignore || []);
    const pairs = toPairs(list4);
    let pairIndex = -1;
    while (++pairIndex < pairs.length) {
      visitParents(tree, "text", visitor);
    }
    function visitor(node3, parents) {
      let index2 = -1;
      let grandparent;
      while (++index2 < parents.length) {
        const parent = parents[index2];
        const siblings = grandparent ? grandparent.children : void 0;
        if (ignored(
          parent,
          siblings ? siblings.indexOf(parent) : void 0,
          grandparent
        )) {
          return;
        }
        grandparent = parent;
      }
      if (grandparent) {
        return handler(node3, parents);
      }
    }
    function handler(node3, parents) {
      const parent = parents[parents.length - 1];
      const find2 = pairs[pairIndex][0];
      const replace4 = pairs[pairIndex][1];
      let start2 = 0;
      const siblings = parent.children;
      const index2 = siblings.indexOf(node3);
      let change = false;
      let nodes = [];
      find2.lastIndex = 0;
      let match2 = find2.exec(node3.value);
      while (match2) {
        const position4 = match2.index;
        const matchObject = {
          index: match2.index,
          input: match2.input,
          stack: [...parents, node3]
        };
        let value = replace4(...match2, matchObject);
        if (typeof value === "string") {
          value = value.length > 0 ? { type: "text", value } : void 0;
        }
        if (value === false) {
          find2.lastIndex = position4 + 1;
        } else {
          if (start2 !== position4) {
            nodes.push({
              type: "text",
              value: node3.value.slice(start2, position4)
            });
          }
          if (Array.isArray(value)) {
            nodes.push(...value);
          } else if (value) {
            nodes.push(value);
          }
          start2 = position4 + match2[0].length;
          change = true;
        }
        if (!find2.global) {
          break;
        }
        match2 = find2.exec(node3.value);
      }
      if (change) {
        if (start2 < node3.value.length) {
          nodes.push({ type: "text", value: node3.value.slice(start2) });
        }
        parent.children.splice(index2, 1, ...nodes);
      } else {
        nodes = [node3];
      }
      return index2 + nodes.length;
    }
  }
  function toPairs(tupleOrList) {
    const result = [];
    if (!Array.isArray(tupleOrList)) {
      throw new TypeError("Expected find and replace tuple or list of tuples");
    }
    const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
    let index2 = -1;
    while (++index2 < list4.length) {
      const tuple = list4[index2];
      result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
    }
    return result;
  }
  function toExpression(find2) {
    return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
  }
  function toFunction(replace4) {
    return typeof replace4 === "function" ? replace4 : function() {
      return replace4;
    };
  }

  // ../../node_modules/mdast-util-gfm-autolink-literal/lib/index.js
  var inConstruct = "phrasing";
  var notInConstruct = ["autolink", "link", "image", "label"];
  function gfmAutolinkLiteralFromMarkdown() {
    return {
      transforms: [transformGfmAutolinkLiterals],
      enter: {
        literalAutolink: enterLiteralAutolink,
        literalAutolinkEmail: enterLiteralAutolinkValue,
        literalAutolinkHttp: enterLiteralAutolinkValue,
        literalAutolinkWww: enterLiteralAutolinkValue
      },
      exit: {
        literalAutolink: exitLiteralAutolink,
        literalAutolinkEmail: exitLiteralAutolinkEmail,
        literalAutolinkHttp: exitLiteralAutolinkHttp,
        literalAutolinkWww: exitLiteralAutolinkWww
      }
    };
  }
  function gfmAutolinkLiteralToMarkdown() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct,
          notInConstruct
        }
      ]
    };
  }
  function enterLiteralAutolink(token2) {
    this.enter({ type: "link", title: null, url: "", children: [] }, token2);
  }
  function enterLiteralAutolinkValue(token2) {
    this.config.enter.autolinkProtocol.call(this, token2);
  }
  function exitLiteralAutolinkHttp(token2) {
    this.config.exit.autolinkProtocol.call(this, token2);
  }
  function exitLiteralAutolinkWww(token2) {
    this.config.exit.data.call(this, token2);
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "link");
    node3.url = "http://" + this.sliceSerialize(token2);
  }
  function exitLiteralAutolinkEmail(token2) {
    this.config.exit.autolinkEmail.call(this, token2);
  }
  function exitLiteralAutolink(token2) {
    this.exit(token2);
  }
  function transformGfmAutolinkLiterals(tree) {
    findAndReplace(
      tree,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
        [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function findUrl(_, protocol, domain2, path2, match2) {
    let prefix2 = "";
    if (!previous2(match2)) {
      return false;
    }
    if (/^w/i.test(protocol)) {
      domain2 = protocol + domain2;
      protocol = "";
      prefix2 = "http://";
    }
    if (!isCorrectDomain(domain2)) {
      return false;
    }
    const parts = splitUrl(domain2 + path2);
    if (!parts[0]) return false;
    const result = {
      type: "link",
      title: null,
      url: prefix2 + protocol + parts[0],
      children: [{ type: "text", value: protocol + parts[0] }]
    };
    if (parts[1]) {
      return [result, { type: "text", value: parts[1] }];
    }
    return result;
  }
  function findEmail(_, atext, label, match2) {
    if (
      // Not an expected previous character.
      !previous2(match2, true) || // Label ends in not allowed character.
      /[-\d_]$/.test(label)
    ) {
      return false;
    }
    return {
      type: "link",
      title: null,
      url: "mailto:" + atext + "@" + label,
      children: [{ type: "text", value: atext + "@" + label }]
    };
  }
  function isCorrectDomain(domain2) {
    const parts = domain2.split(".");
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
      return false;
    }
    return true;
  }
  function splitUrl(url) {
    const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
    if (!trailExec) {
      return [url, void 0];
    }
    url = url.slice(0, trailExec.index);
    let trail2 = trailExec[0];
    let closingParenIndex = trail2.indexOf(")");
    const openingParens = ccount(url, "(");
    let closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail2.slice(0, closingParenIndex + 1);
      trail2 = trail2.slice(closingParenIndex + 1);
      closingParenIndex = trail2.indexOf(")");
      closingParens++;
    }
    return [url, trail2];
  }
  function previous2(match2, email) {
    const code4 = match2.input.charCodeAt(match2.index - 1);
    return (match2.index === 0 || unicodeWhitespace(code4) || unicodePunctuation(code4)) && // If it’s an email, the previous character should not be a slash.
    (!email || code4 !== 47);
  }

  // ../../node_modules/mdast-util-gfm-footnote/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-footnote/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  footnoteReference2.peek = footnoteReferencePeek;
  function enterFootnoteCallString() {
    this.buffer();
  }
  function enterFootnoteCall(token2) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token2);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function enterFootnoteDefinition(token2) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      token2
    );
  }
  function exitFootnoteCallString(token2) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "footnoteReference");
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    node3.label = label;
  }
  function exitFootnoteCall(token2) {
    this.exit(token2);
  }
  function exitFootnoteDefinitionLabelString(token2) {
    const label = this.resume();
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "footnoteDefinition");
    node3.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    node3.label = label;
  }
  function exitFootnoteDefinition(token2) {
    this.exit(token2);
  }
  function footnoteReferencePeek() {
    return "[";
  }
  function footnoteReference2(node3, _, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteReference");
    const subexit = state.enter("reference");
    value += tracker.move(
      state.safe(state.associationId(node3), { after: "]", before: value })
    );
    subexit();
    exit3();
    value += tracker.move("]");
    return value;
  }
  function gfmFootnoteFromMarkdown() {
    return {
      enter: {
        gfmFootnoteCallString: enterFootnoteCallString,
        gfmFootnoteCall: enterFootnoteCall,
        gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: enterFootnoteDefinition
      },
      exit: {
        gfmFootnoteCallString: exitFootnoteCallString,
        gfmFootnoteCall: exitFootnoteCall,
        gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: exitFootnoteDefinition
      }
    };
  }
  function gfmFootnoteToMarkdown(options) {
    let firstLineBlank = false;
    if (options && options.firstLineBlank) {
      firstLineBlank = true;
    }
    return {
      handlers: { footnoteDefinition, footnoteReference: footnoteReference2 },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function footnoteDefinition(node3, _, state, info) {
      const tracker = state.createTracker(info);
      let value = tracker.move("[^");
      const exit3 = state.enter("footnoteDefinition");
      const subexit = state.enter("label");
      value += tracker.move(
        state.safe(state.associationId(node3), { before: value, after: "]" })
      );
      subexit();
      value += tracker.move("]:");
      if (node3.children && node3.children.length > 0) {
        tracker.shift(4);
        value += tracker.move(
          (firstLineBlank ? "\n" : " ") + state.indentLines(
            state.containerFlow(node3, tracker.current()),
            firstLineBlank ? mapAll : mapExceptFirst
          )
        );
      }
      exit3();
      return value;
    }
  }
  function mapExceptFirst(line2, index2, blank) {
    return index2 === 0 ? line2 : mapAll(line2, index2, blank);
  }
  function mapAll(line2, index2, blank) {
    return (blank ? "" : "    ") + line2;
  }

  // ../../node_modules/mdast-util-gfm-strikethrough/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-strikethrough/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var constructsWithoutStrikethrough = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  handleDelete.peek = peekDelete;
  function gfmStrikethroughFromMarkdown() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: enterStrikethrough },
      exit: { strikethrough: exitStrikethrough }
    };
  }
  function gfmStrikethroughToMarkdown() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: constructsWithoutStrikethrough
        }
      ],
      handlers: { delete: handleDelete }
    };
  }
  function enterStrikethrough(token2) {
    this.enter({ type: "delete", children: [] }, token2);
  }
  function exitStrikethrough(token2) {
    this.exit(token2);
  }
  function handleDelete(node3, _, state, info) {
    const tracker = state.createTracker(info);
    const exit3 = state.enter("strikethrough");
    let value = tracker.move("~~");
    value += state.containerPhrasing(node3, {
      ...tracker.current(),
      before: value,
      after: "~"
    });
    value += tracker.move("~~");
    exit3();
    return value;
  }
  function peekDelete() {
    return "~";
  }

  // ../../node_modules/mdast-util-gfm-table/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-table/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/markdown-table/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function defaultStringLength(value) {
    return value.length;
  }
  function markdownTable(table2, options) {
    const settings = options || {};
    const align = (settings.align || []).concat();
    const stringLength = settings.stringLength || defaultStringLength;
    const alignments = [];
    const cellMatrix = [];
    const sizeMatrix = [];
    const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    while (++rowIndex < table2.length) {
      const row2 = [];
      const sizes2 = [];
      let columnIndex2 = -1;
      if (table2[rowIndex].length > mostCellsPerRow) {
        mostCellsPerRow = table2[rowIndex].length;
      }
      while (++columnIndex2 < table2[rowIndex].length) {
        const cell = serialize3(table2[rowIndex][columnIndex2]);
        if (settings.alignDelimiters !== false) {
          const size3 = stringLength(cell);
          sizes2[columnIndex2] = size3;
          if (longestCellByColumn[columnIndex2] === void 0 || size3 > longestCellByColumn[columnIndex2]) {
            longestCellByColumn[columnIndex2] = size3;
          }
        }
        row2.push(cell);
      }
      cellMatrix[rowIndex] = row2;
      sizeMatrix[rowIndex] = sizes2;
    }
    let columnIndex = -1;
    if (typeof align === "object" && "length" in align) {
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = toAlignment(align[columnIndex]);
      }
    } else {
      const code4 = toAlignment(align);
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = code4;
      }
    }
    columnIndex = -1;
    const row = [];
    const sizes = [];
    while (++columnIndex < mostCellsPerRow) {
      const code4 = alignments[columnIndex];
      let before = "";
      let after = "";
      if (code4 === 99) {
        before = ":";
        after = ":";
      } else if (code4 === 108) {
        before = ":";
      } else if (code4 === 114) {
        after = ":";
      }
      let size3 = settings.alignDelimiters === false ? 1 : Math.max(
        1,
        longestCellByColumn[columnIndex] - before.length - after.length
      );
      const cell = before + "-".repeat(size3) + after;
      if (settings.alignDelimiters !== false) {
        size3 = before.length + size3 + after.length;
        if (size3 > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size3;
        }
        sizes[columnIndex] = size3;
      }
      row[columnIndex] = cell;
    }
    cellMatrix.splice(1, 0, row);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    const lines = [];
    while (++rowIndex < cellMatrix.length) {
      const row2 = cellMatrix[rowIndex];
      const sizes2 = sizeMatrix[rowIndex];
      columnIndex = -1;
      const line2 = [];
      while (++columnIndex < mostCellsPerRow) {
        const cell = row2[columnIndex] || "";
        let before = "";
        let after = "";
        if (settings.alignDelimiters !== false) {
          const size3 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
          const code4 = alignments[columnIndex];
          if (code4 === 114) {
            before = " ".repeat(size3);
          } else if (code4 === 99) {
            if (size3 % 2) {
              before = " ".repeat(size3 / 2 + 0.5);
              after = " ".repeat(size3 / 2 - 0.5);
            } else {
              before = " ".repeat(size3 / 2);
              after = before;
            }
          } else {
            after = " ".repeat(size3);
          }
        }
        if (settings.delimiterStart !== false && !columnIndex) {
          line2.push("|");
        }
        if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
        // empty: there will be a closing space.
        !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
          line2.push(" ");
        }
        if (settings.alignDelimiters !== false) {
          line2.push(before);
        }
        line2.push(cell);
        if (settings.alignDelimiters !== false) {
          line2.push(after);
        }
        if (settings.padding !== false) {
          line2.push(" ");
        }
        if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
          line2.push("|");
        }
      }
      lines.push(
        settings.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join("")
      );
    }
    return lines.join("\n");
  }
  function serialize3(value) {
    return value === null || value === void 0 ? "" : String(value);
  }
  function toAlignment(value) {
    const code4 = typeof value === "string" ? value.codePointAt(0) : 0;
    return code4 === 67 || code4 === 99 ? 99 : code4 === 76 || code4 === 108 ? 108 : code4 === 82 || code4 === 114 ? 114 : 0;
  }

  // ../../node_modules/mdast-util-to-markdown/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/handle/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function blockquote2(node3, _, state, info) {
    const exit3 = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value = state.indentLines(
      state.containerFlow(node3, tracker.current()),
      map
    );
    exit3();
    return value;
  }
  function map(line2, _, blank) {
    return ">" + (blank ? "" : " ") + line2;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/break.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
  }
  function listInScope(stack, list4, none) {
    if (typeof list4 === "string") {
      list4 = [list4];
    }
    if (!list4 || list4.length === 0) {
      return none;
    }
    let index2 = -1;
    while (++index2 < list4.length) {
      if (stack.includes(list4[index2])) {
        return true;
      }
    }
    return false;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/break.js
  function hardBreak2(_, _1, state, info) {
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/code.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/longest-streak/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function longestStreak(value, substring) {
    const source = String(value);
    let index2 = source.indexOf(substring);
    let expected = index2;
    let count = 0;
    let max2 = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index2 !== -1) {
      if (index2 === expected) {
        if (++count > max2) {
          max2 = count;
        }
      } else {
        count = 1;
      }
      expected = index2 + substring.length;
      index2 = source.indexOf(substring, expected);
    }
    return max2;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function formatCodeAsIndented(node3, state) {
    return Boolean(
      state.options.fences === false && node3.value && // If there’s no info…
      !node3.lang && // And there’s a non-whitespace character…
      /[^ \r\n]/.test(node3.value) && // And the value doesn’t start or end in a blank…
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node3.value)
    );
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-fence.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkFence(state) {
    const marker17 = state.options.fence || "`";
    if (marker17 !== "`" && marker17 !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker17 + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/code.js
  function code2(node3, _, state, info) {
    const marker17 = checkFence(state);
    const raw = node3.value || "";
    const suffix = marker17 === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node3, state)) {
      const exit4 = state.enter("codeIndented");
      const value2 = state.indentLines(raw, map2);
      exit4();
      return value2;
    }
    const tracker = state.createTracker(info);
    const sequence = marker17.repeat(Math.max(longestStreak(raw, marker17) + 1, 3));
    const exit3 = state.enter("codeFenced");
    let value = tracker.move(sequence);
    if (node3.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value += tracker.move(
        state.safe(node3.lang, {
          before: value,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node3.lang && node3.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value += tracker.move(" ");
      value += tracker.move(
        state.safe(node3.meta, {
          before: value,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw) {
      value += tracker.move(raw + "\n");
    }
    value += tracker.move(sequence);
    exit3();
    return value;
  }
  function map2(line2, _, blank) {
    return (blank ? "" : "    ") + line2;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/definition.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkQuote(state) {
    const marker17 = state.options.quote || '"';
    if (marker17 !== '"' && marker17 !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker17 + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/definition.js
  function definition2(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    value += tracker.move(
      state.safe(state.associationId(node3), {
        before: value,
        after: "]",
        ...tracker.current()
      })
    );
    value += tracker.move("]: ");
    subexit();
    if (
      // If there’s no url, or…
      !node3.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    exit3();
    return value;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkEmphasis(state) {
    const marker17 = state.options.emphasis || "*";
    if (marker17 !== "*" && marker17 !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker17 + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function encodeCharacterReference(code4) {
    return "&#x" + code4.toString(16).toUpperCase() + ";";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/encode-info.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function encodeInfo(outside, inside, marker17) {
    const outsideKind = classifyCharacter(outside);
    const insideKind = classifyCharacter(inside);
    if (outsideKind === void 0) {
      return insideKind === void 0 ? (
        // Letter inside:
        // we have to encode *both* letters for `_` as it is looser.
        // it already forms for `*` (and GFMs `~`).
        marker17 === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (letter, whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: encode outer (letter)
        { inside: false, outside: true }
      );
    }
    if (outsideKind === 1) {
      return insideKind === void 0 ? (
        // Letter inside: already forms.
        { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: already forms.
        { inside: false, outside: false }
      );
    }
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: true, outside: false }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
  emphasis2.peek = emphasisPeek;
  function emphasis2(node3, _, state, info) {
    const marker17 = checkEmphasis(state);
    const exit3 = state.enter("emphasis");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker17);
    let between = tracker.move(
      state.containerPhrasing(node3, {
        after: marker17,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between.charCodeAt(0);
    const open = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker17
    );
    if (open.inside) {
      between = encodeCharacterReference(betweenHead) + between.slice(1);
    }
    const betweenTail = between.charCodeAt(between.length - 1);
    const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker17);
    if (close.inside) {
      between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker17);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close.outside,
      before: open.outside
    };
    return before + between + after;
  }
  function emphasisPeek(_, _1, state) {
    return state.options.emphasis || "*";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/heading.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function formatHeadingAsSetext(node3, state) {
    let literalWithBreak = false;
    visit(node3, function(node4) {
      if ("value" in node4 && /\r?\n|\r/.test(node4.value) || node4.type === "break") {
        literalWithBreak = true;
        return EXIT;
      }
    });
    return Boolean(
      (!node3.depth || node3.depth < 3) && toString(node3) && (state.options.setext || literalWithBreak)
    );
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/heading.js
  function heading2(node3, _, state, info) {
    const rank = Math.max(Math.min(6, node3.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node3, state)) {
      const exit4 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value2 = state.containerPhrasing(node3, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit4();
      return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole size…
        value2.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)…
        (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit3 = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value = state.containerPhrasing(node3, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value)) {
      value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
    }
    value = value ? sequence + " " + value : sequence;
    if (state.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit3();
    return value;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/html.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  html4.peek = htmlPeek;
  function html4(node3) {
    return node3.value || "";
  }
  function htmlPeek() {
    return "<";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  image2.peek = imagePeek;
  function image2(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    value += tracker.move(
      state.safe(node3.alt, { before: value, after: "]", ...tracker.current() })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node3.url && node3.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function imagePeek() {
    return "!";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  imageReference2.peek = imageReferencePeek;
  function imageReference2(node3, _, state, info) {
    const type = node3.referenceType;
    const exit3 = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    const alt = state.safe(node3.alt, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(alt + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !alt || alt !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  inlineCode2.peek = inlineCodePeek;
  function inlineCode2(node3, _, state) {
    let value = node3.value || "";
    let sequence = "`";
    let index2 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
      value = " " + value + " ";
    }
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      const expression = state.compilePattern(pattern);
      let match2;
      if (!pattern.atBreak) continue;
      while (match2 = expression.exec(value)) {
        let position4 = match2.index;
        if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
          position4--;
        }
        value = value.slice(0, position4) + " " + value.slice(match2.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/link.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function formatLinkAsAutolink(node3, state) {
    const raw = toString(node3);
    return Boolean(
      !state.options.resourceLink && // If there’s a url…
      node3.url && // And there’s a no title…
      !node3.title && // And the content of `node` is a single text node…
      node3.children && node3.children.length === 1 && node3.children[0].type === "text" && // And if the url is the same as the content…
      (raw === node3.url || "mailto:" + raw === node3.url) && // And that starts w/ a protocol…
      /^[a-z][a-z+.-]+:/i.test(node3.url) && // And that doesn’t contain ASCII control codes (character escapes and
      // references don’t work), space, or angle brackets…
      !/[\0- <>\u007F]/.test(node3.url)
    );
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/link.js
  link2.peek = linkPeek;
  function link2(node3, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit3;
    let subexit;
    if (formatLinkAsAutolink(node3, state)) {
      const stack = state.stack;
      state.stack = [];
      exit3 = state.enter("autolink");
      let value2 = tracker.move("<");
      value2 += tracker.move(
        state.containerPhrasing(node3, {
          before: value2,
          after: ">",
          ...tracker.current()
        })
      );
      value2 += tracker.move(">");
      exit3();
      state.stack = stack;
      return value2;
    }
    exit3 = state.enter("link");
    subexit = state.enter("label");
    let value = tracker.move("[");
    value += tracker.move(
      state.containerPhrasing(node3, {
        before: value,
        after: "](",
        ...tracker.current()
      })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If there’s no url but there is a title…
      !node3.url && node3.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node3.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node3.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node3.url, {
          before: value,
          after: node3.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node3.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node3.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function linkPeek(node3, _, state) {
    return formatLinkAsAutolink(node3, state) ? "<" : "[";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  linkReference2.peek = linkReferencePeek;
  function linkReference2(node3, _, state, info) {
    const type = node3.referenceType;
    const exit3 = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    const text9 = state.containerPhrasing(node3, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(text9 + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node3), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !text9 || text9 !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/list.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkBullet(state) {
    const marker17 = state.options.bullet || "*";
    if (marker17 !== "*" && marker17 !== "+" && marker17 !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker17 + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkBulletOrdered(state) {
    const marker17 = state.options.bulletOrdered || ".";
    if (marker17 !== "." && marker17 !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker17 + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-rule.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkRule(state) {
    const marker17 = state.options.rule || "*";
    if (marker17 !== "*" && marker17 !== "-" && marker17 !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker17 + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/list.js
  function list3(node3, parent, state, info) {
    const exit3 = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node3.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node3.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
    let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
    if (!node3.ordered) {
      const firstListItem = node3.children ? node3.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index2 = -1;
        while (++index2 < node3.children.length) {
          const item = node3.children[index2];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value = state.containerFlow(node3, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit3();
    return value;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkListItemIndent(state) {
    const style = state.options.listItemIndent || "one";
    if (style !== "tab" && style !== "one" && style !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js
  function listItem2(node3, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node3)) + bullet;
    }
    let size3 = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node3.spread)) {
      size3 = Math.ceil(size3 / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size3 - bullet.length));
    tracker.shift(size3);
    const exit3 = state.enter("listItem");
    const value = state.indentLines(
      state.containerFlow(node3, tracker.current()),
      map3
    );
    exit3();
    return value;
    function map3(line2, index2, blank) {
      if (index2) {
        return (blank ? "" : " ".repeat(size3)) + line2;
      }
      return (blank ? bullet : bullet + " ".repeat(size3 - bullet.length)) + line2;
    }
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function paragraph2(node3, _, state, info) {
    const exit3 = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node3, info);
    subexit();
    exit3();
    return value;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/root.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-phrasing/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-phrasing/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var phrasing = (
    /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
    convert([
      "break",
      "delete",
      "emphasis",
      // To do: next major: removed since footnotes were added to GFM.
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      // Enabled by `mdast-util-math`:
      "inlineMath",
      "link",
      "linkReference",
      // Enabled by `mdast-util-mdx`:
      "mdxJsxTextElement",
      // Enabled by `mdast-util-mdx`:
      "mdxTextExpression",
      "strong",
      "text",
      // Enabled by `mdast-util-directive`:
      "textDirective"
    ])
  );

  // ../../node_modules/mdast-util-to-markdown/lib/handle/root.js
  function root3(node3, _, state, info) {
    const hasPhrasing = node3.children.some(function(d) {
      return phrasing(d);
    });
    const container2 = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return container2.call(state, node3, info);
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/strong.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-strong.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkStrong(state) {
    const marker17 = state.options.strong || "*";
    if (marker17 !== "*" && marker17 !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker17 + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker17;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/strong.js
  strong2.peek = strongPeek;
  function strong2(node3, _, state, info) {
    const marker17 = checkStrong(state);
    const exit3 = state.enter("strong");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker17 + marker17);
    let between = tracker.move(
      state.containerPhrasing(node3, {
        after: marker17,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between.charCodeAt(0);
    const open = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker17
    );
    if (open.inside) {
      between = encodeCharacterReference(betweenHead) + between.slice(1);
    }
    const betweenTail = between.charCodeAt(between.length - 1);
    const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker17);
    if (close.inside) {
      between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker17 + marker17);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close.outside,
      before: open.outside
    };
    return before + between + after;
  }
  function strongPeek(_, _1, state) {
    return state.options.strong || "*";
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/text.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function text6(node3, _, state, info) {
    return state.safe(node3.value, info);
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
  function thematicBreak3(_, _1, state) {
    const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value.slice(0, -1) : value;
  }

  // ../../node_modules/mdast-util-to-markdown/lib/handle/index.js
  var handle = {
    blockquote: blockquote2,
    break: hardBreak2,
    code: code2,
    definition: definition2,
    emphasis: emphasis2,
    hardBreak: hardBreak2,
    heading: heading2,
    html: html4,
    image: image2,
    imageReference: imageReference2,
    inlineCode: inlineCode2,
    link: link2,
    linkReference: linkReference2,
    list: list3,
    listItem: listItem2,
    paragraph: paragraph2,
    root: root3,
    strong: strong2,
    text: text6,
    thematicBreak: thematicBreak3
  };

  // ../../node_modules/mdast-util-gfm-table/lib/index.js
  function gfmTableFromMarkdown() {
    return {
      enter: {
        table: enterTable,
        tableData: enterCell,
        tableHeader: enterCell,
        tableRow: enterRow
      },
      exit: {
        codeText: exitCodeText,
        table: exitTable,
        tableData: exit2,
        tableHeader: exit2,
        tableRow: exit2
      }
    };
  }
  function enterTable(token2) {
    const align = token2._align;
    ok(align, "expected `_align` on table");
    this.enter(
      {
        type: "table",
        align: align.map(function(d) {
          return d === "none" ? null : d;
        }),
        children: []
      },
      token2
    );
    this.data.inTable = true;
  }
  function exitTable(token2) {
    this.exit(token2);
    this.data.inTable = void 0;
  }
  function enterRow(token2) {
    this.enter({ type: "tableRow", children: [] }, token2);
  }
  function exit2(token2) {
    this.exit(token2);
  }
  function enterCell(token2) {
    this.enter({ type: "tableCell", children: [] }, token2);
  }
  function exitCodeText(token2) {
    let value = this.resume();
    if (this.data.inTable) {
      value = value.replace(/\\([\\|])/g, replace2);
    }
    const node3 = this.stack[this.stack.length - 1];
    ok(node3.type === "inlineCode");
    node3.value = value;
    this.exit(token2);
  }
  function replace2($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
  function gfmTableToMarkdown(options) {
    const settings = options || {};
    const padding3 = settings.tableCellPadding;
    const alignDelimiters = settings.tablePipeAlign;
    const stringLength = settings.stringLength;
    const around = padding3 ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: "\n", inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: true, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: true, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: true, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: inlineCodeWithTable,
        table: handleTable,
        tableCell: handleTableCell,
        tableRow: handleTableRow
      }
    };
    function handleTable(node3, _, state, info) {
      return serializeData(handleTableAsData(node3, state, info), node3.align);
    }
    function handleTableRow(node3, _, state, info) {
      const row = handleTableRowAsData(node3, state, info);
      const value = serializeData([row]);
      return value.slice(0, value.indexOf("\n"));
    }
    function handleTableCell(node3, _, state, info) {
      const exit3 = state.enter("tableCell");
      const subexit = state.enter("phrasing");
      const value = state.containerPhrasing(node3, {
        ...info,
        before: around,
        after: around
      });
      subexit();
      exit3();
      return value;
    }
    function serializeData(matrix, align) {
      return markdownTable(matrix, {
        align,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding: padding3,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength
      });
    }
    function handleTableAsData(node3, state, info) {
      const children2 = node3.children;
      let index2 = -1;
      const result = [];
      const subexit = state.enter("table");
      while (++index2 < children2.length) {
        result[index2] = handleTableRowAsData(children2[index2], state, info);
      }
      subexit();
      return result;
    }
    function handleTableRowAsData(node3, state, info) {
      const children2 = node3.children;
      let index2 = -1;
      const result = [];
      const subexit = state.enter("tableRow");
      while (++index2 < children2.length) {
        result[index2] = handleTableCell(children2[index2], node3, state, info);
      }
      subexit();
      return result;
    }
    function inlineCodeWithTable(node3, parent, state) {
      let value = handle.inlineCode(node3, parent, state);
      if (state.stack.includes("tableCell")) {
        value = value.replace(/\|/g, "\\$&");
      }
      return value;
    }
  }

  // ../../node_modules/mdast-util-gfm-task-list-item/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/mdast-util-gfm-task-list-item/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function gfmTaskListItemFromMarkdown() {
    return {
      exit: {
        taskListCheckValueChecked: exitCheck,
        taskListCheckValueUnchecked: exitCheck,
        paragraph: exitParagraphWithTaskListItem
      }
    };
  }
  function gfmTaskListItemToMarkdown() {
    return {
      unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
      handlers: { listItem: listItemWithTaskListItem }
    };
  }
  function exitCheck(token2) {
    const node3 = this.stack[this.stack.length - 2];
    ok(node3.type === "listItem");
    node3.checked = token2.type === "taskListCheckValueChecked";
  }
  function exitParagraphWithTaskListItem(token2) {
    const parent = this.stack[this.stack.length - 2];
    if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
      const node3 = this.stack[this.stack.length - 1];
      ok(node3.type === "paragraph");
      const head = node3.children[0];
      if (head && head.type === "text") {
        const siblings = parent.children;
        let index2 = -1;
        let firstParaghraph;
        while (++index2 < siblings.length) {
          const sibling = siblings[index2];
          if (sibling.type === "paragraph") {
            firstParaghraph = sibling;
            break;
          }
        }
        if (firstParaghraph === node3) {
          head.value = head.value.slice(1);
          if (head.value.length === 0) {
            node3.children.shift();
          } else if (node3.position && head.position && typeof head.position.start.offset === "number") {
            head.position.start.column++;
            head.position.start.offset++;
            node3.position.start = Object.assign({}, head.position.start);
          }
        }
      }
    }
    this.exit(token2);
  }
  function listItemWithTaskListItem(node3, parent, state, info) {
    const head = node3.children[0];
    const checkable = typeof node3.checked === "boolean" && head && head.type === "paragraph";
    const checkbox = "[" + (node3.checked ? "x" : " ") + "] ";
    const tracker = state.createTracker(info);
    if (checkable) {
      tracker.move(checkbox);
    }
    let value = handle.listItem(node3, parent, state, {
      ...info,
      ...tracker.current()
    });
    if (checkable) {
      value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    function check($0) {
      return $0 + checkbox;
    }
  }

  // ../../node_modules/mdast-util-gfm/lib/index.js
  function gfmFromMarkdown() {
    return [
      gfmAutolinkLiteralFromMarkdown(),
      gfmFootnoteFromMarkdown(),
      gfmStrikethroughFromMarkdown(),
      gfmTableFromMarkdown(),
      gfmTaskListItemFromMarkdown()
    ];
  }
  function gfmToMarkdown(options) {
    return {
      extensions: [
        gfmAutolinkLiteralToMarkdown(),
        gfmFootnoteToMarkdown(options),
        gfmStrikethroughToMarkdown(),
        gfmTableToMarkdown(options),
        gfmTaskListItemToMarkdown()
      ]
    };
  }

  // ../../node_modules/micromark-extension-gfm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-autolink-literal/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var wwwPrefix = {
    tokenize: tokenizeWwwPrefix,
    partial: true
  };
  var domain = {
    tokenize: tokenizeDomain,
    partial: true
  };
  var path = {
    tokenize: tokenizePath,
    partial: true
  };
  var trail = {
    tokenize: tokenizeTrail,
    partial: true
  };
  var emailDomainDotTrail = {
    tokenize: tokenizeEmailDomainDotTrail,
    partial: true
  };
  var wwwAutolink = {
    name: "wwwAutolink",
    tokenize: tokenizeWwwAutolink,
    previous: previousWww
  };
  var protocolAutolink = {
    name: "protocolAutolink",
    tokenize: tokenizeProtocolAutolink,
    previous: previousProtocol
  };
  var emailAutolink = {
    name: "emailAutolink",
    tokenize: tokenizeEmailAutolink,
    previous: previousEmail
  };
  var text7 = {};
  function gfmAutolinkLiteral() {
    return {
      text: text7
    };
  }
  var code3 = 48;
  while (code3 < 123) {
    text7[code3] = emailAutolink;
    code3++;
    if (code3 === 58) code3 = 65;
    else if (code3 === 91) code3 = 97;
  }
  text7[43] = emailAutolink;
  text7[45] = emailAutolink;
  text7[46] = emailAutolink;
  text7[95] = emailAutolink;
  text7[72] = [emailAutolink, protocolAutolink];
  text7[104] = [emailAutolink, protocolAutolink];
  text7[87] = [emailAutolink, wwwAutolink];
  text7[119] = [emailAutolink, wwwAutolink];
  function tokenizeEmailAutolink(effects, ok3, nok) {
    const self2 = this;
    let dot;
    let data2;
    return start2;
    function start2(code4) {
      if (!gfmAtext(code4) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code4);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkEmail");
      return atext(code4);
    }
    function atext(code4) {
      if (gfmAtext(code4)) {
        effects.consume(code4);
        return atext;
      }
      if (code4 === 64) {
        effects.consume(code4);
        return emailDomain;
      }
      return nok(code4);
    }
    function emailDomain(code4) {
      if (code4 === 46) {
        return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code4);
      }
      if (code4 === 45 || code4 === 95 || asciiAlphanumeric(code4)) {
        data2 = true;
        effects.consume(code4);
        return emailDomain;
      }
      return emailDomainAfter(code4);
    }
    function emailDomainDot(code4) {
      effects.consume(code4);
      dot = true;
      return emailDomain;
    }
    function emailDomainAfter(code4) {
      if (data2 && dot && asciiAlpha(self2.previous)) {
        effects.exit("literalAutolinkEmail");
        effects.exit("literalAutolink");
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  function tokenizeWwwAutolink(effects, ok3, nok) {
    const self2 = this;
    return wwwStart;
    function wwwStart(code4) {
      if (code4 !== 87 && code4 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code4);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkWww");
      return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code4);
    }
    function wwwAfter(code4) {
      effects.exit("literalAutolinkWww");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
  }
  function tokenizeProtocolAutolink(effects, ok3, nok) {
    const self2 = this;
    let buffer = "";
    let seen = false;
    return protocolStart;
    function protocolStart(code4) {
      if ((code4 === 72 || code4 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        buffer += String.fromCodePoint(code4);
        effects.consume(code4);
        return protocolPrefixInside;
      }
      return nok(code4);
    }
    function protocolPrefixInside(code4) {
      if (asciiAlpha(code4) && buffer.length < 5) {
        buffer += String.fromCodePoint(code4);
        effects.consume(code4);
        return protocolPrefixInside;
      }
      if (code4 === 58) {
        const protocol = buffer.toLowerCase();
        if (protocol === "http" || protocol === "https") {
          effects.consume(code4);
          return protocolSlashesInside;
        }
      }
      return nok(code4);
    }
    function protocolSlashesInside(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        if (seen) {
          return afterProtocol;
        }
        seen = true;
        return protocolSlashesInside;
      }
      return nok(code4);
    }
    function afterProtocol(code4) {
      return code4 === null || asciiControl(code4) || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || unicodePunctuation(code4) ? nok(code4) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code4);
    }
    function protocolAfter(code4) {
      effects.exit("literalAutolinkHttp");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
  }
  function tokenizeWwwPrefix(effects, ok3, nok) {
    let size3 = 0;
    return wwwPrefixInside;
    function wwwPrefixInside(code4) {
      if ((code4 === 87 || code4 === 119) && size3 < 3) {
        size3++;
        effects.consume(code4);
        return wwwPrefixInside;
      }
      if (code4 === 46 && size3 === 3) {
        effects.consume(code4);
        return wwwPrefixAfter;
      }
      return nok(code4);
    }
    function wwwPrefixAfter(code4) {
      return code4 === null ? nok(code4) : ok3(code4);
    }
  }
  function tokenizeDomain(effects, ok3, nok) {
    let underscoreInLastSegment;
    let underscoreInLastLastSegment;
    let seen;
    return domainInside;
    function domainInside(code4) {
      if (code4 === 46 || code4 === 95) {
        return effects.check(trail, domainAfter, domainAtPunctuation)(code4);
      }
      if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== 45 && unicodePunctuation(code4)) {
        return domainAfter(code4);
      }
      seen = true;
      effects.consume(code4);
      return domainInside;
    }
    function domainAtPunctuation(code4) {
      if (code4 === 95) {
        underscoreInLastSegment = true;
      } else {
        underscoreInLastLastSegment = underscoreInLastSegment;
        underscoreInLastSegment = void 0;
      }
      effects.consume(code4);
      return domainInside;
    }
    function domainAfter(code4) {
      if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
        return nok(code4);
      }
      return ok3(code4);
    }
  }
  function tokenizePath(effects, ok3) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    function pathInside(code4) {
      if (code4 === 40) {
        sizeOpen++;
        effects.consume(code4);
        return pathInside;
      }
      if (code4 === 41 && sizeClose < sizeOpen) {
        return pathAtPunctuation(code4);
      }
      if (code4 === 33 || code4 === 34 || code4 === 38 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 60 || code4 === 63 || code4 === 93 || code4 === 95 || code4 === 126) {
        return effects.check(trail, ok3, pathAtPunctuation)(code4);
      }
      if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
        return ok3(code4);
      }
      effects.consume(code4);
      return pathInside;
    }
    function pathAtPunctuation(code4) {
      if (code4 === 41) {
        sizeClose++;
      }
      effects.consume(code4);
      return pathInside;
    }
  }
  function tokenizeTrail(effects, ok3, nok) {
    return trail2;
    function trail2(code4) {
      if (code4 === 33 || code4 === 34 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 63 || code4 === 95 || code4 === 126) {
        effects.consume(code4);
        return trail2;
      }
      if (code4 === 38) {
        effects.consume(code4);
        return trailCharacterReferenceStart;
      }
      if (code4 === 93) {
        effects.consume(code4);
        return trailBracketAfter;
      }
      if (
        // `<` is an end.
        code4 === 60 || // So is whitespace.
        code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)
      ) {
        return ok3(code4);
      }
      return nok(code4);
    }
    function trailBracketAfter(code4) {
      if (code4 === null || code4 === 40 || code4 === 91 || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
        return ok3(code4);
      }
      return trail2(code4);
    }
    function trailCharacterReferenceStart(code4) {
      return asciiAlpha(code4) ? trailCharacterReferenceInside(code4) : nok(code4);
    }
    function trailCharacterReferenceInside(code4) {
      if (code4 === 59) {
        effects.consume(code4);
        return trail2;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return trailCharacterReferenceInside;
      }
      return nok(code4);
    }
  }
  function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
    return start2;
    function start2(code4) {
      effects.consume(code4);
      return after;
    }
    function after(code4) {
      return asciiAlphanumeric(code4) ? nok(code4) : ok3(code4);
    }
  }
  function previousWww(code4) {
    return code4 === null || code4 === 40 || code4 === 42 || code4 === 95 || code4 === 91 || code4 === 93 || code4 === 126 || markdownLineEndingOrSpace(code4);
  }
  function previousProtocol(code4) {
    return !asciiAlpha(code4);
  }
  function previousEmail(code4) {
    return !(code4 === 47 || gfmAtext(code4));
  }
  function gfmAtext(code4) {
    return code4 === 43 || code4 === 45 || code4 === 46 || code4 === 95 || asciiAlphanumeric(code4);
  }
  function previousUnbalanced(events) {
    let index2 = events.length;
    let result = false;
    while (index2--) {
      const token2 = events[index2][1];
      if ((token2.type === "labelLink" || token2.type === "labelImage") && !token2._balanced) {
        result = true;
        break;
      }
      if (token2._gfmAutolinkLiteralWalkedInto) {
        result = false;
        break;
      }
    }
    if (events.length > 0 && !result) {
      events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
  }

  // ../../node_modules/micromark-extension-gfm-footnote/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-footnote/lib/syntax.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var indent = {
    tokenize: tokenizeIndent2,
    partial: true
  };
  function gfmFootnote() {
    return {
      document: {
        [91]: {
          name: "gfmFootnoteDefinition",
          tokenize: tokenizeDefinitionStart,
          continuation: {
            tokenize: tokenizeDefinitionContinuation
          },
          exit: gfmFootnoteDefinitionEnd
        }
      },
      text: {
        [91]: {
          name: "gfmFootnoteCall",
          tokenize: tokenizeGfmFootnoteCall
        },
        [93]: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: tokenizePotentialGfmFootnoteCall,
          resolveTo: resolveToPotentialGfmFootnoteCall
        }
      }
    };
  }
  function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let labelStart;
    while (index2--) {
      const token2 = self2.events[index2][1];
      if (token2.type === "labelImage") {
        labelStart = token2;
        break;
      }
      if (token2.type === "gfmFootnoteCall" || token2.type === "labelLink" || token2.type === "label" || token2.type === "image" || token2.type === "link") {
        break;
      }
    }
    return start2;
    function start2(code4) {
      if (!labelStart || !labelStart._balanced) {
        return nok(code4);
      }
      const id = normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      }));
      if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
        return nok(code4);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      return ok3(code4);
    }
  }
  function resolveToPotentialGfmFootnoteCall(events, context) {
    let index2 = events.length;
    let labelStart;
    while (index2--) {
      if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
        labelStart = events[index2][1];
        break;
      }
    }
    events[index2 + 1][1].type = "data";
    events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
    const call = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, events[index2 + 3][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const marker17 = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, events[index2 + 3][1].end),
      end: Object.assign({}, events[index2 + 3][1].end)
    };
    marker17.end.column++;
    marker17.end.offset++;
    marker17.end._bufferIndex++;
    const string3 = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, marker17.end),
      end: Object.assign({}, events[events.length - 1][1].start)
    };
    const chunk = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, string3.start),
      end: Object.assign({}, string3.end)
    };
    const replacement = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      events[index2 + 1],
      events[index2 + 2],
      ["enter", call, context],
      // The `[`
      events[index2 + 3],
      events[index2 + 4],
      // The `^`.
      ["enter", marker17, context],
      ["exit", marker17, context],
      // Everything in between.
      ["enter", string3, context],
      ["enter", chunk, context],
      ["exit", chunk, context],
      ["exit", string3, context],
      // The ending (`]`, properly parsed and labelled).
      events[events.length - 2],
      events[events.length - 1],
      ["exit", call, context]
    ];
    events.splice(index2, events.length - index2 + 1, ...replacement);
    return events;
  }
  function tokenizeGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let size3 = 0;
    let data2;
    return start2;
    function start2(code4) {
      effects.enter("gfmFootnoteCall");
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      return callStart;
    }
    function callStart(code4) {
      if (code4 !== 94) return nok(code4);
      effects.enter("gfmFootnoteCallMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallMarker");
      effects.enter("gfmFootnoteCallString");
      effects.enter("chunkString").contentType = "string";
      return callData;
    }
    function callData(code4) {
      if (
        // Too long.
        size3 > 999 || // Closing brace with nothing.
        code4 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
      ) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit("chunkString");
        const token2 = effects.exit("gfmFootnoteCallString");
        if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token2)))) {
          return nok(code4);
        }
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteCallLabelMarker");
        effects.exit("gfmFootnoteCall");
        return ok3;
      }
      if (!markdownLineEndingOrSpace(code4)) {
        data2 = true;
      }
      size3++;
      effects.consume(code4);
      return code4 === 92 ? callEscape : callData;
    }
    function callEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size3++;
        return callData;
      }
      return callData(code4);
    }
  }
  function tokenizeDefinitionStart(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let identifier2;
    let size3 = 0;
    let data2;
    return start2;
    function start2(code4) {
      effects.enter("gfmFootnoteDefinition")._container = true;
      effects.enter("gfmFootnoteDefinitionLabel");
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      return labelAtMarker;
    }
    function labelAtMarker(code4) {
      if (code4 === 94) {
        effects.enter("gfmFootnoteDefinitionMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteDefinitionMarker");
        effects.enter("gfmFootnoteDefinitionLabelString");
        effects.enter("chunkString").contentType = "string";
        return labelInside;
      }
      return nok(code4);
    }
    function labelInside(code4) {
      if (
        // Too long.
        size3 > 999 || // Closing brace with nothing.
        code4 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
      ) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit("chunkString");
        const token2 = effects.exit("gfmFootnoteDefinitionLabelString");
        identifier2 = normalizeIdentifier(self2.sliceSerialize(token2));
        effects.enter("gfmFootnoteDefinitionLabelMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteDefinitionLabelMarker");
        effects.exit("gfmFootnoteDefinitionLabel");
        return labelAfter;
      }
      if (!markdownLineEndingOrSpace(code4)) {
        data2 = true;
      }
      size3++;
      effects.consume(code4);
      return code4 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size3++;
        return labelInside;
      }
      return labelInside(code4);
    }
    function labelAfter(code4) {
      if (code4 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code4);
        effects.exit("definitionMarker");
        if (!defined.includes(identifier2)) {
          defined.push(identifier2);
        }
        return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
      }
      return nok(code4);
    }
    function whitespaceAfter(code4) {
      return ok3(code4);
    }
  }
  function tokenizeDefinitionContinuation(effects, ok3, nok) {
    return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
  }
  function gfmFootnoteDefinitionEnd(effects) {
    effects.exit("gfmFootnoteDefinition");
  }
  function tokenizeIndent2(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code4) : nok(code4);
    }
  }

  // ../../node_modules/micromark-extension-gfm-strikethrough/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function gfmStrikethrough(options) {
    const options_ = options || {};
    let single = options_.singleTilde;
    const tokenizer2 = {
      name: "strikethrough",
      tokenize: tokenizeStrikethrough,
      resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === void 0) {
      single = true;
    }
    return {
      text: {
        [126]: tokenizer2
      },
      insideSpan: {
        null: [tokenizer2]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function resolveAllStrikethrough(events, context) {
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
          let open = index2;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
            events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
              events[index2][1].type = "strikethroughSequence";
              events[open][1].type = "strikethroughSequence";
              const strikethrough2 = {
                type: "strikethrough",
                start: Object.assign({}, events[open][1].start),
                end: Object.assign({}, events[index2][1].end)
              };
              const text9 = {
                type: "strikethroughText",
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index2][1].start)
              };
              const nextEvents = [["enter", strikethrough2, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text9, context]];
              const insideSpan2 = context.parser.constructs.insideSpan.null;
              if (insideSpan2) {
                splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index2), context));
              }
              splice(nextEvents, nextEvents.length, 0, [["exit", text9, context], ["enter", events[index2][1], context], ["exit", events[index2][1], context], ["exit", strikethrough2, context]]);
              splice(events, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "strikethroughSequenceTemporary") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeStrikethrough(effects, ok3, nok) {
      const previous3 = this.previous;
      const events = this.events;
      let size3 = 0;
      return start2;
      function start2(code4) {
        if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
          return nok(code4);
        }
        effects.enter("strikethroughSequenceTemporary");
        return more(code4);
      }
      function more(code4) {
        const before = classifyCharacter(previous3);
        if (code4 === 126) {
          if (size3 > 1) return nok(code4);
          effects.consume(code4);
          size3++;
          return more;
        }
        if (size3 < 2 && !single) return nok(code4);
        const token2 = effects.exit("strikethroughSequenceTemporary");
        const after = classifyCharacter(code4);
        token2._open = !after || after === 2 && Boolean(before);
        token2._close = !before || before === 2 && Boolean(after);
        return ok3(code4);
      }
    }
  }

  // ../../node_modules/micromark-extension-gfm-table/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-table/lib/syntax.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-table/lib/edit-map.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var EditMap = class {
    /**
     * Create a new edit map.
     */
    constructor() {
      this.map = [];
    }
    /**
     * Create an edit: a remove and/or add at a certain place.
     *
     * @param {number} index
     * @param {number} remove
     * @param {Array<Event>} add
     * @returns {undefined}
     */
    add(index2, remove, add) {
      addImplementation(this, index2, remove, add);
    }
    // To do: add this when moving to `micromark`.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {undefined}
    //  */
    // addBefore(index, remove, add) {
    //   addImplementation(this, index, remove, add, true)
    // }
    /**
     * Done, change the events.
     *
     * @param {Array<Event>} events
     * @returns {undefined}
     */
    consume(events) {
      this.map.sort(function(a, b) {
        return a[0] - b[0];
      });
      if (this.map.length === 0) {
        return;
      }
      let index2 = this.map.length;
      const vecs = [];
      while (index2 > 0) {
        index2 -= 1;
        vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]), this.map[index2][2]);
        events.length = this.map[index2][0];
      }
      vecs.push(events.slice());
      events.length = 0;
      let slice2 = vecs.pop();
      while (slice2) {
        for (const element4 of slice2) {
          events.push(element4);
        }
        slice2 = vecs.pop();
      }
      this.map.length = 0;
    }
  };
  function addImplementation(editMap, at, remove, add) {
    let index2 = 0;
    if (remove === 0 && add.length === 0) {
      return;
    }
    while (index2 < editMap.map.length) {
      if (editMap.map[index2][0] === at) {
        editMap.map[index2][1] += remove;
        editMap.map[index2][2].push(...add);
        return;
      }
      index2 += 1;
    }
    editMap.map.push([at, remove, add]);
  }

  // ../../node_modules/micromark-extension-gfm-table/lib/infer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function gfmTableAlign(events, index2) {
    let inDelimiterRow = false;
    const align = [];
    while (index2 < events.length) {
      const event = events[index2];
      if (inDelimiterRow) {
        if (event[0] === "enter") {
          if (event[1].type === "tableContent") {
            align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
          }
        } else if (event[1].type === "tableContent") {
          if (events[index2 - 1][1].type === "tableDelimiterMarker") {
            const alignIndex = align.length - 1;
            align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
          }
        } else if (event[1].type === "tableDelimiterRow") {
          break;
        }
      } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
        inDelimiterRow = true;
      }
      index2 += 1;
    }
    return align;
  }

  // ../../node_modules/micromark-extension-gfm-table/lib/syntax.js
  function gfmTable() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: tokenizeTable,
          resolveAll: resolveTable
        }
      }
    };
  }
  function tokenizeTable(effects, ok3, nok) {
    const self2 = this;
    let size3 = 0;
    let sizeB = 0;
    let seen;
    return start2;
    function start2(code4) {
      let index2 = self2.events.length - 1;
      while (index2 > -1) {
        const type = self2.events[index2][1].type;
        if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        type === "linePrefix") index2--;
        else break;
      }
      const tail = index2 > -1 ? self2.events[index2][1].type : null;
      const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
      if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      return next2(code4);
    }
    function headRowBefore(code4) {
      effects.enter("tableHead");
      effects.enter("tableRow");
      return headRowStart(code4);
    }
    function headRowStart(code4) {
      if (code4 === 124) {
        return headRowBreak(code4);
      }
      seen = true;
      sizeB += 1;
      return headRowBreak(code4);
    }
    function headRowBreak(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        if (sizeB > 1) {
          sizeB = 0;
          self2.interrupt = true;
          effects.exit("tableRow");
          effects.enter("lineEnding");
          effects.consume(code4);
          effects.exit("lineEnding");
          return headDelimiterStart;
        }
        return nok(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, headRowBreak, "whitespace")(code4);
      }
      sizeB += 1;
      if (seen) {
        seen = false;
        size3 += 1;
      }
      if (code4 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        seen = true;
        return headRowBreak;
      }
      effects.enter("data");
      return headRowData(code4);
    }
    function headRowData(code4) {
      if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
        effects.exit("data");
        return headRowBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? headRowEscape : headRowData;
    }
    function headRowEscape(code4) {
      if (code4 === 92 || code4 === 124) {
        effects.consume(code4);
        return headRowData;
      }
      return headRowData(code4);
    }
    function headDelimiterStart(code4) {
      self2.interrupt = false;
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      effects.enter("tableDelimiterRow");
      seen = false;
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
      }
      return headDelimiterBefore(code4);
    }
    function headDelimiterBefore(code4) {
      if (code4 === 45 || code4 === 58) {
        return headDelimiterValueBefore(code4);
      }
      if (code4 === 124) {
        seen = true;
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        return headDelimiterCellBefore;
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterCellBefore(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code4);
      }
      return headDelimiterValueBefore(code4);
    }
    function headDelimiterValueBefore(code4) {
      if (code4 === 58) {
        sizeB += 1;
        seen = true;
        effects.enter("tableDelimiterMarker");
        effects.consume(code4);
        effects.exit("tableDelimiterMarker");
        return headDelimiterLeftAlignmentAfter;
      }
      if (code4 === 45) {
        sizeB += 1;
        return headDelimiterLeftAlignmentAfter(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        return headDelimiterCellAfter(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterLeftAlignmentAfter(code4) {
      if (code4 === 45) {
        effects.enter("tableDelimiterFiller");
        return headDelimiterFiller(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterFiller(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return headDelimiterFiller;
      }
      if (code4 === 58) {
        seen = true;
        effects.exit("tableDelimiterFiller");
        effects.enter("tableDelimiterMarker");
        effects.consume(code4);
        effects.exit("tableDelimiterMarker");
        return headDelimiterRightAlignmentAfter;
      }
      effects.exit("tableDelimiterFiller");
      return headDelimiterRightAlignmentAfter(code4);
    }
    function headDelimiterRightAlignmentAfter(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code4);
      }
      return headDelimiterCellAfter(code4);
    }
    function headDelimiterCellAfter(code4) {
      if (code4 === 124) {
        return headDelimiterBefore(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        if (!seen || size3 !== sizeB) {
          return headDelimiterNok(code4);
        }
        effects.exit("tableDelimiterRow");
        effects.exit("tableHead");
        return ok3(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterNok(code4) {
      return nok(code4);
    }
    function bodyRowStart(code4) {
      effects.enter("tableRow");
      return bodyRowBreak(code4);
    }
    function bodyRowBreak(code4) {
      if (code4 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        return bodyRowBreak;
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("tableRow");
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, bodyRowBreak, "whitespace")(code4);
      }
      effects.enter("data");
      return bodyRowData(code4);
    }
    function bodyRowData(code4) {
      if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
        effects.exit("data");
        return bodyRowBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? bodyRowEscape : bodyRowData;
    }
    function bodyRowEscape(code4) {
      if (code4 === 92 || code4 === 124) {
        effects.consume(code4);
        return bodyRowData;
      }
      return bodyRowData(code4);
    }
  }
  function resolveTable(events, context) {
    let index2 = -1;
    let inFirstCellAwaitingPipe = true;
    let rowKind = 0;
    let lastCell = [0, 0, 0, 0];
    let cell = [0, 0, 0, 0];
    let afterHeadAwaitingFirstBodyRow = false;
    let lastTableEnd = 0;
    let currentTable;
    let currentBody;
    let currentCell;
    const map3 = new EditMap();
    while (++index2 < events.length) {
      const event = events[index2];
      const token2 = event[1];
      if (event[0] === "enter") {
        if (token2.type === "tableHead") {
          afterHeadAwaitingFirstBodyRow = false;
          if (lastTableEnd !== 0) {
            flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
            currentBody = void 0;
            lastTableEnd = 0;
          }
          currentTable = {
            type: "table",
            start: Object.assign({}, token2.start),
            // Note: correct end is set later.
            end: Object.assign({}, token2.end)
          };
          map3.add(index2, 0, [["enter", currentTable, context]]);
        } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
          inFirstCellAwaitingPipe = true;
          currentCell = void 0;
          lastCell = [0, 0, 0, 0];
          cell = [0, index2 + 1, 0, 0];
          if (afterHeadAwaitingFirstBodyRow) {
            afterHeadAwaitingFirstBodyRow = false;
            currentBody = {
              type: "tableBody",
              start: Object.assign({}, token2.start),
              // Note: correct end is set later.
              end: Object.assign({}, token2.end)
            };
            map3.add(index2, 0, [["enter", currentBody, context]]);
          }
          rowKind = token2.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
        } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
          inFirstCellAwaitingPipe = false;
          if (cell[2] === 0) {
            if (lastCell[1] !== 0) {
              cell[0] = cell[1];
              currentCell = flushCell(map3, context, lastCell, rowKind, void 0, currentCell);
              lastCell = [0, 0, 0, 0];
            }
            cell[2] = index2;
          }
        } else if (token2.type === "tableCellDivider") {
          if (inFirstCellAwaitingPipe) {
            inFirstCellAwaitingPipe = false;
          } else {
            if (lastCell[1] !== 0) {
              cell[0] = cell[1];
              currentCell = flushCell(map3, context, lastCell, rowKind, void 0, currentCell);
            }
            lastCell = cell;
            cell = [lastCell[1], index2, 0, 0];
          }
        }
      } else if (token2.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = true;
        lastTableEnd = index2;
      } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
        lastTableEnd = index2;
        if (lastCell[1] !== 0) {
          cell[0] = cell[1];
          currentCell = flushCell(map3, context, lastCell, rowKind, index2, currentCell);
        } else if (cell[1] !== 0) {
          currentCell = flushCell(map3, context, cell, rowKind, index2, currentCell);
        }
        rowKind = 0;
      } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
        cell[3] = index2;
      }
    }
    if (lastTableEnd !== 0) {
      flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
    }
    map3.consume(context.events);
    index2 = -1;
    while (++index2 < context.events.length) {
      const event = context.events[index2];
      if (event[0] === "enter" && event[1].type === "table") {
        event[1]._align = gfmTableAlign(context.events, index2);
      }
    }
    return events;
  }
  function flushCell(map3, context, range, rowKind, rowEnd, previousCell) {
    const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
    const valueName = "tableContent";
    if (range[0] !== 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
      map3.add(range[0], 0, [["exit", previousCell, context]]);
    }
    const now2 = getPoint(context.events, range[1]);
    previousCell = {
      type: groupName,
      start: Object.assign({}, now2),
      // Note: correct end is set later.
      end: Object.assign({}, now2)
    };
    map3.add(range[1], 0, [["enter", previousCell, context]]);
    if (range[2] !== 0) {
      const relatedStart = getPoint(context.events, range[2]);
      const relatedEnd = getPoint(context.events, range[3]);
      const valueToken = {
        type: valueName,
        start: Object.assign({}, relatedStart),
        end: Object.assign({}, relatedEnd)
      };
      map3.add(range[2], 0, [["enter", valueToken, context]]);
      if (rowKind !== 2) {
        const start2 = context.events[range[2]];
        const end = context.events[range[3]];
        start2[1].end = Object.assign({}, end[1].end);
        start2[1].type = "chunkText";
        start2[1].contentType = "text";
        if (range[3] > range[2] + 1) {
          const a = range[2] + 1;
          const b = range[3] - range[2] - 1;
          map3.add(a, b, []);
        }
      }
      map3.add(range[3] + 1, 0, [["exit", valueToken, context]]);
    }
    if (rowEnd !== void 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
      map3.add(rowEnd, 0, [["exit", previousCell, context]]);
      previousCell = void 0;
    }
    return previousCell;
  }
  function flushTableEnd(map3, context, index2, table2, tableBody) {
    const exits = [];
    const related = getPoint(context.events, index2);
    if (tableBody) {
      tableBody.end = Object.assign({}, related);
      exits.push(["exit", tableBody, context]);
    }
    table2.end = Object.assign({}, related);
    exits.push(["exit", table2, context]);
    map3.add(index2 + 1, 0, exits);
  }
  function getPoint(events, index2) {
    const event = events[index2];
    const side = event[0] === "enter" ? "start" : "end";
    return event[1][side];
  }

  // ../../node_modules/micromark-extension-gfm-task-list-item/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tasklistCheck = {
    name: "tasklistCheck",
    tokenize: tokenizeTasklistCheck
  };
  function gfmTaskListItem() {
    return {
      text: {
        [91]: tasklistCheck
      }
    };
  }
  function tokenizeTasklistCheck(effects, ok3, nok) {
    const self2 = this;
    return open;
    function open(code4) {
      if (
        // Exit if there’s stuff before.
        self2.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !self2._gfmTasklistFirstContentOfListItem
      ) {
        return nok(code4);
      }
      effects.enter("taskListCheck");
      effects.enter("taskListCheckMarker");
      effects.consume(code4);
      effects.exit("taskListCheckMarker");
      return inside;
    }
    function inside(code4) {
      if (markdownLineEndingOrSpace(code4)) {
        effects.enter("taskListCheckValueUnchecked");
        effects.consume(code4);
        effects.exit("taskListCheckValueUnchecked");
        return close;
      }
      if (code4 === 88 || code4 === 120) {
        effects.enter("taskListCheckValueChecked");
        effects.consume(code4);
        effects.exit("taskListCheckValueChecked");
        return close;
      }
      return nok(code4);
    }
    function close(code4) {
      if (code4 === 93) {
        effects.enter("taskListCheckMarker");
        effects.consume(code4);
        effects.exit("taskListCheckMarker");
        effects.exit("taskListCheck");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      if (markdownLineEnding(code4)) {
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return effects.check({
          tokenize: spaceThenNonSpace
        }, ok3, nok)(code4);
      }
      return nok(code4);
    }
  }
  function spaceThenNonSpace(effects, ok3, nok) {
    return factorySpace(effects, after, "whitespace");
    function after(code4) {
      return code4 === null ? nok(code4) : ok3(code4);
    }
  }

  // ../../node_modules/micromark-extension-gfm/index.js
  function gfm(options) {
    return combineExtensions([
      gfmAutolinkLiteral(),
      gfmFootnote(),
      gfmStrikethrough(options),
      gfmTable(),
      gfmTaskListItem()
    ]);
  }

  // ../../node_modules/remark-gfm/lib/index.js
  var emptyOptions4 = {};
  function remarkGfm(options) {
    const self2 = (
      /** @type {Processor<Root>} */
      this
    );
    const settings = options || emptyOptions4;
    const data2 = self2.data();
    const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
    const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
    const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
    micromarkExtensions.push(gfm(settings));
    fromMarkdownExtensions.push(gfmFromMarkdown());
    toMarkdownExtensions.push(gfmToMarkdown(settings));
  }

  // ../../node_modules/rehype-sanitize/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/hast-util-sanitize/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/hast-util-sanitize/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/hast-util-sanitize/lib/schema.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var aria2 = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"];
  var defaultSchema = {
    ancestors: {
      tbody: ["table"],
      td: ["table"],
      th: ["table"],
      thead: ["table"],
      tfoot: ["table"],
      tr: ["table"]
    },
    attributes: {
      a: [
        ...aria2,
        // Note: these 3 are used by GFM footnotes, they do work on all links.
        "dataFootnoteBackref",
        "dataFootnoteRef",
        ["className", "data-footnote-backref"],
        "href"
      ],
      blockquote: ["cite"],
      // Note: this class is not normally allowed by GH, when manually writing
      // `code` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      code: [["className", /^language-./]],
      del: ["cite"],
      div: ["itemScope", "itemType"],
      dl: [...aria2],
      // Note: this is used by GFM footnotes.
      h2: [["className", "sr-only"]],
      img: [...aria2, "longDesc", "src"],
      // Note: `input` is not normally allowed by GH, when manually writing
      // it in markdown, they add it from tasklists some other way.
      // We can’t do that, so we have to allow it.
      input: [
        ["disabled", true],
        ["type", "checkbox"]
      ],
      ins: ["cite"],
      // Note: this class is not normally allowed by GH, when manually writing
      // `li` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      li: [["className", "task-list-item"]],
      // Note: this class is not normally allowed by GH, when manually writing
      // `ol` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      ol: [...aria2, ["className", "contains-task-list"]],
      q: ["cite"],
      section: ["dataFootnotes", ["className", "footnotes"]],
      source: ["srcSet"],
      summary: [...aria2],
      table: [...aria2],
      // Note: this class is not normally allowed by GH, when manually writing
      // `ol` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      ul: [...aria2, ["className", "contains-task-list"]],
      "*": [
        "abbr",
        "accept",
        "acceptCharset",
        "accessKey",
        "action",
        "align",
        "alt",
        "axis",
        "border",
        "cellPadding",
        "cellSpacing",
        "char",
        "charOff",
        "charSet",
        "checked",
        "clear",
        "colSpan",
        "color",
        "cols",
        "compact",
        "coords",
        "dateTime",
        "dir",
        // Note: `disabled` is technically allowed on all elements by GH.
        // But it is useless on everything except `input`.
        // Because `input`s are normally not allowed, but we allow them for
        // checkboxes due to tasklists, we allow `disabled` only there.
        "encType",
        "frame",
        "hSpace",
        "headers",
        "height",
        "hrefLang",
        "htmlFor",
        "id",
        "isMap",
        "itemProp",
        "label",
        "lang",
        "maxLength",
        "media",
        "method",
        "multiple",
        "name",
        "noHref",
        "noShade",
        "noWrap",
        "open",
        "prompt",
        "readOnly",
        "rev",
        "rowSpan",
        "rows",
        "rules",
        "scope",
        "selected",
        "shape",
        "size",
        "span",
        "start",
        "summary",
        "tabIndex",
        "title",
        "useMap",
        "vAlign",
        "value",
        "width"
      ]
    },
    clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
    clobberPrefix: "user-content-",
    protocols: {
      cite: ["http", "https"],
      href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
      longDesc: ["http", "https"],
      src: ["http", "https"]
    },
    required: {
      input: { disabled: true, type: "checkbox" }
    },
    strip: ["script"],
    tagNames: [
      "a",
      "b",
      "blockquote",
      "br",
      "code",
      "dd",
      "del",
      "details",
      "div",
      "dl",
      "dt",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      // Note: `input` is not normally allowed by GH, when manually writing
      // it in markdown, they add it from tasklists some other way.
      // We can’t do that, so we have to allow it.
      "input",
      "ins",
      "kbd",
      "li",
      "ol",
      "p",
      "picture",
      "pre",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "source",
      "span",
      "strike",
      "strong",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "tt",
      "ul",
      "var"
    ]
  };

  // ../../node_modules/hast-util-sanitize/lib/index.js
  var own5 = {}.hasOwnProperty;
  function sanitize(node3, options) {
    let result = { type: "root", children: [] };
    const state = {
      schema: options ? { ...defaultSchema, ...options } : defaultSchema,
      stack: []
    };
    const replace4 = transform(state, node3);
    if (replace4) {
      if (Array.isArray(replace4)) {
        if (replace4.length === 1) {
          result = replace4[0];
        } else {
          result.children = replace4;
        }
      } else {
        result = replace4;
      }
    }
    return result;
  }
  function transform(state, node3) {
    if (node3 && typeof node3 === "object") {
      const unsafe = (
        /** @type {Record<string, Readonly<unknown>>} */
        node3
      );
      const type = typeof unsafe.type === "string" ? unsafe.type : "";
      switch (type) {
        case "comment": {
          return comment(state, unsafe);
        }
        case "doctype": {
          return doctype(state, unsafe);
        }
        case "element": {
          return element3(state, unsafe);
        }
        case "root": {
          return root4(state, unsafe);
        }
        case "text": {
          return text8(state, unsafe);
        }
        default:
      }
    }
  }
  function comment(state, unsafe) {
    if (state.schema.allowComments) {
      const result = typeof unsafe.value === "string" ? unsafe.value : "";
      const index2 = result.indexOf("-->");
      const value = index2 < 0 ? result : result.slice(0, index2);
      const node3 = { type: "comment", value };
      patch2(node3, unsafe);
      return node3;
    }
  }
  function doctype(state, unsafe) {
    if (state.schema.allowDoctypes) {
      const node3 = { type: "doctype" };
      patch2(node3, unsafe);
      return node3;
    }
  }
  function element3(state, unsafe) {
    const name21 = typeof unsafe.tagName === "string" ? unsafe.tagName : "";
    state.stack.push(name21);
    const content3 = (
      /** @type {Array<ElementContent>} */
      children(state, unsafe.children)
    );
    const properties_ = properties(state, unsafe.properties);
    state.stack.pop();
    let safeElement = false;
    if (name21 && name21 !== "*" && (!state.schema.tagNames || state.schema.tagNames.includes(name21))) {
      safeElement = true;
      if (state.schema.ancestors && own5.call(state.schema.ancestors, name21)) {
        const ancestors = state.schema.ancestors[name21];
        let index2 = -1;
        safeElement = false;
        while (++index2 < ancestors.length) {
          if (state.stack.includes(ancestors[index2])) {
            safeElement = true;
          }
        }
      }
    }
    if (!safeElement) {
      return state.schema.strip && !state.schema.strip.includes(name21) ? content3 : void 0;
    }
    const node3 = {
      type: "element",
      tagName: name21,
      properties: properties_,
      children: content3
    };
    patch2(node3, unsafe);
    return node3;
  }
  function root4(state, unsafe) {
    const content3 = (
      /** @type {Array<RootContent>} */
      children(state, unsafe.children)
    );
    const node3 = { type: "root", children: content3 };
    patch2(node3, unsafe);
    return node3;
  }
  function text8(_, unsafe) {
    const value = typeof unsafe.value === "string" ? unsafe.value : "";
    const node3 = { type: "text", value };
    patch2(node3, unsafe);
    return node3;
  }
  function children(state, children2) {
    const results = [];
    if (Array.isArray(children2)) {
      const childrenUnknown = (
        /** @type {Array<Readonly<unknown>>} */
        children2
      );
      let index2 = -1;
      while (++index2 < childrenUnknown.length) {
        const value = transform(state, childrenUnknown[index2]);
        if (value) {
          if (Array.isArray(value)) {
            results.push(...value);
          } else {
            results.push(value);
          }
        }
      }
    }
    return results;
  }
  function properties(state, properties2) {
    const tagName = state.stack[state.stack.length - 1];
    const attributes = state.schema.attributes;
    const required = state.schema.required;
    const specific = attributes && own5.call(attributes, tagName) ? attributes[tagName] : void 0;
    const defaults = attributes && own5.call(attributes, "*") ? attributes["*"] : void 0;
    const properties_ = (
      /** @type {Readonly<Record<string, Readonly<unknown>>>} */
      properties2 && typeof properties2 === "object" ? properties2 : {}
    );
    const result = {};
    let key;
    for (key in properties_) {
      if (own5.call(properties_, key)) {
        const unsafe = properties_[key];
        let safe = propertyValue(
          state,
          findDefinition(specific, key),
          key,
          unsafe
        );
        if (safe === null || safe === void 0) {
          safe = propertyValue(state, findDefinition(defaults, key), key, unsafe);
        }
        if (safe !== null && safe !== void 0) {
          result[key] = safe;
        }
      }
    }
    if (required && own5.call(required, tagName)) {
      const properties3 = required[tagName];
      for (key in properties3) {
        if (own5.call(properties3, key) && !own5.call(result, key)) {
          result[key] = properties3[key];
        }
      }
    }
    return result;
  }
  function propertyValue(state, definition3, key, value) {
    return definition3 ? Array.isArray(value) ? propertyValueMany(state, definition3, key, value) : propertyValuePrimitive(state, definition3, key, value) : void 0;
  }
  function propertyValueMany(state, definition3, key, values) {
    let index2 = -1;
    const result = [];
    while (++index2 < values.length) {
      const value = propertyValuePrimitive(state, definition3, key, values[index2]);
      if (typeof value === "number" || typeof value === "string") {
        result.push(value);
      }
    }
    return result;
  }
  function propertyValuePrimitive(state, definition3, key, value) {
    if (typeof value !== "boolean" && typeof value !== "number" && typeof value !== "string") {
      return;
    }
    if (!safeProtocol2(state, key, value)) {
      return;
    }
    if (typeof definition3 === "object" && definition3.length > 1) {
      let ok3 = false;
      let index2 = 0;
      while (++index2 < definition3.length) {
        const allowed = definition3[index2];
        if (allowed && typeof allowed === "object" && "flags" in allowed) {
          if (allowed.test(String(value))) {
            ok3 = true;
            break;
          }
        } else if (allowed === value) {
          ok3 = true;
          break;
        }
      }
      if (!ok3) return;
    }
    return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key) ? state.schema.clobberPrefix + value : value;
  }
  function safeProtocol2(state, key, value) {
    const protocols = state.schema.protocols && own5.call(state.schema.protocols, key) ? state.schema.protocols[key] : void 0;
    if (!protocols || protocols.length === 0) {
      return true;
    }
    const url = String(value);
    const colon = url.indexOf(":");
    const questionMark = url.indexOf("?");
    const numberSign = url.indexOf("#");
    const slash = url.indexOf("/");
    if (colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {
      return true;
    }
    let index2 = -1;
    while (++index2 < protocols.length) {
      const protocol = protocols[index2];
      if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {
        return true;
      }
    }
    return false;
  }
  function patch2(node3, unsafe) {
    const cleanPosition = position(
      // @ts-expect-error: looks like a node.
      unsafe
    );
    if (unsafe.data) {
      node3.data = esm_default2(unsafe.data);
    }
    if (cleanPosition) node3.position = cleanPosition;
  }
  function findDefinition(definitions, key) {
    let dataDefault;
    let index2 = -1;
    if (definitions) {
      while (++index2 < definitions.length) {
        const entry = definitions[index2];
        const name21 = typeof entry === "string" ? entry : entry[0];
        if (name21 === key) {
          return entry;
        }
        if (name21 === "data*") dataDefault = entry;
      }
    }
    if (key.length > 4 && key.slice(0, 4).toLowerCase() === "data") {
      return dataDefault;
    }
  }

  // ../../node_modules/rehype-sanitize/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function rehypeSanitize(options) {
    return function(tree) {
      const result = (
        /** @type {Root} */
        sanitize(tree, options)
      );
      return result;
    };
  }

  // ../../packages/aihappey-core/dist/components/activity/progress/ProgressNotificationCard.js
  var ProgressNotificationCard = ({ notif }) => {
    const theme = useTheme();
    return theme.Card({
      title: notif.progressToken.toString(),
      children: (0, import_jsx_runtime24.jsx)(Markdown, { remarkPlugins: [remarkGfm], rehypePlugins: [rehypeSanitize], children: notif.message })
    });
  };

  // ../../packages/aihappey-core/dist/components/activity/progress/ProgressNotificationsActivity.js
  var ProgressNotificationsActivity = () => {
    const progress = useAppStore((s) => s.progress);
    if (!progress.length) {
      return (0, import_jsx_runtime25.jsx)("div", { className: "p-3 text-muted", children: "No progress" });
    }
    progress.reverse();
    return (0, import_jsx_runtime25.jsx)("div", { className: "p-3", style: { display: "flex", flexDirection: "column", gap: 8 }, children: progress.map((n, i) => (0, import_jsx_runtime25.jsx)(ProgressNotificationCard, { notif: n }, i)) });
  };

  // ../../packages/aihappey-core/dist/components/activity/sampling/SamplingActivity.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-core/dist/components/activity/sampling/SamplingCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var SamplingCard = ({ notif }) => {
    const { Chat: Chat3, Card: Card3 } = useTheme();
    console.log("dsadsa");
    console.log(notif);
    const flatMapped = notif[0].messages.flatMap((msg) => (Array.isArray(msg.content) ? msg.content : [msg.content]).map((contentItem) => ({
      id: msg.id,
      // or generate if missing
      role: msg.role,
      content: typeof contentItem === "string" ? contentItem : contentItem?.text ?? ""
    })));
    if (notif[1]) {
      flatMapped.push({
        id: notif[1].id,
        // or generate if missing
        role: notif[1].role,
        content: notif[1].content.text,
        createdAt: ""
      });
    }
    return notif[1] ? (0, import_jsx_runtime26.jsx)(Card3, { title: notif[0].modelPreferences?.hints[0]?.name, text: notif[1].content.text }) : (0, import_jsx_runtime26.jsx)(Card3, { title: notif[0].modelPreferences?.hints[0]?.name, children: (0, import_jsx_runtime26.jsx)(Chat3, { messages: flatMapped }) });
  };

  // ../../packages/aihappey-core/dist/components/activity/sampling/SamplingActivity.js
  var SamplingActivity = () => {
    const sampling = useAppStore((s) => s.sampling);
    var items = Object.keys(sampling).map((t) => sampling[t]).reverse();
    if (!items.length) {
      return (0, import_jsx_runtime27.jsx)("div", { className: "p-3 text-muted", children: "No sampling" });
    }
    return (0, import_jsx_runtime27.jsx)("div", { className: "p-3", style: { display: "flex", flexDirection: "column", gap: 8 }, children: items.map((n, i) => (0, import_jsx_runtime27.jsx)(SamplingCard, { notif: n }, i)) });
  };

  // ../../packages/aihappey-core/dist/components/pages/ChatPage.js
  var ChatPage = () => {
    const [selectedModel, setSelectedModel] = (0, import_react32.useState)("gpt-4.1");
    const [activeTab, setActiveTab] = (0, import_react32.useState)("toolInvocations");
    const theme = useTheme();
    const { showActivities, setActivities } = useUi();
    return (0, import_jsx_runtime28.jsxs)("div", { style: {
      display: "flex",
      height: "100vh",
      minHeight: 0,
      minWidth: 0
    }, children: [(0, import_jsx_runtime28.jsx)("div", { style: {
      width: 260,
      minWidth: 180,
      maxWidth: 320,
      borderRight: "1px solid #ddd",
      height: "100%",
      display: "flex",
      flexDirection: "column"
    }, children: (0, import_jsx_runtime28.jsx)(ConversationSidebar, {}) }), (0, import_jsx_runtime28.jsxs)("div", { style: {
      flex: 1,
      minWidth: 0,
      display: "flex",
      flexDirection: "column"
    }, children: [(0, import_jsx_runtime28.jsx)(ChatHeader, { value: selectedModel, onChange: setSelectedModel }), (0, import_jsx_runtime28.jsx)("div", { style: {
      flex: 1,
      minHeight: 0,
      display: "flex",
      flexDirection: "column"
    }, children: (0, import_jsx_runtime28.jsx)(ChatPanel, { model: selectedModel }) })] }), theme.Drawer && theme.Drawer({
      open: showActivities,
      onClose: () => setActivities(false),
      title: "Activities",
      size: "medium",
      children: (0, import_jsx_runtime28.jsxs)(theme.Tabs, { activeKey: activeTab, onSelect: setActiveTab, children: [(0, import_jsx_runtime28.jsx)(theme.Tab, { eventKey: "toolInvocations", title: "Tools", children: (0, import_jsx_runtime28.jsx)(ToolInvocationsActivity, {}) }), (0, import_jsx_runtime28.jsx)(theme.Tab, { eventKey: "mcpProgress", title: "Progress", children: (0, import_jsx_runtime28.jsx)(ProgressNotificationsActivity, {}) }), (0, import_jsx_runtime28.jsx)(theme.Tab, { eventKey: "mcpSampling", title: "Sampling", children: (0, import_jsx_runtime28.jsx)(SamplingActivity, {}) }), (0, import_jsx_runtime28.jsx)(theme.Tab, { eventKey: "mcpLogging", title: "Log", children: (0, import_jsx_runtime28.jsx)(LoggingNotificationsActivity, {}) })] })
    })] });
  };

  // ../../packages/aihappey-core/dist/components/mcp/useRemoteMcpServers.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react33 = __toESM(require_react());
  var useRemoteMcpServers = (configUrls = []) => {
    const addServer = useAppStore((s) => s.addServer);
    (0, import_react33.useEffect)(() => {
      if (!configUrls.length)
        return;
      (async () => {
        const results = await Promise.all(configUrls.map(async (url) => {
          const res = await fetch(url);
          if (!res.ok)
            return null;
          return res.json();
        }));
        results.filter(Boolean).flat().forEach((item) => {
          const record = item && typeof item === "object" && "servers" in item ? item.servers : item;
          Object.entries(record).forEach(([name21, cfg]) => addServer(name21, cfg));
        });
      })();
    }, [JSON.stringify(configUrls), addServer]);
  };

  // ../../packages/aihappey-core/dist/components/mcp/McpConnectionsProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var import_react34 = __toESM(require_react());
  var McpConnectionsProvider = ({ children: children2, samplingApi }) => {
    const servers = useAppStore((s) => s.servers);
    const selected = useAppStore((s) => s.selected);
    const connect = useAppStore((s) => s.connect);
    const addNotification = useAppStore((s) => s.addNotification);
    const addProgress = useAppStore((s) => s.addProgress);
    const addSamplingRequest = useAppStore((s) => s.addSamplingRequest);
    const addSamplingResponse = useAppStore((s) => s.addSamplingResponse);
    (0, import_react34.useEffect)(() => {
      const urls = selected.map((n) => servers[n]?.url).filter(Boolean);
      const onSample = samplingApi ? async (params) => {
        const id = crypto.randomUUID();
        addSamplingRequest(id, params);
        const accessToken = await acquireAccessToken();
        const res = await fetch(samplingApi, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${accessToken}`
          },
          body: JSON.stringify(params)
        });
        if (!res.ok) {
          throw new Error(`Sampling failed (${res.status})`);
        }
        const json = await res.json();
        addSamplingResponse(id, json);
        return json;
      } : void 0;
      const onLogging = async (notif) => addNotification(notif);
      const onProgress = async (notif) => addProgress(notif);
      const connectServers = async () => {
        await Promise.all(urls.map((url) => connect(url, { onSample, onLogging, onProgress })));
      };
      connectServers();
    }, [JSON.stringify(selected), JSON.stringify(servers), samplingApi]);
    return (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children: children2 });
  };

  // ../../packages/aihappey-core/dist/CoreRoot.js
  var import_react35 = __toESM(require_react());
  var CoreRoot = ({ initialLists = [], chatConfig, appName, authConfig }) => {
    useTheme();
    useRemoteMcpServers(initialLists);
    const msalInstance = (0, import_react35.useMemo)(() => authConfig ? initAuth(authConfig) : null, [authConfig]);
    const mergedChatConfig = (0, import_react35.useMemo)(() => {
      if (!authConfig)
        return chatConfig;
      const api = chatConfig?.api ?? "/api/chat";
      return {
        ...chatConfig,
        appName,
        api,
        getAccessToken: () => acquireAccessToken(authConfig.msal.scopes)
      };
    }, [chatConfig, authConfig]);
    const chatUi = mergedChatConfig ? (0, import_jsx_runtime30.jsx)(ChatProvider, { config: mergedChatConfig, children: (0, import_jsx_runtime30.jsx)(ChatPage, {}) }) : (0, import_jsx_runtime30.jsx)("div", { children: "Loaded" });
    const wrappedUi = (0, import_jsx_runtime30.jsx)(McpConnectionsProvider, { samplingApi: mergedChatConfig?.samplingApi, children: chatUi });
    return msalInstance ? (0, import_jsx_runtime30.jsx)(MsalAuthProvider, { instance: msalInstance, children: (0, import_jsx_runtime30.jsx)(MsalAuthenticationTemplate, { interactionType: InteractionType.Redirect, authenticationRequest: { scopes: authConfig.msal.scopes }, children: wrappedUi }) }) : (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, { children: wrappedUi });
  };

  // ../../packages/aihappey-core/dist/components/markdown/Markdown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime31 = __toESM(require_jsx_runtime());
  var Markdown2 = ({ text: text9 }) => (0, import_jsx_runtime31.jsx)(Markdown, { remarkPlugins: [remarkGfm], rehypePlugins: [rehypeSanitize], components: {
    p: ({ node: node3, ...props }) => (0, import_jsx_runtime31.jsx)("p", { style: { margin: "0.5em 0" }, ...props })
  }, children: text9 });

  // ../../packages/aihappey-theme-fluent/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-theme-fluent/dist/ThemeProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());

  // ../../packages/aihappey-theme-fluent/dist/primitives.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-theme-fluent/dist/fluentTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../packages/aihappey-theme-fluent/dist/primitives/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());

  // ../../node_modules/@fluentui/react-components/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/react/index.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/index.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/shorthands/border.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/shorthands/borderWidth.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/shorthands/generateStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var positionMap = ["Top", "Right", "Bottom", "Left"];
  function generateStyles(property, suffix, ...values) {
    const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
    const valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
    const styles = {};
    for (let i = 0; i < valuesWithDefaults.length; i += 1) {
      if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {
        const newKey = property + positionMap[i] + suffix;
        styles[newKey] = valuesWithDefaults[i];
      }
    }
    return styles;
  }

  // ../../node_modules/@griffel/core/shorthands/borderWidth.esm.js
  function borderWidth(...values) {
    return generateStyles("border", "Width", ...values);
  }

  // ../../node_modules/@griffel/core/shorthands/borderStyle.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderStyle(...values) {
    return generateStyles("border", "Style", ...values);
  }

  // ../../node_modules/@griffel/core/shorthands/borderColor.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderColor(...values) {
    return generateStyles("border", "Color", ...values);
  }

  // ../../node_modules/@griffel/core/shorthands/utils.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var LINE_STYLES = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
  function isBorderStyle(value) {
    return LINE_STYLES.includes(value);
  }

  // ../../node_modules/@griffel/core/shorthands/border.esm.js
  function border(...values) {
    if (isBorderStyle(values[0])) {
      return Object.assign({}, borderStyle(values[0]), values[1] && borderWidth(values[1]), values[2] && borderColor(values[2]));
    }
    return Object.assign({}, borderWidth(values[0]), values[1] && borderStyle(values[1]), values[2] && borderColor(values[2]));
  }

  // ../../node_modules/@griffel/core/shorthands/borderLeft.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderLeft(...values) {
    if (isBorderStyle(values[0])) {
      return Object.assign({
        borderLeftStyle: values[0]
      }, values[1] && {
        borderLeftWidth: values[1]
      }, values[2] && {
        borderLeftColor: values[2]
      });
    }
    return Object.assign({
      borderLeftWidth: values[0]
    }, values[1] && {
      borderLeftStyle: values[1]
    }, values[2] && {
      borderLeftColor: values[2]
    });
  }

  // ../../node_modules/@griffel/core/shorthands/borderBottom.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderBottom(...values) {
    if (isBorderStyle(values[0])) {
      return Object.assign({
        borderBottomStyle: values[0]
      }, values[1] && {
        borderBottomWidth: values[1]
      }, values[2] && {
        borderBottomColor: values[2]
      });
    }
    return Object.assign({
      borderBottomWidth: values[0]
    }, values[1] && {
      borderBottomStyle: values[1]
    }, values[2] && {
      borderBottomColor: values[2]
    });
  }

  // ../../node_modules/@griffel/core/shorthands/borderRight.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderRight(...values) {
    if (isBorderStyle(values[0])) {
      return Object.assign({
        borderRightStyle: values[0]
      }, values[1] && {
        borderRightWidth: values[1]
      }, values[2] && {
        borderRightColor: values[2]
      });
    }
    return Object.assign({
      borderRightWidth: values[0]
    }, values[1] && {
      borderRightStyle: values[1]
    }, values[2] && {
      borderRightColor: values[2]
    });
  }

  // ../../node_modules/@griffel/core/shorthands/borderTop.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderTop(...values) {
    if (isBorderStyle(values[0])) {
      return Object.assign({
        borderTopStyle: values[0]
      }, values[1] && {
        borderTopWidth: values[1]
      }, values[2] && {
        borderTopColor: values[2]
      });
    }
    return Object.assign({
      borderTopWidth: values[0]
    }, values[1] && {
      borderTopStyle: values[1]
    }, values[2] && {
      borderTopColor: values[2]
    });
  }

  // ../../node_modules/@griffel/core/shorthands/borderRadius.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function borderRadius(value1, value2 = value1, value3 = value1, value4 = value2) {
    return {
      borderBottomRightRadius: value3,
      borderBottomLeftRadius: value4,
      borderTopRightRadius: value2,
      borderTopLeftRadius: value1
    };
  }

  // ../../node_modules/@griffel/core/shorthands/flex.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var isUnit = (value) => typeof value === "string" && /(\d+(\w+|%))/.test(value);
  var isUnitless = (value) => typeof value === "number" && !Number.isNaN(value);
  var isInitial = (value) => value === "initial";
  var isAuto = (value) => value === "auto";
  var isNone = (value) => value === "none";
  var widthReservedKeys = ["content", "fit-content", "max-content", "min-content"];
  var isWidth = (value) => widthReservedKeys.some((key) => value === key) || isUnit(value);
  function flex(...values) {
    const isOneValueSyntax = values.length === 1;
    const isTwoValueSyntax = values.length === 2;
    const isThreeValueSyntax = values.length === 3;
    if (isOneValueSyntax) {
      const [firstValue] = values;
      if (isInitial(firstValue)) {
        return {
          flexGrow: 0,
          flexShrink: 1,
          flexBasis: "auto"
        };
      }
      if (isAuto(firstValue)) {
        return {
          flexGrow: 1,
          flexShrink: 1,
          flexBasis: "auto"
        };
      }
      if (isNone(firstValue)) {
        return {
          flexGrow: 0,
          flexShrink: 0,
          flexBasis: "auto"
        };
      }
      if (isUnitless(firstValue)) {
        return {
          flexGrow: firstValue,
          flexShrink: 1,
          flexBasis: 0
        };
      }
      if (isWidth(firstValue)) {
        return {
          flexGrow: 1,
          flexShrink: 1,
          flexBasis: firstValue
        };
      }
    }
    if (isTwoValueSyntax) {
      const [firstValue, secondValue] = values;
      if (isUnitless(secondValue)) {
        return {
          flexGrow: firstValue,
          flexShrink: secondValue,
          flexBasis: 0
        };
      }
      if (isWidth(secondValue)) {
        return {
          flexGrow: firstValue,
          flexShrink: 1,
          flexBasis: secondValue
        };
      }
    }
    if (isThreeValueSyntax) {
      const [firstValue, secondValue, thirdValue] = values;
      if (isUnitless(firstValue) && isUnitless(secondValue) && (isAuto(thirdValue) || isWidth(thirdValue))) {
        return {
          flexGrow: firstValue,
          flexShrink: secondValue,
          flexBasis: thirdValue
        };
      }
    }
    if (false) {
      console.error(`The value passed to shorthands.flex did not match any flex property specs. The CSS styles were not generated. Please, check the flex documentation.`);
    }
    return {};
  }

  // ../../node_modules/@griffel/core/shorthands/gap.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function gap(columnGap, rowGap = columnGap) {
    return {
      columnGap,
      rowGap
    };
  }

  // ../../node_modules/@griffel/core/shorthands/gridArea.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cssVarRegEx = /var\(.*\)/gi;
  function isValidGridAreaInput(value) {
    return value === void 0 || typeof value === "number" || typeof value === "string" && !cssVarRegEx.test(value);
  }
  var customIdentRegEx = /^[a-zA-Z0-9\-_\\#;]+$/;
  var nonCustomIdentRegEx = /^-moz-initial$|^auto$|^initial$|^inherit$|^revert$|^unset$|^span \d+$|^\d.*/;
  function isCustomIdent(value) {
    return value !== void 0 && typeof value === "string" && customIdentRegEx.test(value) && !nonCustomIdentRegEx.test(value);
  }
  function gridArea(...values) {
    if (values.some((value) => !isValidGridAreaInput(value))) {
      if (false) {
        console.error(`The value passed to shorthands.gridArea() did not match any gridArea property specs. The CSS styles were not generated. Please, check the gridArea documentation.`, ["The value passed to shorthands.gridArea() did not match any gridArea property specs. ", "The CSS styles were not generated.\n", "Please, check the `grid-area` documentation:\n", "- https://developer.mozilla.org/docs/Web/CSS/grid-area", "- https://griffel.js.org/react/api/shorthands#shorthandsgridarea"].join(""));
      }
      return {};
    }
    const gridRowStart = values[0] !== void 0 ? values[0] : "auto";
    const gridColumnStart = values[1] !== void 0 ? values[1] : isCustomIdent(gridRowStart) ? gridRowStart : "auto";
    const gridRowEnd = values[2] !== void 0 ? values[2] : isCustomIdent(gridRowStart) ? gridRowStart : "auto";
    const gridColumnEnd = values[3] !== void 0 ? values[3] : isCustomIdent(gridColumnStart) ? gridColumnStart : "auto";
    return {
      gridRowStart,
      gridColumnStart,
      gridRowEnd,
      gridColumnEnd
    };
  }

  // ../../node_modules/@griffel/core/shorthands/margin.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function margin(...values) {
    return generateStyles("margin", "", ...values);
  }

  // ../../node_modules/@griffel/core/shorthands/marginBlock.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function marginBlock(start2, end = start2) {
    return {
      marginBlockStart: start2,
      marginBlockEnd: end
    };
  }

  // ../../node_modules/@griffel/core/shorthands/marginInline.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function marginInline(start2, end = start2) {
    return {
      marginInlineStart: start2,
      marginInlineEnd: end
    };
  }

  // ../../node_modules/@griffel/core/shorthands/padding.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function padding(...values) {
    return generateStyles("padding", "", ...values);
  }

  // ../../node_modules/@griffel/core/shorthands/paddingBlock.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function paddingBlock(start2, end = start2) {
    return {
      paddingBlockStart: start2,
      paddingBlockEnd: end
    };
  }

  // ../../node_modules/@griffel/core/shorthands/paddingInline.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function paddingInline(start2, end = start2) {
    return {
      paddingInlineStart: start2,
      paddingInlineEnd: end
    };
  }

  // ../../node_modules/@griffel/core/shorthands/overflow.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function overflow(overflowX, overflowY = overflowX) {
    return {
      overflowX,
      overflowY
    };
  }

  // ../../node_modules/@griffel/core/shorthands/inset.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function inset(...values) {
    const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
    return {
      top: firstValue,
      right: secondValue,
      bottom: thirdValue,
      left: fourthValue
    };
  }

  // ../../node_modules/@griffel/core/shorthands/outline.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function outline(outlineWidth, outlineStyle, outlineColor) {
    return Object.assign({
      outlineWidth
    }, outlineStyle && {
      outlineStyle
    }, outlineColor && {
      outlineColor
    });
  }

  // ../../node_modules/@griffel/core/shorthands/transition.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function transition(...values) {
    if (isTransitionGlobalInputs(values)) {
      return {
        transitionDelay: values[0],
        transitionDuration: values[0],
        transitionProperty: values[0],
        transitionTimingFunction: values[0]
      };
    }
    const transitionInputs = normalizeTransitionInputs(values);
    return transitionInputs.reduce((acc, [property, duration = "0s", delay2 = "0s", timingFunction = "ease"], index2) => {
      if (index2 === 0) {
        acc.transitionProperty = property;
        acc.transitionDuration = duration;
        acc.transitionDelay = delay2;
        acc.transitionTimingFunction = timingFunction;
      } else {
        acc.transitionProperty += `, ${property}`;
        acc.transitionDuration += `, ${duration}`;
        acc.transitionDelay += `, ${delay2}`;
        acc.transitionTimingFunction += `, ${timingFunction}`;
      }
      return acc;
    }, {});
  }
  var transitionGlobalInputs = ["-moz-initial", "inherit", "initial", "revert", "unset"];
  function isTransitionGlobalInputs(values) {
    return values.length === 1 && transitionGlobalInputs.includes(values[0]);
  }
  function normalizeTransitionInputs(transitionInputs) {
    if (transitionInputs.length === 1 && Array.isArray(transitionInputs[0])) {
      return transitionInputs[0];
    }
    return [transitionInputs];
  }

  // ../../node_modules/@griffel/core/shorthands/textDecoration.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function textDecoration(value, ...values) {
    if (values.length === 0) {
      return isTextDecorationStyleInput(value) ? {
        textDecorationStyle: value
      } : {
        textDecorationLine: value
      };
    }
    const [textDecorationStyle, textDecorationColor, textDecorationThickness] = values;
    return Object.assign({
      textDecorationLine: value
    }, textDecorationStyle && {
      textDecorationStyle
    }, textDecorationColor && {
      textDecorationColor
    }, textDecorationThickness && {
      textDecorationThickness
    });
  }
  var textDecorationStyleInputs = ["dashed", "dotted", "double", "solid", "wavy"];
  function isTextDecorationStyleInput(value) {
    return textDecorationStyleInputs.includes(value);
  }

  // ../../node_modules/@griffel/core/renderer/createDOMRenderer.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/constants.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var __GLOBAL__ = typeof window === "undefined" ? global : window;
  var __NAMESPACE_PREFIX__ = "@griffel/";
  function getGlobalVar(name21, defaultValue) {
    if (!__GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name21)]) {
      __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name21)] = defaultValue;
    }
    return __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name21)];
  }
  var DEFINITION_LOOKUP_TABLE = /* @__PURE__ */ getGlobalVar("DEFINITION_LOOKUP_TABLE", {});
  var DATA_BUCKET_ATTR = "data-make-styles-bucket";
  var DATA_PRIORITY_ATTR = "data-priority";
  var HASH_PREFIX = "f";
  var SEQUENCE_HASH_LENGTH = 7;
  var SEQUENCE_PREFIX = "___";
  var DEBUG_SEQUENCE_SEPARATOR = "_";
  var SEQUENCE_SIZE = true ? SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH : SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH + DEBUG_SEQUENCE_SEPARATOR.length + SEQUENCE_HASH_LENGTH;
  var LOOKUP_DEFINITIONS_INDEX = 0;
  var LOOKUP_DIR_INDEX = 1;
  var UNSUPPORTED_CSS_PROPERTIES = {
    all: 1,
    borderColor: 1,
    borderStyle: 1,
    borderWidth: 1,
    borderBlock: 1,
    borderBlockEnd: 1,
    borderBlockStart: 1,
    borderInline: 1,
    borderInlineEnd: 1,
    borderInlineStart: 1
  };
  var RESET = "DO_NOT_USE_DIRECTLY: @griffel/reset-value";

  // ../../node_modules/@griffel/core/mergeClasses.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/utils/hashSequence.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@emotion/hash/dist/emotion-hash.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // ../../node_modules/@griffel/core/runtime/utils/hashSequence.esm.js
  function padEndHash(value) {
    const hashLength = value.length;
    if (hashLength === SEQUENCE_HASH_LENGTH) {
      return value;
    }
    for (let i = hashLength; i < SEQUENCE_HASH_LENGTH; i++) {
      value += "0";
    }
    return value;
  }
  function hashSequence(classes, dir, sequenceIds = []) {
    if (true) {
      return SEQUENCE_PREFIX + padEndHash(murmur2(classes + dir));
    }
    return SEQUENCE_PREFIX + padEndHash(murmur2(classes + dir)) + DEBUG_SEQUENCE_SEPARATOR + padEndHash(murmur2(sequenceIds.join("")));
  }

  // ../../node_modules/@griffel/core/runtime/reduceToClassNameForSlots.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function reduceToClassName(classMap, dir) {
    let classString = "";
    let hashString2 = "";
    for (const propertyHash in classMap) {
      const classNameMapping = classMap[propertyHash];
      if (classNameMapping === 0) {
        hashString2 += propertyHash + " ";
        continue;
      }
      const hasRTLClassName = Array.isArray(classNameMapping);
      const className = dir === "rtl" ? (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " " : (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
      classString += className;
      hashString2 += className;
    }
    return [classString.slice(0, -1), hashString2.slice(0, -1)];
  }
  function reduceToClassNameForSlots(classesMapBySlot, dir) {
    const classNamesForSlots = {};
    for (const slotName in classesMapBySlot) {
      const [slotClasses, slotClassesHash] = reduceToClassName(classesMapBySlot[slotName], dir);
      if (slotClassesHash === "") {
        classNamesForSlots[slotName] = "";
        continue;
      }
      const sequenceHash = hashSequence(slotClassesHash, dir);
      const resultSlotClasses = sequenceHash + (slotClasses === "" ? "" : " " + slotClasses);
      DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
      classNamesForSlots[slotName] = resultSlotClasses;
    }
    return classNamesForSlots;
  }

  // ../../node_modules/@griffel/core/mergeClasses.esm.js
  var mergeClassesCachedResults = {};
  function mergeClasses() {
    let dir = null;
    let resultClassName = "";
    let sequenceMatch = "";
    const sequencesIds = new Array(arguments.length);
    let containsResetClassName = "";
    for (let i = 0; i < arguments.length; i++) {
      const className = arguments[i];
      if (typeof className === "string" && className !== "") {
        const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);
        if (sequenceIndex === -1) {
          if (false) {
            className.split(" ").forEach((entry) => {
              if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) {
                if (containsResetClassName) {
                  console.error(`mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:https://griffel.js.org/react/api/make-reset-styles#limitations
Source string: ${className}`);
                } else {
                  containsResetClassName = entry;
                }
              }
            });
          }
          resultClassName += className + " ";
        } else {
          const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);
          if (sequenceIndex > 0) {
            resultClassName += className.slice(0, sequenceIndex);
          }
          sequenceMatch += sequenceId;
          sequencesIds[i] = sequenceId;
        }
        if (false) {
          if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {
            console.error(`mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start with "${SEQUENCE_PREFIX}"), it's possible that passed classes were concatenated in a wrong way. Source string: ${className}`);
          }
        }
      }
    }
    if (sequenceMatch === "") {
      return resultClassName.slice(0, -1);
    }
    const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];
    if (mergeClassesResult !== void 0) {
      return resultClassName + mergeClassesResult;
    }
    const sequenceMappings = [];
    for (let i = 0; i < arguments.length; i++) {
      const sequenceId = sequencesIds[i];
      if (sequenceId) {
        const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];
        if (sequenceMapping) {
          sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);
          if (false) {
            if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {
              console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction (dir="${sequenceMapping[1] ? "rtl" : "ltr"}") setting than other classes. This is not supported. Source string: ${arguments[i]}`);
            }
          }
          dir = sequenceMapping[LOOKUP_DIR_INDEX];
        } else {
          if (false) {
            console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry in cache. Source string: ${arguments[i]}`);
          }
        }
      }
    }
    const resultClassesMap = Object.assign.apply(
      Object,
      // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
      [{}].concat(sequenceMappings)
    );
    const [atomicClasses, classesMapHash] = reduceToClassName(resultClassesMap, dir);
    const newSequenceHash = hashSequence(classesMapHash, dir, sequencesIds);
    const newClassName = newSequenceHash + " " + atomicClasses;
    mergeClassesCachedResults[sequenceMatch] = newClassName;
    DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultClassesMap, dir];
    return resultClassName + newClassName;
  }

  // ../../node_modules/@griffel/core/runtime/utils/normalizeCSSBucketEntry.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function normalizeCSSBucketEntry(entry) {
    if (!Array.isArray(entry)) {
      return [entry];
    }
    if (false) {
      throw new Error("CSS Bucket contains an entry with greater than 2 items, please report this to https://github.com/microsoft/griffel/issues");
    }
    return entry;
  }

  // ../../node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/renderer/createIsomorphicStyleSheet.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createIsomorphicStyleSheet(styleElement, bucketName, priority, elementAttributes) {
    const __cssRulesForSSR = [];
    elementAttributes[DATA_BUCKET_ATTR] = bucketName;
    elementAttributes[DATA_PRIORITY_ATTR] = String(priority);
    if (styleElement) {
      for (const attrName in elementAttributes) {
        styleElement.setAttribute(attrName, elementAttributes[attrName]);
      }
    }
    function insertRule(rule) {
      if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
        return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);
      }
      return __cssRulesForSSR.push(rule);
    }
    return {
      elementAttributes,
      insertRule,
      element: styleElement,
      bucketName,
      cssRules() {
        if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
          return Array.from(styleElement.sheet.cssRules).map((cssRule) => cssRule.cssText);
        }
        return __cssRulesForSSR;
      }
    };
  }

  // ../../node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js
  var styleBucketOrdering = [
    // reset styles
    "r",
    // catch-all
    "d",
    // link
    "l",
    // visited
    "v",
    // focus-within
    "w",
    // focus
    "f",
    // focus-visible
    "i",
    // hover
    "h",
    // active
    "a",
    // at rules for reset styles
    "s",
    // keyframes
    "k",
    // at-rules
    "t",
    // @media rules
    "m",
    // @container rules
    "c"
  ];
  var styleBucketOrderingMap = /* @__PURE__ */ styleBucketOrdering.reduce((acc, cur, j) => {
    acc[cur] = j;
    return acc;
  }, {});
  function getStyleSheetKey(bucketName, media, priority) {
    return (bucketName === "m" ? bucketName + media : bucketName) + priority;
  }
  function getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {
    var _a17, _b;
    const isMediaBucket = bucketName === "m";
    const media = (_a17 = metadata["m"]) !== null && _a17 !== void 0 ? _a17 : "0";
    const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
    const stylesheetKey = getStyleSheetKey(bucketName, media, priority);
    if (!renderer.stylesheets[stylesheetKey]) {
      const tag = targetDocument && targetDocument.createElement("style");
      const stylesheet = createIsomorphicStyleSheet(tag, bucketName, priority, Object.assign({}, renderer.styleElementAttributes, isMediaBucket && {
        media
      }));
      renderer.stylesheets[stylesheetKey] = stylesheet;
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.head) && tag) {
        targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));
      }
    }
    return renderer.stylesheets[stylesheetKey];
  }
  function isSameInsertionKey(element4, bucketName, metadata) {
    var _a17, _b;
    const targetKey = bucketName + ((_a17 = metadata["m"]) !== null && _a17 !== void 0 ? _a17 : "");
    const elementKey = element4.getAttribute(DATA_BUCKET_ATTR) + ((_b = element4.media) !== null && _b !== void 0 ? _b : "");
    return targetKey === elementKey;
  }
  function findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata = {}) {
    var _a17, _b;
    const targetOrder = styleBucketOrderingMap[targetBucket];
    const media = (_a17 = metadata["m"]) !== null && _a17 !== void 0 ? _a17 : "";
    const priority = (_b = metadata["p"]) !== null && _b !== void 0 ? _b : 0;
    let comparer = (el) => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];
    let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);
    if (targetBucket === "m") {
      const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}="${targetBucket}"]`);
      if (mediaElements.length) {
        styleElements = mediaElements;
        comparer = (el) => renderer.compareMediaQueries(media, el.media);
      }
    }
    const comparerWithPriority = (el) => {
      if (isSameInsertionKey(el, targetBucket, metadata)) {
        return priority - Number(el.getAttribute("data-priority"));
      }
      return comparer(el);
    };
    const length2 = styleElements.length;
    let index2 = length2 - 1;
    while (index2 >= 0) {
      const styleElement = styleElements.item(index2);
      if (comparerWithPriority(styleElement) > 0) {
        return styleElement.nextSibling;
      }
      index2--;
    }
    if (length2 > 0) {
      return styleElements.item(0);
    }
    return insertionPoint ? insertionPoint.nextSibling : null;
  }

  // ../../node_modules/@griffel/core/renderer/safeInsertRule.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ignoreSuffixes = /* @__PURE__ */ ["-moz-placeholder", "-moz-focus-inner", "-moz-focusring", "-ms-input-placeholder", "-moz-read-write", "-moz-read-only"].join("|");
  var ignoreSuffixesRegex = /* @__PURE__ */ new RegExp(`:(${ignoreSuffixes})`);
  function safeInsertRule(sheet, ruleCSS) {
    try {
      sheet.insertRule(ruleCSS);
    } catch (e) {
      if (false) {
        console.error(`There was a problem inserting the following rule: "${ruleCSS}"`, e);
      }
    }
  }

  // ../../node_modules/@griffel/core/renderer/createDOMRenderer.esm.js
  var lastIndex = 0;
  var defaultCompareMediaQueries = (a, b) => a < b ? -1 : a > b ? 1 : 0;
  function createDOMRenderer(targetDocument = typeof document === "undefined" ? void 0 : document, options = {}) {
    const {
      classNameHashSalt,
      unstable_filterCSSRule,
      insertionPoint,
      styleElementAttributes,
      compareMediaQueries = defaultCompareMediaQueries
    } = options;
    const renderer = {
      classNameHashSalt,
      insertionCache: {},
      stylesheets: {},
      styleElementAttributes: Object.freeze(styleElementAttributes),
      compareMediaQueries,
      id: `d${lastIndex++}`,
      insertCSSRules(cssRules) {
        for (const styleBucketName in cssRules) {
          const cssRulesForBucket = cssRules[styleBucketName];
          for (let i = 0, l = cssRulesForBucket.length; i < l; i++) {
            const [ruleCSS, metadata] = normalizeCSSBucketEntry(cssRulesForBucket[i]);
            const sheet = getStyleSheetForBucket(styleBucketName, targetDocument, insertionPoint || null, renderer, metadata);
            if (renderer.insertionCache[ruleCSS]) {
              continue;
            }
            renderer.insertionCache[ruleCSS] = styleBucketName;
            if (false) {
              debugData.addCSSRule(ruleCSS);
            }
            if (unstable_filterCSSRule) {
              if (unstable_filterCSSRule(ruleCSS)) {
                safeInsertRule(sheet, ruleCSS);
              }
            } else {
              safeInsertRule(sheet, ruleCSS);
            }
          }
        }
      }
    };
    if (targetDocument && false) {
      injectDevTools(targetDocument);
    }
    return renderer;
  }

  // ../../node_modules/@griffel/core/makeStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/insertionFactory.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var insertionFactory = () => {
    const insertionCache = {};
    return function insertStyles(renderer, cssRules) {
      if (insertionCache[renderer.id] === void 0) {
        renderer.insertCSSRules(cssRules);
        insertionCache[renderer.id] = true;
      }
    };
  };

  // ../../node_modules/@griffel/core/resolveStyleRulesForSlots.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/resolveStyleRules.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/rtl-css-js/dist/esm/core.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/rtl-css-js/dist/esm/convert-9768a965.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function arrayToObject(array) {
    return array.reduce(function(obj, _ref) {
      var prop1 = _ref[0], prop2 = _ref[1];
      obj[prop1] = prop2;
      obj[prop2] = prop1;
      return obj;
    }, {});
  }
  function isBoolean(val) {
    return typeof val === "boolean";
  }
  function isFunction(val) {
    return typeof val === "function";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isNullOrUndefined(val) {
    return val === null || typeof val === "undefined";
  }
  function isObject(val) {
    return val && typeof val === "object";
  }
  function isString(val) {
    return typeof val === "string";
  }
  function includes(inclusive, inclusee) {
    return inclusive.indexOf(inclusee) !== -1;
  }
  function flipSign(value) {
    if (parseFloat(value) === 0) {
      return value;
    }
    if (value[0] === "-") {
      return value.slice(1);
    }
    return "-" + value;
  }
  function flipTransformSign(match2, prefix2, offset4, suffix) {
    return prefix2 + flipSign(offset4) + suffix;
  }
  function calculateNewBackgroundPosition(value) {
    var idx = value.indexOf(".");
    if (idx === -1) {
      value = 100 - parseFloat(value) + "%";
    } else {
      var len = value.length - idx - 2;
      value = 100 - parseFloat(value);
      value = value.toFixed(len) + "%";
    }
    return value;
  }
  function getValuesAsList(value) {
    return value.replace(/ +/g, " ").split(" ").map(function(i) {
      return i.trim();
    }).filter(Boolean).reduce(function(_ref2, item) {
      var list4 = _ref2.list, state = _ref2.state;
      var openParansCount = (item.match(/\(/g) || []).length;
      var closedParansCount = (item.match(/\)/g) || []).length;
      if (state.parensDepth > 0) {
        list4[list4.length - 1] = list4[list4.length - 1] + " " + item;
      } else {
        list4.push(item);
      }
      state.parensDepth += openParansCount - closedParansCount;
      return {
        list: list4,
        state
      };
    }, {
      list: [],
      state: {
        parensDepth: 0
      }
    }).list;
  }
  function handleQuartetValues(value) {
    var splitValues = getValuesAsList(value);
    if (splitValues.length <= 3 || splitValues.length > 4) {
      return value;
    }
    var top = splitValues[0], right = splitValues[1], bottom = splitValues[2], left = splitValues[3];
    return [top, left, bottom, right].join(" ");
  }
  function canConvertValue(value) {
    return !isBoolean(value) && !isNullOrUndefined(value);
  }
  function splitShadow(value) {
    var shadows = [];
    var start2 = 0;
    var end = 0;
    var rgba = false;
    while (end < value.length) {
      if (!rgba && value[end] === ",") {
        shadows.push(value.substring(start2, end).trim());
        end++;
        start2 = end;
      } else if (value[end] === "(") {
        rgba = true;
        end++;
      } else if (value[end] === ")") {
        rgba = false;
        end++;
      } else {
        end++;
      }
    }
    if (start2 != end) {
      shadows.push(value.substring(start2, end + 1));
    }
    return shadows;
  }
  var propertyValueConverters = {
    padding: function padding2(_ref) {
      var value = _ref.value;
      if (isNumber(value)) {
        return value;
      }
      return handleQuartetValues(value);
    },
    textShadow: function textShadow(_ref2) {
      var value = _ref2.value;
      var flippedShadows = splitShadow(value).map(function(shadow) {
        return shadow.replace(/(^|\s)(-*)([.|\d]+)/, function(match2, whiteSpace, negative, number2) {
          if (number2 === "0") {
            return match2;
          }
          var doubleNegative = negative === "" ? "-" : "";
          return "" + whiteSpace + doubleNegative + number2;
        });
      });
      return flippedShadows.join(",");
    },
    borderColor: function borderColor2(_ref3) {
      var value = _ref3.value;
      return handleQuartetValues(value);
    },
    borderRadius: function borderRadius2(_ref4) {
      var value = _ref4.value;
      if (isNumber(value)) {
        return value;
      }
      if (includes(value, "/")) {
        var _value$split = value.split("/"), radius1 = _value$split[0], radius2 = _value$split[1];
        var convertedRadius1 = propertyValueConverters.borderRadius({
          value: radius1.trim()
        });
        var convertedRadius2 = propertyValueConverters.borderRadius({
          value: radius2.trim()
        });
        return convertedRadius1 + " / " + convertedRadius2;
      }
      var splitValues = getValuesAsList(value);
      switch (splitValues.length) {
        case 2: {
          return splitValues.reverse().join(" ");
        }
        case 4: {
          var topLeft = splitValues[0], topRight = splitValues[1], bottomRight = splitValues[2], bottomLeft = splitValues[3];
          return [topRight, topLeft, bottomLeft, bottomRight].join(" ");
        }
        default: {
          return value;
        }
      }
    },
    background: function background(_ref5) {
      var value = _ref5.value, valuesToConvert2 = _ref5.valuesToConvert, isRtl = _ref5.isRtl, bgImgDirectionRegex2 = _ref5.bgImgDirectionRegex, bgPosDirectionRegex2 = _ref5.bgPosDirectionRegex;
      if (isNumber(value)) {
        return value;
      }
      var backgroundPositionValue = value.replace(/(url\(.*?\))|(rgba?\(.*?\))|(hsl\(.*?\))|(#[a-fA-F0-9]+)|((^| )(\D)+( |$))/g, "").trim();
      value = value.replace(backgroundPositionValue, propertyValueConverters.backgroundPosition({
        value: backgroundPositionValue,
        valuesToConvert: valuesToConvert2,
        isRtl,
        bgPosDirectionRegex: bgPosDirectionRegex2
      }));
      return propertyValueConverters.backgroundImage({
        value,
        valuesToConvert: valuesToConvert2,
        bgImgDirectionRegex: bgImgDirectionRegex2
      });
    },
    backgroundImage: function backgroundImage(_ref6) {
      var value = _ref6.value, valuesToConvert2 = _ref6.valuesToConvert, bgImgDirectionRegex2 = _ref6.bgImgDirectionRegex;
      if (!includes(value, "url(") && !includes(value, "linear-gradient(")) {
        return value;
      }
      return value.replace(bgImgDirectionRegex2, function(match2, g1, group2) {
        return match2.replace(group2, valuesToConvert2[group2]);
      });
    },
    backgroundPosition: function backgroundPosition(_ref7) {
      var value = _ref7.value, valuesToConvert2 = _ref7.valuesToConvert, isRtl = _ref7.isRtl, bgPosDirectionRegex2 = _ref7.bgPosDirectionRegex;
      return value.replace(isRtl ? /^((-|\d|\.)+%)/ : null, function(match2, group) {
        return calculateNewBackgroundPosition(group);
      }).replace(bgPosDirectionRegex2, function(match2) {
        return valuesToConvert2[match2];
      });
    },
    backgroundPositionX: function backgroundPositionX(_ref8) {
      var value = _ref8.value, valuesToConvert2 = _ref8.valuesToConvert, isRtl = _ref8.isRtl, bgPosDirectionRegex2 = _ref8.bgPosDirectionRegex;
      if (isNumber(value)) {
        return value;
      }
      return propertyValueConverters.backgroundPosition({
        value,
        valuesToConvert: valuesToConvert2,
        isRtl,
        bgPosDirectionRegex: bgPosDirectionRegex2
      });
    },
    transition: function transition2(_ref9) {
      var value = _ref9.value, propertiesToConvert2 = _ref9.propertiesToConvert;
      return value.split(/,\s*/g).map(function(transition3) {
        var values = transition3.split(" ");
        values[0] = propertiesToConvert2[values[0]] || values[0];
        return values.join(" ");
      }).join(", ");
    },
    transitionProperty: function transitionProperty(_ref10) {
      var value = _ref10.value, propertiesToConvert2 = _ref10.propertiesToConvert;
      return value.split(/,\s*/g).map(function(prop) {
        return propertiesToConvert2[prop] || prop;
      }).join(", ");
    },
    transform: function transform2(_ref11) {
      var value = _ref11.value;
      var nonAsciiPattern = "[^\\u0020-\\u007e]";
      var escapePattern = "(?:(?:(?:\\[0-9a-f]{1,6})(?:\\r\\n|\\s)?)|\\\\[^\\r\\n\\f0-9a-f])";
      var signedQuantPattern = "((?:-?" + ("(?:[0-9]*\\.[0-9]+|[0-9]+)(?:\\s*(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)|" + ("-?" + ("(?:[_a-z]|" + nonAsciiPattern + "|" + escapePattern + ")") + ("(?:[_a-z0-9-]|" + nonAsciiPattern + "|" + escapePattern + ")") + "*") + ")?") + ")|(?:inherit|auto))";
      var translateXRegExp = new RegExp("(translateX\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
      var translateRegExp = new RegExp("(translate\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,1}\\s*\\))", "gi");
      var translate3dRegExp = new RegExp("(translate3d\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,2}\\s*\\))", "gi");
      var rotateRegExp = new RegExp("(rotate[ZY]?\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
      return value.replace(translateXRegExp, flipTransformSign).replace(translateRegExp, flipTransformSign).replace(translate3dRegExp, flipTransformSign).replace(rotateRegExp, flipTransformSign);
    }
  };
  propertyValueConverters.objectPosition = propertyValueConverters.backgroundPosition;
  propertyValueConverters.margin = propertyValueConverters.padding;
  propertyValueConverters.borderWidth = propertyValueConverters.padding;
  propertyValueConverters.boxShadow = propertyValueConverters.textShadow;
  propertyValueConverters.webkitBoxShadow = propertyValueConverters.boxShadow;
  propertyValueConverters.mozBoxShadow = propertyValueConverters.boxShadow;
  propertyValueConverters.WebkitBoxShadow = propertyValueConverters.boxShadow;
  propertyValueConverters.MozBoxShadow = propertyValueConverters.boxShadow;
  propertyValueConverters.borderStyle = propertyValueConverters.borderColor;
  propertyValueConverters.webkitTransform = propertyValueConverters.transform;
  propertyValueConverters.mozTransform = propertyValueConverters.transform;
  propertyValueConverters.WebkitTransform = propertyValueConverters.transform;
  propertyValueConverters.MozTransform = propertyValueConverters.transform;
  propertyValueConverters.transformOrigin = propertyValueConverters.backgroundPosition;
  propertyValueConverters.webkitTransformOrigin = propertyValueConverters.transformOrigin;
  propertyValueConverters.mozTransformOrigin = propertyValueConverters.transformOrigin;
  propertyValueConverters.WebkitTransformOrigin = propertyValueConverters.transformOrigin;
  propertyValueConverters.MozTransformOrigin = propertyValueConverters.transformOrigin;
  propertyValueConverters.webkitTransition = propertyValueConverters.transition;
  propertyValueConverters.mozTransition = propertyValueConverters.transition;
  propertyValueConverters.WebkitTransition = propertyValueConverters.transition;
  propertyValueConverters.MozTransition = propertyValueConverters.transition;
  propertyValueConverters.webkitTransitionProperty = propertyValueConverters.transitionProperty;
  propertyValueConverters.mozTransitionProperty = propertyValueConverters.transitionProperty;
  propertyValueConverters.WebkitTransitionProperty = propertyValueConverters.transitionProperty;
  propertyValueConverters.MozTransitionProperty = propertyValueConverters.transitionProperty;
  propertyValueConverters["text-shadow"] = propertyValueConverters.textShadow;
  propertyValueConverters["border-color"] = propertyValueConverters.borderColor;
  propertyValueConverters["border-radius"] = propertyValueConverters.borderRadius;
  propertyValueConverters["background-image"] = propertyValueConverters.backgroundImage;
  propertyValueConverters["background-position"] = propertyValueConverters.backgroundPosition;
  propertyValueConverters["background-position-x"] = propertyValueConverters.backgroundPositionX;
  propertyValueConverters["object-position"] = propertyValueConverters.objectPosition;
  propertyValueConverters["border-width"] = propertyValueConverters.padding;
  propertyValueConverters["box-shadow"] = propertyValueConverters.textShadow;
  propertyValueConverters["-webkit-box-shadow"] = propertyValueConverters.textShadow;
  propertyValueConverters["-moz-box-shadow"] = propertyValueConverters.textShadow;
  propertyValueConverters["border-style"] = propertyValueConverters.borderColor;
  propertyValueConverters["-webkit-transform"] = propertyValueConverters.transform;
  propertyValueConverters["-moz-transform"] = propertyValueConverters.transform;
  propertyValueConverters["transform-origin"] = propertyValueConverters.transformOrigin;
  propertyValueConverters["-webkit-transform-origin"] = propertyValueConverters.transformOrigin;
  propertyValueConverters["-moz-transform-origin"] = propertyValueConverters.transformOrigin;
  propertyValueConverters["-webkit-transition"] = propertyValueConverters.transition;
  propertyValueConverters["-moz-transition"] = propertyValueConverters.transition;
  propertyValueConverters["transition-property"] = propertyValueConverters.transitionProperty;
  propertyValueConverters["-webkit-transition-property"] = propertyValueConverters.transitionProperty;
  propertyValueConverters["-moz-transition-property"] = propertyValueConverters.transitionProperty;
  var propertiesToConvert = arrayToObject([
    ["paddingLeft", "paddingRight"],
    ["marginLeft", "marginRight"],
    ["left", "right"],
    ["borderLeft", "borderRight"],
    ["borderLeftColor", "borderRightColor"],
    ["borderLeftStyle", "borderRightStyle"],
    ["borderLeftWidth", "borderRightWidth"],
    ["borderTopLeftRadius", "borderTopRightRadius"],
    ["borderBottomLeftRadius", "borderBottomRightRadius"],
    // kebab-case versions
    ["padding-left", "padding-right"],
    ["margin-left", "margin-right"],
    ["border-left", "border-right"],
    ["border-left-color", "border-right-color"],
    ["border-left-style", "border-right-style"],
    ["border-left-width", "border-right-width"],
    ["border-top-left-radius", "border-top-right-radius"],
    ["border-bottom-left-radius", "border-bottom-right-radius"]
  ]);
  var propsToIgnore = ["content"];
  var valuesToConvert = arrayToObject([["ltr", "rtl"], ["left", "right"], ["w-resize", "e-resize"], ["sw-resize", "se-resize"], ["nw-resize", "ne-resize"]]);
  var bgImgDirectionRegex = new RegExp("(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)", "g");
  var bgPosDirectionRegex = new RegExp("(left)|(right)");
  function convert2(object2) {
    return Object.keys(object2).reduce(function(newObj, originalKey) {
      var originalValue = object2[originalKey];
      if (isString(originalValue)) {
        originalValue = originalValue.trim();
      }
      if (includes(propsToIgnore, originalKey)) {
        newObj[originalKey] = originalValue;
        return newObj;
      }
      var _convertProperty = convertProperty(originalKey, originalValue), key = _convertProperty.key, value = _convertProperty.value;
      newObj[key] = value;
      return newObj;
    }, Array.isArray(object2) ? [] : {});
  }
  function convertProperty(originalKey, originalValue) {
    var isNoFlip = /\/\*\s?@noflip\s?\*\//.test(originalValue);
    var key = isNoFlip ? originalKey : getPropertyDoppelganger(originalKey);
    var value = isNoFlip ? originalValue : getValueDoppelganger(key, originalValue);
    return {
      key,
      value
    };
  }
  function getPropertyDoppelganger(property) {
    return propertiesToConvert[property] || property;
  }
  function getValueDoppelganger(key, originalValue) {
    if (!canConvertValue(originalValue)) {
      return originalValue;
    }
    if (isObject(originalValue)) {
      return convert2(originalValue);
    }
    var isNum = isNumber(originalValue);
    var isFunc = isFunction(originalValue);
    var importantlessValue = isNum || isFunc ? originalValue : originalValue.replace(/ !important.*?$/, "");
    var isImportant = !isNum && importantlessValue.length !== originalValue.length;
    var valueConverter = propertyValueConverters[key];
    var newValue;
    if (valueConverter) {
      newValue = valueConverter({
        value: importantlessValue,
        valuesToConvert,
        propertiesToConvert,
        isRtl: true,
        bgImgDirectionRegex,
        bgPosDirectionRegex
      });
    } else {
      newValue = valuesToConvert[importantlessValue] || importantlessValue;
    }
    if (isImportant) {
      return newValue + " !important";
    }
    return newValue;
  }

  // ../../node_modules/@griffel/core/runtime/compileAtomicCSSRule.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/utils/hyphenateProperty.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match2) {
    return "-" + match2.toLowerCase();
  }
  function hyphenateProperty(name21) {
    if (Object.prototype.hasOwnProperty.call(cache, name21)) {
      return cache[name21];
    }
    if (name21.substr(0, 2) === "--") {
      return name21;
    }
    const hName = name21.replace(uppercasePattern, toHyphenLower);
    return cache[name21] = msPattern.test(hName) ? "-" + hName : hName;
  }

  // ../../node_modules/@griffel/core/runtime/utils/normalizeNestedProperty.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function normalizeNestedProperty(nestedProperty) {
    if (nestedProperty.charAt(0) === "&") {
      return nestedProperty.slice(1);
    }
    return nestedProperty;
  }

  // ../../node_modules/@griffel/core/runtime/compileCSSRules.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/stylis/src/Enum.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var MEDIA = "@media";
  var IMPORT = "@import";
  var SUPPORTS = "@supports";
  var NAMESPACE = "@namespace";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // ../../node_modules/stylis/src/Utility.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace3(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search2, position4) {
    return value.indexOf(search2, position4);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }

  // ../../node_modules/stylis/src/Parser.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/stylis/src/Tokenizer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var line = 1;
  var column = 1;
  var length = 0;
  var position3 = 0;
  var character = 0;
  var characters = "";
  function node2(value, root5, parent, type, props, children2, length2, siblings) {
    return { value, root: root5, parent, type, props, children: children2, line, column, length: length2, return: "", siblings };
  }
  function copy(root5, props) {
    return assign(node2("", null, null, "", null, null, 0, root5.siblings), root5, { length: -root5.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position3 > 0 ? charat(characters, --position3) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position3 < length ? charat(characters, position3++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position3);
  }
  function caret() {
    return position3;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position3 = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position3 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function tokenize(value) {
    return dealloc(tokenizer(alloc(value)));
  }
  function whitespace2(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function tokenizer(children2) {
    while (next())
      switch (token(character)) {
        case 0:
          append(identifier(position3 - 1), children2);
          break;
        case 2:
          append(delimit(character), children2);
          break;
        default:
          append(from(character), children2);
      }
    return children2;
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position3;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position3;
  }
  function commenter(type, index2) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position3 - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position3);
  }

  // ../../node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse3("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse3(value, root5, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset4 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous3 = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children2 = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous3 = character2, character2 = next()) {
        // (
        case 40:
          if (previous3 != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace3(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace2(previous3);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment2(commenter(next(), caret()), root5, parent, declarations), declarations);
              if ((token(previous3 || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset4:
              if (ampersand == -1) characters2 = replace3(characters2, /\f/g, "");
              if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous3 === 47))
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace3(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root5, parent, index2, offset4, rules, points, type, props = [], children2 = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset4 === 0)
                  parse3(characters2, root5, reference, reference, props, rulesets, length2, points, children2);
                else {
                  switch (atrule) {
                    // c(ontainer)
                    case 99:
                      if (charat(characters2, 3) === 110) break;
                    // l(ayer)
                    case 108:
                      if (charat(characters2, 2) === 97) break;
                    default:
                      offset4 = 0;
                    // d(ocument) m(edia) s(upports)
                    case 100:
                    case 109:
                    case 115:
                  }
                  if (offset4) parse3(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children2), children2), rules, children2, length2, points, rule ? props : children2);
                  else parse3(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
          }
          index2 = offset4 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous3;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset4 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset4 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous3 === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root5, parent, index2, offset4, rules, points, type, props, children2, length2, siblings) {
    var post2 = offset4 - 1;
    var rule = offset4 === 0 ? rules : [""];
    var size3 = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index2; ++i)
      for (var x = 0, y = substr(value, post2 + 1, post2 = abs(j = points[i])), z = value; x < size3; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace3(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node2(value, root5, parent, offset4 === 0 ? RULESET : type, props, children2, length2, siblings);
  }
  function comment2(value, root5, parent, siblings) {
    return node2(value, root5, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root5, parent, length2, siblings) {
    return node2(value, root5, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }

  // ../../node_modules/stylis/src/Serializer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function serialize4(children2, callback) {
    var output = "";
    for (var i = 0; i < children2.length; i++)
      output += callback(children2[i], i, children2, callback) || "";
    return output;
  }
  function stringify3(element4, index2, children2, callback) {
    switch (element4.type) {
      case LAYER:
        if (element4.children.length) break;
      case IMPORT:
      case NAMESPACE:
      case DECLARATION:
        return element4.return = element4.return || element4.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element4.return = element4.value + "{" + serialize4(element4.children, callback) + "}";
      case RULESET:
        if (!strlen(element4.value = element4.props.join(","))) return "";
    }
    return strlen(children2 = serialize4(element4.children, callback)) ? element4.return = element4.value + "{" + children2 + "}" : "";
  }

  // ../../node_modules/stylis/src/Middleware.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element4, index2, children2, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element4, index2, children2, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element4) {
      if (!element4.root) {
        if (element4 = element4.return)
          callback(element4);
      }
    };
  }

  // ../../node_modules/@griffel/core/runtime/stylis/globalPlugin.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var globalPlugin = (element4) => {
    switch (element4.type) {
      case RULESET:
        if (typeof element4.props === "string") {
          if (false) {
            throw new Error(`"element.props" has type "string" (${JSON.stringify(element4.props, null, 2)}), it's not expected. Please report a bug if it happens.`);
          }
          return;
        }
        element4.props = element4.props.map((value) => {
          if (value.indexOf(":global(") === -1) {
            return value;
          }
          return tokenize(value).reduce((acc, value2, index2, children2) => {
            if (value2 === "") {
              return acc;
            }
            if (value2 === ":" && children2[index2 + 1] === "global") {
              const selector = (
                // An inner part of ":global()"
                children2[index2 + 2].slice(1, -1) + // A separator between selectors i.e. "body .class"
                " "
              );
              acc.unshift(selector);
              children2[index2 + 1] = "";
              children2[index2 + 2] = "";
              return acc;
            }
            acc.push(value2);
            return acc;
          }, []).join("");
        });
    }
  };

  // ../../node_modules/@griffel/core/runtime/stylis/prefixerPlugin.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function prefix(value, length2, children2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // backface-visibility, column, box-decoration-break
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
        return WEBKIT + value + value;
      // backdrop-filter, background-clip: text
      case 4215:
        if (charat(value, 9) === 102) {
          return WEBKIT + value + value;
        }
        if (charat(value, length2 + 1) === 116) {
          return WEBKIT + value + value;
        }
        break;
      // tab-size
      case 4789:
        return MOZ + value + value;
      // appearance, user-select, hyphens
      case 5349:
      case 4246:
      case 6968:
        return WEBKIT + value + MOZ + value + value;
      // cursor
      // @ts-expect-error fall through is intentional here
      case 6187:
        if (!match(value, /grab/)) {
          return replace3(replace3(replace3(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        }
      // background, background-image
      case 5495:
      case 3959:
        return replace3(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace3(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (f)ill-available
          // @ts-expect-error fall through is intentional here
          case 102:
            if (charat(value, length2 + 3) === 108) {
              return replace3(
                value,
                /(.+:)(.+)-([^]+)/,
                // eslint-disable-next-line no-useless-concat, eqeqeq
                "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")
              ) + value;
            }
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace3(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
    }
    return value;
  }
  function prefixerPlugin(element4, index2, children2, callback) {
    if (element4.length > -1) {
      if (!element4.return) switch (element4.type) {
        case DECLARATION:
          element4.return = prefix(element4.value, element4.length);
          return;
        case RULESET:
          if (element4.length)
            return combine(element4.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                // :read-(only|write)
                case ":read-only":
                case ":read-write":
                  return serialize4(
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    [copy(element4, {
                      props: [replace3(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                    })],
                    callback
                  );
                // :placeholder
                case "::placeholder":
                  return serialize4([
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    copy(element4, {
                      props: [replace3(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                    }),
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    copy(element4, {
                      props: [replace3(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                    })
                  ], callback);
              }
              return "";
            });
      }
    }
    return void 0;
  }

  // ../../node_modules/@griffel/core/runtime/stylis/sortClassesInAtRulesPlugin.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/stylis/isAtRuleElement.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isAtRuleElement(element4) {
    switch (element4.type) {
      case "@container":
      case MEDIA:
      case SUPPORTS:
      case LAYER:
        return true;
    }
    return false;
  }

  // ../../node_modules/@griffel/core/runtime/stylis/sortClassesInAtRulesPlugin.esm.js
  var sortClassesInAtRulesPlugin = (element4) => {
    if (isAtRuleElement(element4) && Array.isArray(element4.children)) {
      element4.children.sort((a, b) => a.props[0] > b.props[0] ? 1 : -1);
    }
  };

  // ../../node_modules/@griffel/core/runtime/compileCSSRules.esm.js
  function noop2() {
  }
  function compileCSSRules(cssRules, sortClassesInAtRules) {
    const rules = [];
    serialize4(compile(cssRules), middleware([
      globalPlugin,
      sortClassesInAtRules ? sortClassesInAtRulesPlugin : noop2,
      prefixerPlugin,
      stringify3,
      // 💡 we are using `.insertRule()` API for DOM operations, which does not support
      // insertion of multiple CSS rules in a single call. `rulesheet` plugin extracts
      // individual rules to be used with this API
      rulesheet((rule) => rules.push(rule))
    ]));
    return rules;
  }

  // ../../node_modules/@griffel/core/runtime/compileAtomicCSSRule.esm.js
  var PSEUDO_SELECTOR_REGEX = /,( *[^ &])/g;
  function normalizePseudoSelector(pseudoSelector) {
    return "&" + normalizeNestedProperty(
      // Regex there replaces a comma, spaces and an ampersand if it's present with comma and an ampersand.
      // This allows to normalize input, see examples in JSDoc.
      pseudoSelector.replace(PSEUDO_SELECTOR_REGEX, ",&$1")
    );
  }
  function createCSSRule(classNameSelector, cssDeclaration, pseudos) {
    let cssRule = cssDeclaration;
    if (pseudos.length > 0) {
      cssRule = pseudos.reduceRight((acc, selector) => {
        return `${normalizePseudoSelector(selector)} { ${acc} }`;
      }, cssDeclaration);
    }
    return `${classNameSelector}{${cssRule}}`;
  }
  function compileAtomicCSSRule(options, atRules) {
    const {
      className,
      selectors,
      property,
      rtlClassName,
      rtlProperty,
      rtlValue,
      value
    } = options;
    const {
      container: container2,
      layer,
      media,
      supports
    } = atRules;
    const classNameSelector = `.${className}`;
    const cssDeclaration = Array.isArray(value) ? `${value.map((v) => `${hyphenateProperty(property)}: ${v}`).join(";")};` : `${hyphenateProperty(property)}: ${value};`;
    let cssRule = createCSSRule(classNameSelector, cssDeclaration, selectors);
    if (rtlProperty && rtlClassName) {
      const rtlClassNameSelector = `.${rtlClassName}`;
      const rtlCSSDeclaration = Array.isArray(rtlValue) ? `${rtlValue.map((v) => `${hyphenateProperty(rtlProperty)}: ${v}`).join(";")};` : `${hyphenateProperty(rtlProperty)}: ${rtlValue};`;
      cssRule += createCSSRule(rtlClassNameSelector, rtlCSSDeclaration, selectors);
    }
    if (media) {
      cssRule = `@media ${media} { ${cssRule} }`;
    }
    if (layer) {
      cssRule = `@layer ${layer} { ${cssRule} }`;
    }
    if (supports) {
      cssRule = `@supports ${supports} { ${cssRule} }`;
    }
    if (container2) {
      cssRule = `@container ${container2} { ${cssRule} }`;
    }
    return compileCSSRules(cssRule, true);
  }

  // ../../node_modules/@griffel/core/runtime/compileKeyframeCSS.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/utils/cssifyObject.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function cssifyObject(style) {
    let css = "";
    for (const property in style) {
      const value = style[property];
      if (typeof value === "string" || typeof value === "number") {
        css += hyphenateProperty(property) + ":" + value + ";";
        continue;
      }
      if (Array.isArray(value)) {
        for (const arrValue of value) {
          css += hyphenateProperty(property) + ":" + arrValue + ";";
        }
      }
    }
    return css;
  }

  // ../../node_modules/@griffel/core/runtime/compileKeyframeCSS.esm.js
  function compileKeyframeRule(keyframeObject) {
    let css = "";
    for (const percentage in keyframeObject) {
      css += `${percentage}{${cssifyObject(keyframeObject[percentage])}}`;
    }
    return css;
  }
  function compileKeyframesCSS(keyframeName, keyframeCSS) {
    const cssRule = `@keyframes ${keyframeName} {${keyframeCSS}}`;
    const rules = [];
    serialize4(compile(cssRule), middleware([
      stringify3,
      prefixerPlugin,
      // 💡 we are using `.insertRule()` API for DOM operations, which does not support
      // insertion of multiple CSS rules in a single call. `rulesheet` plugin extracts
      // individual rules to be used with this API
      rulesheet((rule) => rules.push(rule))
    ]));
    return rules;
  }

  // ../../node_modules/@griffel/core/runtime/shorthands.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var shorthands = {
    animation: [-1, ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimeline", "animationTimingFunction"]],
    animationRange: [-1, ["animationRangeEnd", "animationRangeStart"]],
    background: [-2, ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPosition", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"]],
    backgroundPosition: [-1, ["backgroundPositionX", "backgroundPositionY"]],
    border: [-2, ["borderBottom", "borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderLeft", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRight", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTop", "borderTopColor", "borderTopStyle", "borderTopWidth"]],
    borderBottom: [-1, ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"]],
    borderImage: [-1, ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"]],
    borderLeft: [-1, ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"]],
    borderRadius: [-1, ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"]],
    borderRight: [-1, ["borderRightColor", "borderRightStyle", "borderRightWidth"]],
    borderTop: [-1, ["borderTopColor", "borderTopStyle", "borderTopWidth"]],
    caret: [-1, ["caretColor", "caretShape"]],
    columnRule: [-1, ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"]],
    columns: [-1, ["columnCount", "columnWidth"]],
    containIntrinsicSize: [-1, ["containIntrinsicHeight", "containIntrinsicWidth"]],
    container: [-1, ["containerName", "containerType"]],
    flex: [-1, ["flexBasis", "flexGrow", "flexShrink"]],
    flexFlow: [-1, ["flexDirection", "flexWrap"]],
    font: [-1, ["fontFamily", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "lineHeight"]],
    gap: [-1, ["columnGap", "rowGap"]],
    grid: [-1, ["columnGap", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridColumnGap", "gridRowGap", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows", "rowGap"]],
    gridArea: [-1, ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"]],
    gridColumn: [-1, ["gridColumnEnd", "gridColumnStart"]],
    gridRow: [-1, ["gridRowEnd", "gridRowStart"]],
    gridTemplate: [-1, ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"]],
    inset: [-1, ["bottom", "left", "right", "top"]],
    insetBlock: [-1, ["insetBlockEnd", "insetBlockStart"]],
    insetInline: [-1, ["insetInlineEnd", "insetInlineStart"]],
    listStyle: [-1, ["listStyleImage", "listStylePosition", "listStyleType"]],
    margin: [-1, ["marginBottom", "marginLeft", "marginRight", "marginTop"]],
    marginBlock: [-1, ["marginBlockEnd", "marginBlockStart"]],
    marginInline: [-1, ["marginInlineEnd", "marginInlineStart"]],
    mask: [-1, ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPosition", "maskRepeat", "maskSize"]],
    maskBorder: [-1, ["maskBorderMode", "maskBorderOutset", "maskBorderRepeat", "maskBorderSlice", "maskBorderSource", "maskBorderWidth"]],
    offset: [-1, ["offsetAnchor", "offsetDistance", "offsetPath", "offsetPosition", "offsetRotate"]],
    outline: [-1, ["outlineColor", "outlineStyle", "outlineWidth"]],
    overflow: [-1, ["overflowX", "overflowY"]],
    overscrollBehavior: [-1, ["overscrollBehaviorX", "overscrollBehaviorY"]],
    padding: [-1, ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"]],
    paddingBlock: [-1, ["paddingBlockEnd", "paddingBlockStart"]],
    paddingInline: [-1, ["paddingInlineEnd", "paddingInlineStart"]],
    placeContent: [-1, ["alignContent", "justifyContent"]],
    placeItems: [-1, ["alignItems", "justifyItems"]],
    placeSelf: [-1, ["alignSelf", "justifySelf"]],
    scrollMargin: [-1, ["scrollMarginBottom", "scrollMarginLeft", "scrollMarginRight", "scrollMarginTop"]],
    scrollMarginBlock: [-1, ["scrollMarginBlockEnd", "scrollMarginBlockStart"]],
    scrollMarginInline: [-1, ["scrollMarginInlineEnd", "scrollMarginInlineStart"]],
    scrollPadding: [-1, ["scrollPaddingBottom", "scrollPaddingLeft", "scrollPaddingRight", "scrollPaddingTop"]],
    scrollPaddingBlock: [-1, ["scrollPaddingBlockEnd", "scrollPaddingBlockStart"]],
    scrollPaddingInline: [-1, ["scrollPaddingInlineEnd", "scrollPaddingInlineStart"]],
    scrollTimeline: [-1, ["scrollTimelineAxis", "scrollTimelineName"]],
    textDecoration: [-1, ["textDecorationColor", "textDecorationLine", "textDecorationStyle", "textDecorationThickness"]],
    textEmphasis: [-1, ["textEmphasisColor", "textEmphasisStyle"]],
    transition: [-1, ["transitionBehavior", "transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"]],
    viewTimeline: [-1, ["viewTimelineAxis", "viewTimelineName"]]
  };

  // ../../node_modules/@griffel/core/runtime/utils/generateCombinedMediaQuery.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function generateCombinedQuery(currentMediaQuery, nestedMediaQuery) {
    if (currentMediaQuery.length === 0) {
      return nestedMediaQuery;
    }
    return `${currentMediaQuery} and ${nestedMediaQuery}`;
  }

  // ../../node_modules/@griffel/core/runtime/utils/isMediaQuerySelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isMediaQuerySelector(property) {
    return property.substr(0, 6) === "@media";
  }

  // ../../node_modules/@griffel/core/runtime/utils/isLayerSelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isLayerSelector(property) {
    return property.substr(0, 6) === "@layer";
  }

  // ../../node_modules/@griffel/core/runtime/utils/isNestedSelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var regex = /^(:|\[|>|&)/;
  function isNestedSelector(property) {
    return regex.test(property);
  }

  // ../../node_modules/@griffel/core/runtime/utils/isSupportQuerySelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isSupportQuerySelector(property) {
    return property.substr(0, 9) === "@supports";
  }

  // ../../node_modules/@griffel/core/runtime/utils/isContainerQuerySelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isContainerQuerySelector(property) {
    return property.substring(0, 10) === "@container";
  }

  // ../../node_modules/@griffel/core/runtime/utils/isObject.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isObject2(val) {
    return val != null && typeof val === "object" && Array.isArray(val) === false;
  }

  // ../../node_modules/@griffel/core/runtime/getStyleBucketName.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var pseudosMap = {
    // :focus-within
    "us-w": "w",
    // :focus-visible
    "us-v": "i",
    // :link
    nk: "l",
    // :visited
    si: "v",
    // :focus
    cu: "f",
    // :hover
    ve: "h",
    // :active
    ti: "a"
  };
  function getStyleBucketName(selectors, atRules) {
    if (atRules.media) {
      return "m";
    }
    if (atRules.layer || atRules.supports) {
      return "t";
    }
    if (atRules.container) {
      return "c";
    }
    if (selectors.length > 0) {
      const normalizedPseudo = selectors[0].trim();
      if (normalizedPseudo.charCodeAt(0) === 58) {
        return pseudosMap[normalizedPseudo.slice(4, 8)] || pseudosMap[normalizedPseudo.slice(3, 5)] || "d";
      }
    }
    return "d";
  }

  // ../../node_modules/@griffel/core/runtime/utils/hashClassName.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/utils/hashPropertyKey.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function addAtRulePrefix(atRule, prefix2) {
    return atRule ? prefix2 + atRule : atRule;
  }
  function atRulesToString(atRules) {
    return addAtRulePrefix(atRules.container, "c") + addAtRulePrefix(atRules.media, "m") + addAtRulePrefix(atRules.layer, "l") + addAtRulePrefix(atRules.supports, "s");
  }
  function hashPropertyKey(selector, property, atRules) {
    const computedKey = selector + atRulesToString(atRules) + property;
    const hashedKey = murmur2(computedKey);
    const firstCharCode = hashedKey.charCodeAt(0);
    const startsWithNumber = firstCharCode >= 48 && firstCharCode <= 57;
    if (startsWithNumber) {
      return String.fromCharCode(firstCharCode + 17) + hashedKey.slice(1);
    }
    return hashedKey;
  }

  // ../../node_modules/@griffel/core/runtime/utils/hashClassName.esm.js
  function hashClassName({
    property,
    selector,
    salt,
    value
  }, atRules) {
    return HASH_PREFIX + murmur2(salt + selector + atRulesToString(atRules) + property + // Trimming of value is required to generate consistent hashes
    value.trim());
  }

  // ../../node_modules/@griffel/core/runtime/utils/isResetValue.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isResetValue(value) {
    return value === RESET;
  }

  // ../../node_modules/@griffel/core/runtime/utils/trimSelector.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function trimSelector(selector) {
    return selector.replace(/>\s+/g, ">");
  }

  // ../../node_modules/@griffel/core/runtime/warnings/warnAboutUnresolvedRule.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/core/runtime/warnings/logError.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function logError(...args) {
    if (false) {
      console.error(...args);
    }
  }

  // ../../node_modules/@griffel/core/runtime/warnings/warnAboutUnresolvedRule.esm.js
  function warnAboutUnresolvedRule(property, value) {
    const message = /* @__PURE__ */ (() => {
      const ruleText = JSON.stringify(value, null, 2);
      const message2 = ["@griffel/react: A rule was not resolved to CSS properly. Please check your `makeStyles` or `makeResetStyles` calls for following:", " ".repeat(2) + "makeStyles({", " ".repeat(4) + `[slot]: {`, " ".repeat(6) + `"${property}": ${ruleText.split("\n").map((l, n) => " ".repeat(n === 0 ? 0 : 6) + l).join("\n")}`, " ".repeat(4) + "}", " ".repeat(2) + `})`, ""];
      if (property.indexOf("&") === -1) {
        message2.push(`It looks that you're are using a nested selector, but it is missing an ampersand placeholder where the generated class name should be injected.`);
        message2.push(`Try to update a property to include it i.e "${property}" => "&${property}".`);
      } else {
        message2.push("");
        message2.push("If it's not obvious what triggers a problem, please report an issue at https://github.com/microsoft/griffel/issues");
      }
      return message2.join("\n");
    })();
    logError(message);
  }

  // ../../node_modules/@griffel/core/runtime/warnings/warnAboutUnsupportedProperties.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function warnAboutUnsupportedProperties(property, value) {
    const message = /* @__PURE__ */ (() => [`@griffel/react: You are using unsupported shorthand CSS property "${property}". Please check your "makeStyles" calls, there *should not* be following:`, " ".repeat(2) + `makeStyles({`, " ".repeat(4) + `[slot]: { ${property}: "${value}" }`, " ".repeat(2) + `})`, "", "Learn why CSS shorthands are not supported: https://aka.ms/griffel-css-shorthands"].join("\n"))();
    logError(message);
  }

  // ../../node_modules/@griffel/core/runtime/resolveStyleRules.esm.js
  function getShorthandDefinition(property) {
    return shorthands[property];
  }
  function computePropertyPriority(shorthand) {
    var _a17;
    return (_a17 = shorthand === null || shorthand === void 0 ? void 0 : shorthand[0]) !== null && _a17 !== void 0 ? _a17 : 0;
  }
  function pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {
    classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;
  }
  function createBucketEntry(cssRule, metadata) {
    if (metadata.length > 0) {
      return [cssRule, Object.fromEntries(metadata)];
    }
    return cssRule;
  }
  function pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media, priority) {
    var _a17;
    const metadata = [];
    if (priority !== 0) {
      metadata.push(["p", priority]);
    }
    if (styleBucketName === "m" && media) {
      metadata.push(["m", media]);
    }
    (_a17 = cssRulesByBucket[styleBucketName]) !== null && _a17 !== void 0 ? _a17 : cssRulesByBucket[styleBucketName] = [];
    if (ltrCSS) {
      cssRulesByBucket[styleBucketName].push(createBucketEntry(ltrCSS, metadata));
    }
    if (rtlCSS) {
      cssRulesByBucket[styleBucketName].push(createBucketEntry(rtlCSS, metadata));
    }
  }
  function resolveStyleRules(styles, classNameHashSalt = "", selectors = [], atRules = {
    container: "",
    layer: "",
    media: "",
    supports: ""
  }, cssClassesMap = {}, cssRulesByBucket = {}, rtlValue) {
    for (const property in styles) {
      if (UNSUPPORTED_CSS_PROPERTIES.hasOwnProperty(property)) {
        warnAboutUnsupportedProperties(property, styles[property]);
        continue;
      }
      const value = styles[property];
      if (value == null) {
        continue;
      }
      if (isResetValue(value)) {
        const selector = trimSelector(selectors.join(""));
        const key = hashPropertyKey(selector, property, atRules);
        pushToClassesMap(cssClassesMap, key, 0, void 0);
        continue;
      }
      if (typeof value === "string" || typeof value === "number") {
        const selector = trimSelector(selectors.join(""));
        const shorthand = getShorthandDefinition(property);
        if (shorthand) {
          const shorthandProperties = shorthand[1];
          const shorthandResetStyles = Object.fromEntries(shorthandProperties.map((property2) => [property2, RESET]));
          resolveStyleRules(shorthandResetStyles, classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket);
        }
        const key = hashPropertyKey(selector, property, atRules);
        const className = hashClassName({
          value: value.toString(),
          salt: classNameHashSalt,
          selector,
          property
        }, atRules);
        const rtlDefinition = rtlValue && {
          key: property,
          value: rtlValue
        } || convertProperty(property, value);
        const flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;
        const rtlClassName = flippedInRtl ? hashClassName({
          value: rtlDefinition.value.toString(),
          property: rtlDefinition.key,
          salt: classNameHashSalt,
          selector
        }, atRules) : void 0;
        const rtlCompileOptions = flippedInRtl ? {
          rtlClassName,
          rtlProperty: rtlDefinition.key,
          rtlValue: rtlDefinition.value
        } : void 0;
        const styleBucketName = getStyleBucketName(selectors, atRules);
        const [ltrCSS, rtlCSS] = compileAtomicCSSRule(Object.assign({
          className,
          selectors,
          property,
          value
        }, rtlCompileOptions), atRules);
        pushToClassesMap(cssClassesMap, key, className, rtlClassName);
        pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, atRules.media, computePropertyPriority(shorthand));
      } else if (property === "animationName") {
        const animationNameValue = Array.isArray(value) ? value : [value];
        const animationNames = [];
        const rtlAnimationNames = [];
        for (const keyframeObject of animationNameValue) {
          const keyframeCSS = compileKeyframeRule(keyframeObject);
          const rtlKeyframeCSS = compileKeyframeRule(convert2(keyframeObject));
          const animationName = HASH_PREFIX + murmur2(keyframeCSS);
          let rtlAnimationName;
          const keyframeRules = compileKeyframesCSS(animationName, keyframeCSS);
          let rtlKeyframeRules = [];
          if (keyframeCSS === rtlKeyframeCSS) {
            rtlAnimationName = animationName;
          } else {
            rtlAnimationName = HASH_PREFIX + murmur2(rtlKeyframeCSS);
            rtlKeyframeRules = compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);
          }
          for (let i = 0; i < keyframeRules.length; i++) {
            pushToCSSRules(
              cssRulesByBucket,
              // keyframes styles should be inserted into own bucket
              "k",
              keyframeRules[i],
              rtlKeyframeRules[i],
              atRules.media,
              // keyframes always have default priority
              0
            );
          }
          animationNames.push(animationName);
          rtlAnimationNames.push(rtlAnimationName);
        }
        resolveStyleRules({
          animationName: animationNames.join(", ")
        }, classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket, rtlAnimationNames.join(", "));
      } else if (Array.isArray(value)) {
        if (value.length === 0) {
          if (false) {
            console.warn(`makeStyles(): An empty array was passed as input to "${property}", the property will be omitted in the styles.`);
          }
          continue;
        }
        const selector = trimSelector(selectors.join(""));
        const shorthand = getShorthandDefinition(property);
        if (shorthand) {
          const shorthandProperties = shorthand[1];
          const shorthandResetStyles = Object.fromEntries(shorthandProperties.map((property2) => [property2, RESET]));
          resolveStyleRules(shorthandResetStyles, classNameHashSalt, selectors, atRules, cssClassesMap, cssRulesByBucket);
        }
        const key = hashPropertyKey(selector, property, atRules);
        const className = hashClassName({
          value: value.map((v) => (v !== null && v !== void 0 ? v : "").toString()).join(";"),
          salt: classNameHashSalt,
          selector,
          property
        }, atRules);
        const rtlDefinitions = value.map((v) => convertProperty(property, v));
        const rtlPropertyConsistent = !rtlDefinitions.some((v) => v.key !== rtlDefinitions[0].key);
        if (!rtlPropertyConsistent) {
          if (false) {
            console.error("makeStyles(): mixing CSS fallback values which result in multiple CSS properties in RTL is not supported.");
          }
          continue;
        }
        const flippedInRtl = rtlDefinitions[0].key !== property || rtlDefinitions.some((v, i) => v.value !== value[i]);
        const rtlClassName = flippedInRtl ? hashClassName({
          value: rtlDefinitions.map((v) => {
            var _a17;
            return ((_a17 = v === null || v === void 0 ? void 0 : v.value) !== null && _a17 !== void 0 ? _a17 : "").toString();
          }).join(";"),
          salt: classNameHashSalt,
          property: rtlDefinitions[0].key,
          selector
        }, atRules) : void 0;
        const rtlCompileOptions = flippedInRtl ? {
          rtlClassName,
          rtlProperty: rtlDefinitions[0].key,
          rtlValue: rtlDefinitions.map((d) => d.value)
        } : void 0;
        const styleBucketName = getStyleBucketName(selectors, atRules);
        const [ltrCSS, rtlCSS] = compileAtomicCSSRule(Object.assign({
          className,
          selectors,
          property,
          value
        }, rtlCompileOptions), atRules);
        pushToClassesMap(cssClassesMap, key, className, rtlClassName);
        pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, atRules.media, computePropertyPriority(shorthand));
      } else if (isObject2(value)) {
        if (isNestedSelector(property)) {
          resolveStyleRules(value, classNameHashSalt, selectors.concat(normalizeNestedProperty(property)), atRules, cssClassesMap, cssRulesByBucket);
        } else if (isMediaQuerySelector(property)) {
          const combinedMediaQuery = generateCombinedQuery(atRules.media, property.slice(6).trim());
          resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, {
            media: combinedMediaQuery
          }), cssClassesMap, cssRulesByBucket);
        } else if (isLayerSelector(property)) {
          const combinedLayerQuery = (atRules.layer ? `${atRules.layer}.` : "") + property.slice(6).trim();
          resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, {
            layer: combinedLayerQuery
          }), cssClassesMap, cssRulesByBucket);
        } else if (isSupportQuerySelector(property)) {
          const combinedSupportQuery = generateCombinedQuery(atRules.supports, property.slice(9).trim());
          resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, {
            supports: combinedSupportQuery
          }), cssClassesMap, cssRulesByBucket);
        } else if (isContainerQuerySelector(property)) {
          const containerQuery = property.slice(10).trim();
          resolveStyleRules(value, classNameHashSalt, selectors, Object.assign({}, atRules, {
            container: containerQuery
          }), cssClassesMap, cssRulesByBucket);
        } else {
          warnAboutUnresolvedRule(property, value);
        }
      }
    }
    return [cssClassesMap, cssRulesByBucket];
  }

  // ../../node_modules/@griffel/core/resolveStyleRulesForSlots.esm.js
  function resolveStyleRulesForSlots(stylesBySlots, classNameHashSalt = "") {
    const classesMapBySlot = {};
    const cssRules = {};
    for (const slotName in stylesBySlots) {
      const slotStyles = stylesBySlots[slotName];
      const [cssClassMap, cssRulesByBucket] = resolveStyleRules(slotStyles, classNameHashSalt);
      classesMapBySlot[slotName] = cssClassMap;
      Object.keys(cssRulesByBucket).forEach((styleBucketName) => {
        cssRules[styleBucketName] = (cssRules[styleBucketName] || []).concat(cssRulesByBucket[styleBucketName]);
      });
    }
    return [classesMapBySlot, cssRules];
  }

  // ../../node_modules/@griffel/core/makeStyles.esm.js
  function makeStyles(stylesBySlots, factory = insertionFactory) {
    const insertStyles = factory();
    let classesMapBySlot = null;
    let cssRules = null;
    let ltrClassNamesForSlots = null;
    let rtlClassNamesForSlots = null;
    let sourceURL;
    if (false) {
      sourceURL = getSourceURLfromError();
    }
    let classNameHashSalt;
    function computeClasses(options) {
      const {
        dir,
        renderer
      } = options;
      if (classesMapBySlot === null) {
        [classesMapBySlot, cssRules] = resolveStyleRulesForSlots(stylesBySlots, renderer.classNameHashSalt);
        if (false) {
          if (renderer.classNameHashSalt) {
            if (classNameHashSalt !== renderer.classNameHashSalt) {
              console.error(["@griffel/core:", "\n\n", 'A provided renderer has different "classNameHashSalt".', "This is not supported and WILL cause issues with classnames generation.", 'Ensure that all renderers created with "createDOMRenderer()" have the same "classNameHashSalt".'].join(" "));
            }
            classNameHashSalt = renderer.classNameHashSalt;
          }
        }
      }
      const isLTR = dir === "ltr";
      if (isLTR) {
        if (ltrClassNamesForSlots === null) {
          ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      } else {
        if (rtlClassNamesForSlots === null) {
          rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      }
      insertStyles(renderer, cssRules);
      const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
      if (false) {
        debugData.addSequenceDetails(classNamesForSlots, sourceURL);
      }
      return classNamesForSlots;
    }
    return computeClasses;
  }

  // ../../node_modules/@griffel/core/__styles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function __styles(classesMapBySlot, cssRules, factory = insertionFactory) {
    const insertStyles = factory();
    let ltrClassNamesForSlots = null;
    let rtlClassNamesForSlots = null;
    let sourceURL;
    if (false) {
      sourceURL = getSourceURLfromError();
    }
    function computeClasses(options) {
      const {
        dir,
        renderer
      } = options;
      const isLTR = dir === "ltr";
      if (isLTR) {
        if (ltrClassNamesForSlots === null) {
          ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      } else {
        if (rtlClassNamesForSlots === null) {
          rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
        }
      }
      insertStyles(renderer, cssRules);
      const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
      if (false) {
        debugData.addSequenceDetails(classNamesForSlots, sourceURL);
      }
      return classNamesForSlots;
    }
    return computeClasses;
  }

  // ../../node_modules/@griffel/core/__resetStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function __resetStyles(ltrClassName, rtlClassName, cssRules, factory = insertionFactory) {
    const insertStyles = factory();
    function computeClassName(options) {
      const {
        dir,
        renderer
      } = options;
      const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
      insertStyles(renderer, Array.isArray(cssRules) ? {
        r: cssRules
      } : cssRules);
      if (false) {
        DEBUG_RESET_CLASSES[className] = 1;
      }
      return className;
    }
    return computeClassName;
  }

  // ../../node_modules/@griffel/core/index.esm.js
  var shorthands2 = {
    border,
    borderLeft,
    borderBottom,
    borderRight,
    borderTop,
    borderColor,
    borderStyle,
    borderRadius,
    borderWidth,
    flex,
    gap,
    gridArea,
    margin,
    marginBlock,
    marginInline,
    padding,
    paddingBlock,
    paddingInline,
    overflow,
    inset,
    outline,
    transition,
    textDecoration
  };

  // ../../node_modules/@griffel/react/makeStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/react/insertionFactory.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@griffel/react/utils/canUseDOM.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function canUseDOM() {
    return typeof window !== "undefined" && !!(window.document && window.document.createElement);
  }

  // ../../node_modules/@griffel/react/useInsertionEffect.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React15 = __toESM(require_react());
  var useInsertionEffect2 = (
    // @ts-expect-error Hack to make sure that `useInsertionEffect` will not cause bundling issues in older React versions
    // eslint-disable-next-line no-useless-concat
    React15["useInsertionEffect"] ? React15["useInsertionEffect"] : void 0
  );

  // ../../node_modules/@griffel/react/insertionFactory.esm.js
  var insertionFactory2 = () => {
    const insertionCache = {};
    return function insert(renderer, cssRules) {
      if (useInsertionEffect2 && canUseDOM()) {
        useInsertionEffect2(() => {
          renderer.insertCSSRules(cssRules);
        }, [renderer, cssRules]);
        return;
      }
      if (insertionCache[renderer.id] === void 0) {
        renderer.insertCSSRules(cssRules);
        insertionCache[renderer.id] = true;
      }
    };
  };

  // ../../node_modules/@griffel/react/RendererContext.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React16 = __toESM(require_react());
  var RendererContext = /* @__PURE__ */ React16.createContext(/* @__PURE__ */ createDOMRenderer());
  function useRenderer() {
    return React16.useContext(RendererContext);
  }

  // ../../node_modules/@griffel/react/TextDirectionContext.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React17 = __toESM(require_react());
  var TextDirectionContext = /* @__PURE__ */ React17.createContext("ltr");
  var TextDirectionProvider = ({
    children: children2,
    dir
  }) => {
    return /* @__PURE__ */ React17.createElement(TextDirectionContext.Provider, {
      value: dir
    }, children2);
  };
  function useTextDirection() {
    return React17.useContext(TextDirectionContext);
  }

  // ../../node_modules/@griffel/react/makeStyles.esm.js
  function makeStyles2(stylesBySlots) {
    const getStyles = makeStyles(stylesBySlots, insertionFactory2);
    if (false) {
      if (isInsideComponent()) {
        throw new Error(["makeStyles(): this function cannot be called in component's scope.", "All makeStyles() calls should be top level i.e. in a root scope of a file."].join(" "));
      }
    }
    return function useClasses() {
      const dir = useTextDirection();
      const renderer = useRenderer();
      return getStyles({
        dir,
        renderer
      });
    };
  }

  // ../../node_modules/@griffel/react/__styles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function __styles2(classesMapBySlot, cssRules) {
    const getStyles = __styles(classesMapBySlot, cssRules, insertionFactory2);
    return function useClasses() {
      const dir = useTextDirection();
      const renderer = useRenderer();
      return getStyles({
        dir,
        renderer
      });
    };
  }

  // ../../node_modules/@griffel/react/__resetStyles.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function __resetStyles2(ltrClassName, rtlClassName, cssRules) {
    const getStyles = __resetStyles(ltrClassName, rtlClassName, cssRules, insertionFactory2);
    return function useClasses() {
      const dir = useTextDirection();
      const renderer = useRenderer();
      return getStyles({
        dir,
        renderer
      });
    };
  }

  // ../../node_modules/@fluentui/react-provider/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-provider/lib/FluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/createCSSRuleFromTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createCSSRuleFromTheme(selector, theme) {
    if (theme) {
      const cssVarsAsString = Object.keys(theme).reduce((cssVarRule, cssVar) => {
        return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
      }, "");
      return `${selector} { ${cssVarsAsString} }`;
    }
    return `${selector} {}`;
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React60 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/compose/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/compose/slot.js
  var slot_exports = {};
  __export(slot_exports, {
    always: () => always,
    optional: () => optional,
    resolveShorthand: () => resolveShorthand
  });
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React18 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/compose/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SLOT_RENDER_FUNCTION_SYMBOL = Symbol.for("fui.slotRenderFunction");
  var SLOT_ELEMENT_TYPE_SYMBOL = Symbol.for("fui.slotElementType");
  var SLOT_CLASS_NAME_PROP_SYMBOL = Symbol.for("fui.slotClassNameProp");

  // ../../node_modules/@fluentui/react-utilities/lib/compose/slot.js
  function always(value, options) {
    const { defaultProps, elementType } = options;
    const props = resolveShorthand(value);
    const propsWithMetadata = {
      ...defaultProps,
      ...props,
      [SLOT_ELEMENT_TYPE_SYMBOL]: elementType,
      [SLOT_CLASS_NAME_PROP_SYMBOL]: props === null || props === void 0 ? void 0 : props.className
    };
    if (props && typeof props.children === "function") {
      propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
      propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
    }
    return propsWithMetadata;
  }
  function optional(value, options) {
    if (value === null || value === void 0 && !options.renderByDefault) {
      return void 0;
    }
    return always(value, options);
  }
  function resolveShorthand(value) {
    if (typeof value === "string" || typeof value === "number" || Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    React18.isValidElement(value)) {
      return {
        children: value
      };
    }
    if (value && typeof value !== "object" && false) {
      console.error(`@fluentui/react-utilities [slot.${resolveShorthand.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
    }
    return value;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React19 = __toESM(require_react());
  function isResolvedShorthand(shorthand) {
    return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !React19.isValidElement(shorthand);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isSlot(element4) {
    return Boolean(element4 === null || element4 === void 0 ? void 0 : element4.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React20 = __toESM(require_react());
  function assertSlots(state) {
    if (false) {
      const typedState = state;
      for (const slotName of Object.keys(typedState.components)) {
        const slotElement = typedState[slotName];
        if (slotElement === void 0) {
          continue;
        }
        if (!isSlot(slotElement)) {
          typedState[slotName] = always(slotElement, {
            elementType: typedState.components[slotName]
          });
          console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
        } else {
          const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
          if (elementType !== typedState.components[slotName]) {
            slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
            console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
          }
        }
      }
    }
  }

  // ../../node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React22 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React21 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/utils/properties.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var toObjectMap = (...items) => {
    const result = {};
    for (const item of items) {
      const keys2 = Array.isArray(item) ? item : Object.keys(item);
      for (const key of keys2) {
        result[key] = 1;
      }
    }
    return result;
  };
  var baseElementEvents = toObjectMap([
    "onAuxClick",
    "onAnimationEnd",
    "onAnimationStart",
    "onCopy",
    "onCut",
    "onPaste",
    "onCompositionEnd",
    "onCompositionStart",
    "onCompositionUpdate",
    "onFocus",
    "onFocusCapture",
    "onBlur",
    "onBlurCapture",
    "onChange",
    "onInput",
    "onSubmit",
    "onLoad",
    "onError",
    "onKeyDown",
    "onKeyDownCapture",
    "onKeyPress",
    "onKeyUp",
    "onAbort",
    "onCanPlay",
    "onCanPlayThrough",
    "onDurationChange",
    "onEmptied",
    "onEncrypted",
    "onEnded",
    "onLoadedData",
    "onLoadedMetadata",
    "onLoadStart",
    "onPause",
    "onPlay",
    "onPlaying",
    "onProgress",
    "onRateChange",
    "onSeeked",
    "onSeeking",
    "onStalled",
    "onSuspend",
    "onTimeUpdate",
    "onVolumeChange",
    "onWaiting",
    "onClick",
    "onClickCapture",
    "onContextMenu",
    "onDoubleClick",
    "onDrag",
    "onDragEnd",
    "onDragEnter",
    "onDragExit",
    "onDragLeave",
    "onDragOver",
    "onDragStart",
    "onDrop",
    "onMouseDown",
    "onMouseDownCapture",
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onMouseOut",
    "onMouseOver",
    "onMouseUp",
    "onMouseUpCapture",
    "onSelect",
    "onTouchCancel",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "onScroll",
    "onWheel",
    "onPointerCancel",
    "onPointerDown",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerMove",
    "onPointerOut",
    "onPointerOver",
    "onPointerUp",
    "onGotPointerCapture",
    "onLostPointerCapture"
  ]);
  var baseElementProperties = toObjectMap([
    "accessKey",
    "children",
    "className",
    "contentEditable",
    "dir",
    "draggable",
    "hidden",
    "htmlFor",
    "id",
    "lang",
    "ref",
    "role",
    "style",
    "tabIndex",
    "title",
    "translate",
    "spellCheck",
    "name"
  ]);
  var microdataProperties = toObjectMap([
    "itemID",
    "itemProp",
    "itemRef",
    "itemScope",
    "itemType"
  ]);
  var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
  var labelProperties = toObjectMap(htmlElementProperties, [
    "form"
  ]);
  var audioProperties = toObjectMap(htmlElementProperties, [
    "height",
    "loop",
    "muted",
    "preload",
    "src",
    "width"
  ]);
  var videoProperties = toObjectMap(audioProperties, [
    "poster"
  ]);
  var olProperties = toObjectMap(htmlElementProperties, [
    "start"
  ]);
  var liProperties = toObjectMap(htmlElementProperties, [
    "value"
  ]);
  var anchorProperties = toObjectMap(htmlElementProperties, [
    "download",
    "href",
    "hrefLang",
    "media",
    "rel",
    "target",
    "type"
  ]);
  var timeProperties = toObjectMap(htmlElementProperties, [
    "dateTime"
  ]);
  var buttonProperties = toObjectMap(htmlElementProperties, [
    "autoFocus",
    "disabled",
    "form",
    "formAction",
    "formEncType",
    "formMethod",
    "formNoValidate",
    "formTarget",
    "type",
    "value"
  ]);
  var inputProperties = toObjectMap(buttonProperties, [
    "accept",
    "alt",
    "autoCorrect",
    "autoCapitalize",
    "autoComplete",
    "checked",
    "dirname",
    "form",
    "height",
    "inputMode",
    "list",
    "max",
    "maxLength",
    "min",
    "minLength",
    "multiple",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "src",
    "step",
    "size",
    "type",
    "value",
    "width"
  ]);
  var textAreaProperties = toObjectMap(buttonProperties, [
    "autoCapitalize",
    "cols",
    "dirname",
    "form",
    "maxLength",
    "placeholder",
    "readOnly",
    "required",
    "rows",
    "wrap"
  ]);
  var selectProperties = toObjectMap(buttonProperties, [
    "form",
    "multiple",
    "required"
  ]);
  var optionProperties = toObjectMap(htmlElementProperties, [
    "selected",
    "value"
  ]);
  var tableProperties = toObjectMap(htmlElementProperties, [
    "cellPadding",
    "cellSpacing"
  ]);
  var trProperties = htmlElementProperties;
  var thProperties = toObjectMap(htmlElementProperties, [
    "colSpan",
    "rowSpan",
    "scope"
  ]);
  var tdProperties = toObjectMap(htmlElementProperties, [
    "colSpan",
    "headers",
    "rowSpan",
    "scope"
  ]);
  var colGroupProperties = toObjectMap(htmlElementProperties, [
    "span"
  ]);
  var colProperties = toObjectMap(htmlElementProperties, [
    "span"
  ]);
  var fieldsetProperties = toObjectMap(htmlElementProperties, [
    "disabled",
    "form"
  ]);
  var formProperties = toObjectMap(htmlElementProperties, [
    "acceptCharset",
    "action",
    "encType",
    "encType",
    "method",
    "noValidate",
    "target"
  ]);
  var iframeProperties = toObjectMap(htmlElementProperties, [
    "allow",
    "allowFullScreen",
    "allowPaymentRequest",
    "allowTransparency",
    "csp",
    "height",
    "importance",
    "referrerPolicy",
    "sandbox",
    "src",
    "srcDoc",
    "width"
  ]);
  var imgProperties = toObjectMap(htmlElementProperties, [
    "alt",
    "crossOrigin",
    "height",
    "src",
    "srcSet",
    "useMap",
    "width"
  ]);
  var dialogProperties = toObjectMap(htmlElementProperties, [
    "open",
    "onCancel",
    "onClose"
  ]);
  function getNativeProps(props, allowedPropNames, excludedPropNames) {
    const isArray = Array.isArray(allowedPropNames);
    const result = {};
    const keys2 = Object.keys(props);
    for (const key of keys2) {
      const isNativeProp = !isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
      if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
        result[key] = props[key];
      }
    }
    return result;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
  var nativeElementMap = {
    label: labelProperties,
    audio: audioProperties,
    video: videoProperties,
    ol: olProperties,
    li: liProperties,
    a: anchorProperties,
    button: buttonProperties,
    input: inputProperties,
    textarea: textAreaProperties,
    select: selectProperties,
    option: optionProperties,
    table: tableProperties,
    tr: trProperties,
    th: thProperties,
    td: tdProperties,
    colGroup: colGroupProperties,
    col: colProperties,
    fieldset: fieldsetProperties,
    form: formProperties,
    iframe: iframeProperties,
    img: imgProperties,
    time: timeProperties,
    dialog: dialogProperties
  };
  function getNativeElementProps(tagName, props, excludedPropNames) {
    const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
    allowedPropNames.as = 1;
    return getNativeProps(props, allowedPropNames, excludedPropNames);
  }
  var getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
    return {
      root: {
        style: props.style,
        className: props.className
      },
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      primary: getNativeElementProps(primarySlotTagName, props, [
        ...excludedPropNames || [],
        "style",
        "className"
      ])
    };
  };

  // ../../node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
  var getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
    var _props_as;
    return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
  };

  // ../../node_modules/@fluentui/react-utilities/lib/utils/omit.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function omit(obj, exclusions) {
    const result = {};
    for (const key in obj) {
      if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React23 = __toESM(require_react());
  function useBrowserTimer(setTimer, cancelTimer) {
    const id = React23.useRef(void 0);
    const set = React23.useCallback((fn, delay2) => {
      if (id.current !== void 0) {
        cancelTimer(id.current);
      }
      id.current = setTimer(fn, delay2);
      return id.current;
    }, [
      cancelTimer,
      setTimer
    ]);
    const cancel = React23.useCallback(() => {
      if (id.current !== void 0) {
        cancelTimer(id.current);
        id.current = void 0;
      }
    }, [
      cancelTimer
    ]);
    React23.useEffect(() => cancel, [
      cancel
    ]);
    return [
      set,
      cancel
    ];
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React24 = __toESM(require_react());
  var ThemeContext2 = React24.createContext(void 0);
  var ThemeProvider = ThemeContext2.Provider;

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React25 = __toESM(require_react());
  var ThemeClassNameContext = React25.createContext(void 0);
  var themeClassNameContextDefaultVaue = "";
  var ThemeClassNameProvider = ThemeClassNameContext.Provider;
  function useThemeClassName() {
    var _React_useContext;
    return (_React_useContext = React25.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React26 = __toESM(require_react());
  var TooltipVisibilityContext = React26.createContext(void 0);
  var TooltipVisibilityProvider = TooltipVisibilityContext.Provider;

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React27 = __toESM(require_react());
  var ProviderContext = React27.createContext(void 0);
  var providerContextDefaultValue = {
    // eslint-disable-next-line @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )
    targetDocument: typeof document === "object" ? document : void 0,
    dir: "ltr"
  };
  var Provider = ProviderContext.Provider;
  function useFluent() {
    var _React_useContext;
    return (_React_useContext = React27.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React28 = __toESM(require_react());
  var OverridesContext = React28.createContext(void 0);
  var OverridesProvider = OverridesContext.Provider;
  function useOverrides() {
    var _React_useContext;
    return (_React_useContext = React28.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
  }

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React29 = __toESM(require_react());
  var CustomStyleHooksContext = React29.createContext(void 0);
  var noop3 = () => {
  };
  var CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
  var useCustomStyleHook = (hook) => {
    var _React_useContext;
    var _React_useContext_hook;
    return (_React_useContext_hook = (_React_useContext = React29.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop3;
  };

  // ../../node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React30 = __toESM(require_react());
  var PortalMountNodeContext = React30.createContext(void 0);
  var PortalMountNodeProvider = PortalMountNodeContext.Provider;
  function usePortalMountNode() {
    return React30.useContext(PortalMountNodeContext);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
  var setAnimationFrameNoop = (callback) => {
    callback(0);
    return 0;
  };
  var cancelAnimationFrameNoop = (handle2) => handle2;
  function useAnimationFrame() {
    const { targetDocument } = useFluent();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const setAnimationFrame = win ? win.requestAnimationFrame : setAnimationFrameNoop;
    const clearAnimationFrame = win ? win.cancelAnimationFrame : cancelAnimationFrameNoop;
    return useBrowserTimer(setAnimationFrame, clearAnimationFrame);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React31 = __toESM(require_react());
  function isFactoryDispatch(newState) {
    return typeof newState === "function";
  }
  var useControllableState = (options) => {
    "use no memo";
    if (false) {
      if (options.state !== void 0 && options.defaultState !== void 0) {
        console.error(`@fluentui/react-utilities [useControllableState]:
A component must be either controlled or uncontrolled (specify either the state or the defaultState, but not both).
Decide between using a controlled or uncontrolled component and remove one of this props.
More info: https://reactjs.org/link/controlled-components
${new Error().stack}`);
      }
    }
    const [internalState, setInternalState] = React31.useState(() => {
      if (options.defaultState === void 0) {
        return options.initialState;
      }
      return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
    });
    const stateValueRef = React31.useRef(options.state);
    React31.useEffect(() => {
      stateValueRef.current = options.state;
    }, [
      options.state
    ]);
    const setControlledState = React31.useCallback((newState) => {
      if (isFactoryDispatch(newState)) {
        newState(stateValueRef.current);
      }
    }, []);
    return useIsControlled(options.state) ? [
      options.state,
      setControlledState
    ] : [
      internalState,
      setInternalState
    ];
  };
  function isInitializer(value) {
    return typeof value === "function";
  }
  var useIsControlled = (controlledValue) => {
    "use no memo";
    const [isControlled] = React31.useState(() => controlledValue !== void 0);
    if (false) {
      React31.useEffect(() => {
        if (isControlled !== (controlledValue !== void 0)) {
          const error = new Error();
          const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
          const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
          console.error(`@fluentui/react-utilities [useControllableState]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
        }
      }, [
        isControlled,
        controlledValue
      ]);
    }
    return isControlled;
  };

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React34 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React33 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function canUseDOM2() {
    return (
      /* eslint-disable @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )*/
      typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line @typescript-eslint/no-deprecated
      window.document.createElement)
    );
  }

  // ../../node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React32 = __toESM(require_react());
  var defaultSSRContextValue = {
    current: 0
  };
  var SSRContext = /* @__PURE__ */ React32.createContext(void 0);
  function useSSRContext() {
    var _React_useContext;
    return (_React_useContext = React32.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
  var useIsomorphicLayoutEffect2 = canUseDOM2() ? React33.useLayoutEffect : React33.useEffect;

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
  var useEventCallback = (fn) => {
    const callbackRef = React34.useRef(() => {
      throw new Error("Cannot call an event handler while rendering");
    });
    useIsomorphicLayoutEffect2(() => {
      callbackRef.current = fn;
    }, [
      fn
    ]);
    return React34.useCallback((...args) => {
      const callback = callbackRef.current;
      return callback(...args);
    }, [
      callbackRef
    ]);
  };

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React35 = __toESM(require_react());
  function useFirstMount() {
    const isFirst = React35.useRef(true);
    if (isFirst.current) {
      isFirst.current = false;
      return true;
    }
    return isFirst.current;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React36 = __toESM(require_react());
  function useForceUpdate() {
    return React36.useReducer((x) => x + 1, 0)[1];
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useId.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React37 = __toESM(require_react());
  var IdPrefixContext = React37.createContext(void 0);
  var IdPrefixProvider = IdPrefixContext.Provider;
  function useIdPrefix() {
    return React37.useContext(IdPrefixContext) || "";
  }
  function useId4(prefix2 = "fui-", providedId) {
    "use no memo";
    const contextValue = useSSRContext();
    const idPrefix = useIdPrefix();
    const _useId = React37["useId"];
    if (_useId) {
      const generatedId = _useId();
      const escapedId = React37.useMemo(() => generatedId.replace(/:/g, ""), [
        generatedId
      ]);
      return providedId || `${idPrefix}${prefix2}${escapedId}`;
    }
    return React37.useMemo(() => {
      if (providedId) {
        return providedId;
      }
      return `${idPrefix}${prefix2}${++contextValue.current}`;
    }, [
      idPrefix,
      prefix2,
      providedId,
      contextValue
    ]);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React38 = __toESM(require_react());
  function useMergedRefs(...refs) {
    "use no memo";
    const mergedCallback = React38.useCallback(
      (value) => {
        mergedCallback.current = value;
        for (const ref of refs) {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
        }
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
      [
        ...refs
      ]
    );
    return mergedCallback;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useOnClickOutside.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React39 = __toESM(require_react());
  var DEFAULT_CONTAINS = (parent, child) => !!(parent === null || parent === void 0 ? void 0 : parent.contains(child));
  var useOnClickOutside = (options) => {
    const { targetDocument } = useFluent();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const { refs, callback, element: element4, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
    const timeoutId = React39.useRef(void 0);
    useIFrameFocus({
      element: element4,
      disabled: disabledFocusOnIframe || disabled,
      callback,
      refs,
      contains
    });
    const isMouseDownInsideRef = React39.useRef(false);
    const listener = useEventCallback((ev) => {
      if (isMouseDownInsideRef.current) {
        isMouseDownInsideRef.current = false;
        return;
      }
      const target = ev.composedPath()[0];
      const isOutside = refs.every((ref) => !contains(ref.current || null, target));
      if (isOutside && !disabled) {
        callback(ev);
      }
    });
    const handleMouseDown = useEventCallback((ev) => {
      isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
    });
    React39.useEffect(() => {
      if (disabled) {
        return;
      }
      let currentEvent = getWindowEvent(win);
      const conditionalHandler = (event) => {
        if (event === currentEvent) {
          currentEvent = void 0;
          return;
        }
        listener(event);
      };
      element4 === null || element4 === void 0 ? void 0 : element4.addEventListener("click", conditionalHandler, true);
      element4 === null || element4 === void 0 ? void 0 : element4.addEventListener("touchstart", conditionalHandler, true);
      element4 === null || element4 === void 0 ? void 0 : element4.addEventListener("contextmenu", conditionalHandler, true);
      element4 === null || element4 === void 0 ? void 0 : element4.addEventListener("mousedown", handleMouseDown, true);
      timeoutId.current = win === null || win === void 0 ? void 0 : win.setTimeout(() => {
        currentEvent = void 0;
      }, 1);
      return () => {
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("click", conditionalHandler, true);
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("touchstart", conditionalHandler, true);
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("contextmenu", conditionalHandler, true);
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("mousedown", handleMouseDown, true);
        win === null || win === void 0 ? void 0 : win.clearTimeout(timeoutId.current);
        currentEvent = void 0;
      };
    }, [
      listener,
      element4,
      disabled,
      handleMouseDown,
      win
    ]);
  };
  var getWindowEvent = (target) => {
    if (target) {
      var _target_ownerDocument_defaultView, _target_ownerDocument;
      if (typeof target.window === "object" && target.window === target) {
        return target.event;
      }
      var _target_ownerDocument_defaultView_event;
      return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
    }
    return void 0;
  };
  var FUI_FRAME_EVENT = "fuiframefocus";
  var useIFrameFocus = (options) => {
    const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 1e3, refs } = options;
    const timeoutRef = React39.useRef();
    const listener = useEventCallback((e) => {
      const isOutside = refs.every((ref) => !contains(ref.current || null, e.target));
      if (isOutside && !disabled) {
        callback(e);
      }
    });
    React39.useEffect(() => {
      if (disabled) {
        return;
      }
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
      return () => {
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
      };
    }, [
      targetDocument,
      disabled,
      listener
    ]);
    React39.useEffect(() => {
      var _targetDocument_defaultView;
      if (disabled) {
        return;
      }
      timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
        const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
        if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
          const event = new CustomEvent(FUI_FRAME_EVENT, {
            bubbles: true
          });
          activeElement.dispatchEvent(event);
        }
      }, pollDuration);
      return () => {
        var _targetDocument_defaultView2;
        targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.clearTimeout(timeoutRef.current);
      };
    }, [
      targetDocument,
      disabled,
      pollDuration
    ]);
  };

  // ../../node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var setTimeoutNoop = (_callback) => -1;
  var clearTimeoutNoop = (_handle) => void 0;
  function useTimeout() {
    const { targetDocument } = useFluent();
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    const setTimerFn = win ? win.setTimeout : setTimeoutNoop;
    const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop;
    return useBrowserTimer(setTimerFn, clearTimerFn);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function mergeCallbacks(callback1, callback2) {
    return (...args) => {
      callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
      callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
    };
  }

  // ../../node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isHTMLElement(element4, options) {
    var _typedElement_ownerDocument;
    const typedElement = element4;
    var _options_constructorName;
    return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React41 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React40 = __toESM(require_react());
  function isFluentTrigger(element4) {
    return Boolean(element4.type.isFluentTriggerComponent);
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
  function applyTriggerPropsToChildren(children2, triggerChildProps) {
    if (typeof children2 === "function") {
      return children2(triggerChildProps);
    } else if (children2) {
      return cloneTriggerTree(children2, triggerChildProps);
    }
    return children2 || null;
  }
  function cloneTriggerTree(child, triggerProps) {
    if (!React41.isValidElement(child) || child.type === React41.Fragment) {
      throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
    }
    if (isFluentTrigger(child)) {
      const grandchild = cloneTriggerTree(child.props.children, triggerProps);
      return React41.cloneElement(child, void 0, grandchild);
    } else {
      return React41.cloneElement(child, triggerProps);
    }
  }

  // ../../node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React42 = __toESM(require_react());
  function getTriggerChild(children2) {
    if (!React42.isValidElement(children2)) {
      return null;
    }
    return isFluentTrigger(children2) ? getTriggerChild(
      // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
      // but for some reason it's failing on build
      children2.props.children
    ) : children2;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isVirtualElement(element4) {
    return element4 && !!element4._virtual;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
  function getVirtualParent(child) {
    return isVirtualElement(child) ? child._virtual.parent || null : null;
  }
  function getParent(child, options = {}) {
    if (!child) {
      return null;
    }
    if (!options.skipVirtual) {
      const virtualParent = getVirtualParent(child);
      if (virtualParent) {
        return virtualParent;
      }
    }
    const parent = child.parentNode;
    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      return parent.host;
    }
    return parent;
  }

  // ../../node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function setVirtualParent(child, parent) {
    if (!child) {
      return;
    }
    const virtualChild = child;
    if (!virtualChild._virtual) {
      virtualChild._virtual = {};
    }
    virtualChild._virtual.parent = parent;
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  var React45 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React43 = __toESM(require_react());
  function createCompatSlotComponent(type, props) {
    return {
      ...props,
      [SLOT_ELEMENT_TYPE_SYMBOL]: type
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React44 = __toESM(require_react());
  var import_react_is = __toESM(require_react_is());
  function warnIfElementTypeIsInvalid(type) {
    if (false) {
      console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
    }
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
  function createJSX(runtime, slotRuntime) {
    return function jsx5(type, overrideProps, key, source, self2) {
      if (isSlot(overrideProps)) {
        return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self2);
      }
      if (isSlot(type)) {
        return slotRuntime(type, overrideProps, key, source, self2);
      }
      warnIfElementTypeIsInvalid(type);
      return runtime(type, overrideProps, key, source, self2);
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React46 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getMetadataFromSlotComponent(type) {
    const { as, [SLOT_CLASS_NAME_PROP_SYMBOL]: _classNameProp, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
    const props = propsWithoutMetadata;
    const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
    if (typeof elementType !== "string" && as) {
      props.as = as;
    }
    return {
      elementType,
      props,
      renderFunction
    };
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ReactRuntime = __toESM(require_jsx_runtime());
  var Runtime = ReactRuntime;

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
  var jsxSlot = (type, overrideProps, key) => {
    const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
    const props = {
      ...slotProps,
      ...overrideProps
    };
    if (renderFunction) {
      return Runtime.jsx(React46.Fragment, {
        children: renderFunction(elementType, props)
      }, key);
    }
    return Runtime.jsx(elementType, props, key);
  };

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React47 = __toESM(require_react());
  var jsxsSlot = (type, overrideProps, key) => {
    const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
    const props = {
      ...slotProps,
      ...overrideProps
    };
    if (renderFunction) {
      return Runtime.jsx(React47.Fragment, {
        children: renderFunction(elementType, {
          ...props,
          children: Runtime.jsxs(React47.Fragment, {
            children: props.children
          }, void 0)
        })
      }, key);
    }
    return Runtime.jsxs(elementType, props, key);
  };

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
  var import_react36 = __toESM(require_react());
  var jsx2 = createJSX(Runtime.jsx, jsxSlot);
  var jsxs2 = createJSX(Runtime.jsxs, jsxsSlot);

  // ../../node_modules/@fluentui/react-icons/lib/providers.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-icons/lib/contexts/IconDirectionContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React48 = __toESM(require_react());
  var IconDirectionContext = React48.createContext(void 0);
  var IconDirectionContextDefaultValue = {};
  var IconDirectionContextProvider = IconDirectionContext.Provider;
  var useIconContext = () => React48.useContext(IconDirectionContext) ? React48.useContext(IconDirectionContext) : IconDirectionContextDefaultValue;

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
  var renderFluentProvider_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(Provider, {
      value: contextValues.provider,
      children: /* @__PURE__ */ jsx2(ThemeProvider, {
        value: contextValues.theme,
        children: /* @__PURE__ */ jsx2(ThemeClassNameProvider, {
          value: contextValues.themeClassName,
          children: /* @__PURE__ */ jsx2(CustomStyleHooksProvider, {
            value: contextValues.customStyleHooks_unstable,
            children: /* @__PURE__ */ jsx2(TooltipVisibilityProvider, {
              value: contextValues.tooltip,
              children: /* @__PURE__ */ jsx2(TextDirectionProvider, {
                dir: contextValues.textDirection,
                children: /* @__PURE__ */ jsx2(IconDirectionContextProvider, {
                  value: contextValues.iconDirection,
                  children: /* @__PURE__ */ jsx2(OverridesProvider, {
                    value: contextValues.overrides_unstable,
                    children: /* @__PURE__ */ jsxs2(state.root, {
                      children: [
                        canUseDOM2() ? null : /* @__PURE__ */ jsx2("style", {
                          // Using dangerous HTML because react can escape characters
                          // which can lead to invalid CSS.
                          // eslint-disable-next-line react/no-danger
                          dangerouslySetInnerHTML: {
                            __html: state.serverStyleProps.cssRule
                          },
                          ...state.serverStyleProps.attributes
                        }),
                        state.root.children
                      ]
                    })
                  })
                })
              })
            })
          })
        })
      })
    });
  };

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/tabster/dist/tabster.esm.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/keyborg/dist/esm/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var _canUseWeakRef = typeof WeakRef !== "undefined";
  var WeakRefInstance = class {
    constructor(instance) {
      if (_canUseWeakRef && typeof instance === "object") {
        this._weakRef = new WeakRef(instance);
      } else {
        this._instance = instance;
      }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
     */
    deref() {
      var _a17, _b;
      let instance;
      if (this._weakRef) {
        instance = (_a17 = this._weakRef) == null ? void 0 : _a17.deref();
        if (!instance) {
          delete this._weakRef;
        }
      } else {
        instance = this._instance;
        if ((_b = instance == null ? void 0 : instance.isDisposed) == null ? void 0 : _b.call(instance)) {
          delete this._instance;
        }
      }
      return instance;
    }
  };
  var KEYBORG_FOCUSIN = "keyborg:focusin";
  var KEYBORG_FOCUSOUT = "keyborg:focusout";
  function canOverrideNativeFocus(win) {
    const HTMLElement2 = win.HTMLElement;
    const origFocus = HTMLElement2.prototype.focus;
    let isCustomFocusCalled = false;
    HTMLElement2.prototype.focus = function focus() {
      isCustomFocusCalled = true;
    };
    const btn = win.document.createElement("button");
    btn.focus();
    HTMLElement2.prototype.focus = origFocus;
    return isCustomFocusCalled;
  }
  var _canOverrideNativeFocus = false;
  function nativeFocus(element4) {
    const focus = element4.focus;
    if (focus.__keyborgNativeFocus) {
      focus.__keyborgNativeFocus.call(element4);
    } else {
      element4.focus();
    }
  }
  function setupFocusEvent(win) {
    const kwin = win;
    if (!_canOverrideNativeFocus) {
      _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
    }
    const origFocus = kwin.HTMLElement.prototype.focus;
    if (origFocus.__keyborgNativeFocus) {
      return;
    }
    kwin.HTMLElement.prototype.focus = focus;
    const shadowTargets = /* @__PURE__ */ new Set();
    const focusOutHandler = (e) => {
      const target = e.target;
      if (!target) {
        return;
      }
      const event = new CustomEvent(KEYBORG_FOCUSOUT, {
        cancelable: true,
        bubbles: true,
        // Allows the event to bubble past an open shadow root
        composed: true,
        detail: {
          originalEvent: e
        }
      });
      target.dispatchEvent(event);
    };
    const focusInHandler = (e) => {
      const target = e.target;
      if (!target) {
        return;
      }
      let node3 = e.composedPath()[0];
      const currentShadows = /* @__PURE__ */ new Set();
      while (node3) {
        if (node3.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          currentShadows.add(node3);
          node3 = node3.host;
        } else {
          node3 = node3.parentNode;
        }
      }
      for (const shadowRootWeakRef of shadowTargets) {
        const shadowRoot = shadowRootWeakRef.deref();
        if (!shadowRoot || !currentShadows.has(shadowRoot)) {
          shadowTargets.delete(shadowRootWeakRef);
          if (shadowRoot) {
            shadowRoot.removeEventListener("focusin", focusInHandler, true);
            shadowRoot.removeEventListener("focusout", focusOutHandler, true);
          }
        }
      }
      onFocusIn(target, e.relatedTarget || void 0);
    };
    const onFocusIn = (target, relatedTarget, originalEvent) => {
      var _a17;
      const shadowRoot = target.shadowRoot;
      if (shadowRoot) {
        for (const shadowRootWeakRef of shadowTargets) {
          if (shadowRootWeakRef.deref() === shadowRoot) {
            return;
          }
        }
        shadowRoot.addEventListener("focusin", focusInHandler, true);
        shadowRoot.addEventListener("focusout", focusOutHandler, true);
        shadowTargets.add(new WeakRefInstance(shadowRoot));
        return;
      }
      const details = {
        relatedTarget,
        originalEvent
      };
      const event = new CustomEvent(KEYBORG_FOCUSIN, {
        cancelable: true,
        bubbles: true,
        // Allows the event to bubble past an open shadow root
        composed: true,
        detail: details
      });
      event.details = details;
      if (_canOverrideNativeFocus || data2.lastFocusedProgrammatically) {
        details.isFocusedProgrammatically = target === ((_a17 = data2.lastFocusedProgrammatically) == null ? void 0 : _a17.deref());
        data2.lastFocusedProgrammatically = void 0;
      }
      target.dispatchEvent(event);
    };
    const data2 = kwin.__keyborgData = {
      focusInHandler,
      focusOutHandler,
      shadowTargets
    };
    kwin.document.addEventListener(
      "focusin",
      kwin.__keyborgData.focusInHandler,
      true
    );
    kwin.document.addEventListener(
      "focusout",
      kwin.__keyborgData.focusOutHandler,
      true
    );
    function focus() {
      const keyborgNativeFocusEvent = kwin.__keyborgData;
      if (keyborgNativeFocusEvent) {
        keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(
          this
        );
      }
      return origFocus.apply(this, arguments);
    }
    let activeElement = kwin.document.activeElement;
    while (activeElement && activeElement.shadowRoot) {
      onFocusIn(activeElement);
      activeElement = activeElement.shadowRoot.activeElement;
    }
    focus.__keyborgNativeFocus = origFocus;
  }
  function disposeFocusEvent(win) {
    const kwin = win;
    const proto = kwin.HTMLElement.prototype;
    const origFocus = proto.focus.__keyborgNativeFocus;
    const keyborgNativeFocusEvent = kwin.__keyborgData;
    if (keyborgNativeFocusEvent) {
      kwin.document.removeEventListener(
        "focusin",
        keyborgNativeFocusEvent.focusInHandler,
        true
      );
      kwin.document.removeEventListener(
        "focusout",
        keyborgNativeFocusEvent.focusOutHandler,
        true
      );
      for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {
        const shadowRoot = shadowRootWeakRef.deref();
        if (shadowRoot) {
          shadowRoot.removeEventListener(
            "focusin",
            keyborgNativeFocusEvent.focusInHandler,
            true
          );
          shadowRoot.removeEventListener(
            "focusout",
            keyborgNativeFocusEvent.focusOutHandler,
            true
          );
        }
      }
      keyborgNativeFocusEvent.shadowTargets.clear();
      delete kwin.__keyborgData;
    }
    if (origFocus) {
      proto.focus = origFocus;
    }
  }
  var _dismissTimeout = 500;
  var _lastId = 0;
  var KeyborgCore = class {
    constructor(win, props) {
      this._isNavigatingWithKeyboard_DO_NOT_USE = false;
      this._onFocusIn = (e) => {
        if (this._isMouseOrTouchUsedTimer) {
          return;
        }
        if (this.isNavigatingWithKeyboard) {
          return;
        }
        const details = e.detail;
        if (!details.relatedTarget) {
          return;
        }
        if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
          return;
        }
        this.isNavigatingWithKeyboard = true;
      };
      this._onMouseDown = (e) => {
        if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {
          return;
        }
        this._onMouseOrTouch();
      };
      this._onMouseOrTouch = () => {
        const win2 = this._win;
        if (win2) {
          if (this._isMouseOrTouchUsedTimer) {
            win2.clearTimeout(this._isMouseOrTouchUsedTimer);
          }
          this._isMouseOrTouchUsedTimer = win2.setTimeout(() => {
            delete this._isMouseOrTouchUsedTimer;
          }, 1e3);
        }
        this.isNavigatingWithKeyboard = false;
      };
      this._onKeyDown = (e) => {
        const isNavigatingWithKeyboard = this.isNavigatingWithKeyboard;
        if (isNavigatingWithKeyboard) {
          if (this._shouldDismissKeyboardNavigation(e)) {
            this._scheduleDismiss();
          }
        } else {
          if (this._shouldTriggerKeyboardNavigation(e)) {
            this.isNavigatingWithKeyboard = true;
          }
        }
      };
      this.id = "c" + ++_lastId;
      this._win = win;
      const doc = win.document;
      if (props) {
        const triggerKeys = props.triggerKeys;
        const dismissKeys = props.dismissKeys;
        if (triggerKeys == null ? void 0 : triggerKeys.length) {
          this._triggerKeys = new Set(triggerKeys);
        }
        if (dismissKeys == null ? void 0 : dismissKeys.length) {
          this._dismissKeys = new Set(dismissKeys);
        }
      }
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.addEventListener("mousedown", this._onMouseDown, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      doc.addEventListener("touchstart", this._onMouseOrTouch, true);
      doc.addEventListener("touchend", this._onMouseOrTouch, true);
      doc.addEventListener("touchcancel", this._onMouseOrTouch, true);
      setupFocusEvent(win);
    }
    get isNavigatingWithKeyboard() {
      return this._isNavigatingWithKeyboard_DO_NOT_USE;
    }
    set isNavigatingWithKeyboard(val) {
      if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {
        this._isNavigatingWithKeyboard_DO_NOT_USE = val;
        this.update();
      }
    }
    dispose() {
      const win = this._win;
      if (win) {
        if (this._isMouseOrTouchUsedTimer) {
          win.clearTimeout(this._isMouseOrTouchUsedTimer);
          this._isMouseOrTouchUsedTimer = void 0;
        }
        if (this._dismissTimer) {
          win.clearTimeout(this._dismissTimer);
          this._dismissTimer = void 0;
        }
        disposeFocusEvent(win);
        const doc = win.document;
        doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        doc.removeEventListener("mousedown", this._onMouseDown, true);
        win.removeEventListener("keydown", this._onKeyDown, true);
        doc.removeEventListener("touchstart", this._onMouseOrTouch, true);
        doc.removeEventListener("touchend", this._onMouseOrTouch, true);
        doc.removeEventListener("touchcancel", this._onMouseOrTouch, true);
        delete this._win;
      }
    }
    isDisposed() {
      return !!this._win;
    }
    /**
     * Updates all keyborg instances with the keyboard navigation state
     */
    update() {
      var _a17, _b;
      const keyborgs = (_b = (_a17 = this._win) == null ? void 0 : _a17.__keyborg) == null ? void 0 : _b.refs;
      if (keyborgs) {
        for (const id of Object.keys(keyborgs)) {
          Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);
        }
      }
    }
    /**
     * @returns whether the keyboard event should trigger keyboard navigation mode
     */
    _shouldTriggerKeyboardNavigation(e) {
      var _a17;
      if (e.key === "Tab") {
        return true;
      }
      const activeElement = (_a17 = this._win) == null ? void 0 : _a17.document.activeElement;
      const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);
      const isEditable = activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable);
      return isTriggerKey && !isEditable;
    }
    /**
     * @returns whether the keyboard event should dismiss keyboard navigation mode
     */
    _shouldDismissKeyboardNavigation(e) {
      var _a17;
      return (_a17 = this._dismissKeys) == null ? void 0 : _a17.has(e.keyCode);
    }
    _scheduleDismiss() {
      const win = this._win;
      if (win) {
        if (this._dismissTimer) {
          win.clearTimeout(this._dismissTimer);
          this._dismissTimer = void 0;
        }
        const was = win.document.activeElement;
        this._dismissTimer = win.setTimeout(() => {
          this._dismissTimer = void 0;
          const cur = win.document.activeElement;
          if (was && cur && was === cur) {
            this.isNavigatingWithKeyboard = false;
          }
        }, _dismissTimeout);
      }
    }
  };
  var Keyborg = class _Keyborg {
    constructor(win, props) {
      this._cb = [];
      this._id = "k" + ++_lastId;
      this._win = win;
      const current = win.__keyborg;
      if (current) {
        this._core = current.core;
        current.refs[this._id] = this;
      } else {
        this._core = new KeyborgCore(win, props);
        win.__keyborg = {
          core: this._core,
          refs: { [this._id]: this }
        };
      }
    }
    static create(win, props) {
      return new _Keyborg(win, props);
    }
    static dispose(instance) {
      instance.dispose();
    }
    /**
     * Updates all subscribed callbacks with the keyboard navigation state
     */
    static update(instance, isNavigatingWithKeyboard) {
      instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
    }
    dispose() {
      var _a17;
      const current = (_a17 = this._win) == null ? void 0 : _a17.__keyborg;
      if (current == null ? void 0 : current.refs[this._id]) {
        delete current.refs[this._id];
        if (Object.keys(current.refs).length === 0) {
          current.core.dispose();
          delete this._win.__keyborg;
        }
      } else if (false) {
        console.error(
          `Keyborg instance ${this._id} is being disposed incorrectly.`
        );
      }
      this._cb = [];
      delete this._core;
      delete this._win;
    }
    /**
     * @returns Whether the user is navigating with keyboard
     */
    isNavigatingWithKeyboard() {
      var _a17;
      return !!((_a17 = this._core) == null ? void 0 : _a17.isNavigatingWithKeyboard);
    }
    /**
     * @param callback - Called when the keyboard navigation state changes
     */
    subscribe(callback) {
      this._cb.push(callback);
    }
    /**
     * @param callback - Registered with subscribe
     */
    unsubscribe(callback) {
      const index2 = this._cb.indexOf(callback);
      if (index2 >= 0) {
        this._cb.splice(index2, 1);
      }
    }
    /**
     * Manually set the keyboard navigtion state
     */
    setVal(isNavigatingWithKeyboard) {
      if (this._core) {
        this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;
      }
    }
  };
  function createKeyborg(win, props) {
    return Keyborg.create(win, props);
  }
  function disposeKeyborg(instance) {
    Keyborg.dispose(instance);
  }

  // ../../node_modules/tabster/dist/tabster.esm.js
  var TABSTER_ATTRIBUTE_NAME = "data-tabster";
  var TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = "data-tabster-dummy";
  var FOCUSABLE_SELECTOR = /* @__PURE__ */ ["a[href]", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]", "details > summary", "audio[controls]", "video[controls]"].join(", ");
  var AsyncFocusSources = {
    EscapeGroupper: 1,
    Restorer: 2,
    Deloser: 3
  };
  var Visibilities = {
    Invisible: 0,
    PartiallyVisible: 1,
    Visible: 2
  };
  var RestorerTypes = {
    Source: 0,
    Target: 1
  };
  var MoverDirections = {
    Both: 0,
    // Default, both left/up keys move to the previous, right/down move to the next.
    Vertical: 1,
    // Only up/down arrows move to the next/previous.
    Horizontal: 2,
    // Only left/right arrows move to the next/previous.
    Grid: 3,
    // Two-dimentional movement depending on the visual placement.
    GridLinear: 4
    // Two-dimentional movement depending on the visual placement. Allows linear movement.
  };
  var MoverKeys = {
    ArrowUp: 1,
    ArrowDown: 2,
    ArrowLeft: 3,
    ArrowRight: 4,
    PageUp: 5,
    PageDown: 6,
    Home: 7,
    End: 8
  };
  var GroupperTabbabilities = {
    Unlimited: 0,
    Limited: 1,
    // The tabbability is limited to the container and explicit Enter is needed to go inside.
    LimitedTrapFocus: 2
    // The focus is limited as above, plus trapped when inside.
  };
  var GroupperMoveFocusActions = {
    Enter: 1,
    Escape: 2
  };
  var SysDummyInputsPositions = {
    Auto: 0,
    // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.
    Inside: 1,
    // Tabster will always place dummy inputs inside the container.
    Outside: 2
    // Tabster will always place dummy inputs outside of the container.
  };
  function getTabsterOnElement(tabster, element4) {
    var _a17;
    return (_a17 = tabster.storageEntry(element4)) === null || _a17 === void 0 ? void 0 : _a17.tabster;
  }
  function updateTabsterByAttribute(tabster, element4, dispose) {
    var _a17, _b;
    const newAttrValue = dispose || tabster._noop ? void 0 : element4.getAttribute(TABSTER_ATTRIBUTE_NAME);
    let entry = tabster.storageEntry(element4);
    let newAttr;
    if (newAttrValue) {
      if (newAttrValue !== ((_a17 = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a17 === void 0 ? void 0 : _a17.string)) {
        try {
          const newValue = JSON.parse(newAttrValue);
          if (typeof newValue !== "object") {
            throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
          }
          newAttr = {
            string: newAttrValue,
            object: newValue
          };
        } catch (e) {
          if (false) {
            console.error(`data-tabster attribute error: ${e}`, element4);
          }
        }
      } else {
        return;
      }
    } else if (!entry) {
      return;
    }
    if (!entry) {
      entry = tabster.storageEntry(element4, true);
    }
    if (!entry.tabster) {
      entry.tabster = {};
    }
    const tabsterOnElement = entry.tabster || {};
    const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
    const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
    for (const key of Object.keys(oldTabsterProps)) {
      if (!newTabsterProps[key]) {
        if (key === "root") {
          const root5 = tabsterOnElement[key];
          if (root5) {
            tabster.root.onRoot(root5, true);
          }
        }
        switch (key) {
          case "deloser":
          case "root":
          case "groupper":
          case "modalizer":
          case "restorer":
          case "mover":
            const part = tabsterOnElement[key];
            if (part) {
              part.dispose();
              delete tabsterOnElement[key];
            }
            break;
          case "observed":
            delete tabsterOnElement[key];
            if (tabster.observedElement) {
              tabster.observedElement.onObservedElementUpdate(element4);
            }
            break;
          case "focusable":
          case "outline":
          case "uncontrolled":
          case "sys":
            delete tabsterOnElement[key];
            break;
        }
      }
    }
    for (const key of Object.keys(newTabsterProps)) {
      const sys = newTabsterProps.sys;
      switch (key) {
        case "deloser":
          if (tabsterOnElement.deloser) {
            tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
          } else {
            if (tabster.deloser) {
              tabsterOnElement.deloser = tabster.deloser.createDeloser(element4, newTabsterProps.deloser);
            } else if (false) {
              console.error("Deloser API used before initialization, please call `getDeloser()`");
            }
          }
          break;
        case "root":
          if (tabsterOnElement.root) {
            tabsterOnElement.root.setProps(newTabsterProps.root);
          } else {
            tabsterOnElement.root = tabster.root.createRoot(element4, newTabsterProps.root, sys);
          }
          tabster.root.onRoot(tabsterOnElement.root);
          break;
        case "modalizer":
          if (tabsterOnElement.modalizer) {
            tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
          } else {
            if (tabster.modalizer) {
              tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element4, newTabsterProps.modalizer, sys);
            } else if (false) {
              console.error("Modalizer API used before initialization, please call `getModalizer()`");
            }
          }
          break;
        case "restorer":
          if (tabsterOnElement.restorer) {
            tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
          } else {
            if (tabster.restorer) {
              if (newTabsterProps.restorer) {
                tabsterOnElement.restorer = tabster.restorer.createRestorer(element4, newTabsterProps.restorer);
              }
            } else if (false) {
              console.error("Restorer API used before initialization, please call `getRestorer()`");
            }
          }
          break;
        case "focusable":
          tabsterOnElement.focusable = newTabsterProps.focusable;
          break;
        case "groupper":
          if (tabsterOnElement.groupper) {
            tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
          } else {
            if (tabster.groupper) {
              tabsterOnElement.groupper = tabster.groupper.createGroupper(element4, newTabsterProps.groupper, sys);
            } else if (false) {
              console.error("Groupper API used before initialization, please call `getGroupper()`");
            }
          }
          break;
        case "mover":
          if (tabsterOnElement.mover) {
            tabsterOnElement.mover.setProps(newTabsterProps.mover);
          } else {
            if (tabster.mover) {
              tabsterOnElement.mover = tabster.mover.createMover(element4, newTabsterProps.mover, sys);
            } else if (false) {
              console.error("Mover API used before initialization, please call `getMover()`");
            }
          }
          break;
        case "observed":
          if (tabster.observedElement) {
            tabsterOnElement.observed = newTabsterProps.observed;
            tabster.observedElement.onObservedElementUpdate(element4);
          } else if (false) {
            console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
          }
          break;
        case "uncontrolled":
          tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
          break;
        case "outline":
          if (tabster.outline) {
            tabsterOnElement.outline = newTabsterProps.outline;
          } else if (false) {
            console.error("Outline API used before initialization, please call `getOutline()`");
          }
          break;
        case "sys":
          tabsterOnElement.sys = newTabsterProps.sys;
          break;
        default:
          console.error(`Unknown key '${key}' in data-tabster attribute value.`);
      }
    }
    if (newAttr) {
      entry.attr = newAttr;
    } else {
      if (Object.keys(tabsterOnElement).length === 0) {
        delete entry.tabster;
        delete entry.attr;
      }
      tabster.storageEntry(element4, false);
    }
  }
  var TabsterFocusInEventName = "tabster:focusin";
  var TabsterFocusOutEventName = "tabster:focusout";
  var TabsterMoveFocusEventName = "tabster:movefocus";
  var ModalizerActiveEventName = "tabster:modalizer:active";
  var ModalizerInactiveEventName = "tabster:modalizer:inactive";
  var MoverStateEventName = "tabster:mover:state";
  var MoverMoveFocusEventName = "tabster:mover:movefocus";
  var MoverMemorizedElementEventName = "tabster:mover:memorized-element";
  var GroupperMoveFocusEventName = "tabster:groupper:movefocus";
  var RestorerRestoreFocusEventName = "tabster:restorer:restore-focus";
  var RootFocusEventName = "tabster:root:focus";
  var RootBlurEventName = "tabster:root:blur";
  var CustomEvent_ = typeof CustomEvent !== "undefined" ? CustomEvent : function() {
  };
  var TabsterCustomEvent = class extends CustomEvent_ {
    constructor(type, detail) {
      super(type, {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail
      });
      this.details = detail;
    }
  };
  var TabsterFocusInEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterFocusInEventName, detail);
    }
  };
  var TabsterFocusOutEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterFocusOutEventName, detail);
    }
  };
  var TabsterMoveFocusEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(TabsterMoveFocusEventName, detail);
    }
  };
  var MoverStateEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(MoverStateEventName, detail);
    }
  };
  var ModalizerActiveEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(ModalizerActiveEventName, detail);
    }
  };
  var ModalizerInactiveEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(ModalizerInactiveEventName, detail);
    }
  };
  var RestorerRestoreFocusEvent = class extends TabsterCustomEvent {
    constructor() {
      super(RestorerRestoreFocusEventName);
    }
  };
  var RootFocusEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(RootFocusEventName, detail);
    }
  };
  var RootBlurEvent = class extends TabsterCustomEvent {
    constructor(detail) {
      super(RootBlurEventName, detail);
    }
  };
  var _createMutationObserver = (callback) => new MutationObserver(callback);
  var _createTreeWalker = (doc, root5, whatToShow, filter3) => doc.createTreeWalker(root5, whatToShow, filter3);
  var _getParentNode = (node3) => node3 ? node3.parentNode : null;
  var _getParentElement = (element4) => element4 ? element4.parentElement : null;
  var _nodeContains = (parent, child) => !!(child && (parent === null || parent === void 0 ? void 0 : parent.contains(child)));
  var _getActiveElement = (doc) => doc.activeElement;
  var _querySelector = (element4, selector) => element4.querySelector(selector);
  var _querySelectorAll = (element4, selector) => Array.prototype.slice.call(element4.querySelectorAll(selector), 0);
  var _getElementById = (doc, id) => doc.getElementById(id);
  var _getFirstChild = (node3) => (node3 === null || node3 === void 0 ? void 0 : node3.firstChild) || null;
  var _getLastChild = (node3) => (node3 === null || node3 === void 0 ? void 0 : node3.lastChild) || null;
  var _getNextSibling = (node3) => (node3 === null || node3 === void 0 ? void 0 : node3.nextSibling) || null;
  var _getPreviousSibling = (node3) => (node3 === null || node3 === void 0 ? void 0 : node3.previousSibling) || null;
  var _getFirstElementChild = (element4) => (element4 === null || element4 === void 0 ? void 0 : element4.firstElementChild) || null;
  var _getLastElementChild = (element4) => (element4 === null || element4 === void 0 ? void 0 : element4.lastElementChild) || null;
  var _getNextElementSibling = (element4) => (element4 === null || element4 === void 0 ? void 0 : element4.nextElementSibling) || null;
  var _getPreviousElementSibling = (element4) => (element4 === null || element4 === void 0 ? void 0 : element4.previousElementSibling) || null;
  var _appendChild = (parent, child) => parent.appendChild(child);
  var _insertBefore = (parent, child, referenceChild) => parent.insertBefore(child, referenceChild);
  var _getSelection = (ref) => {
    var _a17;
    return ((_a17 = ref.ownerDocument) === null || _a17 === void 0 ? void 0 : _a17.getSelection()) || null;
  };
  var _getElementsByName = (referenceElement, name21) => referenceElement.ownerDocument.getElementsByName(name21);
  var dom = {
    createMutationObserver: _createMutationObserver,
    createTreeWalker: _createTreeWalker,
    getParentNode: _getParentNode,
    getParentElement: _getParentElement,
    nodeContains: _nodeContains,
    getActiveElement: _getActiveElement,
    querySelector: _querySelector,
    querySelectorAll: _querySelectorAll,
    getElementById: _getElementById,
    getFirstChild: _getFirstChild,
    getLastChild: _getLastChild,
    getNextSibling: _getNextSibling,
    getPreviousSibling: _getPreviousSibling,
    getFirstElementChild: _getFirstElementChild,
    getLastElementChild: _getLastElementChild,
    getNextElementSibling: _getNextElementSibling,
    getPreviousElementSibling: _getPreviousElementSibling,
    appendChild: _appendChild,
    insertBefore: _insertBefore,
    getSelection: _getSelection,
    getElementsByName: _getElementsByName
  };
  function setDOMAPI(domapi) {
    for (const key of Object.keys(domapi)) {
      dom[key] = domapi[key];
    }
  }
  var _isBrokenIE11;
  var _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
    constructor(x, y, width, height) {
      this.left = x || 0;
      this.top = y || 0;
      this.right = (x || 0) + (width || 0);
      this.bottom = (y || 0) + (height || 0);
    }
  };
  var _uidCounter = 0;
  try {
    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
    _isBrokenIE11 = false;
  } catch (e) {
    _isBrokenIE11 = true;
  }
  var _updateDummyInputsTimeout = 100;
  function getInstanceContext(getWindow2) {
    const win = getWindow2();
    let ctx = win.__tabsterInstanceContext;
    if (!ctx) {
      ctx = {
        elementByUId: {},
        basics: {
          Promise: win.Promise || void 0,
          WeakRef: win.WeakRef || void 0
        },
        containerBoundingRectCache: {},
        lastContainerBoundingRectCacheId: 0,
        fakeWeakRefs: [],
        fakeWeakRefsStarted: false
      };
      win.__tabsterInstanceContext = ctx;
    }
    return ctx;
  }
  function disposeInstanceContext(win) {
    const ctx = win.__tabsterInstanceContext;
    if (ctx) {
      ctx.elementByUId = {};
      delete ctx.WeakRef;
      ctx.containerBoundingRectCache = {};
      if (ctx.containerBoundingRectCacheTimer) {
        win.clearTimeout(ctx.containerBoundingRectCacheTimer);
      }
      if (ctx.fakeWeakRefsTimer) {
        win.clearTimeout(ctx.fakeWeakRefsTimer);
      }
      ctx.fakeWeakRefs = [];
      delete win.__tabsterInstanceContext;
    }
  }
  function createWeakMap(win) {
    const ctx = win.__tabsterInstanceContext;
    return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
  }
  function hasSubFocusable(element4) {
    return !!element4.querySelector(FOCUSABLE_SELECTOR);
  }
  var FakeWeakRef = class {
    constructor(target) {
      this._target = target;
    }
    deref() {
      return this._target;
    }
    static cleanup(fwr, forceRemove) {
      if (!fwr._target) {
        return true;
      }
      if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
        delete fwr._target;
        return true;
      }
      return false;
    }
  };
  var WeakHTMLElement = class {
    constructor(getWindow2, element4, data2) {
      const context = getInstanceContext(getWindow2);
      let ref;
      if (context.WeakRef) {
        ref = new context.WeakRef(element4);
      } else {
        ref = new FakeWeakRef(element4);
        context.fakeWeakRefs.push(ref);
      }
      this._ref = ref;
      this._data = data2;
    }
    get() {
      const ref = this._ref;
      let element4;
      if (ref) {
        element4 = ref.deref();
        if (!element4) {
          delete this._ref;
        }
      }
      return element4;
    }
    getData() {
      return this._data;
    }
  };
  function cleanupFakeWeakRefs(getWindow2, forceRemove) {
    const context = getInstanceContext(getWindow2);
    context.fakeWeakRefs = context.fakeWeakRefs.filter((e) => !FakeWeakRef.cleanup(e, forceRemove));
  }
  function startFakeWeakRefsCleanup(getWindow2) {
    const context = getInstanceContext(getWindow2);
    if (!context.fakeWeakRefsStarted) {
      context.fakeWeakRefsStarted = true;
      context.WeakRef = getWeakRef(context);
    }
    if (!context.fakeWeakRefsTimer) {
      context.fakeWeakRefsTimer = getWindow2().setTimeout(() => {
        context.fakeWeakRefsTimer = void 0;
        cleanupFakeWeakRefs(getWindow2);
        startFakeWeakRefsCleanup(getWindow2);
      }, 2 * 60 * 1e3);
    }
  }
  function stopFakeWeakRefsCleanupAndClearStorage(getWindow2) {
    const context = getInstanceContext(getWindow2);
    context.fakeWeakRefsStarted = false;
    if (context.fakeWeakRefsTimer) {
      getWindow2().clearTimeout(context.fakeWeakRefsTimer);
      context.fakeWeakRefsTimer = void 0;
      context.fakeWeakRefs = [];
    }
  }
  function createElementTreeWalker(doc, root5, acceptNode) {
    if (root5.nodeType !== Node.ELEMENT_NODE) {
      return void 0;
    }
    const filter3 = _isBrokenIE11 ? acceptNode : {
      acceptNode
    };
    return dom.createTreeWalker(
      doc,
      root5,
      NodeFilter.SHOW_ELEMENT,
      filter3,
      // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
      false
      /* Last argument is not optional for IE11! */
    );
  }
  function getBoundingRect(getWindow2, element4) {
    let cacheId = element4.__tabsterCacheId;
    const context = getInstanceContext(getWindow2);
    const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
    if (cached) {
      return cached.rect;
    }
    const scrollingElement = element4.ownerDocument && element4.ownerDocument.documentElement;
    if (!scrollingElement) {
      return new _DOMRect();
    }
    let left = 0;
    let top = 0;
    let right = scrollingElement.clientWidth;
    let bottom = scrollingElement.clientHeight;
    if (element4 !== scrollingElement) {
      const r = element4.getBoundingClientRect();
      left = Math.max(left, r.left);
      top = Math.max(top, r.top);
      right = Math.min(right, r.right);
      bottom = Math.min(bottom, r.bottom);
    }
    const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);
    if (!cacheId) {
      cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
      element4.__tabsterCacheId = cacheId;
    }
    context.containerBoundingRectCache[cacheId] = {
      rect,
      element: element4
    };
    if (!context.containerBoundingRectCacheTimer) {
      context.containerBoundingRectCacheTimer = window.setTimeout(() => {
        context.containerBoundingRectCacheTimer = void 0;
        for (const cId of Object.keys(context.containerBoundingRectCache)) {
          delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
        }
        context.containerBoundingRectCache = {};
      }, 50);
    }
    return rect;
  }
  function isElementVerticallyVisibleInContainer(getWindow2, element4, tolerance) {
    const container2 = getScrollableContainer(element4);
    if (!container2) {
      return false;
    }
    const containerRect = getBoundingRect(getWindow2, container2);
    const elementRect = element4.getBoundingClientRect();
    const intersectionTolerance = elementRect.height * (1 - tolerance);
    const topIntersection = Math.max(0, containerRect.top - elementRect.top);
    const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
    const totalIntersection = topIntersection + bottomIntersection;
    return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
  }
  function scrollIntoView(getWindow2, element4, alignToTop) {
    const container2 = getScrollableContainer(element4);
    if (container2) {
      const containerRect = getBoundingRect(getWindow2, container2);
      const elementRect = element4.getBoundingClientRect();
      if (alignToTop) {
        container2.scrollTop += elementRect.top - containerRect.top;
      } else {
        container2.scrollTop += elementRect.bottom - containerRect.bottom;
      }
    }
  }
  function getScrollableContainer(element4) {
    const doc = element4.ownerDocument;
    if (doc) {
      for (let el = dom.getParentElement(element4); el; el = dom.getParentElement(el)) {
        if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
          return el;
        }
      }
      return doc.documentElement;
    }
    return null;
  }
  function makeFocusIgnored(element4) {
    element4.__shouldIgnoreFocus = true;
  }
  function shouldIgnoreFocus(element4) {
    return !!element4.__shouldIgnoreFocus;
  }
  function getUId(wnd) {
    const rnd = new Uint32Array(4);
    if (wnd.crypto && wnd.crypto.getRandomValues) {
      wnd.crypto.getRandomValues(rnd);
    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
      wnd.msCrypto.getRandomValues(rnd);
    } else {
      for (let i = 0; i < rnd.length; i++) {
        rnd[i] = 4294967295 * Math.random();
      }
    }
    const srnd = [];
    for (let i = 0; i < rnd.length; i++) {
      srnd.push(rnd[i].toString(36));
    }
    srnd.push("|");
    srnd.push((++_uidCounter).toString(36));
    srnd.push("|");
    srnd.push(Date.now().toString(36));
    return srnd.join("");
  }
  function getElementUId(getWindow2, element4) {
    const context = getInstanceContext(getWindow2);
    let uid = element4.__tabsterElementUID;
    if (!uid) {
      uid = element4.__tabsterElementUID = getUId(getWindow2());
    }
    if (!context.elementByUId[uid] && documentContains(element4.ownerDocument, element4)) {
      context.elementByUId[uid] = new WeakHTMLElement(getWindow2, element4);
    }
    return uid;
  }
  function clearElementCache(getWindow2, parent) {
    const context = getInstanceContext(getWindow2);
    for (const key of Object.keys(context.elementByUId)) {
      const wel = context.elementByUId[key];
      const el = wel && wel.get();
      if (el && parent) {
        if (!dom.nodeContains(parent, el)) {
          continue;
        }
      }
      delete context.elementByUId[key];
    }
  }
  function documentContains(doc, element4) {
    return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element4);
  }
  function matchesSelector(element4, selector) {
    const matches = element4.matches || element4.matchesSelector || element4.msMatchesSelector || element4.webkitMatchesSelector;
    return matches && matches.call(element4, selector);
  }
  function getPromise(getWindow2) {
    const context = getInstanceContext(getWindow2);
    if (context.basics.Promise) {
      return context.basics.Promise;
    }
    throw new Error("No Promise defined.");
  }
  function getWeakRef(context) {
    return context.basics.WeakRef;
  }
  var _lastTabsterPartId = 0;
  var TabsterPart = class {
    constructor(tabster, element4, props) {
      const getWindow2 = tabster.getWindow;
      this._tabster = tabster;
      this._element = new WeakHTMLElement(getWindow2, element4);
      this._props = {
        ...props
      };
      this.id = "i" + ++_lastTabsterPartId;
    }
    getElement() {
      return this._element.get();
    }
    getProps() {
      return this._props;
    }
    setProps(props) {
      this._props = {
        ...props
      };
    }
  };
  var DummyInput = class {
    constructor(getWindow2, isOutside, props, element4, fixedTarget) {
      var _a17;
      this._focusIn = (e) => {
        if (this._fixedTarget) {
          const target = this._fixedTarget.get();
          if (target) {
            nativeFocus(target);
          }
          return;
        }
        const input2 = this.input;
        if (this.onFocusIn && input2) {
          const relatedTarget = e.relatedTarget;
          this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
        }
      };
      this._focusOut = (e) => {
        if (this._fixedTarget) {
          return;
        }
        this.useDefaultAction = false;
        const input2 = this.input;
        if (this.onFocusOut && input2) {
          const relatedTarget = e.relatedTarget;
          this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
        }
      };
      const win = getWindow2();
      const input = win.document.createElement("i");
      input.tabIndex = 0;
      input.setAttribute("role", "none");
      input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, "");
      input.setAttribute("aria-hidden", "true");
      const style = input.style;
      style.position = "fixed";
      style.width = style.height = "1px";
      style.opacity = "0.001";
      style.zIndex = "-1";
      style.setProperty("content-visibility", "hidden");
      makeFocusIgnored(input);
      this.input = input;
      this.isFirst = props.isFirst;
      this.isOutside = isOutside;
      this._isPhantom = (_a17 = props.isPhantom) !== null && _a17 !== void 0 ? _a17 : false;
      this._fixedTarget = fixedTarget;
      input.addEventListener("focusin", this._focusIn);
      input.addEventListener("focusout", this._focusOut);
      input.__tabsterDummyContainer = element4;
      if (this._isPhantom) {
        this._disposeTimer = win.setTimeout(() => {
          delete this._disposeTimer;
          this.dispose();
        }, 0);
        this._clearDisposeTimeout = () => {
          if (this._disposeTimer) {
            win.clearTimeout(this._disposeTimer);
            delete this._disposeTimer;
          }
          delete this._clearDisposeTimeout;
        };
      }
    }
    dispose() {
      var _a17;
      if (this._clearDisposeTimeout) {
        this._clearDisposeTimeout();
      }
      const input = this.input;
      if (!input) {
        return;
      }
      delete this._fixedTarget;
      delete this.onFocusIn;
      delete this.onFocusOut;
      delete this.input;
      input.removeEventListener("focusin", this._focusIn);
      input.removeEventListener("focusout", this._focusOut);
      delete input.__tabsterDummyContainer;
      (_a17 = dom.getParentNode(input)) === null || _a17 === void 0 ? void 0 : _a17.removeChild(input);
    }
    setTopLeft(top, left) {
      var _a17;
      const style = (_a17 = this.input) === null || _a17 === void 0 ? void 0 : _a17.style;
      if (style) {
        style.top = `${top}px`;
        style.left = `${left}px`;
      }
    }
    _isBackward(isIn, current, previous3) {
      return isIn && !previous3 ? !this.isFirst : !!(previous3 && current.compareDocumentPosition(previous3) & Node.DOCUMENT_POSITION_FOLLOWING);
    }
  };
  var DummyInputManagerPriorities = {
    Root: 1,
    Modalizer: 2,
    Mover: 3,
    Groupper: 4
  };
  var DummyInputManager = class {
    constructor(tabster, element4, priority, sys, outsideByDefault, callForDefaultAction) {
      this._element = element4;
      this._instance = new DummyInputManagerCore(tabster, element4, this, priority, sys, outsideByDefault, callForDefaultAction);
    }
    _setHandlers(onFocusIn, onFocusOut) {
      this._onFocusIn = onFocusIn;
      this._onFocusOut = onFocusOut;
    }
    moveOut(backwards) {
      var _a17;
      (_a17 = this._instance) === null || _a17 === void 0 ? void 0 : _a17.moveOut(backwards);
    }
    moveOutWithDefaultAction(backwards, relatedEvent) {
      var _a17;
      (_a17 = this._instance) === null || _a17 === void 0 ? void 0 : _a17.moveOutWithDefaultAction(backwards, relatedEvent);
    }
    getHandler(isIn) {
      return isIn ? this._onFocusIn : this._onFocusOut;
    }
    setTabbable(tabbable) {
      var _a17;
      (_a17 = this._instance) === null || _a17 === void 0 ? void 0 : _a17.setTabbable(this, tabbable);
    }
    dispose() {
      if (this._instance) {
        this._instance.dispose(this);
        delete this._instance;
      }
      delete this._onFocusIn;
      delete this._onFocusOut;
    }
    static moveWithPhantomDummy(tabster, element4, moveOutOfElement, isBackward, relatedEvent) {
      const dummy = new DummyInput(tabster.getWindow, true, {
        isPhantom: true,
        isFirst: true
      });
      const input = dummy.input;
      if (input) {
        let parent;
        let insertBefore;
        if (element4.tagName === "BODY") {
          parent = element4;
          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element4) : null;
        } else {
          if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element4, false, true, true))) {
            parent = element4;
            insertBefore = isBackward ? element4.firstElementChild : null;
          } else {
            parent = dom.getParentElement(element4);
            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element4 : dom.getNextElementSibling(element4);
          }
          let potentialDummy;
          let dummyFor;
          do {
            potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;
            dummyFor = getDummyInputContainer(potentialDummy);
            if (dummyFor === element4) {
              insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);
            } else {
              dummyFor = null;
            }
          } while (dummyFor);
        }
        if (parent === null || parent === void 0 ? void 0 : parent.dispatchEvent(new TabsterMoveFocusEvent({
          by: "root",
          owner: parent,
          next: null,
          relatedEvent
        }))) {
          dom.insertBefore(parent, input, insertBefore);
          nativeFocus(input);
        }
      }
    }
    static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
      const dummy = new DummyInput(tabster.getWindow, true, {
        isPhantom: true,
        isFirst: true
      }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
      const input = dummy.input;
      if (input) {
        let dummyParent;
        let insertBefore;
        if (hasSubFocusable(sourceElement) && !isBackward) {
          dummyParent = sourceElement;
          insertBefore = dom.getFirstElementChild(sourceElement);
        } else {
          dummyParent = dom.getParentElement(sourceElement);
          insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);
        }
        if (dummyParent) {
          dom.insertBefore(dummyParent, input, insertBefore);
        }
      }
    }
  };
  var DummyInputObserver = class {
    constructor(win) {
      this._updateQueue = /* @__PURE__ */ new Set();
      this._lastUpdateQueueTime = 0;
      this._changedParents = /* @__PURE__ */ new WeakSet();
      this._dummyElements = [];
      this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
      this._domChanged = (parent) => {
        var _a17;
        if (this._changedParents.has(parent)) {
          return;
        }
        this._changedParents.add(parent);
        if (this._updateDummyInputsTimer) {
          return;
        }
        this._updateDummyInputsTimer = (_a17 = this._win) === null || _a17 === void 0 ? void 0 : _a17.call(this).setTimeout(() => {
          delete this._updateDummyInputsTimer;
          for (const ref of this._dummyElements) {
            const dummyElement = ref.get();
            if (dummyElement) {
              const callback = this._dummyCallbacks.get(dummyElement);
              if (callback) {
                const dummyParent = dom.getParentNode(dummyElement);
                if (!dummyParent || this._changedParents.has(dummyParent)) {
                  callback();
                }
              }
            }
          }
          this._changedParents = /* @__PURE__ */ new WeakSet();
        }, _updateDummyInputsTimeout);
      };
      this._win = win;
    }
    add(dummy, callback) {
      if (!this._dummyCallbacks.has(dummy) && this._win) {
        this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
        this._dummyCallbacks.set(dummy, callback);
        this.domChanged = this._domChanged;
      }
    }
    remove(dummy) {
      this._dummyElements = this._dummyElements.filter((ref) => {
        const element4 = ref.get();
        return element4 && element4 !== dummy;
      });
      this._dummyCallbacks.delete(dummy);
      if (this._dummyElements.length === 0) {
        delete this.domChanged;
      }
    }
    dispose() {
      var _a17;
      const win = (_a17 = this._win) === null || _a17 === void 0 ? void 0 : _a17.call(this);
      if (this._updateTimer) {
        win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      if (this._updateDummyInputsTimer) {
        win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
        delete this._updateDummyInputsTimer;
      }
      this._changedParents = /* @__PURE__ */ new WeakSet();
      this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
      this._dummyElements = [];
      this._updateQueue.clear();
      delete this.domChanged;
      delete this._win;
    }
    updatePositions(compute) {
      if (!this._win) {
        return;
      }
      this._updateQueue.add(compute);
      this._lastUpdateQueueTime = Date.now();
      this._scheduledUpdatePositions();
    }
    _scheduledUpdatePositions() {
      var _a17;
      if (this._updateTimer) {
        return;
      }
      this._updateTimer = (_a17 = this._win) === null || _a17 === void 0 ? void 0 : _a17.call(this).setTimeout(() => {
        delete this._updateTimer;
        if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
          const scrollTopLeftCache = /* @__PURE__ */ new Map();
          const setTopLeftCallbacks = [];
          for (const compute of this._updateQueue) {
            setTopLeftCallbacks.push(compute(scrollTopLeftCache));
          }
          this._updateQueue.clear();
          for (const setTopLeft of setTopLeftCallbacks) {
            setTopLeft();
          }
          scrollTopLeftCache.clear();
        } else {
          this._scheduledUpdatePositions();
        }
      }, _updateDummyInputsTimeout);
    }
  };
  var DummyInputManagerCore = class {
    constructor(tabster, element4, manager, priority, sys, outsideByDefault, callForDefaultAction) {
      this._wrappers = [];
      this._isOutside = false;
      this._transformElements = /* @__PURE__ */ new Set();
      this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
        this._onFocus(true, dummyInput, isBackward, relatedTarget);
      };
      this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
        this._onFocus(false, dummyInput, isBackward, relatedTarget);
      };
      this.moveOut = (backwards) => {
        var _a17;
        const first = this._firstDummy;
        const last = this._lastDummy;
        if (first && last) {
          this._ensurePosition();
          const firstInput = first.input;
          const lastInput = last.input;
          const element5 = (_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get();
          if (firstInput && lastInput && element5) {
            let toFocus;
            if (backwards) {
              firstInput.tabIndex = 0;
              toFocus = firstInput;
            } else {
              lastInput.tabIndex = 0;
              toFocus = lastInput;
            }
            if (toFocus) {
              nativeFocus(toFocus);
            }
          }
        }
      };
      this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
        var _a17;
        const first = this._firstDummy;
        const last = this._lastDummy;
        if (first && last) {
          this._ensurePosition();
          const firstInput = first.input;
          const lastInput = last.input;
          const element5 = (_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get();
          if (firstInput && lastInput && element5) {
            let toFocus;
            if (backwards) {
              if (!first.isOutside && this._tabster.focusable.isFocusable(element5, true, true, true)) {
                toFocus = element5;
              } else {
                first.useDefaultAction = true;
                firstInput.tabIndex = 0;
                toFocus = firstInput;
              }
            } else {
              last.useDefaultAction = true;
              lastInput.tabIndex = 0;
              toFocus = lastInput;
            }
            if (toFocus && element5.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: element5,
              next: null,
              relatedEvent
            }))) {
              nativeFocus(toFocus);
            }
          }
        }
      };
      this.setTabbable = (manager2, tabbable) => {
        var _a17, _b;
        for (const w of this._wrappers) {
          if (w.manager === manager2) {
            w.tabbable = tabbable;
            break;
          }
        }
        const wrapper = this._getCurrent();
        if (wrapper) {
          const tabIndex = wrapper.tabbable ? 0 : -1;
          let input = (_a17 = this._firstDummy) === null || _a17 === void 0 ? void 0 : _a17.input;
          if (input) {
            input.tabIndex = tabIndex;
          }
          input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
          if (input) {
            input.tabIndex = tabIndex;
          }
        }
        if (false) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
        }
      };
      this._addDummyInputs = () => {
        if (this._addTimer) {
          return;
        }
        this._addTimer = this._getWindow().setTimeout(() => {
          delete this._addTimer;
          this._ensurePosition();
          if (false) {
            this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
            this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
          }
          this._addTransformOffsets();
        }, 0);
      };
      this._addTransformOffsets = () => {
        this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
      };
      this._computeTransformOffsets = (scrollTopLeftCache) => {
        var _a17, _b;
        const from2 = ((_a17 = this._firstDummy) === null || _a17 === void 0 ? void 0 : _a17.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
        const transformElements = this._transformElements;
        const newTransformElements = /* @__PURE__ */ new Set();
        let scrollTop = 0;
        let scrollLeft = 0;
        const win = this._getWindow();
        for (let element5 = from2; element5 && element5.nodeType === Node.ELEMENT_NODE; element5 = dom.getParentElement(element5)) {
          let scrollTopLeft = scrollTopLeftCache.get(element5);
          if (scrollTopLeft === void 0) {
            const transform3 = win.getComputedStyle(element5).transform;
            if (transform3 && transform3 !== "none") {
              scrollTopLeft = {
                scrollTop: element5.scrollTop,
                scrollLeft: element5.scrollLeft
              };
            }
            scrollTopLeftCache.set(element5, scrollTopLeft || null);
          }
          if (scrollTopLeft) {
            newTransformElements.add(element5);
            if (!transformElements.has(element5)) {
              element5.addEventListener("scroll", this._addTransformOffsets);
            }
            scrollTop += scrollTopLeft.scrollTop;
            scrollLeft += scrollTopLeft.scrollLeft;
          }
        }
        for (const el2 of transformElements) {
          if (!newTransformElements.has(el2)) {
            el2.removeEventListener("scroll", this._addTransformOffsets);
          }
        }
        this._transformElements = newTransformElements;
        return () => {
          var _a18, _b2;
          (_a18 = this._firstDummy) === null || _a18 === void 0 ? void 0 : _a18.setTopLeft(scrollTop, scrollLeft);
          (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
        };
      };
      const el = element4.get();
      if (!el) {
        throw new Error("No element");
      }
      this._tabster = tabster;
      this._getWindow = tabster.getWindow;
      this._callForDefaultAction = callForDefaultAction;
      const instance = el.__tabsterDummy;
      (instance || this)._wrappers.push({
        manager,
        priority,
        tabbable: true
      });
      if (instance) {
        if (false) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
        }
        return instance;
      }
      el.__tabsterDummy = this;
      const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
      const tagName = el.tagName;
      this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
      this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
        isFirst: true
      }, element4);
      this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
        isFirst: false
      }, element4);
      const dummyElement = this._firstDummy.input;
      dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
      this._firstDummy.onFocusIn = this._onFocusIn;
      this._firstDummy.onFocusOut = this._onFocusOut;
      this._lastDummy.onFocusIn = this._onFocusIn;
      this._lastDummy.onFocusOut = this._onFocusOut;
      this._element = element4;
      this._addDummyInputs();
    }
    dispose(manager, force) {
      var _a17, _b, _c, _d;
      const wrappers = this._wrappers = this._wrappers.filter((w) => w.manager !== manager && !force);
      if (false) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
      }
      if (wrappers.length === 0) {
        delete ((_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get()).__tabsterDummy;
        for (const el of this._transformElements) {
          el.removeEventListener("scroll", this._addTransformOffsets);
        }
        this._transformElements.clear();
        const win = this._getWindow();
        if (this._addTimer) {
          win.clearTimeout(this._addTimer);
          delete this._addTimer;
        }
        const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
        dummyElement && this._tabster._dummyObserver.remove(dummyElement);
        (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
      var _a17;
      const wrapper = this._getCurrent();
      if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
        (_a17 = wrapper.manager.getHandler(isIn)) === null || _a17 === void 0 ? void 0 : _a17(dummyInput, isBackward, relatedTarget);
      }
    }
    _getCurrent() {
      this._wrappers.sort((a, b) => {
        if (a.tabbable !== b.tabbable) {
          return a.tabbable ? -1 : 1;
        }
        return a.priority - b.priority;
      });
      return this._wrappers[0];
    }
    _ensurePosition() {
      var _a17, _b, _c;
      const element4 = (_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get();
      const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
      const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
      if (!element4 || !firstDummyInput || !lastDummyInput) {
        return;
      }
      if (this._isOutside) {
        const elementParent = dom.getParentNode(element4);
        if (elementParent) {
          const nextSibling = dom.getNextSibling(element4);
          if (nextSibling !== lastDummyInput) {
            dom.insertBefore(elementParent, lastDummyInput, nextSibling);
          }
          if (dom.getPreviousElementSibling(element4) !== firstDummyInput) {
            dom.insertBefore(elementParent, firstDummyInput, element4);
          }
        }
      } else {
        if (dom.getLastElementChild(element4) !== lastDummyInput) {
          dom.appendChild(element4, lastDummyInput);
        }
        const firstElementChild = dom.getFirstElementChild(element4);
        if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {
          dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);
        }
      }
    }
  };
  function getLastChild$2(container2) {
    let lastChild = null;
    for (let i = dom.getLastElementChild(container2); i; i = dom.getLastElementChild(i)) {
      lastChild = i;
    }
    return lastChild || void 0;
  }
  function getAdjacentElement(from2, prev2) {
    let cur = from2;
    let adjacent = null;
    while (cur && !adjacent) {
      adjacent = prev2 ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);
      cur = dom.getParentElement(cur);
    }
    return adjacent || void 0;
  }
  function augmentAttribute(tabster, element4, name21, value) {
    const entry = tabster.storageEntry(element4, true);
    let ret = false;
    if (!entry.aug) {
      if (value === void 0) {
        return ret;
      }
      entry.aug = {};
    }
    if (value === void 0) {
      if (name21 in entry.aug) {
        const origVal = entry.aug[name21];
        delete entry.aug[name21];
        if (origVal === null) {
          element4.removeAttribute(name21);
        } else {
          element4.setAttribute(name21, origVal);
        }
        ret = true;
      }
    } else {
      let origValue;
      if (!(name21 in entry.aug)) {
        origValue = element4.getAttribute(name21);
      }
      if (origValue !== void 0 && origValue !== value) {
        entry.aug[name21] = origValue;
        if (value === null) {
          element4.removeAttribute(name21);
        } else {
          element4.setAttribute(name21, value);
        }
        ret = true;
      }
    }
    if (value === void 0 && Object.keys(entry.aug).length === 0) {
      delete entry.aug;
      tabster.storageEntry(element4, false);
    }
    return ret;
  }
  function isDisplayNone(element4) {
    var _a17, _b;
    const elementDocument = element4.ownerDocument;
    const computedStyle = (_a17 = elementDocument.defaultView) === null || _a17 === void 0 ? void 0 : _a17.getComputedStyle(element4);
    if (element4.offsetParent === null && elementDocument.body !== element4 && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== "fixed") {
      return true;
    }
    if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === "hidden") {
      return true;
    }
    if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === "fixed") {
      if (computedStyle.display === "none") {
        return true;
      }
      if (((_b = element4.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element4.parentElement) {
        return true;
      }
    }
    return false;
  }
  function isRadio(element4) {
    return element4.tagName === "INPUT" && !!element4.name && element4.type === "radio";
  }
  function getRadioButtonGroup(element4) {
    if (!isRadio(element4)) {
      return;
    }
    const name21 = element4.name;
    let radioButtons = Array.from(dom.getElementsByName(element4, name21));
    let checked;
    radioButtons = radioButtons.filter((el) => {
      if (isRadio(el)) {
        if (el.checked) {
          checked = el;
        }
        return true;
      }
      return false;
    });
    return {
      name: name21,
      buttons: new Set(radioButtons),
      checked
    };
  }
  function getDummyInputContainer(element4) {
    var _a17;
    return ((_a17 = element4 === null || element4 === void 0 ? void 0 : element4.__tabsterDummyContainer) === null || _a17 === void 0 ? void 0 : _a17.get()) || null;
  }
  function getTabsterAttribute(props, plain) {
    const attr = JSON.stringify(props);
    if (plain === true) {
      return attr;
    }
    return {
      [TABSTER_ATTRIBUTE_NAME]: attr
    };
  }
  function mergeTabsterProps(props, newProps) {
    for (const key of Object.keys(newProps)) {
      const value = newProps[key];
      if (value) {
        props[key] = value;
      } else {
        delete props[key];
      }
    }
  }
  function setTabsterAttribute(element4, newProps, update) {
    let props;
    if (update) {
      const attr = element4.getAttribute(TABSTER_ATTRIBUTE_NAME);
      if (attr) {
        try {
          props = JSON.parse(attr);
        } catch (e) {
          if (false) {
            console.error(`data-tabster attribute error: ${e}`, element4);
          }
        }
      }
    }
    if (!props) {
      props = {};
    }
    mergeTabsterProps(props, newProps);
    if (Object.keys(props).length > 0) {
      element4.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));
    } else {
      element4.removeAttribute(TABSTER_ATTRIBUTE_NAME);
    }
  }
  var RootDummyManager = class extends DummyInputManager {
    constructor(tabster, element4, setFocused, sys) {
      super(tabster, element4, DummyInputManagerPriorities.Root, sys, void 0, true);
      this._onDummyInputFocus = (dummyInput) => {
        var _a17;
        if (dummyInput.useDefaultAction) {
          this._setFocused(false);
        } else {
          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
          const element5 = this._element.get();
          if (element5) {
            this._setFocused(true);
            const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
              container: element5,
              ignoreAccessibility: true
            });
            if (toFocus) {
              nativeFocus(toFocus);
              return;
            }
          }
          (_a17 = dummyInput.input) === null || _a17 === void 0 ? void 0 : _a17.blur();
        }
      };
      this._setHandlers(this._onDummyInputFocus);
      this._tabster = tabster;
      this._setFocused = setFocused;
    }
  };
  var Root = class extends TabsterPart {
    constructor(tabster, element4, onDispose, props, sys) {
      super(tabster, element4, props);
      this._isFocused = false;
      this._setFocused = (hasFocused) => {
        var _a17;
        if (this._setFocusedTimer) {
          this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
          delete this._setFocusedTimer;
        }
        if (this._isFocused === hasFocused) {
          return;
        }
        const element5 = this._element.get();
        if (element5) {
          if (hasFocused) {
            this._isFocused = true;
            (_a17 = this._dummyManager) === null || _a17 === void 0 ? void 0 : _a17.setTabbable(false);
            element5.dispatchEvent(new RootFocusEvent({
              element: element5
            }));
          } else {
            this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
              var _a18;
              delete this._setFocusedTimer;
              this._isFocused = false;
              (_a18 = this._dummyManager) === null || _a18 === void 0 ? void 0 : _a18.setTabbable(true);
              element5.dispatchEvent(new RootBlurEvent({
                element: element5
              }));
            }, 0);
          }
        }
      };
      this._onFocusIn = (event) => {
        const getParent2 = this._tabster.getParent;
        const rootElement = this._element.get();
        let curElement = event.composedPath()[0];
        do {
          if (curElement === rootElement) {
            this._setFocused(true);
            return;
          }
          curElement = curElement && getParent2(curElement);
        } while (curElement);
      };
      this._onFocusOut = () => {
        this._setFocused(false);
      };
      this._onDispose = onDispose;
      const win = tabster.getWindow;
      this.uid = getElementUId(win, element4);
      this._sys = sys;
      if (tabster.controlTab || tabster.rootDummyInputs) {
        this.addDummyInputs();
      }
      const w = win();
      const doc = w.document;
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
      doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
      this._add();
    }
    addDummyInputs() {
      if (!this._dummyManager) {
        this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
      }
    }
    dispose() {
      var _a17;
      this._onDispose(this);
      const win = this._tabster.getWindow();
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
      doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
      if (this._setFocusedTimer) {
        win.clearTimeout(this._setFocusedTimer);
        delete this._setFocusedTimer;
      }
      (_a17 = this._dummyManager) === null || _a17 === void 0 ? void 0 : _a17.dispose();
      this._remove();
    }
    moveOutWithDefaultAction(isBackward, relatedEvent) {
      const dummyManager = this._dummyManager;
      if (dummyManager) {
        dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
      } else {
        const el = this.getElement();
        if (el) {
          RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
        }
      }
    }
    _add() {
      if (false) {
        _setInformativeStyle$3(this._element, false, this.uid);
      }
    }
    _remove() {
      if (false) {
        _setInformativeStyle$3(this._element, true);
      }
    }
  };
  var RootAPI = class {
    constructor(tabster, autoRoot) {
      this._autoRootWaiting = false;
      this._roots = {};
      this._forceDummy = false;
      this.rootById = {};
      this._autoRootCreate = () => {
        var _a17;
        const doc = this._win().document;
        const body = doc.body;
        if (body) {
          this._autoRootUnwait(doc);
          const props = this._autoRoot;
          if (props) {
            setTabsterAttribute(body, {
              root: props
            }, true);
            updateTabsterByAttribute(this._tabster, body);
            return (_a17 = getTabsterOnElement(this._tabster, body)) === null || _a17 === void 0 ? void 0 : _a17.root;
          }
        } else if (!this._autoRootWaiting) {
          this._autoRootWaiting = true;
          doc.addEventListener("readystatechange", this._autoRootCreate);
        }
        return void 0;
      };
      this._onRootDispose = (root5) => {
        delete this._roots[root5.id];
      };
      this._tabster = tabster;
      this._win = tabster.getWindow;
      this._autoRoot = autoRoot;
      tabster.queueInit(() => {
        if (this._autoRoot) {
          this._autoRootCreate();
        }
      });
    }
    _autoRootUnwait(doc) {
      doc.removeEventListener("readystatechange", this._autoRootCreate);
      this._autoRootWaiting = false;
    }
    dispose() {
      const win = this._win();
      this._autoRootUnwait(win.document);
      delete this._autoRoot;
      Object.keys(this._roots).forEach((rootId) => {
        if (this._roots[rootId]) {
          this._roots[rootId].dispose();
          delete this._roots[rootId];
        }
      });
      this.rootById = {};
    }
    createRoot(element4, props, sys) {
      if (false) ;
      const newRoot = new Root(this._tabster, element4, this._onRootDispose, props, sys);
      this._roots[newRoot.id] = newRoot;
      if (this._forceDummy) {
        newRoot.addDummyInputs();
      }
      return newRoot;
    }
    addDummyInputs() {
      this._forceDummy = true;
      const roots = this._roots;
      for (const id of Object.keys(roots)) {
        roots[id].addDummyInputs();
      }
    }
    static getRootByUId(getWindow2, id) {
      const tabster = getWindow2().__tabsterInstance;
      return tabster && tabster.root.rootById[id];
    }
    /**
     * Fetches the tabster context for an element walking up its ancestors
     *
     * @param tabster Tabster instance
     * @param element The element the tabster context should represent
     * @param options Additional options
     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
     */
    static getTabsterContext(tabster, element4, options) {
      if (options === void 0) {
        options = {};
      }
      var _a17, _b, _c, _d;
      if (!element4.ownerDocument) {
        return void 0;
      }
      const {
        checkRtl,
        referenceElement
      } = options;
      const getParent2 = tabster.getParent;
      tabster.drainInitQueue();
      let root5;
      let modalizer;
      let groupper;
      let mover;
      let excludedFromMover = false;
      let groupperBeforeMover;
      let modalizerInGroupper;
      let dirRightToLeft;
      let uncontrolled;
      let curElement = referenceElement || element4;
      const ignoreKeydown = {};
      while (curElement && (!root5 || checkRtl)) {
        const tabsterOnElement = getTabsterOnElement(tabster, curElement);
        if (checkRtl && dirRightToLeft === void 0) {
          const dir = curElement.dir;
          if (dir) {
            dirRightToLeft = dir.toLowerCase() === "rtl";
          }
        }
        if (!tabsterOnElement) {
          curElement = getParent2(curElement);
          continue;
        }
        const tagName = curElement.tagName;
        if ((tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") && tabster.focusable.isVisible(curElement)) {
          uncontrolled = curElement;
        }
        if (!mover && ((_a17 = tabsterOnElement.focusable) === null || _a17 === void 0 ? void 0 : _a17.excludeFromMover) && !groupper) {
          excludedFromMover = true;
        }
        const curModalizer = tabsterOnElement.modalizer;
        const curGroupper = tabsterOnElement.groupper;
        const curMover = tabsterOnElement.mover;
        if (!modalizer && curModalizer) {
          modalizer = curModalizer;
        }
        if (!groupper && curGroupper && (!modalizer || curModalizer)) {
          if (modalizer) {
            if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
              modalizer = void 0;
              groupper = curGroupper;
            }
            modalizerInGroupper = curGroupper;
          } else {
            groupper = curGroupper;
          }
        }
        if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element4) && curElement.contains(element4)) {
          mover = curMover;
          groupperBeforeMover = !!groupper && groupper !== curGroupper;
        }
        if (tabsterOnElement.root) {
          root5 = tabsterOnElement.root;
        }
        if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
          Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
        }
        curElement = getParent2(curElement);
      }
      if (!root5) {
        const rootAPI = tabster.root;
        const autoRoot = rootAPI._autoRoot;
        if (autoRoot) {
          if ((_d = element4.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
            root5 = rootAPI._autoRootCreate();
          }
        }
      }
      if (groupper && !mover) {
        groupperBeforeMover = true;
      }
      if (false) {
        if (modalizer || groupper || mover) {
          console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
        }
      }
      const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
      return root5 ? {
        root: root5,
        modalizer,
        groupper,
        mover,
        groupperBeforeMover,
        modalizerInGroupper,
        rtl: checkRtl ? !!dirRightToLeft : void 0,
        uncontrolled,
        excludedFromMover,
        ignoreKeydown: shouldIgnoreKeydown
      } : void 0;
    }
    static getRoot(tabster, element4) {
      var _a17;
      const getParent2 = tabster.getParent;
      for (let el = element4; el; el = getParent2(el)) {
        const root5 = (_a17 = getTabsterOnElement(tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.root;
        if (root5) {
          return root5;
        }
      }
      return void 0;
    }
    onRoot(root5, removed) {
      if (removed) {
        delete this.rootById[root5.uid];
      } else {
        this.rootById[root5.uid] = root5;
      }
    }
  };
  var Subscribable = class {
    constructor() {
      this._callbacks = [];
    }
    dispose() {
      this._callbacks = [];
      delete this._val;
    }
    subscribe(callback) {
      const callbacks = this._callbacks;
      const index2 = callbacks.indexOf(callback);
      if (index2 < 0) {
        callbacks.push(callback);
      }
    }
    subscribeFirst(callback) {
      const callbacks = this._callbacks;
      const index2 = callbacks.indexOf(callback);
      if (index2 >= 0) {
        callbacks.splice(index2, 1);
      }
      callbacks.unshift(callback);
    }
    unsubscribe(callback) {
      const index2 = this._callbacks.indexOf(callback);
      if (index2 >= 0) {
        this._callbacks.splice(index2, 1);
      }
    }
    setVal(val, detail) {
      if (this._val === val) {
        return;
      }
      this._val = val;
      this._callCallbacks(val, detail);
    }
    getVal() {
      return this._val;
    }
    trigger(val, detail) {
      this._callCallbacks(val, detail);
    }
    _callCallbacks(val, detail) {
      this._callbacks.forEach((callback) => callback(val, detail));
    }
  };
  var FocusableAPI = class {
    constructor(tabster) {
      this._tabster = tabster;
    }
    dispose() {
    }
    getProps(element4) {
      const tabsterOnElement = getTabsterOnElement(this._tabster, element4);
      return tabsterOnElement && tabsterOnElement.focusable || {};
    }
    isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
      if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
        return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
      }
      return false;
    }
    isVisible(el) {
      if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
        return false;
      }
      if (isDisplayNone(el)) {
        return false;
      }
      const rect = el.ownerDocument.body.getBoundingClientRect();
      if (rect.width === 0 && rect.height === 0) {
        return false;
      }
      return true;
    }
    isAccessible(el) {
      var _a17;
      for (let e = el; e; e = dom.getParentElement(e)) {
        const tabsterOnElement = getTabsterOnElement(this._tabster, e);
        if (this._isHidden(e)) {
          return false;
        }
        const ignoreDisabled = (_a17 = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a17 === void 0 ? void 0 : _a17.ignoreAriaDisabled;
        if (!ignoreDisabled && this._isDisabled(e)) {
          return false;
        }
      }
      return true;
    }
    _isDisabled(el) {
      return el.hasAttribute("disabled");
    }
    _isHidden(el) {
      var _a17;
      const attrVal = el.getAttribute("aria-hidden");
      if (attrVal && attrVal.toLowerCase() === "true") {
        if (!((_a17 = this._tabster.modalizer) === null || _a17 === void 0 ? void 0 : _a17.isAugmented(el))) {
          return true;
        }
      }
      return false;
    }
    findFirst(options, out) {
      return this.findElement({
        ...options
      }, out);
    }
    findLast(options, out) {
      return this.findElement({
        isBackward: true,
        ...options
      }, out);
    }
    findNext(options, out) {
      return this.findElement({
        ...options
      }, out);
    }
    findPrev(options, out) {
      return this.findElement({
        ...options,
        isBackward: true
      }, out);
    }
    findDefault(options, out) {
      return this.findElement({
        ...options,
        acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
      }, out) || null;
    }
    findAll(options) {
      return this._findElements(true, options) || [];
    }
    findElement(options, out) {
      const found = this._findElements(false, options, out);
      return found ? found[0] : found;
    }
    _findElements(isFindAll, options, out) {
      var _a17, _b, _c;
      const {
        container: container2,
        currentElement = null,
        includeProgrammaticallyFocusable,
        useActiveModalizer,
        ignoreAccessibility,
        modalizerId,
        isBackward,
        onElement
      } = options;
      if (!out) {
        out = {};
      }
      const elements = [];
      let {
        acceptCondition
      } = options;
      const hasCustomCondition = !!acceptCondition;
      if (!container2) {
        return null;
      }
      if (!acceptCondition) {
        acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
      }
      const acceptElementState = {
        container: container2,
        modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a17 = this._tabster.modalizer) === null || _a17 === void 0 ? void 0 : _a17.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container2)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
        from: currentElement || container2,
        isBackward,
        isFindAll,
        acceptCondition,
        hasCustomCondition,
        includeProgrammaticallyFocusable,
        ignoreAccessibility,
        cachedGrouppers: {},
        cachedRadioGroups: {}
      };
      const walker = createElementTreeWalker(container2.ownerDocument, container2, (node3) => this._acceptElement(node3, acceptElementState));
      if (!walker) {
        return null;
      }
      const prepareForNextElement = (shouldContinueIfNotFound) => {
        var _a18, _b2;
        const foundElement = (_a18 = acceptElementState.foundElement) !== null && _a18 !== void 0 ? _a18 : acceptElementState.foundBackward;
        if (foundElement) {
          elements.push(foundElement);
        }
        if (isFindAll) {
          if (foundElement) {
            acceptElementState.found = false;
            delete acceptElementState.foundElement;
            delete acceptElementState.foundBackward;
            delete acceptElementState.fromCtx;
            acceptElementState.from = foundElement;
            if (onElement && !onElement(foundElement)) {
              return false;
            }
          }
          return !!(foundElement || shouldContinueIfNotFound);
        } else {
          if (foundElement && out) {
            out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
          }
          return !!(shouldContinueIfNotFound && !foundElement);
        }
      };
      if (!currentElement) {
        out.outOfDOMOrder = true;
      }
      if (currentElement && dom.nodeContains(container2, currentElement)) {
        walker.currentNode = currentElement;
      } else if (isBackward) {
        const lastChild = getLastChild$2(container2);
        if (!lastChild) {
          return null;
        }
        if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
          if (acceptElementState.skippedFocusable) {
            out.outOfDOMOrder = true;
          }
          return elements;
        }
        walker.currentNode = lastChild;
      }
      do {
        if (isBackward) {
          walker.previousNode();
        } else {
          walker.nextNode();
        }
      } while (prepareForNextElement());
      if (acceptElementState.skippedFocusable) {
        out.outOfDOMOrder = true;
      }
      return elements.length ? elements : null;
    }
    _acceptElement(element4, state) {
      var _a17, _b, _c;
      if (state.found) {
        return NodeFilter.FILTER_ACCEPT;
      }
      const foundBackward = state.foundBackward;
      if (foundBackward && (element4 === foundBackward || !dom.nodeContains(foundBackward, element4))) {
        state.found = true;
        state.foundElement = foundBackward;
        return NodeFilter.FILTER_ACCEPT;
      }
      const container2 = state.container;
      if (element4 === container2) {
        return NodeFilter.FILTER_SKIP;
      }
      if (!dom.nodeContains(container2, element4)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (getDummyInputContainer(element4)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (dom.nodeContains(state.rejectElementsFrom, element4)) {
        return NodeFilter.FILTER_REJECT;
      }
      const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element4);
      if (!ctx) {
        return NodeFilter.FILTER_SKIP;
      }
      if (shouldIgnoreFocus(element4)) {
        if (this.isFocusable(element4, void 0, true, true)) {
          state.skippedFocusable = true;
        }
        return NodeFilter.FILTER_SKIP;
      }
      if (!state.hasCustomCondition && (element4.tagName === "IFRAME" || element4.tagName === "WEBVIEW")) {
        if (this.isVisible(element4) && ((_a17 = ctx.modalizer) === null || _a17 === void 0 ? void 0 : _a17.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
          state.found = true;
          state.rejectElementsFrom = state.foundElement = element4;
          return NodeFilter.FILTER_ACCEPT;
        } else {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (!state.ignoreAccessibility && !this.isAccessible(element4)) {
        if (this.isFocusable(element4, false, true, true)) {
          state.skippedFocusable = true;
        }
        return NodeFilter.FILTER_REJECT;
      }
      let result;
      let fromCtx = state.fromCtx;
      if (!fromCtx) {
        fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
      }
      const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
      let groupper = ctx.groupper;
      let mover = ctx.mover;
      result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element4, state);
      if (result !== void 0) {
        state.skippedFocusable = true;
      }
      if (result === void 0 && (groupper || mover || fromMover)) {
        const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
        const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
        let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
        if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container2, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {
          mover = fromMover;
          moverElement = fromMoverElement;
        }
        if (groupperElement) {
          if (groupperElement === container2 || !dom.nodeContains(container2, groupperElement)) {
            groupper = void 0;
          } else if (!dom.nodeContains(groupperElement, element4)) {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (moverElement) {
          if (!dom.nodeContains(container2, moverElement)) {
            mover = void 0;
          } else if (!dom.nodeContains(moverElement, element4)) {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (groupper && mover) {
          if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {
            mover = void 0;
          } else {
            groupper = void 0;
          }
        }
        if (groupper) {
          result = groupper.acceptElement(element4, state);
        }
        if (mover) {
          result = mover.acceptElement(element4, state);
        }
      }
      if (result === void 0) {
        result = state.acceptCondition(element4) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element4, false, true, true)) {
          state.skippedFocusable = true;
        }
      }
      if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
        if (!state.isFindAll && isRadio(element4) && !element4.checked) {
          const radioGroupName = element4.name;
          let radioGroup = state.cachedRadioGroups[radioGroupName];
          if (!radioGroup) {
            radioGroup = getRadioButtonGroup(element4);
            if (radioGroup) {
              state.cachedRadioGroups[radioGroupName] = radioGroup;
            }
          }
          if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element4) {
            return NodeFilter.FILTER_SKIP;
          }
        }
        if (state.isBackward) {
          state.foundBackward = element4;
          result = NodeFilter.FILTER_SKIP;
        } else {
          state.found = true;
          state.foundElement = element4;
        }
      }
      return result;
    }
  };
  var Keys = {
    Tab: "Tab",
    Enter: "Enter",
    Escape: "Escape",
    PageUp: "PageUp",
    PageDown: "PageDown",
    End: "End",
    Home: "Home",
    ArrowLeft: "ArrowLeft",
    ArrowUp: "ArrowUp",
    ArrowRight: "ArrowRight",
    ArrowDown: "ArrowDown"
  };
  function getUncontrolledCompletelyContainer(tabster, element4) {
    var _a17;
    const getParent2 = tabster.getParent;
    let el = element4;
    do {
      const uncontrolledOnElement = (_a17 = getTabsterOnElement(tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.uncontrolled;
      if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
        return el;
      }
      el = getParent2(el);
    } while (el);
    return void 0;
  }
  var AsyncFocusIntentPriorityBySource = {
    [AsyncFocusSources.Restorer]: 0,
    [AsyncFocusSources.Deloser]: 1,
    [AsyncFocusSources.EscapeGroupper]: 2
  };
  var FocusedElementState = class _FocusedElementState extends Subscribable {
    constructor(tabster, getWindow2) {
      super();
      this._init = () => {
        const win = this._win();
        const doc = win.document;
        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
        win.addEventListener("keydown", this._onKeyDown, true);
        const activeElement = dom.getActiveElement(doc);
        if (activeElement && activeElement !== doc.body) {
          this._setFocusedElement(activeElement);
        }
        this.subscribe(this._onChanged);
      };
      this._onFocusIn = (e) => {
        const target = e.composedPath()[0];
        if (target) {
          this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);
        }
      };
      this._onFocusOut = (e) => {
        var _a17;
        this._setFocusedElement(void 0, (_a17 = e.detail) === null || _a17 === void 0 ? void 0 : _a17.originalEvent.relatedTarget);
      };
      this._validateFocusedElement = (element4) => {
      };
      this._onKeyDown = (event) => {
        if (event.key !== Keys.Tab || event.ctrlKey) {
          return;
        }
        const currentElement = this.getVal();
        if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
          return;
        }
        const tabster2 = this._tabster;
        const controlTab = tabster2.controlTab;
        const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
        if (!ctx || ctx.ignoreKeydown(event)) {
          return;
        }
        const isBackward = event.shiftKey;
        const next2 = _FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
        const rootElement = ctx.root.getElement();
        if (!rootElement) {
          return;
        }
        const nextElement = next2 === null || next2 === void 0 ? void 0 : next2.element;
        const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
        if (nextElement) {
          const nextUncontrolled = next2.uncontrolled;
          if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {
            if (!next2.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {
              return;
            }
            DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
            return;
          }
          if (nextUncontrolled && tabster2.focusable.isVisible(nextUncontrolled) || nextElement.tagName === "IFRAME" && tabster2.focusable.isVisible(nextElement)) {
            if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: rootElement,
              next: nextElement,
              relatedEvent: event
            }))) {
              DummyInputManager.moveWithPhantomDummy(tabster2, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
            }
            return;
          }
          if (controlTab || (next2 === null || next2 === void 0 ? void 0 : next2.outOfDOMOrder)) {
            if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
              by: "root",
              owner: rootElement,
              next: nextElement,
              relatedEvent: event
            }))) {
              event.preventDefault();
              event.stopImmediatePropagation();
              nativeFocus(nextElement);
            }
          }
        } else {
          if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: null,
            relatedEvent: event
          }))) {
            ctx.root.moveOutWithDefaultAction(isBackward, event);
          }
        }
      };
      this._onChanged = (element4, detail) => {
        var _a17, _b;
        if (element4) {
          element4.dispatchEvent(new TabsterFocusInEvent(detail));
        } else {
          const last = (_a17 = this._lastVal) === null || _a17 === void 0 ? void 0 : _a17.get();
          if (last) {
            const d = {
              ...detail
            };
            const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
            const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
            if (modalizerId) {
              d.modalizerId = modalizerId;
            }
            last.dispatchEvent(new TabsterFocusOutEvent(d));
          }
        }
      };
      this._tabster = tabster;
      this._win = getWindow2;
      tabster.queueInit(this._init);
    }
    dispose() {
      super.dispose();
      const win = this._win();
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      this.unsubscribe(this._onChanged);
      const asyncFocus = this._asyncFocus;
      if (asyncFocus) {
        win.clearTimeout(asyncFocus.timeout);
        delete this._asyncFocus;
      }
      delete _FocusedElementState._lastResetElement;
      delete this._nextVal;
      delete this._lastVal;
    }
    static forgetMemorized(instance, parent) {
      var _a17, _b;
      let wel = _FocusedElementState._lastResetElement;
      let el = wel && wel.get();
      if (el && dom.nodeContains(parent, el)) {
        delete _FocusedElementState._lastResetElement;
      }
      el = (_b = (_a17 = instance._nextVal) === null || _a17 === void 0 ? void 0 : _a17.element) === null || _b === void 0 ? void 0 : _b.get();
      if (el && dom.nodeContains(parent, el)) {
        delete instance._nextVal;
      }
      wel = instance._lastVal;
      el = wel && wel.get();
      if (el && dom.nodeContains(parent, el)) {
        delete instance._lastVal;
      }
    }
    getFocusedElement() {
      return this.getVal();
    }
    getLastFocusedElement() {
      var _a17;
      let el = (_a17 = this._lastVal) === null || _a17 === void 0 ? void 0 : _a17.get();
      if (!el || el && !documentContains(el.ownerDocument, el)) {
        this._lastVal = el = void 0;
      }
      return el;
    }
    focus(element4, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {
      if (!this._tabster.focusable.isFocusable(element4, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
        return false;
      }
      element4.focus({
        preventScroll
      });
      return true;
    }
    focusDefault(container2) {
      const el = this._tabster.focusable.findDefault({
        container: container2
      });
      if (el) {
        this._tabster.focusedElement.focus(el);
        return true;
      }
      return false;
    }
    getFirstOrLastTabbable(isFirst, props) {
      var _a17;
      const {
        container: container2,
        ignoreAccessibility
      } = props;
      let toFocus;
      if (container2) {
        const ctx = RootAPI.getTabsterContext(this._tabster, container2);
        if (ctx) {
          toFocus = (_a17 = _FocusedElementState.findNextTabbable(this._tabster, ctx, container2, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a17 === void 0 ? void 0 : _a17.element;
        }
      }
      if (toFocus && !dom.nodeContains(container2, toFocus)) {
        toFocus = void 0;
      }
      return toFocus || void 0;
    }
    _focusFirstOrLast(isFirst, props) {
      const toFocus = this.getFirstOrLastTabbable(isFirst, props);
      if (toFocus) {
        this.focus(toFocus, false, true);
        return true;
      }
      return false;
    }
    focusFirst(props) {
      return this._focusFirstOrLast(true, props);
    }
    focusLast(props) {
      return this._focusFirstOrLast(false, props);
    }
    resetFocus(container2) {
      if (!this._tabster.focusable.isVisible(container2)) {
        return false;
      }
      if (!this._tabster.focusable.isFocusable(container2, true, true, true)) {
        const prevTabIndex = container2.getAttribute("tabindex");
        const prevAriaHidden = container2.getAttribute("aria-hidden");
        container2.tabIndex = -1;
        container2.setAttribute("aria-hidden", "true");
        _FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container2);
        this.focus(container2, true, true);
        this._setOrRemoveAttribute(container2, "tabindex", prevTabIndex);
        this._setOrRemoveAttribute(container2, "aria-hidden", prevAriaHidden);
      } else {
        this.focus(container2);
      }
      return true;
    }
    requestAsyncFocus(source, callback, delay2) {
      const win = this._tabster.getWindow();
      const currentAsyncFocus = this._asyncFocus;
      if (currentAsyncFocus) {
        if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {
          return;
        }
        win.clearTimeout(currentAsyncFocus.timeout);
      }
      this._asyncFocus = {
        source,
        callback,
        timeout: win.setTimeout(() => {
          this._asyncFocus = void 0;
          callback();
        }, delay2)
      };
    }
    cancelAsyncFocus(source) {
      const asyncFocus = this._asyncFocus;
      if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {
        this._tabster.getWindow().clearTimeout(asyncFocus.timeout);
        this._asyncFocus = void 0;
      }
    }
    _setOrRemoveAttribute(element4, name21, value) {
      if (value === null) {
        element4.removeAttribute(name21);
      } else {
        element4.setAttribute(name21, value);
      }
    }
    _setFocusedElement(element4, relatedTarget, isFocusedProgrammatically) {
      var _a17, _b;
      if (this._tabster._noop) {
        return;
      }
      const detail = {
        relatedTarget
      };
      if (element4) {
        const lastResetElement = (_a17 = _FocusedElementState._lastResetElement) === null || _a17 === void 0 ? void 0 : _a17.get();
        _FocusedElementState._lastResetElement = void 0;
        if (lastResetElement === element4 || shouldIgnoreFocus(element4)) {
          return;
        }
        detail.isFocusedProgrammatically = isFocusedProgrammatically;
        const ctx = RootAPI.getTabsterContext(this._tabster, element4);
        const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
        if (modalizerId) {
          detail.modalizerId = modalizerId;
        }
      }
      const nextVal = this._nextVal = {
        element: element4 ? new WeakHTMLElement(this._win, element4) : void 0,
        detail
      };
      if (element4 && element4 !== this._val) {
        this._validateFocusedElement(element4);
      }
      if (this._nextVal === nextVal) {
        this.setVal(element4, detail);
      }
      this._nextVal = void 0;
    }
    setVal(val, detail) {
      super.setVal(val, detail);
      if (val) {
        this._lastVal = new WeakHTMLElement(this._win, val);
      }
    }
    static findNextTabbable(tabster, ctx, container2, currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const actualContainer = container2 || ctx.root.getElement();
      if (!actualContainer) {
        return null;
      }
      let next2 = null;
      const isTabbingTimer = _FocusedElementState._isTabbingTimer;
      const win = tabster.getWindow();
      if (isTabbingTimer) {
        win.clearTimeout(isTabbingTimer);
      }
      _FocusedElementState.isTabbing = true;
      _FocusedElementState._isTabbingTimer = win.setTimeout(() => {
        delete _FocusedElementState._isTabbingTimer;
        _FocusedElementState.isTabbing = false;
      }, 0);
      const modalizer = ctx.modalizer;
      const groupper = ctx.groupper;
      const mover = ctx.mover;
      const callFindNext = (what) => {
        next2 = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
        if (currentElement && !(next2 === null || next2 === void 0 ? void 0 : next2.element)) {
          const parentElement = what !== modalizer && dom.getParentElement(what.getElement());
          if (parentElement) {
            const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
              referenceElement: parentElement
            });
            if (parentCtx) {
              const currentScopeElement = what.getElement();
              const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;
              if (newCurrent) {
                next2 = _FocusedElementState.findNextTabbable(tabster, parentCtx, container2, newCurrent, parentElement, isBackward, ignoreAccessibility);
                if (next2) {
                  next2.outOfDOMOrder = true;
                }
              }
            }
          }
        }
      };
      if (groupper && mover) {
        callFindNext(ctx.groupperBeforeMover ? groupper : mover);
      } else if (groupper) {
        callFindNext(groupper);
      } else if (mover) {
        callFindNext(mover);
      } else if (modalizer) {
        callFindNext(modalizer);
      } else {
        const findProps = {
          container: actualContainer,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        next2 = {
          element: nextElement,
          outOfDOMOrder: findPropsOut.outOfDOMOrder,
          uncontrolled: findPropsOut.uncontrolled
        };
      }
      return next2;
    }
  };
  FocusedElementState.isTabbing = false;
  var GroupperDummyManager = class extends DummyInputManager {
    constructor(element4, groupper, tabster, sys) {
      super(tabster, element4, DummyInputManagerPriorities.Groupper, sys, true);
      this._setHandlers((dummyInput, isBackward, relatedTarget) => {
        var _a17, _b;
        const container2 = element4.get();
        const input = dummyInput.input;
        if (container2 && input) {
          const ctx = RootAPI.getTabsterContext(tabster, input);
          if (ctx) {
            let next2;
            next2 = (_a17 = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a17 === void 0 ? void 0 : _a17.element;
            if (!next2) {
              next2 = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container2, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
            }
            if (next2) {
              nativeFocus(next2);
            }
          }
        }
      });
    }
  };
  var Groupper = class extends TabsterPart {
    constructor(tabster, element4, onDispose, props, sys) {
      super(tabster, element4, props);
      this._shouldTabInside = false;
      this.makeTabbable(false);
      this._onDispose = onDispose;
      if (!tabster.controlTab) {
        this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
      }
    }
    dispose() {
      var _a17;
      this._onDispose(this);
      const element4 = this._element.get();
      (_a17 = this.dummyManager) === null || _a17 === void 0 ? void 0 : _a17.dispose();
      delete this.dummyManager;
      if (element4) {
        if (false) {
          _setInformativeStyle$1(this._element, true);
        }
      }
      delete this._first;
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const groupperElement = this.getElement();
      if (!groupperElement) {
        return null;
      }
      const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;
      if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {
        return {
          element: void 0,
          outOfDOMOrder: true
        };
      }
      const groupperFirstFocusable = this.getFirst(true);
      if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {
        return {
          element: groupperFirstFocusable,
          outOfDOMOrder: true
        };
      }
      const tabster = this._tabster;
      let next2 = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      if (this._shouldTabInside && groupperFirstFocusable) {
        const findProps = {
          container: groupperElement,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next2 = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        if (!next2 && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
          next2 = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
            container: groupperElement,
            ignoreAccessibility,
            useActiveModalizer: true
          }, findPropsOut);
          outOfDOMOrder = true;
        }
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next2,
        uncontrolled,
        outOfDOMOrder
      };
    }
    makeTabbable(isTabbable) {
      this._shouldTabInside = isTabbable || !this._props.tabbability;
      if (false) {
        _setInformativeStyle$1(this._element, !this._shouldTabInside);
      }
    }
    isActive(noIfFirstIsFocused) {
      var _a17;
      const element4 = this.getElement() || null;
      let isParentActive = true;
      for (let e = dom.getParentElement(element4); e; e = dom.getParentElement(e)) {
        const g = (_a17 = getTabsterOnElement(this._tabster, e)) === null || _a17 === void 0 ? void 0 : _a17.groupper;
        if (g) {
          if (!g._shouldTabInside) {
            isParentActive = false;
          }
        }
      }
      let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
      if (ret && noIfFirstIsFocused) {
        const focused = this._tabster.focusedElement.getFocusedElement();
        if (focused) {
          ret = focused !== this.getFirst(true);
        }
      }
      return ret;
    }
    getFirst(orContainer) {
      var _a17;
      const groupperElement = this.getElement();
      let first;
      if (groupperElement) {
        if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {
          return groupperElement;
        }
        first = (_a17 = this._first) === null || _a17 === void 0 ? void 0 : _a17.get();
        if (!first) {
          first = this._tabster.focusable.findFirst({
            container: groupperElement,
            useActiveModalizer: true
          }) || void 0;
          if (first) {
            this.setFirst(first);
          }
        }
      }
      return first;
    }
    setFirst(element4) {
      if (element4) {
        this._first = new WeakHTMLElement(this._tabster.getWindow, element4);
      } else {
        delete this._first;
      }
    }
    acceptElement(element4, state) {
      const cachedGrouppers = state.cachedGrouppers;
      const parentElement = dom.getParentElement(this.getElement());
      const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);
      const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
      const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
      let parentGroupperElement;
      const getIsActive = (groupper) => {
        let cached = cachedGrouppers[groupper.id];
        let isActive2;
        if (cached) {
          isActive2 = cached.isActive;
        } else {
          isActive2 = this.isActive(true);
          cached = cachedGrouppers[groupper.id] = {
            isActive: isActive2
          };
        }
        return isActive2;
      };
      if (parentGroupper) {
        parentGroupperElement = parentGroupper.getElement();
        if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {
          state.skippedFocusable = true;
          return NodeFilter.FILTER_REJECT;
        }
      }
      const isActive = getIsActive(this);
      const groupperElement = this.getElement();
      if (groupperElement) {
        if (isActive !== true) {
          if (groupperElement === element4 && parentCtxGroupper) {
            if (!parentGroupperElement) {
              parentGroupperElement = parentCtxGroupper.getElement();
            }
            if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {
              state.skippedFocusable = true;
              return NodeFilter.FILTER_REJECT;
            }
          }
          if (groupperElement !== element4 && dom.nodeContains(groupperElement, element4)) {
            state.skippedFocusable = true;
            return NodeFilter.FILTER_REJECT;
          }
          const cached = cachedGrouppers[this.id];
          let first;
          if ("first" in cached) {
            first = cached.first;
          } else {
            first = cached.first = this.getFirst(true);
          }
          if (first && state.acceptCondition(first)) {
            state.rejectElementsFrom = groupperElement;
            state.skippedFocusable = true;
            if (first !== state.from) {
              state.found = true;
              state.foundElement = first;
              return NodeFilter.FILTER_ACCEPT;
            } else {
              return NodeFilter.FILTER_REJECT;
            }
          }
        }
      }
      return void 0;
    }
  };
  var GroupperAPI = class {
    constructor(tabster, getWindow2) {
      this._current = {};
      this._grouppers = {};
      this._init = () => {
        const win = this._win();
        this._tabster.focusedElement.subscribeFirst(this._onFocus);
        const doc = win.document;
        const activeElement = dom.getActiveElement(doc);
        if (activeElement) {
          this._onFocus(activeElement);
        }
        doc.addEventListener("mousedown", this._onMouseDown, true);
        win.addEventListener("keydown", this._onKeyDown, true);
        win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
      };
      this._onGroupperDispose = (groupper) => {
        delete this._grouppers[groupper.id];
      };
      this._onFocus = (element4) => {
        if (element4) {
          this._updateCurrent(element4);
        }
      };
      this._onMouseDown = (e) => {
        let target = e.target;
        while (target && !this._tabster.focusable.isFocusable(target)) {
          target = this._tabster.getParent(target);
        }
        if (target) {
          this._updateCurrent(target);
        }
      };
      this._onKeyDown = (event) => {
        if (event.key !== Keys.Enter && event.key !== Keys.Escape) {
          return;
        }
        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
          return;
        }
        const element4 = this._tabster.focusedElement.getFocusedElement();
        if (element4) {
          this.handleKeyPress(element4, event);
        }
      };
      this._onMoveFocus = (e) => {
        var _a17;
        const element4 = e.composedPath()[0];
        const action = (_a17 = e.detail) === null || _a17 === void 0 ? void 0 : _a17.action;
        if (element4 && action !== void 0 && !e.defaultPrevented) {
          if (action === GroupperMoveFocusActions.Enter) {
            this._enterGroupper(element4);
          } else {
            this._escapeGroupper(element4);
          }
          e.stopImmediatePropagation();
        }
      };
      this._tabster = tabster;
      this._win = getWindow2;
      tabster.queueInit(this._init);
    }
    dispose() {
      const win = this._win();
      this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
      this._current = {};
      if (this._updateTimer) {
        win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      this._tabster.focusedElement.unsubscribe(this._onFocus);
      win.document.removeEventListener("mousedown", this._onMouseDown, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
      Object.keys(this._grouppers).forEach((groupperId) => {
        if (this._grouppers[groupperId]) {
          this._grouppers[groupperId].dispose();
          delete this._grouppers[groupperId];
        }
      });
    }
    createGroupper(element4, props, sys) {
      if (false) ;
      const tabster = this._tabster;
      const newGroupper = new Groupper(tabster, element4, this._onGroupperDispose, props, sys);
      this._grouppers[newGroupper.id] = newGroupper;
      const focusedElement = tabster.focusedElement.getFocusedElement();
      if (focusedElement && dom.nodeContains(element4, focusedElement) && !this._updateTimer) {
        this._updateTimer = this._win().setTimeout(() => {
          delete this._updateTimer;
          if (focusedElement === tabster.focusedElement.getFocusedElement()) {
            this._updateCurrent(focusedElement);
          }
        }, 0);
      }
      return newGroupper;
    }
    forgetCurrentGrouppers() {
      this._current = {};
    }
    _updateCurrent(element4) {
      var _a17;
      if (this._updateTimer) {
        this._win().clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      const tabster = this._tabster;
      const newIds = {};
      for (let el = tabster.getParent(element4); el; el = tabster.getParent(el)) {
        const groupper = (_a17 = getTabsterOnElement(tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.groupper;
        if (groupper) {
          newIds[groupper.id] = true;
          this._current[groupper.id] = groupper;
          const isTabbable = groupper.isActive() || element4 !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element4);
          groupper.makeTabbable(isTabbable);
        }
      }
      for (const id of Object.keys(this._current)) {
        const groupper = this._current[id];
        if (!(groupper.id in newIds)) {
          groupper.makeTabbable(false);
          groupper.setFirst(void 0);
          delete this._current[id];
        }
      }
    }
    _enterGroupper(element4, relatedEvent) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element4);
      const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      if (groupper && groupperElement && (element4 === groupperElement || groupper.getProps().delegated && element4 === groupper.getFirst(false))) {
        const next2 = tabster.focusable.findNext({
          container: groupperElement,
          currentElement: element4,
          useActiveModalizer: true
        });
        if (next2 && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "groupper",
          owner: groupperElement,
          next: next2,
          relatedEvent
        })))) {
          if (relatedEvent) {
            relatedEvent.preventDefault();
            relatedEvent.stopImmediatePropagation();
          }
          next2.focus();
          return next2;
        }
      }
      return null;
    }
    _escapeGroupper(element4, relatedEvent, fromModalizer) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element4);
      let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      if (groupper && groupperElement && dom.nodeContains(groupperElement, element4)) {
        let next2;
        if (element4 !== groupperElement || fromModalizer) {
          next2 = groupper.getFirst(true);
        } else {
          const parentElement = dom.getParentElement(groupperElement);
          const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : void 0;
          groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
          next2 = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
        }
        if (next2 && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "groupper",
          owner: groupperElement,
          next: next2,
          relatedEvent
        })))) {
          if (groupper) {
            groupper.makeTabbable(false);
          }
          next2.focus();
          return next2;
        }
      }
      return null;
    }
    moveFocus(element4, action) {
      return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element4) : this._escapeGroupper(element4);
    }
    handleKeyPress(element4, event, fromModalizer) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, element4);
      if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {
        tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
        if (ctx.ignoreKeydown(event)) {
          return;
        }
        if (event.key === Keys.Enter) {
          this._enterGroupper(element4, event);
        } else if (event.key === Keys.Escape) {
          const focusedElement = tabster.focusedElement.getFocusedElement();
          tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {
            if (focusedElement !== tabster.focusedElement.getFocusedElement() && // A part of Modalizer that has called this handler to escape the active groupper
            // might have been removed from DOM, if the focus is on body, we still want to handle Esc.
            (fromModalizer && !focusedElement || !fromModalizer)) {
              return;
            }
            this._escapeGroupper(element4, event, fromModalizer);
          }, 0);
        }
      }
    }
  };
  var KeyboardNavigationState = class extends Subscribable {
    constructor(getWindow2) {
      super();
      this._onChange = (isNavigatingWithKeyboard) => {
        this.setVal(isNavigatingWithKeyboard, void 0);
      };
      this._keyborg = createKeyborg(getWindow2());
      this._keyborg.subscribe(this._onChange);
    }
    dispose() {
      super.dispose();
      if (this._keyborg) {
        this._keyborg.unsubscribe(this._onChange);
        disposeKeyborg(this._keyborg);
        delete this._keyborg;
      }
    }
    setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
      var _a17;
      (_a17 = this._keyborg) === null || _a17 === void 0 ? void 0 : _a17.setVal(isNavigatingWithKeyboard);
    }
    isNavigatingWithKeyboard() {
      var _a17;
      return !!((_a17 = this._keyborg) === null || _a17 === void 0 ? void 0 : _a17.isNavigatingWithKeyboard());
    }
  };
  var _wasFocusedCounter = 0;
  var _ariaHidden = "aria-hidden";
  var ModalizerDummyManager = class extends DummyInputManager {
    constructor(element4, tabster, sys) {
      super(tabster, element4, DummyInputManagerPriorities.Modalizer, sys);
      this._setHandlers((dummyInput, isBackward) => {
        var _a17, _b;
        const el = element4.get();
        const container2 = el && ((_a17 = RootAPI.getRoot(tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.getElement());
        const input = dummyInput.input;
        let toFocus;
        if (container2 && input) {
          const dummyContainer = getDummyInputContainer(input);
          const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
          if (ctx) {
            toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container2, input, void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      });
    }
  };
  var Modalizer = class extends TabsterPart {
    constructor(tabster, element4, onDispose, props, sys, activeElements) {
      super(tabster, element4, props);
      this._wasFocused = 0;
      this.userId = props.id;
      this._onDispose = onDispose;
      this._activeElements = activeElements;
      if (!tabster.controlTab) {
        this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
      }
      if (false) {
        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
      }
    }
    makeActive(isActive) {
      if (this._isActive !== isActive) {
        this._isActive = isActive;
        const element4 = this.getElement();
        if (element4) {
          const activeElements = this._activeElements;
          const index2 = activeElements.map((e) => e.get()).indexOf(element4);
          if (isActive) {
            if (index2 < 0) {
              activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element4));
            }
          } else {
            if (index2 >= 0) {
              activeElements.splice(index2, 1);
            }
          }
        }
        if (false) {
          _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
        }
        this._dispatchEvent(isActive);
      }
    }
    focused(noIncrement) {
      if (!noIncrement) {
        this._wasFocused = ++_wasFocusedCounter;
      }
      return this._wasFocused;
    }
    setProps(props) {
      if (props.id) {
        this.userId = props.id;
      }
      this._props = {
        ...props
      };
    }
    dispose() {
      var _a17;
      this.makeActive(false);
      this._onDispose(this);
      (_a17 = this.dummyManager) === null || _a17 === void 0 ? void 0 : _a17.dispose();
      delete this.dummyManager;
      this._activeElements = [];
      this._remove();
    }
    isActive() {
      return !!this._isActive;
    }
    contains(element4) {
      return dom.nodeContains(this.getElement(), element4);
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      var _a17, _b;
      const modalizerElement = this.getElement();
      if (!modalizerElement) {
        return null;
      }
      const tabster = this._tabster;
      let next2 = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      const container2 = currentElement && ((_a17 = RootAPI.getRoot(tabster, currentElement)) === null || _a17 === void 0 ? void 0 : _a17.getElement());
      if (container2) {
        const findProps = {
          container: container2,
          currentElement,
          referenceElement,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next2 = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        if (!next2 && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
          next2 = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
            container: container2,
            ignoreAccessibility,
            useActiveModalizer: true
          }, findPropsOut);
          if (next2 === null) {
            next2 = currentElement;
          }
          outOfDOMOrder = true;
        } else {
          outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        }
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next2,
        uncontrolled,
        outOfDOMOrder
      };
    }
    _dispatchEvent(isActive, allElements) {
      const element4 = this.getElement();
      let defaultPrevented = false;
      if (element4) {
        const elements = allElements ? this._activeElements.map((e) => e.get()) : [element4];
        for (const el of elements) {
          if (el) {
            const eventDetail = {
              id: this.userId,
              element: element4
            };
            const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);
            el.dispatchEvent(event);
            if (event.defaultPrevented) {
              defaultPrevented = true;
            }
          }
        }
      }
      return defaultPrevented;
    }
    _remove() {
      if (false) {
        _setInformativeStyle(this._element, true);
      }
    }
  };
  var ModalizerAPI = class {
    constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
      this._onModalizerDispose = (modalizer) => {
        const id = modalizer.id;
        const userId = modalizer.userId;
        const part = this._parts[userId];
        delete this._modalizers[id];
        if (part) {
          delete part[id];
          if (Object.keys(part).length === 0) {
            delete this._parts[userId];
            const activationHistory = this._activationHistory;
            const cleanActivationHistory = [];
            let prevHistoryItem;
            for (let i = activationHistory.length; i--; ) {
              const modalizerUserIdFromHistory = activationHistory[i];
              if (modalizerUserIdFromHistory === userId) {
                continue;
              }
              if (modalizerUserIdFromHistory !== prevHistoryItem) {
                prevHistoryItem = modalizerUserIdFromHistory;
                if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {
                  cleanActivationHistory.unshift(modalizerUserIdFromHistory);
                }
              }
            }
            this._activationHistory = cleanActivationHistory;
            if (this.activeId === userId) {
              const prevActiveId = cleanActivationHistory[0];
              const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : void 0;
              this.setActive(prevActive);
            }
          }
        }
      };
      this._onKeyDown = (event) => {
        var _a17;
        if (event.key !== Keys.Escape) {
          return;
        }
        const tabster2 = this._tabster;
        const element4 = tabster2.focusedElement.getFocusedElement();
        if (element4) {
          const ctx = RootAPI.getTabsterContext(tabster2, element4);
          const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
          if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
            const activeId = modalizer.userId;
            if (activeId) {
              const part = this._parts[activeId];
              if (part) {
                const focusedSince = Object.keys(part).map((id) => {
                  var _a18;
                  const m = part[id];
                  const el = m.getElement();
                  let groupper;
                  if (el) {
                    groupper = (_a18 = getTabsterOnElement(tabster2, el)) === null || _a18 === void 0 ? void 0 : _a18.groupper;
                  }
                  return m && el && groupper ? {
                    el,
                    focusedSince: m.focused(true)
                  } : {
                    focusedSince: 0
                  };
                }).filter((f) => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);
                if (focusedSince.length) {
                  const groupperElement = focusedSince[0].el;
                  if (groupperElement) {
                    (_a17 = tabster2.groupper) === null || _a17 === void 0 ? void 0 : _a17.handleKeyPress(groupperElement, event, true);
                  }
                }
              }
            }
          }
        }
      };
      this._onFocus = (focusedElement, detail) => {
        var _a17;
        const tabster2 = this._tabster;
        const ctx = focusedElement && RootAPI.getTabsterContext(tabster2, focusedElement);
        if (!ctx || !focusedElement) {
          return;
        }
        const augmentedMap = this._augMap;
        for (let e = focusedElement; e; e = dom.getParentElement(e)) {
          if (augmentedMap.has(e)) {
            augmentedMap.delete(e);
            augmentAttribute(tabster2, e, _ariaHidden);
          }
        }
        let modalizer = ctx.modalizer;
        const tabsterOnFocusedElement = getTabsterOnElement(tabster2, focusedElement);
        const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;
        if (modalizerOnFocusedElement) {
          modalizerOnFocusedElement.focused();
          if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {
            const parentElement = tabster2.getParent(focusedElement);
            const parentModalizer = parentElement && ((_a17 = RootAPI.getTabsterContext(tabster2, parentElement)) === null || _a17 === void 0 ? void 0 : _a17.modalizer);
            if (parentModalizer) {
              modalizer = parentModalizer;
            } else {
              this.setActive(void 0);
              return;
            }
          }
        }
        modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();
        if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
          this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
          return;
        }
        if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
          this.setActive(modalizer);
        } else {
          const win2 = this._win();
          win2.clearTimeout(this._restoreModalizerFocusTimer);
          this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
        }
      };
      this._tabster = tabster;
      this._win = tabster.getWindow;
      this._modalizers = {};
      this._parts = {};
      this._augMap = /* @__PURE__ */ new WeakMap();
      this._aug = [];
      this._alwaysAccessibleSelector = alwaysAccessibleSelector;
      this._accessibleCheck = accessibleCheck;
      this._activationHistory = [];
      this.activeElements = [];
      if (!tabster.controlTab) {
        tabster.root.addDummyInputs();
      }
      const win = this._win();
      win.addEventListener("keydown", this._onKeyDown, true);
      tabster.queueInit(() => {
        this._tabster.focusedElement.subscribe(this._onFocus);
      });
    }
    dispose() {
      const win = this._win();
      win.removeEventListener("keydown", this._onKeyDown, true);
      Object.keys(this._modalizers).forEach((modalizerId) => {
        if (this._modalizers[modalizerId]) {
          this._modalizers[modalizerId].dispose();
          delete this._modalizers[modalizerId];
        }
      });
      win.clearTimeout(this._restoreModalizerFocusTimer);
      win.clearTimeout(this._hiddenUpdateTimer);
      this._parts = {};
      delete this.activeId;
      this.activeElements = [];
      this._augMap = /* @__PURE__ */ new WeakMap();
      this._aug = [];
      this._tabster.focusedElement.unsubscribe(this._onFocus);
    }
    createModalizer(element4, props, sys) {
      var _a17;
      if (false) ;
      const modalizer = new Modalizer(this._tabster, element4, this._onModalizerDispose, props, sys, this.activeElements);
      const id = modalizer.id;
      const userId = props.id;
      this._modalizers[id] = modalizer;
      let part = this._parts[userId];
      if (!part) {
        part = this._parts[userId] = {};
      }
      part[id] = modalizer;
      const focusedElement = (_a17 = this._tabster.focusedElement.getFocusedElement()) !== null && _a17 !== void 0 ? _a17 : null;
      if (element4 !== focusedElement && dom.nodeContains(element4, focusedElement)) {
        if (userId !== this.activeId) {
          this.setActive(modalizer);
        } else {
          modalizer.makeActive(true);
        }
      }
      return modalizer;
    }
    isAugmented(element4) {
      return this._augMap.has(element4);
    }
    hiddenUpdate() {
      if (this._hiddenUpdateTimer) {
        return;
      }
      this._hiddenUpdateTimer = this._win().setTimeout(() => {
        delete this._hiddenUpdateTimer;
        this._hiddenUpdate();
      }, 250);
    }
    setActive(modalizer) {
      const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
      const activeId = this.activeId;
      if (activeId === userId) {
        return;
      }
      this.activeId = userId;
      if (activeId) {
        const part = this._parts[activeId];
        if (part) {
          for (const id of Object.keys(part)) {
            part[id].makeActive(false);
          }
        }
      }
      if (userId) {
        const part = this._parts[userId];
        if (part) {
          for (const id of Object.keys(part)) {
            part[id].makeActive(true);
          }
        }
      }
      this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
      this.hiddenUpdate();
      const activationHistory = this._activationHistory;
      if (activationHistory[0] !== userId && (userId !== void 0 || activationHistory.length > 0)) {
        activationHistory.unshift(userId);
      }
    }
    focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);
      const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
      if (modalizer) {
        this.setActive(modalizer);
        const props = modalizer.getProps();
        const modalizerRoot = modalizer.getElement();
        if (modalizerRoot) {
          if (noFocusFirst === void 0) {
            noFocusFirst = props.isNoFocusFirst;
          }
          if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({
            container: modalizerRoot
          })) {
            return true;
          }
          if (noFocusDefault === void 0) {
            noFocusDefault = props.isNoFocusDefault;
          }
          if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {
            return true;
          }
          tabster.focusedElement.resetFocus(modalizerRoot);
        }
      } else if (false) {
        console.error("Element is not in Modalizer.", elementFromModalizer);
      }
      return false;
    }
    activate(modalizerElementOrContainer) {
      var _a17;
      const modalizerToActivate = modalizerElementOrContainer ? (_a17 = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a17 === void 0 ? void 0 : _a17.modalizer : void 0;
      if (!modalizerElementOrContainer || modalizerToActivate) {
        this.setActive(modalizerToActivate);
        return true;
      }
      return false;
    }
    acceptElement(element4, state) {
      var _a17;
      const modalizerUserId = state.modalizerUserId;
      const currentModalizer = (_a17 = state.currentCtx) === null || _a17 === void 0 ? void 0 : _a17.modalizer;
      if (modalizerUserId) {
        for (const e of this.activeElements) {
          const el = e.get();
          if (el && (dom.nodeContains(element4, el) || el === element4)) {
            return NodeFilter.FILTER_SKIP;
          }
        }
      }
      const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
      if (ret !== void 0) {
        state.skippedFocusable = true;
      }
      return ret;
    }
    _hiddenUpdate() {
      var _a17;
      const tabster = this._tabster;
      const body = tabster.getWindow().document.body;
      const activeId = this.activeId;
      const parts = this._parts;
      const visibleElements = [];
      const hiddenElements = [];
      const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
      const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];
      const activeModalizerElements = [];
      for (const userId of Object.keys(parts)) {
        const modalizerParts = parts[userId];
        for (const id of Object.keys(modalizerParts)) {
          const modalizer = modalizerParts[id];
          const el = modalizer.getElement();
          const props = modalizer.getProps();
          const isAlwaysAccessible = props.isAlwaysAccessible;
          if (el) {
            if (userId === activeId) {
              activeModalizerElements.push(el);
              if (!this.currentIsOthersAccessible) {
                visibleElements.push(el);
              }
            } else if (isAlwaysAccessible) {
              alwaysAccessibleElements.push(el);
            } else {
              hiddenElements.push(el);
            }
          }
        }
      }
      const augmentedMap = this._augMap;
      const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
      const newAugmented = [];
      const newAugmentedMap = /* @__PURE__ */ new WeakMap();
      const toggle = (element4, hide3) => {
        var _a18;
        const tagName = element4.tagName;
        if (tagName === "SCRIPT" || tagName === "STYLE") {
          return;
        }
        let isAugmented = false;
        if (augmentedMap.has(element4)) {
          if (hide3) {
            isAugmented = true;
          } else {
            augmentedMap.delete(element4);
            augmentAttribute(tabster, element4, _ariaHidden);
          }
        } else if (hide3 && !((_a18 = this._accessibleCheck) === null || _a18 === void 0 ? void 0 : _a18.call(this, element4, activeModalizerElements)) && augmentAttribute(tabster, element4, _ariaHidden, "true")) {
          augmentedMap.set(element4, true);
          isAugmented = true;
        }
        if (isAugmented) {
          newAugmented.push(new WeakHTMLElement(tabster.getWindow, element4));
          newAugmentedMap.set(element4, true);
        }
      };
      const walk = (element4) => {
        var _a18;
        for (let el = dom.getFirstElementChild(element4); el; el = dom.getNextElementSibling(el)) {
          let skip = false;
          let containsModalizer = false;
          let containedByModalizer = false;
          if (allVisibleElements) {
            const elParent = tabster.getParent(el);
            for (const c of allVisibleElements) {
              if (el === c) {
                skip = true;
                break;
              }
              if (dom.nodeContains(el, c)) {
                containsModalizer = true;
                break;
              } else if (dom.nodeContains(c, elParent)) {
                containedByModalizer = true;
              }
            }
            if (containsModalizer || ((_a18 = el.__tabsterElementFlags) === null || _a18 === void 0 ? void 0 : _a18.noDirectAriaHidden)) {
              walk(el);
            } else if (!skip && !containedByModalizer) {
              toggle(el, true);
            }
          } else {
            toggle(el, false);
          }
        }
      };
      if (!allVisibleElements) {
        alwaysAccessibleElements.forEach((e) => toggle(e, false));
      }
      hiddenElements.forEach((e) => toggle(e, true));
      if (body) {
        walk(body);
      }
      (_a17 = this._aug) === null || _a17 === void 0 ? void 0 : _a17.map((e) => e.get()).forEach((e) => {
        if (e && !newAugmentedMap.get(e)) {
          toggle(e, false);
        }
      });
      this._aug = newAugmented;
      this._augMap = newAugmentedMap;
    }
    /**
     * Called when an element is focused outside of an active modalizer.
     * Attempts to pull focus back into the active modalizer
     * @param outsideElement - An element being focused outside of the modalizer
     */
    _restoreModalizerFocus(outsideElement) {
      var _a17;
      const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
      if (!outsideElement || !ownerDocument) {
        return;
      }
      const focusedElement = this._tabster.focusedElement.getFocusedElement();
      const focusedElementModalizer = focusedElement && ((_a17 = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a17 === void 0 ? void 0 : _a17.modalizer);
      if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {
        return;
      }
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, outsideElement);
      const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
      const activeId = this.activeId;
      if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
        return;
      }
      const container2 = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
      if (container2) {
        let toFocus = tabster.focusable.findFirst({
          container: container2,
          useActiveModalizer: true
        });
        if (toFocus) {
          if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
            toFocus = tabster.focusable.findLast({
              container: container2,
              useActiveModalizer: true
            });
            if (!toFocus) {
              throw new Error("Something went wrong.");
            }
          }
          tabster.focusedElement.focus(toFocus);
          return;
        }
      }
      outsideElement.blur();
    }
  };
  var _inputSelector = /* @__PURE__ */ ["input", "textarea", "*[contenteditable]"].join(", ");
  var MoverDummyManager = class extends DummyInputManager {
    constructor(element4, tabster, getMemorized, sys) {
      super(tabster, element4, DummyInputManagerPriorities.Mover, sys);
      this._onFocusDummyInput = (dummyInput) => {
        var _a17, _b;
        const container2 = this._element.get();
        const input = dummyInput.input;
        if (container2 && input) {
          const ctx = RootAPI.getTabsterContext(this._tabster, container2);
          let toFocus;
          if (ctx) {
            toFocus = (_a17 = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a17 === void 0 ? void 0 : _a17.element;
          }
          const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
          if (memorized && this._tabster.focusable.isFocusable(memorized)) {
            toFocus = memorized;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      };
      this._tabster = tabster;
      this._getMemorized = getMemorized;
      this._setHandlers(this._onFocusDummyInput);
    }
  };
  var _moverUpdateAdd = 1;
  var _moverUpdateAttr = 2;
  var _moverUpdateRemove = 3;
  var Mover = class extends TabsterPart {
    constructor(tabster, element4, onDispose, props, sys) {
      var _a17;
      super(tabster, element4, props);
      this._visible = {};
      this._onIntersection = (entries) => {
        for (const entry of entries) {
          const el = entry.target;
          const id = getElementUId(this._win, el);
          let newVisibility;
          let fullyVisible = this._fullyVisible;
          if (entry.intersectionRatio >= 0.25) {
            newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
            if (newVisibility === Visibilities.Visible) {
              fullyVisible = id;
            }
          } else {
            newVisibility = Visibilities.Invisible;
          }
          if (this._visible[id] !== newVisibility) {
            if (newVisibility === void 0) {
              delete this._visible[id];
              if (fullyVisible === id) {
                delete this._fullyVisible;
              }
            } else {
              this._visible[id] = newVisibility;
              this._fullyVisible = fullyVisible;
            }
            const state = this.getState(el);
            if (state) {
              el.dispatchEvent(new MoverStateEvent(state));
            }
          }
        }
      };
      this._win = tabster.getWindow;
      this.visibilityTolerance = (_a17 = props.visibilityTolerance) !== null && _a17 !== void 0 ? _a17 : 0.8;
      if (this._props.trackState || this._props.visibilityAware) {
        this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
          threshold: [0, 0.25, 0.5, 0.75, 1]
        });
        this._observeState();
      }
      this._onDispose = onDispose;
      const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
      if (!tabster.controlTab) {
        this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
      }
    }
    dispose() {
      var _a17;
      this._onDispose(this);
      if (this._intersectionObserver) {
        this._intersectionObserver.disconnect();
        delete this._intersectionObserver;
      }
      delete this._current;
      delete this._fullyVisible;
      delete this._allElements;
      delete this._updateQueue;
      if (this._unobserve) {
        this._unobserve();
        delete this._unobserve;
      }
      const win = this._win();
      if (this._setCurrentTimer) {
        win.clearTimeout(this._setCurrentTimer);
        delete this._setCurrentTimer;
      }
      if (this._updateTimer) {
        win.clearTimeout(this._updateTimer);
        delete this._updateTimer;
      }
      (_a17 = this.dummyManager) === null || _a17 === void 0 ? void 0 : _a17.dispose();
      delete this.dummyManager;
    }
    setCurrent(element4) {
      if (element4) {
        this._current = new WeakHTMLElement(this._win, element4);
      } else {
        this._current = void 0;
      }
      if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
        this._setCurrentTimer = this._win().setTimeout(() => {
          var _a17;
          delete this._setCurrentTimer;
          const changed = [];
          if (this._current !== this._prevCurrent) {
            changed.push(this._current);
            changed.push(this._prevCurrent);
            this._prevCurrent = this._current;
          }
          for (const weak of changed) {
            const el = weak === null || weak === void 0 ? void 0 : weak.get();
            if (el && ((_a17 = this._allElements) === null || _a17 === void 0 ? void 0 : _a17.get(el)) === this) {
              const props = this._props;
              if (el && (props.visibilityAware !== void 0 || props.trackState)) {
                const state = this.getState(el);
                if (state) {
                  el.dispatchEvent(new MoverStateEvent(state));
                }
              }
            }
          }
        });
      }
    }
    getCurrent() {
      var _a17;
      return ((_a17 = this._current) === null || _a17 === void 0 ? void 0 : _a17.get()) || null;
    }
    findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
      const container2 = this.getElement();
      const currentIsDummy = container2 && getDummyInputContainer(currentElement) === container2;
      if (!container2) {
        return null;
      }
      let next2 = null;
      let outOfDOMOrder = false;
      let uncontrolled;
      if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container2, currentElement)) {
        const findProps = {
          currentElement,
          referenceElement,
          container: container2,
          ignoreAccessibility,
          useActiveModalizer: true
        };
        const findPropsOut = {};
        next2 = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
        uncontrolled = findPropsOut.uncontrolled;
      }
      return {
        element: next2,
        uncontrolled,
        outOfDOMOrder
      };
    }
    acceptElement(element4, state) {
      var _a17, _b;
      if (!FocusedElementState.isTabbing) {
        return ((_a17 = state.currentCtx) === null || _a17 === void 0 ? void 0 : _a17.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
      }
      const {
        memorizeCurrent,
        visibilityAware,
        hasDefault = true
      } = this._props;
      const moverElement = this.getElement();
      if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {
        let found;
        if (memorizeCurrent) {
          const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();
          if (current && state.acceptCondition(current)) {
            found = current;
          }
        }
        if (!found && hasDefault) {
          found = this._tabster.focusable.findDefault({
            container: moverElement,
            useActiveModalizer: true
          });
        }
        if (!found && visibilityAware) {
          found = this._tabster.focusable.findElement({
            container: moverElement,
            useActiveModalizer: true,
            isBackward: state.isBackward,
            acceptCondition: (el) => {
              var _a18;
              const id = getElementUId(this._win, el);
              const visibility = this._visible[id];
              return moverElement !== el && !!((_a18 = this._allElements) === null || _a18 === void 0 ? void 0 : _a18.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
            }
          });
        }
        if (found) {
          state.found = true;
          state.foundElement = found;
          state.rejectElementsFrom = moverElement;
          state.skippedFocusable = true;
          return NodeFilter.FILTER_ACCEPT;
        }
      }
      return void 0;
    }
    _observeState() {
      const element4 = this.getElement();
      if (this._unobserve || !element4 || typeof MutationObserver === "undefined") {
        return;
      }
      const win = this._win();
      const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
      const tabsterFocusable = this._tabster.focusable;
      let updateQueue = this._updateQueue = [];
      const observer = dom.createMutationObserver((mutations) => {
        for (const mutation of mutations) {
          const target = mutation.target;
          const removed = mutation.removedNodes;
          const added = mutation.addedNodes;
          if (mutation.type === "attributes") {
            if (mutation.attributeName === "tabindex") {
              updateQueue.push({
                element: target,
                type: _moverUpdateAttr
              });
            }
          } else {
            for (let i = 0; i < removed.length; i++) {
              updateQueue.push({
                element: removed[i],
                type: _moverUpdateRemove
              });
            }
            for (let i = 0; i < added.length; i++) {
              updateQueue.push({
                element: added[i],
                type: _moverUpdateAdd
              });
            }
          }
        }
        requestUpdate();
      });
      const setElement = (element5, remove) => {
        var _a17, _b;
        const current = allElements.get(element5);
        if (current && remove) {
          (_a17 = this._intersectionObserver) === null || _a17 === void 0 ? void 0 : _a17.unobserve(element5);
          allElements.delete(element5);
        }
        if (!current && !remove) {
          allElements.set(element5, this);
          (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element5);
        }
      };
      const updateElement = (element5) => {
        const isFocusable = tabsterFocusable.isFocusable(element5);
        const current = allElements.get(element5);
        if (current) {
          if (!isFocusable) {
            setElement(element5, true);
          }
        } else {
          if (isFocusable) {
            setElement(element5);
          }
        }
      };
      const addNewElements = (element5) => {
        const {
          mover
        } = getMoverGroupper(element5);
        if (mover && mover !== this) {
          if (mover.getElement() === element5 && tabsterFocusable.isFocusable(element5)) {
            setElement(element5);
          } else {
            return;
          }
        }
        const walker = createElementTreeWalker(win.document, element5, (node3) => {
          const {
            mover: mover2,
            groupper
          } = getMoverGroupper(node3);
          if (mover2 && mover2 !== this) {
            return NodeFilter.FILTER_REJECT;
          }
          const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
          if (groupper && groupper.getElement() !== node3 && groupperFirstFocusable && groupperFirstFocusable !== node3) {
            return NodeFilter.FILTER_REJECT;
          }
          if (tabsterFocusable.isFocusable(node3)) {
            setElement(node3);
          }
          return NodeFilter.FILTER_SKIP;
        });
        if (walker) {
          walker.currentNode = element5;
          while (walker.nextNode()) {
          }
        }
      };
      const removeWalk = (element5) => {
        const current = allElements.get(element5);
        if (current) {
          setElement(element5, true);
        }
        for (let el = dom.getFirstElementChild(element5); el; el = dom.getNextElementSibling(el)) {
          removeWalk(el);
        }
      };
      const requestUpdate = () => {
        if (!this._updateTimer && updateQueue.length) {
          this._updateTimer = win.setTimeout(() => {
            delete this._updateTimer;
            for (const {
              element: element5,
              type
            } of updateQueue) {
              switch (type) {
                case _moverUpdateAttr:
                  updateElement(element5);
                  break;
                case _moverUpdateAdd:
                  addNewElements(element5);
                  break;
                case _moverUpdateRemove:
                  removeWalk(element5);
                  break;
              }
            }
            updateQueue = this._updateQueue = [];
          }, 0);
        }
      };
      const getMoverGroupper = (element5) => {
        const ret = {};
        for (let el = element5; el; el = dom.getParentElement(el)) {
          const toe = getTabsterOnElement(this._tabster, el);
          if (toe) {
            if (toe.groupper && !ret.groupper) {
              ret.groupper = toe.groupper;
            }
            if (toe.mover) {
              ret.mover = toe.mover;
              break;
            }
          }
        }
        return ret;
      };
      updateQueue.push({
        element: element4,
        type: _moverUpdateAdd
      });
      requestUpdate();
      observer.observe(element4, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["tabindex"]
      });
      this._unobserve = () => {
        observer.disconnect();
      };
    }
    getState(element4) {
      const id = getElementUId(this._win, element4);
      if (id in this._visible) {
        const visibility = this._visible[id] || Visibilities.Invisible;
        const isCurrent = this._current ? this._current.get() === element4 : void 0;
        return {
          isCurrent,
          visibility
        };
      }
      return void 0;
    }
  };
  function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
    return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  }
  var MoverAPI = class {
    constructor(tabster, getWindow2) {
      this._init = () => {
        const win = this._win();
        win.addEventListener("keydown", this._onKeyDown, true);
        win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);
        win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
        this._tabster.focusedElement.subscribe(this._onFocus);
      };
      this._onMoverDispose = (mover) => {
        delete this._movers[mover.id];
      };
      this._onFocus = (element4) => {
        var _a17;
        let currentFocusableElement = element4;
        let deepestFocusableElement = element4;
        for (let el = dom.getParentElement(element4); el; el = dom.getParentElement(el)) {
          const mover = (_a17 = getTabsterOnElement(this._tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.mover;
          if (mover) {
            mover.setCurrent(deepestFocusableElement);
            currentFocusableElement = void 0;
          }
          if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
            currentFocusableElement = deepestFocusableElement = el;
          }
        }
      };
      this._onKeyDown = async (event) => {
        var _a17;
        if (this._ignoredInputTimer) {
          this._win().clearTimeout(this._ignoredInputTimer);
          delete this._ignoredInputTimer;
        }
        (_a17 = this._ignoredInputResolve) === null || _a17 === void 0 ? void 0 : _a17.call(this, false);
        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
          return;
        }
        const key = event.key;
        let moverKey;
        if (key === Keys.ArrowDown) {
          moverKey = MoverKeys.ArrowDown;
        } else if (key === Keys.ArrowRight) {
          moverKey = MoverKeys.ArrowRight;
        } else if (key === Keys.ArrowUp) {
          moverKey = MoverKeys.ArrowUp;
        } else if (key === Keys.ArrowLeft) {
          moverKey = MoverKeys.ArrowLeft;
        } else if (key === Keys.PageDown) {
          moverKey = MoverKeys.PageDown;
        } else if (key === Keys.PageUp) {
          moverKey = MoverKeys.PageUp;
        } else if (key === Keys.Home) {
          moverKey = MoverKeys.Home;
        } else if (key === Keys.End) {
          moverKey = MoverKeys.End;
        }
        if (!moverKey) {
          return;
        }
        const focused = this._tabster.focusedElement.getFocusedElement();
        if (!focused || await this._isIgnoredInput(focused, key)) {
          return;
        }
        this._moveFocus(focused, moverKey, event);
      };
      this._onMoveFocus = (e) => {
        var _a17;
        const element4 = e.composedPath()[0];
        const key = (_a17 = e.detail) === null || _a17 === void 0 ? void 0 : _a17.key;
        if (element4 && key !== void 0 && !e.defaultPrevented) {
          this._moveFocus(element4, key);
          e.stopImmediatePropagation();
        }
      };
      this._onMemorizedElement = (e) => {
        var _a17;
        const target = e.composedPath()[0];
        let memorizedElement = (_a17 = e.detail) === null || _a17 === void 0 ? void 0 : _a17.memorizedElement;
        if (target) {
          const ctx = RootAPI.getTabsterContext(this._tabster, target);
          const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;
          if (mover) {
            if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {
              memorizedElement = void 0;
            }
            mover.setCurrent(memorizedElement);
            e.stopImmediatePropagation();
          }
        }
      };
      this._tabster = tabster;
      this._win = getWindow2;
      this._movers = {};
      tabster.queueInit(this._init);
    }
    dispose() {
      var _a17;
      const win = this._win();
      this._tabster.focusedElement.unsubscribe(this._onFocus);
      (_a17 = this._ignoredInputResolve) === null || _a17 === void 0 ? void 0 : _a17.call(this, false);
      if (this._ignoredInputTimer) {
        win.clearTimeout(this._ignoredInputTimer);
        delete this._ignoredInputTimer;
      }
      win.removeEventListener("keydown", this._onKeyDown, true);
      win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);
      win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
      Object.keys(this._movers).forEach((moverId) => {
        if (this._movers[moverId]) {
          this._movers[moverId].dispose();
          delete this._movers[moverId];
        }
      });
    }
    createMover(element4, props, sys) {
      if (false) ;
      const newMover = new Mover(this._tabster, element4, this._onMoverDispose, props, sys);
      this._movers[newMover.id] = newMover;
      return newMover;
    }
    moveFocus(fromElement, key) {
      return this._moveFocus(fromElement, key);
    }
    _moveFocus(fromElement, key, relatedEvent) {
      var _a17, _b;
      const tabster = this._tabster;
      const ctx = RootAPI.getTabsterContext(tabster, fromElement, {
        checkRtl: true
      });
      if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {
        return null;
      }
      const mover = ctx.mover;
      const container2 = mover.getElement();
      if (ctx.groupperBeforeMover) {
        const groupper = ctx.groupper;
        if (groupper && !groupper.isActive(true)) {
          for (let el = dom.getParentElement(groupper.getElement()); el && el !== container2; el = dom.getParentElement(el)) {
            if ((_b = (_a17 = getTabsterOnElement(tabster, el)) === null || _a17 === void 0 ? void 0 : _a17.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {
              return null;
            }
          }
        } else {
          return null;
        }
      }
      if (!container2) {
        return null;
      }
      const focusable = tabster.focusable;
      const moverProps = mover.getProps();
      const direction = moverProps.direction || MoverDirections.Both;
      const isBoth = direction === MoverDirections.Both;
      const isVertical = isBoth || direction === MoverDirections.Vertical;
      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
      const isGridLinear = direction === MoverDirections.GridLinear;
      const isGrid = isGridLinear || direction === MoverDirections.Grid;
      const isCyclic = moverProps.cyclic;
      let next2;
      let scrollIntoViewArg;
      let focusedElementRect;
      let focusedElementX1 = 0;
      let focusedElementX2 = 0;
      if (isGrid) {
        focusedElementRect = fromElement.getBoundingClientRect();
        focusedElementX1 = Math.ceil(focusedElementRect.left);
        focusedElementX2 = Math.floor(focusedElementRect.right);
      }
      if (ctx.rtl) {
        if (key === MoverKeys.ArrowRight) {
          key = MoverKeys.ArrowLeft;
        } else if (key === MoverKeys.ArrowLeft) {
          key = MoverKeys.ArrowRight;
        }
      }
      if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {
        next2 = focusable.findNext({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true
        });
        if (next2 && isGrid) {
          const nextElementX1 = Math.ceil(next2.getBoundingClientRect().left);
          if (!isGridLinear && focusedElementX2 > nextElementX1) {
            next2 = void 0;
          }
        } else if (!next2 && isCyclic) {
          next2 = focusable.findFirst({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {
        next2 = focusable.findPrev({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true
        });
        if (next2 && isGrid) {
          const nextElementX2 = Math.floor(next2.getBoundingClientRect().right);
          if (!isGridLinear && nextElementX2 > focusedElementX1) {
            next2 = void 0;
          }
        } else if (!next2 && isCyclic) {
          next2 = focusable.findLast({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.Home) {
        if (isGrid) {
          focusable.findElement({
            container: container2,
            currentElement: fromElement,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              var _a18;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a18 = el.getBoundingClientRect().left) !== null && _a18 !== void 0 ? _a18 : 0);
              if (el !== fromElement && focusedElementX1 <= nextElementX1) {
                return true;
              }
              next2 = el;
              return false;
            }
          });
        } else {
          next2 = focusable.findFirst({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.End) {
        if (isGrid) {
          focusable.findElement({
            container: container2,
            currentElement: fromElement,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              var _a18;
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil((_a18 = el.getBoundingClientRect().left) !== null && _a18 !== void 0 ? _a18 : 0);
              if (el !== fromElement && focusedElementX1 >= nextElementX1) {
                return true;
              }
              next2 = el;
              return false;
            }
          });
        } else {
          next2 = focusable.findLast({
            container: container2,
            useActiveModalizer: true
          });
        }
      } else if (key === MoverKeys.PageUp) {
        focusable.findElement({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next2 = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next2) {
          const firstColumnX1 = Math.ceil(next2.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next2,
            container: container2,
            useActiveModalizer: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
                return true;
              }
              next2 = el;
              return false;
            }
          });
        }
        scrollIntoViewArg = false;
      } else if (key === MoverKeys.PageDown) {
        focusable.findElement({
          currentElement: fromElement,
          container: container2,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
              next2 = el;
              return false;
            }
            return true;
          }
        });
        if (isGrid && next2) {
          const lastColumnX1 = Math.ceil(next2.getBoundingClientRect().left);
          focusable.findElement({
            currentElement: next2,
            container: container2,
            useActiveModalizer: true,
            isBackward: true,
            acceptCondition: (el) => {
              if (!focusable.isFocusable(el)) {
                return false;
              }
              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
                return true;
              }
              next2 = el;
              return false;
            }
          });
        }
        scrollIntoViewArg = true;
      } else if (isGrid) {
        const isBackward = key === MoverKeys.ArrowUp;
        const ax1 = focusedElementX1;
        const ay1 = Math.ceil(focusedElementRect.top);
        const ax2 = focusedElementX2;
        const ay2 = Math.floor(focusedElementRect.bottom);
        let targetElement;
        let lastDistance;
        let lastIntersection = 0;
        focusable.findAll({
          container: container2,
          currentElement: fromElement,
          isBackward,
          onElement: (el) => {
            const rect = el.getBoundingClientRect();
            const bx1 = Math.ceil(rect.left);
            const by1 = Math.ceil(rect.top);
            const bx2 = Math.floor(rect.right);
            const by2 = Math.floor(rect.bottom);
            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
              return true;
            }
            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
              const intersection = xIntersectionWidth / minWidth;
              if (intersection > lastIntersection) {
                targetElement = el;
                lastIntersection = intersection;
              }
            } else if (lastIntersection === 0) {
              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
              if (lastDistance === void 0 || distance < lastDistance) {
                lastDistance = distance;
                targetElement = el;
              }
            } else if (lastIntersection > 0) {
              return false;
            }
            return true;
          }
        });
        next2 = targetElement;
      }
      if (next2 && (!relatedEvent || relatedEvent && container2.dispatchEvent(new TabsterMoveFocusEvent({
        by: "mover",
        owner: container2,
        next: next2,
        relatedEvent
      })))) {
        if (scrollIntoViewArg !== void 0) {
          scrollIntoView(this._win, next2, scrollIntoViewArg);
        }
        if (relatedEvent) {
          relatedEvent.preventDefault();
          relatedEvent.stopImmediatePropagation();
        }
        nativeFocus(next2);
        return next2;
      }
      return null;
    }
    async _isIgnoredInput(element4, key) {
      if (element4.getAttribute("aria-expanded") === "true" && element4.hasAttribute("aria-activedescendant")) {
        return true;
      }
      if (matchesSelector(element4, _inputSelector)) {
        let selectionStart = 0;
        let selectionEnd = 0;
        let textLength = 0;
        let asyncRet;
        if (element4.tagName === "INPUT" || element4.tagName === "TEXTAREA") {
          const type = element4.type;
          const value = element4.value;
          textLength = (value || "").length;
          if (type === "email" || type === "number") {
            if (textLength) {
              const selection = dom.getSelection(element4);
              if (selection) {
                const initialLength = selection.toString().length;
                const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;
                selection.modify("extend", isBackward ? "backward" : "forward", "character");
                if (initialLength !== selection.toString().length) {
                  selection.modify("extend", isBackward ? "forward" : "backward", "character");
                  return true;
                } else {
                  textLength = 0;
                }
              }
            }
          } else {
            const selStart = element4.selectionStart;
            if (selStart === null) {
              return type === "hidden";
            }
            selectionStart = selStart || 0;
            selectionEnd = element4.selectionEnd || 0;
          }
        } else if (element4.contentEditable === "true") {
          asyncRet = new (getPromise(this._win))((resolve) => {
            this._ignoredInputResolve = (value) => {
              delete this._ignoredInputResolve;
              resolve(value);
            };
            const win = this._win();
            if (this._ignoredInputTimer) {
              win.clearTimeout(this._ignoredInputTimer);
            }
            const {
              anchorNode: prevAnchorNode,
              focusNode: prevFocusNode,
              anchorOffset: prevAnchorOffset,
              focusOffset: prevFocusOffset
            } = dom.getSelection(element4) || {};
            this._ignoredInputTimer = win.setTimeout(() => {
              var _a17, _b, _c;
              delete this._ignoredInputTimer;
              const {
                anchorNode,
                focusNode,
                anchorOffset,
                focusOffset
              } = dom.getSelection(element4) || {};
              if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
                (_a17 = this._ignoredInputResolve) === null || _a17 === void 0 ? void 0 : _a17.call(this, false);
                return;
              }
              selectionStart = anchorOffset || 0;
              selectionEnd = focusOffset || 0;
              textLength = ((_b = element4.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
              if (anchorNode && focusNode) {
                if (dom.nodeContains(element4, anchorNode) && dom.nodeContains(element4, focusNode)) {
                  if (anchorNode !== element4) {
                    let anchorFound = false;
                    const addOffsets = (node3) => {
                      if (node3 === anchorNode) {
                        anchorFound = true;
                      } else if (node3 === focusNode) {
                        return true;
                      }
                      const nodeText = node3.textContent;
                      if (nodeText && !dom.getFirstChild(node3)) {
                        const len = nodeText.length;
                        if (anchorFound) {
                          if (focusNode !== anchorNode) {
                            selectionEnd += len;
                          }
                        } else {
                          selectionStart += len;
                          selectionEnd += len;
                        }
                      }
                      let stop = false;
                      for (let e = dom.getFirstChild(node3); e && !stop; e = e.nextSibling) {
                        stop = addOffsets(e);
                      }
                      return stop;
                    };
                    addOffsets(element4);
                  }
                }
              }
              (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
            }, 0);
          });
        }
        if (asyncRet && !await asyncRet) {
          return true;
        }
        if (selectionStart !== selectionEnd) {
          return true;
        }
        if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {
          return true;
        }
        if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {
          return true;
        }
      }
      return false;
    }
  };
  function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
    if (typeof MutationObserver === "undefined") {
      return () => {
      };
    }
    const getWindow2 = tabster.getWindow;
    let elementByUId;
    const onMutation = (mutations) => {
      var _a17, _b, _c, _d, _e;
      const removedNodes = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        const target = mutation.target;
        const removed = mutation.removedNodes;
        const added = mutation.addedNodes;
        if (mutation.type === "attributes") {
          if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {
            if (!removedNodes.has(target)) {
              updateTabsterByAttribute2(tabster, target);
            }
          }
        } else {
          for (let i = 0; i < removed.length; i++) {
            const removedNode = removed[i];
            removedNodes.add(removedNode);
            updateTabsterElements(removedNode, true);
            (_b = (_a17 = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a17, target);
          }
          for (let i = 0; i < added.length; i++) {
            updateTabsterElements(added[i]);
            (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
          }
        }
      }
      removedNodes.clear();
      (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
    };
    function updateTabsterElements(node3, removed) {
      if (!elementByUId) {
        elementByUId = getInstanceContext(getWindow2).elementByUId;
      }
      processNode(node3, removed);
      const walker = createElementTreeWalker(doc, node3, (element4) => {
        return processNode(element4, removed);
      });
      if (walker) {
        while (walker.nextNode()) {
        }
      }
    }
    function processNode(element4, removed) {
      var _a17;
      if (!element4.getAttribute) {
        return NodeFilter.FILTER_SKIP;
      }
      const uid = element4.__tabsterElementUID;
      if (uid && elementByUId) {
        if (removed) {
          delete elementByUId[uid];
        } else {
          (_a17 = elementByUId[uid]) !== null && _a17 !== void 0 ? _a17 : elementByUId[uid] = new WeakHTMLElement(getWindow2, element4);
        }
      }
      if (getTabsterOnElement(tabster, element4) || element4.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {
        updateTabsterByAttribute2(tabster, element4, removed);
      }
      return NodeFilter.FILTER_SKIP;
    }
    const observer = dom.createMutationObserver(onMutation);
    if (syncState) {
      updateTabsterElements(getWindow2().document.body);
    }
    observer.observe(doc, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: [TABSTER_ATTRIBUTE_NAME]
    });
    return () => {
      observer.disconnect();
    };
  }
  var UncontrolledAPI = class {
    constructor(isUncontrolledCompletely) {
      this._isUncontrolledCompletely = isUncontrolledCompletely;
    }
    isUncontrolledCompletely(element4, completely) {
      var _a17;
      const isUncontrolledCompletely = (_a17 = this._isUncontrolledCompletely) === null || _a17 === void 0 ? void 0 : _a17.call(this, element4, completely);
      return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
    }
  };
  var Restorer = class extends TabsterPart {
    constructor(tabster, element4, props) {
      var _a17;
      super(tabster, element4, props);
      this._hasFocus = false;
      this._onFocusOut = (e) => {
        var _a18;
        const element5 = (_a18 = this._element) === null || _a18 === void 0 ? void 0 : _a18.get();
        if (element5 && e.relatedTarget === null) {
          element5.dispatchEvent(new RestorerRestoreFocusEvent());
        }
        if (element5 && !dom.nodeContains(element5, e.relatedTarget)) {
          this._hasFocus = false;
        }
      };
      this._onFocusIn = () => {
        this._hasFocus = true;
      };
      if (this._props.type === RestorerTypes.Source) {
        const element5 = (_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get();
        element5 === null || element5 === void 0 ? void 0 : element5.addEventListener("focusout", this._onFocusOut);
        element5 === null || element5 === void 0 ? void 0 : element5.addEventListener("focusin", this._onFocusIn);
        this._hasFocus = dom.nodeContains(element5, element5 && dom.getActiveElement(element5.ownerDocument));
      }
    }
    dispose() {
      var _a17;
      if (this._props.type === RestorerTypes.Source) {
        const element4 = (_a17 = this._element) === null || _a17 === void 0 ? void 0 : _a17.get();
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("focusout", this._onFocusOut);
        element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("focusin", this._onFocusIn);
        if (this._hasFocus) {
          const doc = this._tabster.getWindow().document;
          doc.body.dispatchEvent(new RestorerRestoreFocusEvent());
        }
      }
    }
  };
  var History = class _History {
    constructor(getWindow2) {
      this._stack = [];
      this._getWindow = getWindow2;
    }
    /**
     * Push a weak element to the top of the history stack.
     * If the stack is full, the bottom weak element is removed.
     * If the element is already at the top of the stack, it is not duplicated.
     */
    push(element4) {
      var _a17;
      if (((_a17 = this._stack[this._stack.length - 1]) === null || _a17 === void 0 ? void 0 : _a17.get()) === element4) {
        return;
      }
      if (this._stack.length > _History.DEPTH) {
        this._stack.shift();
      }
      this._stack.push(new WeakHTMLElement(this._getWindow, element4));
    }
    /**
     * Pop the first element from the history that satisfies the callback.
     * The history is searched from the top to the bottom (from the most recent to the least recent).
     *
     * If a weak reference to the element is broken,
     * or the element is no longer in the DOM,
     * the element is removed from the top of the stack while popping.
     *
     * If no matching element is found, undefined is returned.
     * If the stack is empty, undefined is returned.
     */
    pop(filter3) {
      if (filter3 === void 0) {
        filter3 = () => true;
      }
      var _a17;
      const doc = this._getWindow().document;
      for (let index2 = this._stack.length - 1; index2 >= 0; index2--) {
        const maybeElement = (_a17 = this._stack.pop()) === null || _a17 === void 0 ? void 0 : _a17.get();
        if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter3(maybeElement)) {
          return maybeElement;
        }
      }
      return void 0;
    }
  };
  History.DEPTH = 10;
  var RestorerAPI = class {
    constructor(tabster) {
      this._onRestoreFocus = (e) => {
        var _a17, _b;
        this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
        const source = e.composedPath()[0];
        if (source) {
          const sourceId = (_b = (_a17 = getTabsterOnElement(this._tabster, source)) === null || _a17 === void 0 ? void 0 : _a17.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;
          this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);
        }
      };
      this._onFocusIn = (element4) => {
        var _a17;
        if (!element4) {
          return;
        }
        const tabsterAttribute = getTabsterOnElement(this._tabster, element4);
        if (((_a17 = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a17 === void 0 ? void 0 : _a17.getProps().type) !== RestorerTypes.Target) {
          return;
        }
        this._history.push(element4);
      };
      this._restoreFocus = (source, sourceId) => {
        var _a17;
        const doc = this._getWindow().document;
        if (dom.getActiveElement(doc) !== doc.body) {
          return;
        }
        if (
          // clicking on any empty space focuses body - this is can be a false positive
          !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
          dom.nodeContains(doc.body, source)
        ) {
          return;
        }
        const getId = (element4) => {
          var _a18, _b;
          const restorerProps = (_b = (_a18 = getTabsterOnElement(this._tabster, element4)) === null || _a18 === void 0 ? void 0 : _a18.restorer) === null || _b === void 0 ? void 0 : _b.getProps();
          return restorerProps ? restorerProps.id : null;
        };
        (_a17 = this._history.pop((target) => sourceId === getId(target))) === null || _a17 === void 0 ? void 0 : _a17.focus();
      };
      this._tabster = tabster;
      this._getWindow = tabster.getWindow;
      this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
      this._history = new History(this._getWindow);
      this._keyboardNavState = tabster.keyboardNavigation;
      this._focusedElementState = tabster.focusedElement;
      this._focusedElementState.subscribe(this._onFocusIn);
    }
    dispose() {
      const win = this._getWindow();
      this._focusedElementState.unsubscribe(this._onFocusIn);
      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
      win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
    }
    createRestorer(element4, props) {
      const restorer = new Restorer(this._tabster, element4, props);
      if (props.type === RestorerTypes.Target && dom.getActiveElement(element4.ownerDocument) === element4) {
        this._history.push(element4);
      }
      return restorer;
    }
  };
  function nodeContains(node3, otherNode) {
    var _a17, _b;
    if (!node3 || !otherNode) {
      return false;
    }
    let currentNode = otherNode;
    while (currentNode) {
      if (currentNode === node3) {
        return true;
      }
      if (typeof currentNode.assignedElements !== "function" && ((_a17 = currentNode.assignedSlot) === null || _a17 === void 0 ? void 0 : _a17.parentNode)) {
        currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;
      } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
        currentNode = currentNode.host;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return false;
  }
  var ShadowMutationObserver = class _ShadowMutationObserver {
    static _overrideAttachShadow(win) {
      const origAttachShadow = win.Element.prototype.attachShadow;
      if (origAttachShadow.__origAttachShadow) {
        return;
      }
      Element.prototype.attachShadow = function(options) {
        const shadowRoot = origAttachShadow.call(this, options);
        for (const shadowObserver of _ShadowMutationObserver._shadowObservers) {
          shadowObserver._addSubObserver(shadowRoot);
        }
        return shadowRoot;
      };
      Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;
    }
    constructor(callback) {
      this._isObserving = false;
      this._callbackWrapper = (mutations, observer) => {
        for (const mutation of mutations) {
          if (mutation.type === "childList") {
            const removed = mutation.removedNodes;
            const added = mutation.addedNodes;
            for (let i = 0; i < removed.length; i++) {
              this._walkShadows(removed[i], true);
            }
            for (let i = 0; i < added.length; i++) {
              this._walkShadows(added[i]);
            }
          }
        }
        this._callback(mutations, observer);
      };
      this._callback = callback;
      this._observer = new MutationObserver(this._callbackWrapper);
      this._subObservers = /* @__PURE__ */ new Map();
    }
    _addSubObserver(shadowRoot) {
      if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {
        return;
      }
      if (this._options.subtree && nodeContains(this._root, shadowRoot)) {
        const subObserver = new MutationObserver(this._callbackWrapper);
        this._subObservers.set(shadowRoot, subObserver);
        if (this._isObserving) {
          subObserver.observe(shadowRoot, this._options);
        }
        this._walkShadows(shadowRoot);
      }
    }
    disconnect() {
      this._isObserving = false;
      delete this._options;
      _ShadowMutationObserver._shadowObservers.delete(this);
      for (const subObserver of this._subObservers.values()) {
        subObserver.disconnect();
      }
      this._subObservers.clear();
      this._observer.disconnect();
    }
    observe(target, options) {
      const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
      const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;
      if (!doc || !win) {
        return;
      }
      _ShadowMutationObserver._overrideAttachShadow(win);
      _ShadowMutationObserver._shadowObservers.add(this);
      this._root = target;
      this._options = options;
      this._isObserving = true;
      this._observer.observe(target, options);
      this._walkShadows(target);
    }
    _walkShadows(target, remove) {
      const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
      if (!doc) {
        return;
      }
      if (target === doc) {
        target = doc.body;
      } else {
        const shadowRoot = target.shadowRoot;
        if (shadowRoot) {
          this._addSubObserver(shadowRoot);
          return;
        }
      }
      const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node3) => {
          if (node3.nodeType === Node.ELEMENT_NODE) {
            if (remove) {
              const subObserver = this._subObservers.get(node3);
              if (subObserver) {
                subObserver.disconnect();
                this._subObservers.delete(node3);
              }
            } else {
              const shadowRoot = node3.shadowRoot;
              if (shadowRoot) {
                this._addSubObserver(shadowRoot);
              }
            }
          }
          return NodeFilter.FILTER_SKIP;
        }
      });
      walker.nextNode();
    }
    takeRecords() {
      const records = this._observer.takeRecords();
      for (const subObserver of this._subObservers.values()) {
        records.push(...subObserver.takeRecords());
      }
      return records;
    }
  };
  ShadowMutationObserver._shadowObservers = /* @__PURE__ */ new Set();
  var Tabster = class {
    constructor(tabster) {
      this.keyboardNavigation = tabster.keyboardNavigation;
      this.focusedElement = tabster.focusedElement;
      this.focusable = tabster.focusable;
      this.root = tabster.root;
      this.uncontrolled = tabster.uncontrolled;
      this.core = tabster;
    }
  };
  var TabsterCore = class {
    constructor(win, props) {
      var _a17, _b;
      this._forgetMemorizedElements = [];
      this._wrappers = /* @__PURE__ */ new Set();
      this._initQueue = [];
      this._version = "8.5.5";
      this._noop = false;
      this.getWindow = () => {
        if (!this._win) {
          throw new Error("Using disposed Tabster.");
        }
        return this._win;
      };
      this._storage = createWeakMap(win);
      this._win = win;
      const getWindow2 = this.getWindow;
      if (props === null || props === void 0 ? void 0 : props.DOMAPI) {
        setDOMAPI({
          ...props.DOMAPI
        });
      }
      this.keyboardNavigation = new KeyboardNavigationState(getWindow2);
      this.focusedElement = new FocusedElementState(this, getWindow2);
      this.focusable = new FocusableAPI(this);
      this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
      this.uncontrolled = new UncontrolledAPI(
        // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
        (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
      );
      this.controlTab = (_a17 = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a17 !== void 0 ? _a17 : true;
      this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
      this._dummyObserver = new DummyInputObserver(getWindow2);
      this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;
      this.internal = {
        stopObserver: () => {
          if (this._unobserve) {
            this._unobserve();
            delete this._unobserve;
          }
        },
        resumeObserver: (syncState) => {
          if (!this._unobserve) {
            const doc = getWindow2().document;
            this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
          }
        }
      };
      startFakeWeakRefsCleanup(getWindow2);
      this.queueInit(() => {
        this.internal.resumeObserver(true);
      });
    }
    /**
     * Merges external props with the current props. Not all
     * props can/should be mergeable, so let's add more as we move on.
     * @param props Tabster props
     */
    _mergeProps(props) {
      var _a17;
      if (!props) {
        return;
      }
      this.getParent = (_a17 = props.getParent) !== null && _a17 !== void 0 ? _a17 : this.getParent;
    }
    createTabster(noRefCount, props) {
      const wrapper = new Tabster(this);
      if (!noRefCount) {
        this._wrappers.add(wrapper);
      }
      this._mergeProps(props);
      return wrapper;
    }
    disposeTabster(wrapper, allInstances) {
      if (allInstances) {
        this._wrappers.clear();
      } else {
        this._wrappers.delete(wrapper);
      }
      if (this._wrappers.size === 0) {
        this.dispose();
      }
    }
    dispose() {
      var _a17, _b, _c, _d, _e, _f, _g, _h;
      this.internal.stopObserver();
      const win = this._win;
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
      delete this._initTimer;
      this._initQueue = [];
      this._forgetMemorizedElements = [];
      if (win && this._forgetMemorizedTimer) {
        win.clearTimeout(this._forgetMemorizedTimer);
        delete this._forgetMemorizedTimer;
      }
      (_a17 = this.outline) === null || _a17 === void 0 ? void 0 : _a17.dispose();
      (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
      this.keyboardNavigation.dispose();
      this.focusable.dispose();
      this.focusedElement.dispose();
      this.root.dispose();
      this._dummyObserver.dispose();
      stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
      clearElementCache(this.getWindow);
      this._storage = /* @__PURE__ */ new WeakMap();
      this._wrappers.clear();
      if (win) {
        disposeInstanceContext(win);
        delete win.__tabsterInstance;
        delete this._win;
      }
    }
    storageEntry(element4, addremove) {
      const storage = this._storage;
      let entry = storage.get(element4);
      if (entry) {
        if (addremove === false && Object.keys(entry).length === 0) {
          storage.delete(element4);
        }
      } else if (addremove === true) {
        entry = {};
        storage.set(element4, entry);
      }
      return entry;
    }
    forceCleanup() {
      if (!this._win) {
        return;
      }
      this._forgetMemorizedElements.push(this._win.document.body);
      if (this._forgetMemorizedTimer) {
        return;
      }
      this._forgetMemorizedTimer = this._win.setTimeout(() => {
        delete this._forgetMemorizedTimer;
        for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
          clearElementCache(this.getWindow, el);
          FocusedElementState.forgetMemorized(this.focusedElement, el);
        }
      }, 0);
      cleanupFakeWeakRefs(this.getWindow, true);
    }
    queueInit(callback) {
      var _a17;
      if (!this._win) {
        return;
      }
      this._initQueue.push(callback);
      if (!this._initTimer) {
        this._initTimer = (_a17 = this._win) === null || _a17 === void 0 ? void 0 : _a17.setTimeout(() => {
          delete this._initTimer;
          this.drainInitQueue();
        }, 0);
      }
    }
    drainInitQueue() {
      if (!this._win) {
        return;
      }
      const queue = this._initQueue;
      this._initQueue = [];
      queue.forEach((callback) => callback());
    }
  };
  function createTabster(win, props) {
    let tabster = getCurrentTabster(win);
    if (tabster) {
      return tabster.createTabster(false, props);
    }
    tabster = new TabsterCore(win, props);
    win.__tabsterInstance = tabster;
    return tabster.createTabster();
  }
  function getGroupper(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.groupper) {
      tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
    }
    return tabsterCore.groupper;
  }
  function getMover(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.mover) {
      tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
    }
    return tabsterCore.mover;
  }
  function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.modalizer) {
      tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
    }
    return tabsterCore.modalizer;
  }
  function getRestorer(tabster) {
    const tabsterCore = tabster.core;
    if (!tabsterCore.restorer) {
      tabsterCore.restorer = new RestorerAPI(tabsterCore);
    }
    return tabsterCore.restorer;
  }
  function disposeTabster(tabster, allInstances) {
    tabster.core.disposeTabster(tabster, allInstances);
  }
  function getCurrentTabster(win) {
    return win.__tabsterInstance;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React49 = __toESM(require_react());
  var DEFAULT_FACTORY = (tabster) => {
    return tabster;
  };
  function createTabsterWithConfig(targetDocument) {
    const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
    const shadowDOMAPI = defaultView === null || defaultView === void 0 ? void 0 : defaultView.__tabsterShadowDOMAPI;
    if (defaultView) {
      return createTabster(defaultView, {
        autoRoot: {},
        controlTab: false,
        getParent,
        checkUncontrolledTrappingFocus: (element4) => {
          var _element_firstElementChild;
          return !!((_element_firstElementChild = element4.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper"));
        },
        DOMAPI: shadowDOMAPI
      });
    }
  }
  function useTabster(factory = DEFAULT_FACTORY) {
    const { targetDocument } = useFluent();
    const factoryResultRef = React49.useRef(null);
    useIsomorphicLayoutEffect2(() => {
      const tabster = createTabsterWithConfig(targetDocument);
      if (tabster) {
        factoryResultRef.current = factory(tabster);
        return () => {
          disposeTabster(tabster);
          factoryResultRef.current = null;
        };
      }
    }, [
      targetDocument,
      factory
    ]);
    if (false) {
      const previousFactory = usePrevious(factory);
      if (previousFactory !== null && previousFactory !== factory) {
        throw new Error([
          "@fluentui/react-tabster: ",
          "The factory function passed to useTabster has changed. This should not ever happen."
        ].join("\n"));
      }
    }
    return factoryResultRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
  var React50 = __toESM(require_react());
  var useTabsterAttributes = (props) => {
    useTabster();
    const strAttr = getTabsterAttribute(props, true);
    return React50.useMemo(() => ({
      [TABSTER_ATTRIBUTE_NAME]: strAttr
    }), [
      strAttr
    ]);
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
  var useArrowNavigationGroup = (options = {}) => {
    const {
      circular,
      axis,
      memorizeCurrent = true,
      tabbable,
      ignoreDefaultKeydown,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_hasDefault
    } = options;
    useTabster(getMover);
    return useTabsterAttributes({
      mover: {
        cyclic: !!circular,
        direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
        memorizeCurrent,
        tabbable,
        hasDefault: unstable_hasDefault
      },
      ...ignoreDefaultKeydown && {
        focusable: {
          ignoreKeydown: ignoreDefaultKeydown
        }
      }
    });
  };
  function axisToMoverDirection(axis) {
    switch (axis) {
      case "horizontal":
        return MoverDirections.Horizontal;
      case "grid":
        return MoverDirections.Grid;
      case "grid-linear":
        return MoverDirections.GridLinear;
      case "both":
        return MoverDirections.Both;
      case "vertical":
      default:
        return MoverDirections.Vertical;
    }
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useFocusableGroup = (options) => {
    useTabster(getGroupper);
    return useTabsterAttributes({
      groupper: {
        tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior)
      },
      focusable: {
        ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown
      }
    });
  };
  var getTabbability = (tabBehavior) => {
    switch (tabBehavior) {
      case "unlimited":
        return GroupperTabbabilities.Unlimited;
      case "limited":
        return GroupperTabbabilities.Limited;
      case "limited-trap-focus":
        return GroupperTabbabilities.LimitedTrapFocus;
      default:
        return void 0;
    }
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React51 = __toESM(require_react());
  var useFocusFinders = () => {
    const tabsterRef = useTabster();
    const { targetDocument } = useFluent();
    const findAllFocusable = React51.useCallback((container2, acceptCondition) => {
      var _tabsterRef_current;
      return ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findAll({
        container: container2,
        acceptCondition
      })) || [];
    }, [
      tabsterRef
    ]);
    const findFirstFocusable = React51.useCallback((container2) => {
      var _tabsterRef_current;
      return (_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findFirst({
        container: container2
      });
    }, [
      tabsterRef
    ]);
    const findLastFocusable = React51.useCallback((container2) => {
      var _tabsterRef_current;
      return (_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findLast({
        container: container2
      });
    }, [
      tabsterRef
    ]);
    const findNextFocusable = React51.useCallback((currentElement, options = {}) => {
      if (!tabsterRef.current || !targetDocument) {
        return null;
      }
      const { container: container2 = targetDocument.body } = options;
      return tabsterRef.current.focusable.findNext({
        currentElement,
        container: container2
      });
    }, [
      tabsterRef,
      targetDocument
    ]);
    const findPrevFocusable = React51.useCallback((currentElement, options = {}) => {
      if (!tabsterRef.current || !targetDocument) {
        return null;
      }
      const { container: container2 = targetDocument.body } = options;
      return tabsterRef.current.focusable.findPrev({
        currentElement,
        container: container2
      });
    }, [
      tabsterRef,
      targetDocument
    ]);
    return {
      findAllFocusable,
      findFirstFocusable,
      findLastFocusable,
      findNextFocusable,
      findPrevFocusable
    };
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React52 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/focus/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
  var KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
  var FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
  var FOCUS_WITHIN_ATTR = "data-fui-focus-within";
  var defaultOptions2 = {
    style: {},
    selector: "focus",
    customizeSelector: (selector) => selector
  };

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
  function applyFocusVisiblePolyfill(scope, targetWindow) {
    if (alreadyInScope(scope)) {
      return () => void 0;
    }
    const state = {
      current: void 0
    };
    const keyborg = createKeyborg(targetWindow);
    function registerElementIfNavigating(el) {
      if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
        state.current = el;
        el.setAttribute(FOCUS_VISIBLE_ATTR, "");
      }
    }
    function disposeCurrentElement() {
      if (state.current) {
        state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
        state.current = void 0;
      }
    }
    keyborg.subscribe((isNavigatingWithKeyboard) => {
      if (!isNavigatingWithKeyboard) {
        disposeCurrentElement();
      } else {
        registerElementIfNavigating(targetWindow.document.activeElement);
      }
    });
    const keyborgListener = (e) => {
      disposeCurrentElement();
      const target = e.composedPath()[0];
      registerElementIfNavigating(target);
    };
    const blurListener = (e) => {
      if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {
        disposeCurrentElement();
      }
    };
    scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
    scope.addEventListener("focusout", blurListener);
    scope.focusVisible = true;
    if (scope.contains(targetWindow.document.activeElement)) {
      registerElementIfNavigating(targetWindow.document.activeElement);
    }
    return () => {
      disposeCurrentElement();
      scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
      scope.removeEventListener("focusout", blurListener);
      delete scope.focusVisible;
      disposeKeyborg(keyborg);
    };
  }
  function alreadyInScope(el) {
    if (!el) {
      return false;
    }
    if (el.focusVisible) {
      return true;
    }
    return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
  function useFocusVisible(options = {}) {
    const contextValue = useFluent();
    const scopeRef = React52.useRef(null);
    var _options_targetDocument;
    const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
    React52.useEffect(() => {
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
        return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
      }
    }, [
      scopeRef,
      targetDocument
    ]);
    return scopeRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React53 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function applyFocusWithinPolyfill(element4, win) {
    const keyborg = createKeyborg(win);
    keyborg.subscribe((isNavigatingWithKeyboard) => {
      if (!isNavigatingWithKeyboard) {
        removeFocusWithinClass(element4);
      }
    });
    const keyborgListener = (e) => {
      if (keyborg.isNavigatingWithKeyboard() && isHTMLElement2(e.target)) {
        applyFocusWithinClass(element4);
      }
    };
    const blurListener = (e) => {
      if (!e.relatedTarget || isHTMLElement2(e.relatedTarget) && !element4.contains(e.relatedTarget)) {
        removeFocusWithinClass(element4);
      }
    };
    element4.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
    element4.addEventListener("focusout", blurListener);
    return () => {
      element4.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
      element4.removeEventListener("focusout", blurListener);
      disposeKeyborg(keyborg);
    };
  }
  function applyFocusWithinClass(el) {
    el.setAttribute(FOCUS_WITHIN_ATTR, "");
  }
  function removeFocusWithinClass(el) {
    el.removeAttribute(FOCUS_WITHIN_ATTR);
  }
  function isHTMLElement2(target) {
    if (!target) {
      return false;
    }
    return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
  function useFocusWithin() {
    const { targetDocument } = useFluent();
    const elementRef = React53.useRef(null);
    React53.useEffect(() => {
      if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
        return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
      }
    }, [
      elementRef,
      targetDocument
    ]);
    return elementRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React55 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useKeyborgRef.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React54 = __toESM(require_react());
  function useKeyborgRef() {
    const { targetDocument } = useFluent();
    const keyborgRef = React54.useRef(null);
    React54.useEffect(() => {
      const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
      if (targetWindow) {
        const keyborg = createKeyborg(targetWindow);
        keyborgRef.current = keyborg;
        return () => {
          disposeKeyborg(keyborg);
          keyborgRef.current = null;
        };
      }
    }, [
      targetDocument
    ]);
    return keyborgRef;
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
  function useOnKeyboardNavigationChange(callback) {
    const keyborgRef = useKeyborgRef();
    const eventCallback = useEventCallback(callback);
    React55.useEffect(() => {
      const keyborg = keyborgRef.current;
      if (keyborg) {
        const cb = (next2) => {
          eventCallback(next2);
        };
        keyborg.subscribe(cb);
        cb(keyborg.isNavigatingWithKeyboard());
        return () => {
          keyborg.unsubscribe(cb);
        };
      }
    }, [
      keyborgRef,
      eventCallback
    ]);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var DangerousNeverHiddenAttribute = "data-tabster-never-hide";
  var DangerousNeverHiddenPropObject = {
    [DangerousNeverHiddenAttribute]: ""
  };
  var tabsterAccessibleCheck = (element4) => {
    return element4.hasAttribute(DangerousNeverHiddenAttribute);
  };
  function initTabsterModules(tabster) {
    getModalizer(tabster, void 0, tabsterAccessibleCheck);
    getRestorer(tabster);
  }
  var useModalAttributes = (options = {}) => {
    const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
    useTabster(initTabsterModules);
    const id = useId4("modal-", options.id);
    const modalAttributes = useTabsterAttributes({
      restorer: {
        type: RestorerTypes.Source
      },
      ...trapFocus && {
        modalizer: {
          id,
          isOthersAccessible: !trapFocus,
          isAlwaysAccessible: alwaysFocusable,
          isTrapped: legacyTrapFocus && trapFocus
        }
      }
    });
    const triggerAttributes = useTabsterAttributes({
      restorer: {
        type: RestorerTypes.Target
      }
    });
    return {
      modalAttributes,
      triggerAttributes
    };
  };

  // ../../node_modules/@fluentui/react-tabster/lib/hooks/useSetKeyboardNavigation.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React56 = __toESM(require_react());
  function useSetKeyboardNavigation() {
    const keyborgRef = useKeyborgRef();
    return React56.useCallback((isNavigatingWithKeyboard) => {
      var _keyborgRef_current;
      (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.setVal(isNavigatingWithKeyboard);
    }, [
      keyborgRef
    ]);
  }

  // ../../node_modules/@fluentui/react-tabster/lib/focus/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabster/lib/focus/createCustomFocusIndicatorStyle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createCustomFocusIndicatorStyle(style, { selector: selectorType = defaultOptions2.selector, customizeSelector = defaultOptions2.customizeSelector } = defaultOptions2) {
    return {
      [customizeSelector(createBaseSelector(selectorType))]: style
    };
  }
  function createBaseSelector(selectorType) {
    switch (selectorType) {
      case "focus":
        return `&[${FOCUS_VISIBLE_ATTR}]`;
      case "focus-within":
        return `&[${FOCUS_WITHIN_ATTR}]:focus-within`;
    }
  }

  // ../../node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-theme/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/themes/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/global/colorPalette.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/global/colors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var grey = {
    "2": "#050505",
    "4": "#0a0a0a",
    "6": "#0f0f0f",
    "8": "#141414",
    "10": "#1a1a1a",
    "12": "#1f1f1f",
    "14": "#242424",
    "16": "#292929",
    "18": "#2e2e2e",
    "20": "#333333",
    "22": "#383838",
    "24": "#3d3d3d",
    "26": "#424242",
    "28": "#474747",
    "30": "#4d4d4d",
    "32": "#525252",
    "34": "#575757",
    "36": "#5c5c5c",
    "38": "#616161",
    "40": "#666666",
    "42": "#6b6b6b",
    "44": "#707070",
    "46": "#757575",
    "48": "#7a7a7a",
    "50": "#808080",
    "52": "#858585",
    "54": "#8a8a8a",
    "56": "#8f8f8f",
    "58": "#949494",
    "60": "#999999",
    "62": "#9e9e9e",
    "64": "#a3a3a3",
    "66": "#a8a8a8",
    "68": "#adadad",
    "70": "#b3b3b3",
    "72": "#b8b8b8",
    "74": "#bdbdbd",
    "76": "#c2c2c2",
    "78": "#c7c7c7",
    "80": "#cccccc",
    "82": "#d1d1d1",
    "84": "#d6d6d6",
    "86": "#dbdbdb",
    "88": "#e0e0e0",
    "90": "#e6e6e6",
    "92": "#ebebeb",
    "94": "#f0f0f0",
    "96": "#f5f5f5",
    "98": "#fafafa"
  };
  var whiteAlpha = {
    "5": "rgba(255, 255, 255, 0.05)",
    "10": "rgba(255, 255, 255, 0.1)",
    "20": "rgba(255, 255, 255, 0.2)",
    "30": "rgba(255, 255, 255, 0.3)",
    "40": "rgba(255, 255, 255, 0.4)",
    "50": "rgba(255, 255, 255, 0.5)",
    "60": "rgba(255, 255, 255, 0.6)",
    "70": "rgba(255, 255, 255, 0.7)",
    "80": "rgba(255, 255, 255, 0.8)",
    "90": "rgba(255, 255, 255, 0.9)"
  };
  var blackAlpha = {
    "5": "rgba(0, 0, 0, 0.05)",
    "10": "rgba(0, 0, 0, 0.1)",
    "20": "rgba(0, 0, 0, 0.2)",
    "30": "rgba(0, 0, 0, 0.3)",
    "40": "rgba(0, 0, 0, 0.4)",
    "50": "rgba(0, 0, 0, 0.5)",
    "60": "rgba(0, 0, 0, 0.6)",
    "70": "rgba(0, 0, 0, 0.7)",
    "80": "rgba(0, 0, 0, 0.8)",
    "90": "rgba(0, 0, 0, 0.9)"
  };
  var grey10Alpha = {
    "5": "rgba(26, 26, 26, 0.05)",
    "10": "rgba(26, 26, 26, 0.1)",
    "20": "rgba(26, 26, 26, 0.2)",
    "30": "rgba(26, 26, 26, 0.3)",
    "40": "rgba(26, 26, 26, 0.4)",
    "50": "rgba(26, 26, 26, 0.5)",
    "60": "rgba(26, 26, 26, 0.6)",
    "70": "rgba(26, 26, 26, 0.7)",
    "80": "rgba(26, 26, 26, 0.8)",
    "90": "rgba(26, 26, 26, 0.9)"
  };
  var grey12Alpha = {
    "5": "rgba(31, 31, 31, 0.05)",
    "10": "rgba(31, 31, 31, 0.1)",
    "20": "rgba(31, 31, 31, 0.2)",
    "30": "rgba(31, 31, 31, 0.3)",
    "40": "rgba(31, 31, 31, 0.4)",
    "50": "rgba(31, 31, 31, 0.5)",
    "60": "rgba(31, 31, 31, 0.6)",
    "70": "rgba(31, 31, 31, 0.7)",
    "80": "rgba(31, 31, 31, 0.8)",
    "90": "rgba(31, 31, 31, 0.9)"
  };
  var grey14Alpha = {
    "5": "rgba(36, 36, 36, 0.05)",
    "10": "rgba(36, 36, 36, 0.1)",
    "20": "rgba(36, 36, 36, 0.2)",
    "30": "rgba(36, 36, 36, 0.3)",
    "40": "rgba(36, 36, 36, 0.4)",
    "50": "rgba(36, 36, 36, 0.5)",
    "60": "rgba(36, 36, 36, 0.6)",
    "70": "rgba(36, 36, 36, 0.7)",
    "80": "rgba(36, 36, 36, 0.8)",
    "90": "rgba(36, 36, 36, 0.9)"
  };
  var white = "#ffffff";
  var black = "#000000";
  var darkRed = {
    shade50: "#130204",
    shade40: "#230308",
    shade30: "#420610",
    shade20: "#590815",
    shade10: "#690a19",
    primary: "#750b1c",
    tint10: "#861b2c",
    tint20: "#962f3f",
    tint30: "#ac4f5e",
    tint40: "#d69ca5",
    tint50: "#e9c7cd",
    tint60: "#f9f0f2"
  };
  var cranberry = {
    shade50: "#200205",
    shade40: "#3b0509",
    shade30: "#6e0811",
    shade20: "#960b18",
    shade10: "#b10e1c",
    primary: "#c50f1f",
    tint10: "#cc2635",
    tint20: "#d33f4c",
    tint30: "#dc626d",
    tint40: "#eeacb2",
    tint50: "#f6d1d5",
    tint60: "#fdf3f4"
  };
  var red = {
    shade50: "#210809",
    shade40: "#3f1011",
    shade30: "#751d1f",
    shade20: "#9f282b",
    shade10: "#bc2f32",
    primary: "#d13438",
    tint10: "#d7494c",
    tint20: "#dc5e62",
    tint30: "#e37d80",
    tint40: "#f1bbbc",
    tint50: "#f8dadb",
    tint60: "#fdf6f6"
  };
  var darkOrange = {
    shade50: "#230900",
    shade40: "#411200",
    shade30: "#7a2101",
    shade20: "#a62d01",
    shade10: "#c43501",
    primary: "#da3b01",
    tint10: "#de501c",
    tint20: "#e36537",
    tint30: "#e9835e",
    tint40: "#f4bfab",
    tint50: "#f9dcd1",
    tint60: "#fdf6f3"
  };
  var pumpkin = {
    shade50: "#200d03",
    shade40: "#3d1805",
    shade30: "#712d09",
    shade20: "#9a3d0c",
    shade10: "#b6480e",
    primary: "#ca5010",
    tint10: "#d06228",
    tint20: "#d77440",
    tint30: "#df8e64",
    tint40: "#efc4ad",
    tint50: "#f7dfd2",
    tint60: "#fdf7f4"
  };
  var orange = {
    shade50: "#271002",
    shade40: "#4a1e04",
    shade30: "#8a3707",
    shade20: "#bc4b09",
    shade10: "#de590b",
    primary: "#f7630c",
    tint10: "#f87528",
    tint20: "#f98845",
    tint30: "#faa06b",
    tint40: "#fdcfb4",
    tint50: "#fee5d7",
    tint60: "#fff9f5"
  };
  var peach = {
    shade50: "#291600",
    shade40: "#4d2a00",
    shade30: "#8f4e00",
    shade20: "#c26a00",
    shade10: "#e67e00",
    primary: "#ff8c00",
    tint10: "#ff9a1f",
    tint20: "#ffa83d",
    tint30: "#ffba66",
    tint40: "#ffddb3",
    tint50: "#ffedd6",
    tint60: "#fffaf5"
  };
  var marigold = {
    shade50: "#251a00",
    shade40: "#463100",
    shade30: "#835b00",
    shade20: "#b27c00",
    shade10: "#d39300",
    primary: "#eaa300",
    tint10: "#edad1c",
    tint20: "#efb839",
    tint30: "#f2c661",
    tint40: "#f9e2ae",
    tint50: "#fcefd3",
    tint60: "#fefbf4"
  };
  var yellow = {
    shade50: "#282400",
    shade40: "#4c4400",
    shade30: "#817400",
    shade20: "#c0ad00",
    shade10: "#e4cc00",
    primary: "#fde300",
    tint10: "#fde61e",
    tint20: "#fdea3d",
    tint30: "#feee66",
    tint40: "#fef7b2",
    tint50: "#fffad6",
    tint60: "#fffef5"
  };
  var gold = {
    shade50: "#1f1900",
    shade40: "#3a2f00",
    shade30: "#6c5700",
    shade20: "#937700",
    shade10: "#ae8c00",
    primary: "#c19c00",
    tint10: "#c8a718",
    tint20: "#d0b232",
    tint30: "#dac157",
    tint40: "#ecdfa5",
    tint50: "#f5eece",
    tint60: "#fdfbf2"
  };
  var brass = {
    shade50: "#181202",
    shade40: "#2e2103",
    shade30: "#553e06",
    shade20: "#745408",
    shade10: "#89640a",
    primary: "#986f0b",
    tint10: "#a47d1e",
    tint20: "#b18c34",
    tint30: "#c1a256",
    tint40: "#e0cea2",
    tint50: "#efe4cb",
    tint60: "#fbf8f2"
  };
  var brown = {
    shade50: "#170e07",
    shade40: "#2b1a0e",
    shade30: "#50301a",
    shade20: "#6c4123",
    shade10: "#804d29",
    primary: "#8e562e",
    tint10: "#9c663f",
    tint20: "#a97652",
    tint30: "#bb8f6f",
    tint40: "#ddc3b0",
    tint50: "#edded3",
    tint60: "#faf7f4"
  };
  var forest = {
    shade50: "#0c1501",
    shade40: "#162702",
    shade30: "#294903",
    shade20: "#376304",
    shade10: "#427505",
    primary: "#498205",
    tint10: "#599116",
    tint20: "#6ba02b",
    tint30: "#85b44c",
    tint40: "#bdd99b",
    tint50: "#dbebc7",
    tint60: "#f6faf0"
  };
  var seafoam = {
    shade50: "#002111",
    shade40: "#003d20",
    shade30: "#00723b",
    shade20: "#009b51",
    shade10: "#00b85f",
    primary: "#00cc6a",
    tint10: "#19d279",
    tint20: "#34d889",
    tint30: "#5ae0a0",
    tint40: "#a8f0cd",
    tint50: "#cff7e4",
    tint60: "#f3fdf8"
  };
  var lightGreen = {
    shade50: "#031a02",
    shade40: "#063004",
    shade30: "#0b5a08",
    shade20: "#0e7a0b",
    shade10: "#11910d",
    primary: "#13a10e",
    tint10: "#27ac22",
    tint20: "#3db838",
    tint30: "#5ec75a",
    tint40: "#a7e3a5",
    tint50: "#cef0cd",
    tint60: "#f2fbf2"
  };
  var green = {
    shade50: "#031403",
    shade40: "#052505",
    shade30: "#094509",
    shade20: "#0c5e0c",
    shade10: "#0e700e",
    primary: "#107c10",
    tint10: "#218c21",
    tint20: "#359b35",
    tint30: "#54b054",
    tint40: "#9fd89f",
    tint50: "#c9eac9",
    tint60: "#f1faf1"
  };
  var darkGreen = {
    shade50: "#021102",
    shade40: "#032003",
    shade30: "#063b06",
    shade20: "#085108",
    shade10: "#0a5f0a",
    primary: "#0b6a0b",
    tint10: "#1a7c1a",
    tint20: "#2d8e2d",
    tint30: "#4da64d",
    tint40: "#9ad29a",
    tint50: "#c6e7c6",
    tint60: "#f0f9f0"
  };
  var lightTeal = {
    shade50: "#001d1f",
    shade40: "#00373a",
    shade30: "#00666d",
    shade20: "#008b94",
    shade10: "#00a5af",
    primary: "#00b7c3",
    tint10: "#18bfca",
    tint20: "#32c8d1",
    tint30: "#58d3db",
    tint40: "#a6e9ed",
    tint50: "#cef3f5",
    tint60: "#f2fcfd"
  };
  var teal = {
    shade50: "#001516",
    shade40: "#012728",
    shade30: "#02494c",
    shade20: "#026467",
    shade10: "#037679",
    primary: "#038387",
    tint10: "#159195",
    tint20: "#2aa0a4",
    tint30: "#4cb4b7",
    tint40: "#9bd9db",
    tint50: "#c7ebec",
    tint60: "#f0fafa"
  };
  var steel = {
    shade50: "#000f12",
    shade40: "#001b22",
    shade30: "#00333f",
    shade20: "#004555",
    shade10: "#005265",
    primary: "#005b70",
    tint10: "#0f6c81",
    tint20: "#237d92",
    tint30: "#4496a9",
    tint40: "#94c8d4",
    tint50: "#c3e1e8",
    tint60: "#eff7f9"
  };
  var blue = {
    shade50: "#001322",
    shade40: "#002440",
    shade30: "#004377",
    shade20: "#005ba1",
    shade10: "#006cbf",
    primary: "#0078d4",
    tint10: "#1a86d9",
    tint20: "#3595de",
    tint30: "#5caae5",
    tint40: "#a9d3f2",
    tint50: "#d0e7f8",
    tint60: "#f3f9fd"
  };
  var royalBlue = {
    shade50: "#000c16",
    shade40: "#00172a",
    shade30: "#002c4e",
    shade20: "#003b6a",
    shade10: "#00467e",
    primary: "#004e8c",
    tint10: "#125e9a",
    tint20: "#286fa8",
    tint30: "#4a89ba",
    tint40: "#9abfdc",
    tint50: "#c7dced",
    tint60: "#f0f6fa"
  };
  var cornflower = {
    shade50: "#0d1126",
    shade40: "#182047",
    shade30: "#2c3c85",
    shade20: "#3c51b4",
    shade10: "#4760d5",
    primary: "#4f6bed",
    tint10: "#637cef",
    tint20: "#778df1",
    tint30: "#93a4f4",
    tint40: "#c8d1fa",
    tint50: "#e1e6fc",
    tint60: "#f7f9fe"
  };
  var navy = {
    shade50: "#00061d",
    shade40: "#000c36",
    shade30: "#001665",
    shade20: "#001e89",
    shade10: "#0023a2",
    primary: "#0027b4",
    tint10: "#173bbd",
    tint20: "#3050c6",
    tint30: "#546fd2",
    tint40: "#a3b2e8",
    tint50: "#ccd5f3",
    tint60: "#f2f4fc"
  };
  var lavender = {
    shade50: "#120f25",
    shade40: "#221d46",
    shade30: "#3f3682",
    shade20: "#5649b0",
    shade10: "#6656d1",
    primary: "#7160e8",
    tint10: "#8172eb",
    tint20: "#9184ee",
    tint30: "#a79cf1",
    tint40: "#d2ccf8",
    tint50: "#e7e4fb",
    tint60: "#f9f8fe"
  };
  var purple = {
    shade50: "#0f0717",
    shade40: "#1c0e2b",
    shade30: "#341a51",
    shade20: "#46236e",
    shade10: "#532982",
    primary: "#5c2e91",
    tint10: "#6b3f9e",
    tint20: "#7c52ab",
    tint30: "#9470bd",
    tint40: "#c6b1de",
    tint50: "#e0d3ed",
    tint60: "#f7f4fb"
  };
  var grape = {
    shade50: "#160418",
    shade40: "#29072e",
    shade30: "#4c0d55",
    shade20: "#671174",
    shade10: "#7a1589",
    primary: "#881798",
    tint10: "#952aa4",
    tint20: "#a33fb1",
    tint30: "#b55fc1",
    tint40: "#d9a7e0",
    tint50: "#eaceef",
    tint60: "#faf2fb"
  };
  var berry = {
    shade50: "#1f091d",
    shade40: "#3a1136",
    shade30: "#6d2064",
    shade20: "#932b88",
    shade10: "#af33a1",
    primary: "#c239b3",
    tint10: "#c94cbc",
    tint20: "#d161c4",
    tint30: "#da7ed0",
    tint40: "#edbbe7",
    tint50: "#f5daf2",
    tint60: "#fdf5fc"
  };
  var lilac = {
    shade50: "#1c0b1f",
    shade40: "#35153a",
    shade30: "#63276d",
    shade20: "#863593",
    shade10: "#9f3faf",
    primary: "#b146c2",
    tint10: "#ba58c9",
    tint20: "#c36bd1",
    tint30: "#cf87da",
    tint40: "#e6bfed",
    tint50: "#f2dcf5",
    tint60: "#fcf6fd"
  };
  var pink = {
    shade50: "#24091b",
    shade40: "#441232",
    shade30: "#80215d",
    shade20: "#ad2d7e",
    shade10: "#cd3595",
    primary: "#e43ba6",
    tint10: "#e750b0",
    tint20: "#ea66ba",
    tint30: "#ef85c8",
    tint40: "#f7c0e3",
    tint50: "#fbddf0",
    tint60: "#fef6fb"
  };
  var magenta = {
    shade50: "#1f0013",
    shade40: "#390024",
    shade30: "#6b0043",
    shade20: "#91005a",
    shade10: "#ac006b",
    primary: "#bf0077",
    tint10: "#c71885",
    tint20: "#ce3293",
    tint30: "#d957a8",
    tint40: "#eca5d1",
    tint50: "#f5cee6",
    tint60: "#fcf2f9"
  };
  var plum = {
    shade50: "#13000c",
    shade40: "#240017",
    shade30: "#43002b",
    shade20: "#5a003b",
    shade10: "#6b0045",
    primary: "#77004d",
    tint10: "#87105d",
    tint20: "#98246f",
    tint30: "#ad4589",
    tint40: "#d696c0",
    tint50: "#e9c4dc",
    tint60: "#faf0f6"
  };
  var beige = {
    shade50: "#141313",
    shade40: "#252323",
    shade30: "#444241",
    shade20: "#5d5958",
    shade10: "#6e6968",
    primary: "#7a7574",
    tint10: "#8a8584",
    tint20: "#9a9594",
    tint30: "#afabaa",
    tint40: "#d7d4d4",
    tint50: "#eae8e8",
    tint60: "#faf9f9"
  };
  var mink = {
    shade50: "#0f0e0e",
    shade40: "#1c1b1a",
    shade30: "#343231",
    shade20: "#474443",
    shade10: "#54514f",
    primary: "#5d5a58",
    tint10: "#706d6b",
    tint20: "#84817e",
    tint30: "#9e9b99",
    tint40: "#cecccb",
    tint50: "#e5e4e3",
    tint60: "#f8f8f8"
  };
  var platinum = {
    shade50: "#111314",
    shade40: "#1f2426",
    shade30: "#3b4447",
    shade20: "#505c60",
    shade10: "#5f6d71",
    primary: "#69797e",
    tint10: "#79898d",
    tint20: "#89989d",
    tint30: "#a0adb2",
    tint40: "#cdd6d8",
    tint50: "#e4e9ea",
    tint60: "#f8f9fa"
  };
  var anchor = {
    shade50: "#090a0b",
    shade40: "#111315",
    shade30: "#202427",
    shade20: "#2b3135",
    shade10: "#333a3f",
    primary: "#394146",
    tint10: "#4d565c",
    tint20: "#626c72",
    tint30: "#808a90",
    tint40: "#bcc3c7",
    tint50: "#dbdfe1",
    tint60: "#f6f7f8"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/colorPalette.js
  var statusSharedColors = {
    red,
    green,
    darkOrange,
    yellow,
    berry,
    lightGreen,
    marigold
  };
  var personaSharedColors = {
    darkRed,
    cranberry,
    pumpkin,
    peach,
    gold,
    brass,
    brown,
    forest,
    seafoam,
    darkGreen,
    lightTeal,
    teal,
    steel,
    blue,
    royalBlue,
    cornflower,
    navy,
    lavender,
    purple,
    grape,
    lilac,
    pink,
    magenta,
    plum,
    beige,
    mink,
    platinum,
    anchor
  };
  var mappedStatusColors = {
    cranberry,
    green,
    orange
  };

  // ../../node_modules/@fluentui/tokens/lib/sharedColorNames.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var statusSharedColorNames = [
    "red",
    "green",
    "darkOrange",
    "yellow",
    "berry",
    "lightGreen",
    "marigold"
  ];
  var personaSharedColorNames = [
    "darkRed",
    "cranberry",
    "pumpkin",
    "peach",
    "gold",
    "brass",
    "brown",
    "forest",
    "seafoam",
    "darkGreen",
    "lightTeal",
    "teal",
    "steel",
    "blue",
    "royalBlue",
    "cornflower",
    "navy",
    "lavender",
    "purple",
    "grape",
    "lilac",
    "pink",
    "magenta",
    "plum",
    "beige",
    "mink",
    "platinum",
    "anchor"
  ];

  // ../../node_modules/@fluentui/tokens/lib/statusColorMapping.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var statusColorMapping = {
    success: "green",
    warning: "orange",
    danger: "cranberry"
  };

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
  var statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
    const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].tint60,
      [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].tint40,
      [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].shade10,
      [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].shade30,
      [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].tint40,
      [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].primary
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  statusColorPaletteTokens.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
  statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
  statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
  statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
  var personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
    const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].tint40,
      [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].shade30,
      [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].primary
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  var colorPaletteTokens = {
    ...statusColorPaletteTokens,
    ...personaColorPaletteTokens
  };
  var colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
    const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
    const statusColorTokens = {
      [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].tint60,
      [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].tint40,
      [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].shade10,
      [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].shade30,
      [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
      [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].tint40,
      [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].primary
    };
    return Object.assign(acc, statusColorTokens);
  }, {});
  colorStatusTokens.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
  colorStatusTokens.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
  colorStatusTokens.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
  colorStatusTokens.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
  colorStatusTokens.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

  // ../../node_modules/@fluentui/tokens/lib/alias/lightColor.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var generateColorTokens = (brand) => ({
    colorNeutralForeground1: grey[14],
    colorNeutralForeground1Hover: grey[14],
    colorNeutralForeground1Pressed: grey[14],
    colorNeutralForeground1Selected: grey[14],
    colorNeutralForeground2: grey[26],
    colorNeutralForeground2Hover: grey[14],
    colorNeutralForeground2Pressed: grey[14],
    colorNeutralForeground2Selected: grey[14],
    colorNeutralForeground2BrandHover: brand[80],
    colorNeutralForeground2BrandPressed: brand[70],
    colorNeutralForeground2BrandSelected: brand[80],
    colorNeutralForeground3: grey[38],
    colorNeutralForeground3Hover: grey[26],
    colorNeutralForeground3Pressed: grey[26],
    colorNeutralForeground3Selected: grey[26],
    colorNeutralForeground3BrandHover: brand[80],
    colorNeutralForeground3BrandPressed: brand[70],
    colorNeutralForeground3BrandSelected: brand[80],
    colorNeutralForeground4: grey[44],
    colorNeutralForegroundDisabled: grey[74],
    colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
    colorBrandForegroundLink: brand[70],
    colorBrandForegroundLinkHover: brand[60],
    colorBrandForegroundLinkPressed: brand[40],
    colorBrandForegroundLinkSelected: brand[70],
    colorNeutralForeground2Link: grey[26],
    colorNeutralForeground2LinkHover: grey[14],
    colorNeutralForeground2LinkPressed: grey[14],
    colorNeutralForeground2LinkSelected: grey[14],
    colorCompoundBrandForeground1: brand[80],
    colorCompoundBrandForeground1Hover: brand[70],
    colorCompoundBrandForeground1Pressed: brand[60],
    colorBrandForeground1: brand[80],
    colorBrandForeground2: brand[70],
    colorBrandForeground2Hover: brand[60],
    colorBrandForeground2Pressed: brand[30],
    colorNeutralForeground1Static: grey[14],
    colorNeutralForegroundStaticInverted: white,
    colorNeutralForegroundInverted: white,
    colorNeutralForegroundInvertedHover: white,
    colorNeutralForegroundInvertedPressed: white,
    colorNeutralForegroundInvertedSelected: white,
    colorNeutralForegroundInverted2: white,
    colorNeutralForegroundOnBrand: white,
    colorNeutralForegroundInvertedLink: white,
    colorNeutralForegroundInvertedLinkHover: white,
    colorNeutralForegroundInvertedLinkPressed: white,
    colorNeutralForegroundInvertedLinkSelected: white,
    colorBrandForegroundInverted: brand[100],
    colorBrandForegroundInvertedHover: brand[110],
    colorBrandForegroundInvertedPressed: brand[100],
    colorBrandForegroundOnLight: brand[80],
    colorBrandForegroundOnLightHover: brand[70],
    colorBrandForegroundOnLightPressed: brand[50],
    colorBrandForegroundOnLightSelected: brand[60],
    colorNeutralBackground1: white,
    colorNeutralBackground1Hover: grey[96],
    colorNeutralBackground1Pressed: grey[88],
    colorNeutralBackground1Selected: grey[92],
    colorNeutralBackground2: grey[98],
    colorNeutralBackground2Hover: grey[94],
    colorNeutralBackground2Pressed: grey[86],
    colorNeutralBackground2Selected: grey[90],
    colorNeutralBackground3: grey[96],
    colorNeutralBackground3Hover: grey[92],
    colorNeutralBackground3Pressed: grey[84],
    colorNeutralBackground3Selected: grey[88],
    colorNeutralBackground4: grey[94],
    colorNeutralBackground4Hover: grey[98],
    colorNeutralBackground4Pressed: grey[96],
    colorNeutralBackground4Selected: white,
    colorNeutralBackground5: grey[92],
    colorNeutralBackground5Hover: grey[96],
    colorNeutralBackground5Pressed: grey[94],
    colorNeutralBackground5Selected: grey[98],
    colorNeutralBackground6: grey[90],
    colorNeutralBackgroundInverted: grey[16],
    colorNeutralBackgroundStatic: grey[20],
    colorNeutralBackgroundAlpha: whiteAlpha[50],
    colorNeutralBackgroundAlpha2: whiteAlpha[80],
    colorSubtleBackground: "transparent",
    colorSubtleBackgroundHover: grey[96],
    colorSubtleBackgroundPressed: grey[88],
    colorSubtleBackgroundSelected: grey[92],
    colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
    colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
    colorSubtleBackgroundLightAlphaSelected: "transparent",
    colorSubtleBackgroundInverted: "transparent",
    colorSubtleBackgroundInvertedHover: blackAlpha[10],
    colorSubtleBackgroundInvertedPressed: blackAlpha[30],
    colorSubtleBackgroundInvertedSelected: blackAlpha[20],
    colorTransparentBackground: "transparent",
    colorTransparentBackgroundHover: "transparent",
    colorTransparentBackgroundPressed: "transparent",
    colorTransparentBackgroundSelected: "transparent",
    colorNeutralBackgroundDisabled: grey[94],
    colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
    colorNeutralStencil1: grey[90],
    colorNeutralStencil2: grey[98],
    colorNeutralStencil1Alpha: blackAlpha[10],
    colorNeutralStencil2Alpha: blackAlpha[5],
    colorBackgroundOverlay: blackAlpha[40],
    colorScrollbarOverlay: blackAlpha[50],
    colorBrandBackground: brand[80],
    colorBrandBackgroundHover: brand[70],
    colorBrandBackgroundPressed: brand[40],
    colorBrandBackgroundSelected: brand[60],
    colorCompoundBrandBackground: brand[80],
    colorCompoundBrandBackgroundHover: brand[70],
    colorCompoundBrandBackgroundPressed: brand[60],
    colorBrandBackgroundStatic: brand[80],
    colorBrandBackground2: brand[160],
    colorBrandBackground2Hover: brand[150],
    colorBrandBackground2Pressed: brand[130],
    colorBrandBackground3Static: brand[60],
    colorBrandBackground4Static: brand[40],
    colorBrandBackgroundInverted: white,
    colorBrandBackgroundInvertedHover: brand[160],
    colorBrandBackgroundInvertedPressed: brand[140],
    colorBrandBackgroundInvertedSelected: brand[150],
    colorNeutralCardBackground: grey[98],
    colorNeutralCardBackgroundHover: white,
    colorNeutralCardBackgroundPressed: grey[96],
    colorNeutralCardBackgroundSelected: grey[92],
    colorNeutralCardBackgroundDisabled: grey[94],
    colorNeutralStrokeAccessible: grey[38],
    colorNeutralStrokeAccessibleHover: grey[34],
    colorNeutralStrokeAccessiblePressed: grey[30],
    colorNeutralStrokeAccessibleSelected: brand[80],
    colorNeutralStroke1: grey[82],
    colorNeutralStroke1Hover: grey[78],
    colorNeutralStroke1Pressed: grey[70],
    colorNeutralStroke1Selected: grey[74],
    colorNeutralStroke2: grey[88],
    colorNeutralStroke3: grey[94],
    colorNeutralStrokeSubtle: grey[88],
    colorNeutralStrokeOnBrand: white,
    colorNeutralStrokeOnBrand2: white,
    colorNeutralStrokeOnBrand2Hover: white,
    colorNeutralStrokeOnBrand2Pressed: white,
    colorNeutralStrokeOnBrand2Selected: white,
    colorBrandStroke1: brand[80],
    colorBrandStroke2: brand[140],
    colorBrandStroke2Hover: brand[120],
    colorBrandStroke2Pressed: brand[80],
    colorBrandStroke2Contrast: brand[140],
    colorCompoundBrandStroke: brand[80],
    colorCompoundBrandStrokeHover: brand[70],
    colorCompoundBrandStrokePressed: brand[60],
    colorNeutralStrokeDisabled: grey[88],
    colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
    colorTransparentStroke: "transparent",
    colorTransparentStrokeInteractive: "transparent",
    colorTransparentStrokeDisabled: "transparent",
    colorNeutralStrokeAlpha: blackAlpha[5],
    colorNeutralStrokeAlpha2: whiteAlpha[20],
    colorStrokeFocus1: white,
    colorStrokeFocus2: black,
    colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
    colorNeutralShadowKey: "rgba(0,0,0,0.14)",
    colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
    colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
    colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
    colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
    colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
    colorBrandShadowKey: "rgba(0,0,0,0.25)"
  });

  // ../../node_modules/@fluentui/tokens/lib/global/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/global/borderRadius.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var borderRadius3 = {
    borderRadiusNone: "0",
    borderRadiusSmall: "2px",
    borderRadiusMedium: "4px",
    borderRadiusLarge: "6px",
    borderRadiusXLarge: "8px",
    borderRadiusCircular: "10000px"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/curves.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var curves = {
    curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
    curveAccelerateMid: "cubic-bezier(1,0,1,1)",
    curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
    curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
    curveDecelerateMid: "cubic-bezier(0,0,0,1)",
    curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
    curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
    curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
    curveLinear: "cubic-bezier(0,0,1,1)"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/durations.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var durations = {
    durationUltraFast: "50ms",
    durationFaster: "100ms",
    durationFast: "150ms",
    durationNormal: "200ms",
    durationGentle: "250ms",
    durationSlow: "300ms",
    durationSlower: "400ms",
    durationUltraSlow: "500ms"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/fonts.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var fontSizes = {
    fontSizeBase100: "10px",
    fontSizeBase200: "12px",
    fontSizeBase300: "14px",
    fontSizeBase400: "16px",
    fontSizeBase500: "20px",
    fontSizeBase600: "24px",
    fontSizeHero700: "28px",
    fontSizeHero800: "32px",
    fontSizeHero900: "40px",
    fontSizeHero1000: "68px"
  };
  var lineHeights = {
    lineHeightBase100: "14px",
    lineHeightBase200: "16px",
    lineHeightBase300: "20px",
    lineHeightBase400: "22px",
    lineHeightBase500: "28px",
    lineHeightBase600: "32px",
    lineHeightHero700: "36px",
    lineHeightHero800: "40px",
    lineHeightHero900: "52px",
    lineHeightHero1000: "92px"
  };
  var fontWeights = {
    fontWeightRegular: 400,
    fontWeightMedium: 500,
    fontWeightSemibold: 600,
    fontWeightBold: 700
  };
  var fontFamilies = {
    fontFamilyBase: "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif",
    fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
    fontFamilyNumeric: "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
  };

  // ../../node_modules/@fluentui/tokens/lib/global/spacings.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var spacings = {
    none: "0",
    xxs: "2px",
    xs: "4px",
    sNudge: "6px",
    s: "8px",
    mNudge: "10px",
    m: "12px",
    l: "16px",
    xl: "20px",
    xxl: "24px",
    xxxl: "32px"
  };
  var horizontalSpacings = {
    spacingHorizontalNone: spacings.none,
    spacingHorizontalXXS: spacings.xxs,
    spacingHorizontalXS: spacings.xs,
    spacingHorizontalSNudge: spacings.sNudge,
    spacingHorizontalS: spacings.s,
    spacingHorizontalMNudge: spacings.mNudge,
    spacingHorizontalM: spacings.m,
    spacingHorizontalL: spacings.l,
    spacingHorizontalXL: spacings.xl,
    spacingHorizontalXXL: spacings.xxl,
    spacingHorizontalXXXL: spacings.xxxl
  };
  var verticalSpacings = {
    spacingVerticalNone: spacings.none,
    spacingVerticalXXS: spacings.xxs,
    spacingVerticalXS: spacings.xs,
    spacingVerticalSNudge: spacings.sNudge,
    spacingVerticalS: spacings.s,
    spacingVerticalMNudge: spacings.mNudge,
    spacingVerticalM: spacings.m,
    spacingVerticalL: spacings.l,
    spacingVerticalXL: spacings.xl,
    spacingVerticalXXL: spacings.xxl,
    spacingVerticalXXXL: spacings.xxxl
  };

  // ../../node_modules/@fluentui/tokens/lib/global/strokeWidths.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var strokeWidths = {
    strokeWidthThin: "1px",
    strokeWidthThick: "2px",
    strokeWidthThicker: "3px",
    strokeWidthThickest: "4px"
  };

  // ../../node_modules/@fluentui/tokens/lib/tokens.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tokens = {
    // Color tokens
    colorNeutralForeground1: "var(--colorNeutralForeground1)",
    colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
    colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
    colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
    colorNeutralForeground2: "var(--colorNeutralForeground2)",
    colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
    colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
    colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
    colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
    colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
    colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
    colorNeutralForeground3: "var(--colorNeutralForeground3)",
    colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
    colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
    colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
    colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
    colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
    colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
    colorNeutralForeground4: "var(--colorNeutralForeground4)",
    colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
    colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
    colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
    colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
    colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
    colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
    colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
    colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
    colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
    colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
    colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
    colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
    colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
    colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
    colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
    colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
    colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
    colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
    colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
    colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
    colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
    colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
    colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
    colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
    colorBrandForeground1: "var(--colorBrandForeground1)",
    colorBrandForeground2: "var(--colorBrandForeground2)",
    colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
    colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
    colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
    colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
    colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
    colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
    colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
    colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
    colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
    colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
    colorNeutralBackground1: "var(--colorNeutralBackground1)",
    colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
    colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
    colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
    colorNeutralBackground2: "var(--colorNeutralBackground2)",
    colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
    colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
    colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
    colorNeutralBackground3: "var(--colorNeutralBackground3)",
    colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
    colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
    colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
    colorNeutralBackground4: "var(--colorNeutralBackground4)",
    colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
    colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
    colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
    colorNeutralBackground5: "var(--colorNeutralBackground5)",
    colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
    colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
    colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
    colorNeutralBackground6: "var(--colorNeutralBackground6)",
    colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
    colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
    colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
    colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
    colorSubtleBackground: "var(--colorSubtleBackground)",
    colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
    colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
    colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
    colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
    colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
    colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
    colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
    colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
    colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
    colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
    colorTransparentBackground: "var(--colorTransparentBackground)",
    colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
    colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
    colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
    colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
    colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
    colorNeutralStencil1: "var(--colorNeutralStencil1)",
    colorNeutralStencil2: "var(--colorNeutralStencil2)",
    colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
    colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
    colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
    colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
    colorBrandBackground: "var(--colorBrandBackground)",
    colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
    colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
    colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
    colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
    colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
    colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
    colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
    colorBrandBackground2: "var(--colorBrandBackground2)",
    colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
    colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
    colorBrandBackground3Static: "var(--colorBrandBackground3Static)",
    colorBrandBackground4Static: "var(--colorBrandBackground4Static)",
    colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
    colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
    colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
    colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
    colorNeutralCardBackground: "var(--colorNeutralCardBackground)",
    colorNeutralCardBackgroundHover: "var(--colorNeutralCardBackgroundHover)",
    colorNeutralCardBackgroundPressed: "var(--colorNeutralCardBackgroundPressed)",
    colorNeutralCardBackgroundSelected: "var(--colorNeutralCardBackgroundSelected)",
    colorNeutralCardBackgroundDisabled: "var(--colorNeutralCardBackgroundDisabled)",
    colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
    colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
    colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
    colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
    colorNeutralStroke1: "var(--colorNeutralStroke1)",
    colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
    colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
    colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
    colorNeutralStroke2: "var(--colorNeutralStroke2)",
    colorNeutralStroke3: "var(--colorNeutralStroke3)",
    colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
    colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
    colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
    colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
    colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
    colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
    colorBrandStroke1: "var(--colorBrandStroke1)",
    colorBrandStroke2: "var(--colorBrandStroke2)",
    colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
    colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
    colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
    colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
    colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
    colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
    colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
    colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
    colorTransparentStroke: "var(--colorTransparentStroke)",
    colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
    colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
    colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
    colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
    colorStrokeFocus1: "var(--colorStrokeFocus1)",
    colorStrokeFocus2: "var(--colorStrokeFocus2)",
    colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
    colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
    colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
    colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
    colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
    colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
    colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
    colorBrandShadowKey: "var(--colorBrandShadowKey)",
    // Color palette tokens
    // Color palette red tokens
    colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
    colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
    colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
    colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
    colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
    colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
    colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
    colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
    colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
    colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
    // Color palette green tokens
    colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
    colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
    colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
    colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
    colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
    colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
    colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
    colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
    colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
    colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
    // Color palette dark orange tokens
    colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
    colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
    colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
    colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
    colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
    colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
    colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
    colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
    colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
    // Color palette yellow tokens
    colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
    colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
    colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
    colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
    colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
    colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
    colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
    colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
    colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
    colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
    // Color palette berry tokens
    colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
    colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
    colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
    colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
    colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
    colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
    colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
    colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
    colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
    // Color palette marigold tokens
    colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
    colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
    colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
    colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
    colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
    colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
    colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
    colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
    colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
    // Color palette light green tokens
    colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
    colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
    colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
    colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
    colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
    colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
    colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
    colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
    colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
    // Color palette anchor tokens
    colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
    colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
    colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
    // Color palette beige tokens
    colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
    colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
    colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
    // Color palette blue tokens
    colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
    colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
    colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
    // Color palette brass tokens
    colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
    colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
    colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
    // Color palette brown tokens
    colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
    colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
    colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
    // Color palette cornflower tokens
    colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
    colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
    colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
    // Color palette cranberry tokens
    colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
    colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
    colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
    // Color palette dark green tokens
    colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
    colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
    colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
    // Color palette dark red tokens
    colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
    colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
    colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
    // Color palette forest tokens
    colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
    colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
    colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
    // Color palette gold tokens
    colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
    colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
    colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
    // Color palette grape tokens
    colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
    colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
    colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
    // Color palette lavender tokens
    colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
    colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
    colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
    // Color palette light teal tokens
    colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
    colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
    colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
    // Color palette lilac tokens
    colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
    colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
    colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
    // Color palette magenta tokens
    colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
    colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
    colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
    // Color palette mink tokens
    colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
    colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
    colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
    // Color palette navy tokens
    colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
    colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
    colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
    // Color palette peach tokens
    colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
    colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
    colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
    // Color palette pink tokens
    colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
    colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
    colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
    // Color palette platinum tokens
    colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
    colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
    colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
    // Color palette plum tokens
    colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
    colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
    colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
    // Color palette pumpkin tokens
    colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
    colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
    colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
    // Color palette purple tokens
    colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
    colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
    colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
    // Color palette royal blue tokens
    colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
    colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
    colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
    // Color palette seafoam tokens
    colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
    colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
    colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
    // Color palette steel tokens
    colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
    colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
    colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
    // Color palette teal tokens
    colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
    colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
    colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
    // Color status success tokens
    colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
    colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
    colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
    colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
    colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
    colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
    colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
    colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
    colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
    colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
    // Color status warning tokens
    colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
    colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
    colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
    colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
    colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
    colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
    colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
    colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
    colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
    colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
    // Color status danger tokens
    colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
    colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
    colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
    colorStatusDangerBackground3Hover: "var(--colorStatusDangerBackground3Hover)",
    colorStatusDangerBackground3Pressed: "var(--colorStatusDangerBackground3Pressed)",
    colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
    colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
    colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
    colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
    colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
    colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
    colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
    // Border radius tokens
    borderRadiusNone: "var(--borderRadiusNone)",
    borderRadiusSmall: "var(--borderRadiusSmall)",
    borderRadiusMedium: "var(--borderRadiusMedium)",
    borderRadiusLarge: "var(--borderRadiusLarge)",
    borderRadiusXLarge: "var(--borderRadiusXLarge)",
    borderRadiusCircular: "var(--borderRadiusCircular)",
    // Font family tokens
    fontFamilyBase: "var(--fontFamilyBase)",
    fontFamilyMonospace: "var(--fontFamilyMonospace)",
    fontFamilyNumeric: "var(--fontFamilyNumeric)",
    // Font size tokens
    fontSizeBase100: "var(--fontSizeBase100)",
    fontSizeBase200: "var(--fontSizeBase200)",
    fontSizeBase300: "var(--fontSizeBase300)",
    fontSizeBase400: "var(--fontSizeBase400)",
    fontSizeBase500: "var(--fontSizeBase500)",
    fontSizeBase600: "var(--fontSizeBase600)",
    fontSizeHero700: "var(--fontSizeHero700)",
    fontSizeHero800: "var(--fontSizeHero800)",
    fontSizeHero900: "var(--fontSizeHero900)",
    fontSizeHero1000: "var(--fontSizeHero1000)",
    // Font weight tokens
    fontWeightRegular: "var(--fontWeightRegular)",
    fontWeightMedium: "var(--fontWeightMedium)",
    fontWeightSemibold: "var(--fontWeightSemibold)",
    fontWeightBold: "var(--fontWeightBold)",
    // Line height tokens
    lineHeightBase100: "var(--lineHeightBase100)",
    lineHeightBase200: "var(--lineHeightBase200)",
    lineHeightBase300: "var(--lineHeightBase300)",
    lineHeightBase400: "var(--lineHeightBase400)",
    lineHeightBase500: "var(--lineHeightBase500)",
    lineHeightBase600: "var(--lineHeightBase600)",
    lineHeightHero700: "var(--lineHeightHero700)",
    lineHeightHero800: "var(--lineHeightHero800)",
    lineHeightHero900: "var(--lineHeightHero900)",
    lineHeightHero1000: "var(--lineHeightHero1000)",
    // Shadow tokens
    shadow2: "var(--shadow2)",
    shadow4: "var(--shadow4)",
    shadow8: "var(--shadow8)",
    shadow16: "var(--shadow16)",
    shadow28: "var(--shadow28)",
    shadow64: "var(--shadow64)",
    // Shadow brand tokens
    shadow2Brand: "var(--shadow2Brand)",
    shadow4Brand: "var(--shadow4Brand)",
    shadow8Brand: "var(--shadow8Brand)",
    shadow16Brand: "var(--shadow16Brand)",
    shadow28Brand: "var(--shadow28Brand)",
    shadow64Brand: "var(--shadow64Brand)",
    // Stroke width tokens
    strokeWidthThin: "var(--strokeWidthThin)",
    strokeWidthThick: "var(--strokeWidthThick)",
    strokeWidthThicker: "var(--strokeWidthThicker)",
    strokeWidthThickest: "var(--strokeWidthThickest)",
    // Spacings
    spacingHorizontalNone: "var(--spacingHorizontalNone)",
    spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
    spacingHorizontalXS: "var(--spacingHorizontalXS)",
    spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
    spacingHorizontalS: "var(--spacingHorizontalS)",
    spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
    spacingHorizontalM: "var(--spacingHorizontalM)",
    spacingHorizontalL: "var(--spacingHorizontalL)",
    spacingHorizontalXL: "var(--spacingHorizontalXL)",
    spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
    spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
    spacingVerticalNone: "var(--spacingVerticalNone)",
    spacingVerticalXXS: "var(--spacingVerticalXXS)",
    spacingVerticalXS: "var(--spacingVerticalXS)",
    spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
    spacingVerticalS: "var(--spacingVerticalS)",
    spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
    spacingVerticalM: "var(--spacingVerticalM)",
    spacingVerticalL: "var(--spacingVerticalL)",
    spacingVerticalXL: "var(--spacingVerticalXL)",
    spacingVerticalXXL: "var(--spacingVerticalXXL)",
    spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
    // Durations
    durationUltraFast: "var(--durationUltraFast)",
    durationFaster: "var(--durationFaster)",
    durationFast: "var(--durationFast)",
    durationNormal: "var(--durationNormal)",
    durationGentle: "var(--durationGentle)",
    durationSlow: "var(--durationSlow)",
    durationSlower: "var(--durationSlower)",
    durationUltraSlow: "var(--durationUltraSlow)",
    // Curves
    curveAccelerateMax: "var(--curveAccelerateMax)",
    curveAccelerateMid: "var(--curveAccelerateMid)",
    curveAccelerateMin: "var(--curveAccelerateMin)",
    curveDecelerateMax: "var(--curveDecelerateMax)",
    curveDecelerateMid: "var(--curveDecelerateMid)",
    curveDecelerateMin: "var(--curveDecelerateMin)",
    curveEasyEaseMax: "var(--curveEasyEaseMax)",
    curveEasyEase: "var(--curveEasyEase)",
    curveLinear: "var(--curveLinear)",
    /**
    * ZIndexes
    * Special case where the tokens contain default values
    * ZIndexes are not mandatory, so they are not included in the theme, but can be used as tokens with default values
    */
    /**
    * Elevation 0
    * Can be used for background elements, like surfaces
    */
    zIndexBackground: "var(--zIndexBackground, 0)",
    /**
    * Elevation 2
    * Can be used content that is on top of the background, like cards
    */
    zIndexContent: "var(--zIndexContent, 1)",
    /**
    * Elevation 4
    * Can be used for overlays, like the backdrop of a modal
    */
    zIndexOverlay: "var(--zIndexOverlay, 1000)",
    /**
    * Elevation 8
    * Can be used for popups, like modals and drawers
    */
    zIndexPopup: "var(--zIndexPopup, 2000)",
    /**
    * Elevation 16
    * Can be used for messages, like snackbars and toasts
    */
    zIndexMessages: "var(--zIndexMessages, 3000)",
    /**
    * Elevation 28
    * Can be used for floating elements, like dropdowns
    */
    zIndexFloating: "var(--zIndexFloating, 4000)",
    /**
    * Elevation 64
    * Can be used for high priority floating elements, like tooltips
    */
    zIndexPriority: "var(--zIndexPriority, 5000)",
    /**
    * Special elevation
    * Can be used for elements that need to be above everything else, like debug overlays
    */
    zIndexDebug: "var(--zIndexDebug, 6000)"
  };

  // ../../node_modules/@fluentui/tokens/lib/utils/shadows.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
    return {
      [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
      [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
      [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
      [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
      [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
      [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
    };
  }

  // ../../node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
  var createLightTheme = (brand) => {
    const colorTokens = generateColorTokens(brand);
    return {
      ...borderRadius3,
      ...fontSizes,
      ...lineHeights,
      ...fontFamilies,
      ...fontWeights,
      ...strokeWidths,
      ...horizontalSpacings,
      ...verticalSpacings,
      ...durations,
      ...curves,
      ...colorTokens,
      ...colorPaletteTokens,
      ...colorStatusTokens,
      ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
      ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
    };
  };

  // ../../node_modules/@fluentui/tokens/lib/global/brandColors.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var brandWeb = {
    10: `#061724`,
    20: `#082338`,
    30: `#0a2e4a`,
    40: `#0c3b5e`,
    50: `#0e4775`,
    60: `#0f548c`,
    70: `#115ea3`,
    80: `#0f6cbd`,
    90: `#2886de`,
    100: `#479ef5`,
    110: `#62abf5`,
    120: `#77b7f7`,
    130: `#96c6fa`,
    140: `#b4d6fa`,
    150: `#cfe4fa`,
    160: `#ebf3fc`
  };

  // ../../node_modules/@fluentui/tokens/lib/alias/darkColorPalette.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var statusColorPaletteTokens2 = statusSharedColorNames.reduce((acc, sharedColor) => {
    const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].shade40,
      [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].shade30,
      [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].tint30,
      [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].tint40,
      [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].tint20,
      [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].tint30,
      [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].primary,
      [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].tint20
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  statusColorPaletteTokens2.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
  statusColorPaletteTokens2.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
  statusColorPaletteTokens2.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
  statusColorPaletteTokens2.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
  statusColorPaletteTokens2.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
  statusColorPaletteTokens2.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
  statusColorPaletteTokens2.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
  statusColorPaletteTokens2.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
  statusColorPaletteTokens2.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
  var personaColorPaletteTokens2 = personaSharedColorNames.reduce((acc, sharedColor) => {
    const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
    const sharedColorTokens = {
      [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].shade30,
      [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].tint40,
      [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].tint30
    };
    return Object.assign(acc, sharedColorTokens);
  }, {});
  personaColorPaletteTokens2.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
  personaColorPaletteTokens2.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
  var colorPaletteTokens2 = {
    ...statusColorPaletteTokens2,
    ...personaColorPaletteTokens2
  };
  var colorStatusTokens2 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
    const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
    const statusColorTokens = {
      [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].shade40,
      [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].shade30,
      [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].tint30,
      [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].tint40,
      [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].tint20,
      [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].tint30,
      [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
      [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].primary,
      [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].tint20
    };
    return Object.assign(acc, statusColorTokens);
  }, {});
  colorStatusTokens2.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
  colorStatusTokens2.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
  colorStatusTokens2.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint40;
  colorStatusTokens2.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
  colorStatusTokens2.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
  colorStatusTokens2.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
  colorStatusTokens2.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;

  // ../../node_modules/@fluentui/tokens/lib/themes/web/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var webLightTheme = createLightTheme(brandWeb);

  // ../../node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/tokens/lib/alias/darkColor.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var generateColorTokens2 = (brand) => ({
    colorNeutralForeground1: white,
    colorNeutralForeground1Hover: white,
    colorNeutralForeground1Pressed: white,
    colorNeutralForeground1Selected: white,
    colorNeutralForeground2: grey[84],
    colorNeutralForeground2Hover: white,
    colorNeutralForeground2Pressed: white,
    colorNeutralForeground2Selected: white,
    colorNeutralForeground2BrandHover: brand[100],
    colorNeutralForeground2BrandPressed: brand[90],
    colorNeutralForeground2BrandSelected: brand[100],
    colorNeutralForeground3: grey[68],
    colorNeutralForeground3Hover: grey[84],
    colorNeutralForeground3Pressed: grey[84],
    colorNeutralForeground3Selected: grey[84],
    colorNeutralForeground3BrandHover: brand[100],
    colorNeutralForeground3BrandPressed: brand[90],
    colorNeutralForeground3BrandSelected: brand[100],
    colorNeutralForeground4: grey[60],
    colorNeutralForegroundDisabled: grey[36],
    colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
    colorBrandForegroundLink: brand[100],
    colorBrandForegroundLinkHover: brand[110],
    colorBrandForegroundLinkPressed: brand[90],
    colorBrandForegroundLinkSelected: brand[100],
    colorNeutralForeground2Link: grey[84],
    colorNeutralForeground2LinkHover: white,
    colorNeutralForeground2LinkPressed: white,
    colorNeutralForeground2LinkSelected: white,
    colorCompoundBrandForeground1: brand[100],
    colorCompoundBrandForeground1Hover: brand[110],
    colorCompoundBrandForeground1Pressed: brand[90],
    colorBrandForeground1: brand[100],
    colorBrandForeground2: brand[110],
    colorBrandForeground2Hover: brand[130],
    colorBrandForeground2Pressed: brand[160],
    colorNeutralForeground1Static: grey[14],
    colorNeutralForegroundStaticInverted: white,
    colorNeutralForegroundInverted: grey[14],
    colorNeutralForegroundInvertedHover: grey[14],
    colorNeutralForegroundInvertedPressed: grey[14],
    colorNeutralForegroundInvertedSelected: grey[14],
    colorNeutralForegroundInverted2: grey[14],
    colorNeutralForegroundOnBrand: white,
    colorNeutralForegroundInvertedLink: white,
    colorNeutralForegroundInvertedLinkHover: white,
    colorNeutralForegroundInvertedLinkPressed: white,
    colorNeutralForegroundInvertedLinkSelected: white,
    colorBrandForegroundInverted: brand[80],
    colorBrandForegroundInvertedHover: brand[70],
    colorBrandForegroundInvertedPressed: brand[60],
    colorBrandForegroundOnLight: brand[80],
    colorBrandForegroundOnLightHover: brand[70],
    colorBrandForegroundOnLightPressed: brand[50],
    colorBrandForegroundOnLightSelected: brand[60],
    colorNeutralBackground1: grey[16],
    colorNeutralBackground1Hover: grey[24],
    colorNeutralBackground1Pressed: grey[12],
    colorNeutralBackground1Selected: grey[22],
    colorNeutralBackground2: grey[12],
    colorNeutralBackground2Hover: grey[20],
    colorNeutralBackground2Pressed: grey[8],
    colorNeutralBackground2Selected: grey[18],
    colorNeutralBackground3: grey[8],
    colorNeutralBackground3Hover: grey[16],
    colorNeutralBackground3Pressed: grey[4],
    colorNeutralBackground3Selected: grey[14],
    colorNeutralBackground4: grey[4],
    colorNeutralBackground4Hover: grey[12],
    colorNeutralBackground4Pressed: black,
    colorNeutralBackground4Selected: grey[10],
    colorNeutralBackground5: black,
    colorNeutralBackground5Hover: grey[8],
    colorNeutralBackground5Pressed: grey[2],
    colorNeutralBackground5Selected: grey[6],
    colorNeutralBackground6: grey[20],
    colorNeutralBackgroundInverted: white,
    colorNeutralBackgroundStatic: grey[24],
    colorNeutralBackgroundAlpha: grey10Alpha[50],
    colorNeutralBackgroundAlpha2: grey12Alpha[70],
    colorSubtleBackground: "transparent",
    colorSubtleBackgroundHover: grey[22],
    colorSubtleBackgroundPressed: grey[18],
    colorSubtleBackgroundSelected: grey[20],
    colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
    colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
    colorSubtleBackgroundLightAlphaSelected: "transparent",
    colorSubtleBackgroundInverted: "transparent",
    colorSubtleBackgroundInvertedHover: blackAlpha[10],
    colorSubtleBackgroundInvertedPressed: blackAlpha[30],
    colorSubtleBackgroundInvertedSelected: blackAlpha[20],
    colorTransparentBackground: "transparent",
    colorTransparentBackgroundHover: "transparent",
    colorTransparentBackgroundPressed: "transparent",
    colorTransparentBackgroundSelected: "transparent",
    colorNeutralBackgroundDisabled: grey[8],
    colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
    colorNeutralStencil1: grey[34],
    colorNeutralStencil2: grey[20],
    colorNeutralStencil1Alpha: whiteAlpha[10],
    colorNeutralStencil2Alpha: whiteAlpha[5],
    colorBackgroundOverlay: blackAlpha[50],
    colorScrollbarOverlay: whiteAlpha[60],
    colorBrandBackground: brand[70],
    colorBrandBackgroundHover: brand[80],
    colorBrandBackgroundPressed: brand[40],
    colorBrandBackgroundSelected: brand[60],
    colorCompoundBrandBackground: brand[100],
    colorCompoundBrandBackgroundHover: brand[110],
    colorCompoundBrandBackgroundPressed: brand[90],
    colorBrandBackgroundStatic: brand[80],
    colorBrandBackground2: brand[20],
    colorBrandBackground2Hover: brand[40],
    colorBrandBackground2Pressed: brand[10],
    colorBrandBackground3Static: brand[60],
    colorBrandBackground4Static: brand[40],
    colorBrandBackgroundInverted: white,
    colorBrandBackgroundInvertedHover: brand[160],
    colorBrandBackgroundInvertedPressed: brand[140],
    colorBrandBackgroundInvertedSelected: brand[150],
    colorNeutralCardBackground: grey[20],
    colorNeutralCardBackgroundHover: grey[24],
    colorNeutralCardBackgroundPressed: grey[18],
    colorNeutralCardBackgroundSelected: grey[22],
    colorNeutralCardBackgroundDisabled: grey[8],
    colorNeutralStrokeAccessible: grey[68],
    colorNeutralStrokeAccessibleHover: grey[74],
    colorNeutralStrokeAccessiblePressed: grey[70],
    colorNeutralStrokeAccessibleSelected: brand[100],
    colorNeutralStroke1: grey[40],
    colorNeutralStroke1Hover: grey[46],
    colorNeutralStroke1Pressed: grey[42],
    colorNeutralStroke1Selected: grey[44],
    colorNeutralStroke2: grey[32],
    colorNeutralStroke3: grey[24],
    colorNeutralStrokeSubtle: grey[4],
    colorNeutralStrokeOnBrand: grey[16],
    colorNeutralStrokeOnBrand2: white,
    colorNeutralStrokeOnBrand2Hover: white,
    colorNeutralStrokeOnBrand2Pressed: white,
    colorNeutralStrokeOnBrand2Selected: white,
    colorBrandStroke1: brand[100],
    colorBrandStroke2: brand[50],
    colorBrandStroke2Hover: brand[50],
    colorBrandStroke2Pressed: brand[30],
    colorBrandStroke2Contrast: brand[50],
    colorCompoundBrandStroke: brand[100],
    colorCompoundBrandStrokeHover: brand[110],
    colorCompoundBrandStrokePressed: brand[90],
    colorNeutralStrokeDisabled: grey[26],
    colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
    colorTransparentStroke: "transparent",
    colorTransparentStrokeInteractive: "transparent",
    colorTransparentStrokeDisabled: "transparent",
    colorNeutralStrokeAlpha: whiteAlpha[10],
    colorNeutralStrokeAlpha2: whiteAlpha[20],
    colorStrokeFocus1: black,
    colorStrokeFocus2: white,
    colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
    colorNeutralShadowKey: "rgba(0,0,0,0.28)",
    colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
    colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
    colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
    colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
    colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
    colorBrandShadowKey: "rgba(0,0,0,0.25)"
  });

  // ../../node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
  var createDarkTheme = (brand) => {
    const colorTokens = generateColorTokens2(brand);
    return {
      ...borderRadius3,
      ...fontSizes,
      ...lineHeights,
      ...fontFamilies,
      ...fontWeights,
      ...strokeWidths,
      ...horizontalSpacings,
      ...verticalSpacings,
      ...durations,
      ...curves,
      ...colorTokens,
      ...colorPaletteTokens2,
      ...colorStatusTokens2,
      ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
      ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
    };
  };

  // ../../node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
  var webDarkTheme = createDarkTheme(brandWeb);

  // ../../node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
  function getOutlinePosition({ outlineWidth, outlineOffset }, position4) {
    const offsetValue = (outlineOffset === null || outlineOffset === void 0 ? void 0 : outlineOffset[position4]) || outlineOffset;
    if (!outlineOffset) {
      return `calc(${outlineWidth} * -1)`;
    }
    return `calc(0px - ${outlineWidth} - ${offsetValue})`;
  }
  var getFocusOutlineStyles = (options) => {
    const { outlineRadius, outlineColor, outlineWidth } = options;
    return {
      ...shorthands2.borderColor("transparent"),
      "@media (forced-colors: active)": {
        "::after": {
          ...shorthands2.borderColor("Highlight")
        }
      },
      "::after": {
        content: '""',
        position: "absolute",
        pointerEvents: "none",
        zIndex: 1,
        border: `${outlineWidth} solid ${outlineColor}`,
        borderRadius: outlineRadius,
        top: getOutlinePosition(options, "top"),
        right: getOutlinePosition(options, "right"),
        bottom: getOutlinePosition(options, "bottom"),
        left: getOutlinePosition(options, "left")
      }
    };
  };
  var createFocusOutlineStyle = ({ enableOutline = false, selector = defaultOptions2.selector, customizeSelector, style = defaultOptions2.style } = defaultOptions2) => ({
    ":focus": {
      outlineStyle: enableOutline ? void 0 : "none"
    },
    ":focus-visible": {
      outlineStyle: enableOutline ? void 0 : "none"
    },
    ...createCustomFocusIndicatorStyle(getFocusOutlineStyles({
      outlineColor: tokens.colorStrokeFocus2,
      outlineRadius: tokens.borderRadiusMedium,
      // FIXME: tokens.strokeWidthThick causes some weird bugs
      outlineWidth: "2px",
      ...style
    }), {
      selector,
      customizeSelector
    })
  });

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  var React58 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React57 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var fluentProviderClassNames = {
    root: "fui-FluentProvider"
  };
  var useStyles = /* @__PURE__ */ __styles({
    root: {
      sj55zd: "f19n0e5",
      De3pzq: "fxugw4r",
      fsow6f: ["f1o700av", "fes3tcz"],
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    }
  }, {
    d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
  });
  var useFluentProviderStyles_unstable = (state) => {
    "use no memo";
    const renderer = useRenderer();
    const styles = useStyles({
      dir: state.dir,
      renderer
    });
    state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles.root, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
  var useInsertionEffect4 = React57["useInsertionEffect"] ? React57["useInsertionEffect"] : useIsomorphicLayoutEffect2;
  var createStyleTag = (target, elementAttributes) => {
    if (!(target === null || target === void 0 ? void 0 : target.head)) {
      return void 0;
    }
    const tag = target.createElement("style");
    Object.keys(elementAttributes).forEach((attrName) => {
      tag.setAttribute(attrName, elementAttributes[attrName]);
    });
    target.head.appendChild(tag);
    return tag;
  };
  var insertSheet = (tag, rule) => {
    const sheet = tag.sheet;
    if (sheet) {
      if (sheet.cssRules.length > 0) {
        sheet.deleteRule(0);
      }
      sheet.insertRule(rule, 0);
    } else if (false) {
      console.error("FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.");
    }
  };
  var useFluentProviderThemeStyleTag = (options) => {
    "use no memo";
    const { targetDocument, theme, rendererAttributes } = options;
    const styleTag = React57.useRef();
    const styleTagId = useId4(fluentProviderClassNames.root);
    const styleElementAttributes = rendererAttributes;
    const rule = React57.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [
      theme,
      styleTagId
    ]);
    if (false) {
      React57.useMemo(() => {
        if (targetDocument) {
          var _styleElement_textContent;
          const providerElementSelector = `.${fluentProviderClassNames.root}.${styleTagId}`;
          const providerElements = targetDocument.querySelectorAll(providerElementSelector);
          const styleElementSelector = `style[id="${styleTagId}"]`;
          const styleElements = targetDocument.querySelectorAll(styleElementSelector);
          if (styleElements.length > 1) {
            console.error([
              "@fluentui/react-provider: We found multiple <style> elements with same IDs in your DOM.",
              "Please make sure that you configured your application properly.",
              "\n",
              "\n",
              "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
            ].join(" "));
            return;
          }
          const styleElement = styleElements.item(0);
          var _styleElement_textContent_length;
          const isSSR = ((_styleElement_textContent_length = styleElement === null || styleElement === void 0 ? void 0 : (_styleElement_textContent = styleElement.textContent) === null || _styleElement_textContent === void 0 ? void 0 : _styleElement_textContent.length) !== null && _styleElement_textContent_length !== void 0 ? _styleElement_textContent_length : 0) > 0;
          const elementsCount = isSSR ? 1 : 0;
          if (providerElements.length > elementsCount) {
            console.error([
              "@fluentui/react-provider: There are conflicting ids in your DOM.",
              "Please make sure that you configured your application properly.",
              "\n",
              "\n",
              "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
            ].join(" "));
          }
        }
      }, []);
    }
    useHandleSSRStyleElements(targetDocument, styleTagId);
    useInsertionEffect4(() => {
      const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
      if (ssrStyleElement) {
        styleTag.current = ssrStyleElement;
      } else {
        styleTag.current = createStyleTag(targetDocument, {
          ...styleElementAttributes,
          id: styleTagId
        });
        if (styleTag.current) {
          insertSheet(styleTag.current, rule);
        }
      }
      return () => {
        var _styleTag_current;
        (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
      };
    }, [
      styleTagId,
      targetDocument,
      rule,
      styleElementAttributes
    ]);
    return {
      styleTagId,
      rule
    };
  };
  function useHandleSSRStyleElements(targetDocument, styleTagId) {
    React57.useState(() => {
      if (!targetDocument) {
        return;
      }
      const themeStyleElement = targetDocument.getElementById(styleTagId);
      if (themeStyleElement) {
        targetDocument.head.append(themeStyleElement);
      }
    });
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
  var DEFAULT_STYLE_HOOKS = {};
  var DEFAULT_RENDERER_ATTRIBUTES = {};
  var useFluentProvider_unstable = (props, ref) => {
    "use no memo";
    const parentContext = useFluent();
    const parentTheme = useTheme2();
    const parentOverrides = useOverrides();
    const parentCustomStyleHooks = React58.useContext(CustomStyleHooksContext) || DEFAULT_STYLE_HOOKS;
    const {
      applyStylesToPortals = true,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      dir = parentContext.dir,
      targetDocument = parentContext.targetDocument,
      theme,
      overrides_unstable: overrides = {}
    } = props;
    const mergedTheme = shallowMerge(parentTheme, theme);
    const mergedOverrides = shallowMerge(parentOverrides, overrides);
    const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
    const renderer = useRenderer();
    var _renderer_styleElementAttributes;
    const { styleTagId, rule } = useFluentProviderThemeStyleTag({
      theme: mergedTheme,
      targetDocument,
      rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : DEFAULT_RENDERER_ATTRIBUTES
    });
    if (false) {
      React58.useEffect(() => {
        if (mergedTheme === void 0) {
          console.warn([
            '@fluentui/react-provider: FluentProvider does not have your "theme" defined.',
            "Make sure that your top-level FluentProvider has set a `theme` prop or you're setting the theme in your child FluentProvider."
          ].join(" "));
        }
      }, []);
    }
    return {
      applyStylesToPortals,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable: mergedCustomStyleHooks,
      dir,
      targetDocument,
      theme: mergedTheme,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable: mergedOverrides,
      themeClassName: styleTagId,
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ...props,
        dir,
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, useFocusVisible({
          targetDocument
        }))
      }), {
        elementType: "div"
      }),
      serverStyleProps: {
        cssRule: rule,
        attributes: {
          ...renderer.styleElementAttributes,
          id: styleTagId
        }
      }
    };
  };
  function shallowMerge(a, b) {
    if (a && b) {
      return {
        ...a,
        ...b
      };
    }
    if (a) {
      return a;
    }
    return b;
  }
  function useTheme2() {
    return React58.useContext(ThemeContext2);
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React59 = __toESM(require_react());
  function useFluentProviderContextValues_unstable(state) {
    const {
      applyStylesToPortals,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      dir,
      root: root5,
      targetDocument,
      theme,
      themeClassName,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable
    } = state;
    const provider = React59.useMemo(() => ({
      dir,
      targetDocument
    }), [
      dir,
      targetDocument
    ]);
    const [tooltip] = React59.useState(() => ({}));
    const iconDirection = React59.useMemo(() => ({
      textDirection: dir
    }), [
      dir
    ]);
    return {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      customStyleHooks_unstable,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      overrides_unstable,
      provider,
      textDirection: dir,
      iconDirection,
      tooltip,
      theme,
      themeClassName: applyStylesToPortals ? root5.className : themeClassName
    };
  }

  // ../../node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
  var FluentProvider = /* @__PURE__ */ React60.forwardRef((props, ref) => {
    const state = useFluentProvider_unstable(props, ref);
    useFluentProviderStyles_unstable(state);
    const contextValues = useFluentProviderContextValues_unstable(state);
    return renderFluentProvider_unstable(state, contextValues);
  });
  FluentProvider.displayName = "FluentProvider";

  // ../../node_modules/@fluentui/react-context-selector/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-context-selector/lib/createContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React61 = __toESM(require_react());
  var import_scheduler = __toESM(require_scheduler2());
  var createProvider = (Original) => {
    const Provider2 = (props) => {
      const valueRef = React61.useRef(props.value);
      const versionRef = React61.useRef(0);
      const contextValue = React61.useRef();
      if (!contextValue.current) {
        contextValue.current = {
          value: valueRef,
          version: versionRef,
          listeners: []
        };
      }
      useIsomorphicLayoutEffect2(() => {
        valueRef.current = props.value;
        versionRef.current += 1;
        (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
          contextValue.current.listeners.forEach((listener) => {
            listener([
              versionRef.current,
              props.value
            ]);
          });
        });
      }, [
        props.value
      ]);
      return React61.createElement(Original, {
        value: contextValue.current
      }, props.children);
    };
    if (false) {
      Provider2.displayName = "ContextSelector.Provider";
    }
    return Provider2;
  };
  var createContext20 = (defaultValue) => {
    const context = React61.createContext({
      value: {
        current: defaultValue
      },
      version: {
        current: -1
      },
      listeners: []
    });
    context.Provider = createProvider(context.Provider);
    delete context.Consumer;
    return context;
  };

  // ../../node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React62 = __toESM(require_react());
  var useContextSelector = (context, selector) => {
    const contextValue = React62.useContext(context);
    const { value: { current: value }, version: { current: version5 }, listeners } = contextValue;
    const selected = selector(value);
    const [state, setState] = React62.useState([
      value,
      selected
    ]);
    const dispatch = (payload) => {
      setState((prevState) => {
        if (!payload) {
          return [
            value,
            selected
          ];
        }
        if (payload[0] <= version5) {
          if (Object.is(prevState[1], selected)) {
            return prevState;
          }
          return [
            value,
            selected
          ];
        }
        try {
          if (Object.is(prevState[0], payload[1])) {
            return prevState;
          }
          const nextSelected = selector(payload[1]);
          if (Object.is(prevState[1], nextSelected)) {
            return prevState;
          }
          return [
            payload[1],
            nextSelected
          ];
        } catch (e) {
        }
        return [
          prevState[0],
          prevState[1]
        ];
      });
    };
    if (!Object.is(state[1], selected)) {
      dispatch(void 0);
    }
    const stableDispatch = useEventCallback(dispatch);
    useIsomorphicLayoutEffect2(() => {
      listeners.push(stableDispatch);
      return () => {
        const index2 = listeners.indexOf(stableDispatch);
        listeners.splice(index2, 1);
      };
    }, [
      stableDispatch,
      listeners
    ]);
    return state[1];
  };

  // ../../node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React63 = __toESM(require_react());
  function useHasParentContext(context) {
    const contextValue = React63.useContext(context);
    if (contextValue.version) {
      return contextValue.version.current !== -1;
    }
    return false;
  }

  // ../../node_modules/@fluentui/react-aria/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-aria/lib/button/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/keyboard-keys/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/keyboard-keys/lib/keys.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Enter = "Enter";
  var Space = " ";
  var Tab = "Tab";
  var ArrowDown = "ArrowDown";
  var ArrowUp = "ArrowUp";
  var End = "End";
  var Home = "Home";
  var PageDown = "PageDown";
  var PageUp = "PageUp";
  var Escape = "Escape";

  // ../../node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
  var React64 = __toESM(require_react());
  function useARIAButtonProps(type, props) {
    const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
    const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
    const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
    const handleClick = useEventCallback((ev) => {
      if (isDisabled) {
        ev.preventDefault();
        ev.stopPropagation();
      } else {
        onClick === null || onClick === void 0 ? void 0 : onClick(ev);
      }
    });
    const handleKeyDown = useEventCallback((ev) => {
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
      if (ev.isDefaultPrevented()) {
        return;
      }
      const key = ev.key;
      if (isDisabled && (key === Enter || key === Space)) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      if (key === Space) {
        ev.preventDefault();
        return;
      } else if (key === Enter) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    });
    const handleKeyUp = useEventCallback((ev) => {
      onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
      if (ev.isDefaultPrevented()) {
        return;
      }
      const key = ev.key;
      if (isDisabled && (key === Enter || key === Space)) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      if (key === Space) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    });
    if (type === "button" || type === void 0) {
      return {
        ...rest,
        disabled: disabled && !disabledFocusable,
        "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
        // onclick should still use internal handler to ensure prevention if disabled
        // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
        onClick: disabledFocusable ? void 0 : handleClick,
        onKeyUp: disabledFocusable ? void 0 : onKeyUp,
        onKeyDown: disabledFocusable ? void 0 : onKeyDown
      };
    } else {
      const isLink = !!rest.href;
      let roleOverride = isLink ? void 0 : "button";
      if (!roleOverride && isDisabled) {
        roleOverride = "link";
      }
      const resultProps = {
        role: roleOverride,
        tabIndex: disabledFocusable || !isLink && !disabled ? 0 : void 0,
        ...rest,
        // If it's not a <button> than listeners are required even with disabledFocusable
        // Since you cannot assure the default behavior of the element
        // E.g: <a> will redirect on click
        onClick: handleClick,
        onKeyUp: handleKeyUp,
        onKeyDown: handleKeyDown,
        "aria-disabled": isDisabled
      };
      if (type === "a" && isDisabled) {
        resultProps.href = void 0;
      }
      return resultProps;
    }
  }

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/ActiveDescendantContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React65 = __toESM(require_react());
  var noop4 = () => void 0;
  var activeDescendantContextDefaultValue = {
    controller: {
      active: noop4,
      blur: noop4,
      find: noop4,
      first: noop4,
      focus: noop4,
      focusLastActive: noop4,
      scrollActiveIntoView: noop4,
      last: noop4,
      next: noop4,
      prev: noop4,
      showAttributes: noop4,
      hideAttributes: noop4,
      showFocusVisibleAttributes: noop4,
      hideFocusVisibleAttributes: noop4
    }
  };
  var ActiveDescendantContext = React65.createContext(void 0);
  var ActiveDescendantContextProvider = ActiveDescendantContext.Provider;
  var useActiveDescendantContext = () => {
    var _React_useContext;
    return (_React_useContext = React65.useContext(ActiveDescendantContext)) !== null && _React_useContext !== void 0 ? _React_useContext : activeDescendantContextDefaultValue;
  };
  var useHasParentActiveDescendantContext = () => !!React65.useContext(ActiveDescendantContext);

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React67 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/useOptionWalker.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React66 = __toESM(require_react());
  function useOptionWalker(options) {
    const { matchOption } = options;
    const { targetDocument } = useFluent();
    const treeWalkerRef = React66.useRef(null);
    const listboxRef = React66.useRef(null);
    const optionFilter = React66.useCallback((node3) => {
      if (isHTMLElement(node3) && matchOption(node3)) {
        return NodeFilter.FILTER_ACCEPT;
      }
      return NodeFilter.FILTER_SKIP;
    }, [
      matchOption
    ]);
    const setListbox = React66.useCallback((el) => {
      if (el && targetDocument) {
        listboxRef.current = el;
        treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, optionFilter);
      } else {
        listboxRef.current = null;
      }
    }, [
      targetDocument,
      optionFilter
    ]);
    const optionWalker = React66.useMemo(() => ({
      first: () => {
        if (!treeWalkerRef.current || !listboxRef.current) {
          return null;
        }
        treeWalkerRef.current.currentNode = listboxRef.current;
        return treeWalkerRef.current.firstChild();
      },
      last: () => {
        if (!treeWalkerRef.current || !listboxRef.current) {
          return null;
        }
        treeWalkerRef.current.currentNode = listboxRef.current;
        return treeWalkerRef.current.lastChild();
      },
      next: () => {
        if (!treeWalkerRef.current) {
          return null;
        }
        return treeWalkerRef.current.nextNode();
      },
      prev: () => {
        if (!treeWalkerRef.current) {
          return null;
        }
        return treeWalkerRef.current.previousNode();
      },
      find: (predicate, startFrom) => {
        if (!treeWalkerRef.current || !listboxRef.current) {
          return null;
        }
        const start2 = startFrom ? targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(startFrom) : null;
        treeWalkerRef.current.currentNode = start2 !== null && start2 !== void 0 ? start2 : listboxRef.current;
        let cur = treeWalkerRef.current.currentNode;
        while (cur && !predicate(cur.id)) {
          cur = treeWalkerRef.current.nextNode();
        }
        return cur;
      },
      setCurrent: (el) => {
        if (!treeWalkerRef.current) {
          return;
        }
        treeWalkerRef.current.currentNode = el;
      }
    }), [
      targetDocument
    ]);
    return {
      optionWalker,
      listboxCallbackRef: setListbox
    };
  }

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ACTIVEDESCENDANT_ATTRIBUTE = "data-activedescendant";
  var ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE = "data-activedescendant-focusvisible";

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/scrollIntoView.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var scrollIntoView2 = (target) => {
    if (!target) {
      return;
    }
    const scrollParent = findScrollableParent(target.parentElement);
    if (!scrollParent) {
      return;
    }
    const { offsetHeight } = target;
    const offsetTop = getTotalOffsetTop(target, scrollParent);
    const { scrollMarginTop, scrollMarginBottom } = getScrollMargins(target);
    const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
    const isAbove = offsetTop - scrollMarginTop < scrollTop;
    const isBelow = offsetTop + offsetHeight + scrollMarginBottom > scrollTop + parentOffsetHeight;
    const buffer = 2;
    if (isAbove) {
      scrollParent.scrollTo(0, offsetTop - scrollMarginTop - buffer);
    } else if (isBelow) {
      scrollParent.scrollTo(0, offsetTop + offsetHeight + scrollMarginBottom - parentOffsetHeight + buffer);
    }
  };
  var findScrollableParent = (element4) => {
    if (!element4) {
      return null;
    }
    if (element4.scrollHeight > element4.offsetHeight) {
      return element4;
    }
    return findScrollableParent(element4.parentElement);
  };
  var getTotalOffsetTop = (element4, scrollParent) => {
    if (!element4 || element4 === scrollParent) {
      return 0;
    }
    if (element4.contains(scrollParent)) {
      return scrollParent.offsetTop * -1;
    }
    return element4.offsetTop + getTotalOffsetTop(element4.offsetParent, scrollParent);
  };
  var getScrollMargins = (element4) => {
    var _element_ownerDocument;
    const win = (_element_ownerDocument = element4.ownerDocument) === null || _element_ownerDocument === void 0 ? void 0 : _element_ownerDocument.defaultView;
    if (!win) {
      return {
        scrollMarginTop: 0,
        scrollMarginBottom: 0
      };
    }
    const computedStyles = win.getComputedStyle(element4);
    var _getIntValueOfComputedStyle;
    const scrollMarginTop = (_getIntValueOfComputedStyle = getIntValueOfComputedStyle(computedStyles.scrollMarginTop)) !== null && _getIntValueOfComputedStyle !== void 0 ? _getIntValueOfComputedStyle : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockStart);
    var _getIntValueOfComputedStyle1;
    const scrollMarginBottom = (_getIntValueOfComputedStyle1 = getIntValueOfComputedStyle(computedStyles.scrollMarginBottom)) !== null && _getIntValueOfComputedStyle1 !== void 0 ? _getIntValueOfComputedStyle1 : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockEnd);
    return {
      scrollMarginTop,
      scrollMarginBottom
    };
  };
  var getIntValueOfComputedStyle = (computedStyle) => {
    return computedStyle ? parseInt(computedStyle, 10) : 0;
  };

  // ../../node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
  var createActiveDescendantChangeEvent = (detail) => new CustomEvent("activedescendantchange", {
    bubbles: true,
    cancelable: false,
    composed: true,
    detail
  });
  function useActiveDescendant(options) {
    const { imperativeRef, matchOption: matchOptionUnstable } = options;
    const focusVisibleRef = React67.useRef(false);
    const shouldShowFocusVisibleAttrRef = React67.useRef(true);
    const activeIdRef = React67.useRef(null);
    const lastActiveIdRef = React67.useRef(null);
    const activeParentRef = React67.useRef(null);
    const attributeVisibilityRef = React67.useRef(true);
    const removeAttribute = React67.useCallback(() => {
      var _activeParentRef_current;
      (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.removeAttribute("aria-activedescendant");
    }, []);
    const setAttribute = React67.useCallback((id) => {
      if (id) {
        activeIdRef.current = id;
      }
      if (attributeVisibilityRef.current && activeIdRef.current) {
        var _activeParentRef_current;
        (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.setAttribute("aria-activedescendant", activeIdRef.current);
      }
    }, []);
    useOnKeyboardNavigationChange((isNavigatingWithKeyboard) => {
      focusVisibleRef.current = isNavigatingWithKeyboard;
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      if (isNavigatingWithKeyboard && shouldShowFocusVisibleAttrRef.current) {
        active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
      } else {
        active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
      }
    });
    const matchOption = useEventCallback(matchOptionUnstable);
    const listboxRef = React67.useRef(null);
    const { optionWalker, listboxCallbackRef } = useOptionWalker({
      matchOption
    });
    const getActiveDescendant = React67.useCallback(() => {
      var _listboxRef_current;
      return (_listboxRef_current = listboxRef.current) === null || _listboxRef_current === void 0 ? void 0 : _listboxRef_current.querySelector(`#${activeIdRef.current}`);
    }, [
      listboxRef
    ]);
    const setShouldShowFocusVisibleAttribute = React67.useCallback((shouldShow) => {
      shouldShowFocusVisibleAttrRef.current = shouldShow;
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      if (shouldShow && focusVisibleRef.current) {
        active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
      } else {
        active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
      }
    }, [
      getActiveDescendant
    ]);
    const blurActiveDescendant = React67.useCallback(() => {
      const active = getActiveDescendant();
      if (active) {
        active.removeAttribute(ACTIVEDESCENDANT_ATTRIBUTE);
        active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
      }
      removeAttribute();
      lastActiveIdRef.current = activeIdRef.current;
      activeIdRef.current = null;
      var _active_id;
      return (_active_id = active === null || active === void 0 ? void 0 : active.id) !== null && _active_id !== void 0 ? _active_id : null;
    }, [
      getActiveDescendant,
      removeAttribute
    ]);
    const focusActiveDescendant = React67.useCallback((nextActive) => {
      if (!nextActive) {
        return;
      }
      const previousActiveId = blurActiveDescendant();
      scrollIntoView2(nextActive);
      setAttribute(nextActive.id);
      nextActive.setAttribute(ACTIVEDESCENDANT_ATTRIBUTE, "");
      if (focusVisibleRef.current && shouldShowFocusVisibleAttrRef.current) {
        nextActive.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
      }
      const event = createActiveDescendantChangeEvent({
        id: nextActive.id,
        previousId: previousActiveId
      });
      nextActive.dispatchEvent(event);
    }, [
      blurActiveDescendant,
      setAttribute
    ]);
    const controller = React67.useMemo(() => ({
      first: ({ passive } = {}) => {
        const first = optionWalker.first();
        if (!passive) {
          focusActiveDescendant(first);
        }
        return first === null || first === void 0 ? void 0 : first.id;
      },
      last: ({ passive } = {}) => {
        const last = optionWalker.last();
        if (!passive) {
          focusActiveDescendant(last);
        }
        return last === null || last === void 0 ? void 0 : last.id;
      },
      next: ({ passive } = {}) => {
        const active = getActiveDescendant();
        if (!active) {
          return;
        }
        optionWalker.setCurrent(active);
        const next2 = optionWalker.next();
        if (!passive) {
          focusActiveDescendant(next2);
        }
        return next2 === null || next2 === void 0 ? void 0 : next2.id;
      },
      prev: ({ passive } = {}) => {
        const active = getActiveDescendant();
        if (!active) {
          return;
        }
        optionWalker.setCurrent(active);
        const next2 = optionWalker.prev();
        if (!passive) {
          focusActiveDescendant(next2);
        }
        return next2 === null || next2 === void 0 ? void 0 : next2.id;
      },
      blur: () => {
        blurActiveDescendant();
      },
      active: () => {
        var _getActiveDescendant;
        return (_getActiveDescendant = getActiveDescendant()) === null || _getActiveDescendant === void 0 ? void 0 : _getActiveDescendant.id;
      },
      focus: (id) => {
        if (!listboxRef.current) {
          return;
        }
        const target = listboxRef.current.querySelector(`#${id}`);
        if (target) {
          focusActiveDescendant(target);
        }
      },
      focusLastActive: () => {
        if (!listboxRef.current || !lastActiveIdRef.current) {
          return;
        }
        const target = listboxRef.current.querySelector(`#${lastActiveIdRef.current}`);
        if (target) {
          focusActiveDescendant(target);
          return true;
        }
      },
      find(predicate, { passive, startFrom } = {}) {
        const target = optionWalker.find(predicate, startFrom);
        if (!passive) {
          focusActiveDescendant(target);
        }
        return target === null || target === void 0 ? void 0 : target.id;
      },
      scrollActiveIntoView: () => {
        if (!listboxRef.current) {
          return;
        }
        const active = getActiveDescendant();
        if (!active) {
          return;
        }
        scrollIntoView2(active);
      },
      showAttributes() {
        attributeVisibilityRef.current = true;
        setAttribute();
      },
      hideAttributes() {
        attributeVisibilityRef.current = false;
        removeAttribute();
      },
      showFocusVisibleAttributes() {
        setShouldShowFocusVisibleAttribute(true);
      },
      hideFocusVisibleAttributes() {
        setShouldShowFocusVisibleAttribute(false);
      }
    }), [
      optionWalker,
      listboxRef,
      setAttribute,
      removeAttribute,
      focusActiveDescendant,
      blurActiveDescendant,
      getActiveDescendant,
      setShouldShowFocusVisibleAttribute
    ]);
    React67.useImperativeHandle(imperativeRef, () => controller);
    return {
      listboxRef: useMergedRefs(listboxRef, listboxCallbackRef),
      activeParentRef,
      controller
    };
  }

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-0.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React68 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-icons/lib/utils/useIconState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useRootStyles = __styles2({
    "root": {
      "mc9l5x": "f1w7gpdv",
      "Bg96gwp": "fez10in",
      "ycbfsm": "fg4l7m0"
    },
    "rtl": {
      "Bz10aip": "f13rod7r"
    }
  }, {
    "d": [".f1w7gpdv{display:inline;}", ".fez10in{line-height:0;}", ".f13rod7r{-webkit-transform:scaleX(-1);-moz-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1);}"],
    "t": ["@media (forced-colors: active){.fg4l7m0{forced-color-adjust:auto;}}"]
  });
  var useIconState = (props, options) => {
    const {
      title,
      primaryFill = "currentColor",
      ...rest
    } = props;
    const state = {
      ...rest,
      title: void 0,
      fill: primaryFill
    };
    const styles = useRootStyles();
    const iconContext = useIconContext();
    state.className = mergeClasses(styles.root, (options === null || options === void 0 ? void 0 : options.flipInRtl) && (iconContext === null || iconContext === void 0 ? void 0 : iconContext.textDirection) === "rtl" && styles.rtl, state.className);
    if (title) {
      state["aria-label"] = title;
    }
    if (!state["aria-label"] && !state["aria-labelledby"]) {
      state["aria-hidden"] = true;
    } else {
      state["role"] = "img";
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-icons/lib/utils/createFluentIcon.js
  var createFluentIcon = (displayName, width, paths, options) => {
    const viewBoxWidth = width === "1em" ? "20" : width;
    const Icon = React68.forwardRef((props, ref) => {
      const state = {
        ...useIconState(props, {
          flipInRtl: options === null || options === void 0 ? void 0 : options.flipInRtl
        }),
        ref,
        width,
        height: width,
        viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`,
        xmlns: "http://www.w3.org/2000/svg"
      };
      return React68.createElement("svg", state, ...paths.map((d) => React68.createElement("path", {
        d,
        fill: state.fill
      })));
    });
    Icon.displayName = displayName;
    return Icon;
  };

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-0.js
  var AddRegular = /* @__PURE__ */ createFluentIcon("AddRegular", "1em", ["M10 2.5c.28 0 .5.22.5.5v6.5H17a.5.5 0 0 1 0 1h-6.5V17a.5.5 0 0 1-1 0v-6.5H3a.5.5 0 0 1 0-1h6.5V3c0-.28.22-.5.5-.5Z"]);
  var AlertUrgentFilled = /* @__PURE__ */ createFluentIcon("AlertUrgentFilled", "1em", ["M2.47 12.25a5.16 5.16 0 0 1 9.42-4.2l1.22 2.75 1.67 1.62c.38.37.27 1-.22 1.22l-9.73 4.33a.75.75 0 0 1-1.05-.65L3.68 15l-1.21-2.75Zm6.36 5.09a1.49 1.49 0 0 0 2.68-1.2l-2.68 1.2Zm3.26-12.61a.5.5 0 0 1 .69-.14 6.17 6.17 0 0 1 2.91 4.91.5.5 0 1 1-1 0c0-.13 0-.26-.02-.39a5.17 5.17 0 0 0-2.45-3.69.5.5 0 0 1-.13-.7Zm.49-2.49a.5.5 0 0 1 .68-.16c2.46 1.5 4.58 3.8 4.74 7.9a.5.5 0 0 1-1 .04c-.14-3.68-2-5.7-4.26-7.09a.5.5 0 0 1-.16-.69Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-1.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var CheckmarkFilled = /* @__PURE__ */ createFluentIcon("CheckmarkFilled", "1em", ["M7.03 13.9 3.56 10a.75.75 0 0 0-1.12 1l4 4.5c.29.32.79.34 1.09.03l10.5-10.5a.75.75 0 0 0-1.06-1.06l-9.94 9.94Z"]);
  var CheckmarkCircleFilled = /* @__PURE__ */ createFluentIcon("CheckmarkCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16Zm3.36 5.65a.5.5 0 0 0-.64-.06l-.07.06L9 11.3 7.35 9.65l-.07-.06a.5.5 0 0 0-.7.7l.07.07 2 2 .07.06c.17.11.4.11.56 0l.07-.06 4-4 .07-.08a.5.5 0 0 0-.06-.63Z"]);
  var ChevronDownRegular = /* @__PURE__ */ createFluentIcon("ChevronDownRegular", "1em", ["M15.85 7.65c.2.2.2.5 0 .7l-5.46 5.49a.55.55 0 0 1-.78 0L4.15 8.35a.5.5 0 1 1 .7-.7L10 12.8l5.15-5.16c.2-.2.5-.2.7 0Z"]);
  var ChevronUpRegular = /* @__PURE__ */ createFluentIcon("ChevronUpRegular", "1em", ["M4.15 12.35a.5.5 0 0 1 0-.7L9.6 6.16a.55.55 0 0 1 .78 0l5.46 5.49a.5.5 0 0 1-.7.7L10 7.2l-5.15 5.16a.5.5 0 0 1-.7 0Z"]);
  var CircleFilled = /* @__PURE__ */ createFluentIcon("CircleFilled", "1em", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
  var DeleteRegular = /* @__PURE__ */ createFluentIcon("DeleteRegular", "1em", ["M8.5 4h3a1.5 1.5 0 0 0-3 0Zm-1 0a2.5 2.5 0 0 1 5 0h5a.5.5 0 0 1 0 1h-1.05l-1.2 10.34A3 3 0 0 1 12.27 18H7.73a3 3 0 0 1-2.98-2.66L3.55 5H2.5a.5.5 0 0 1 0-1h5ZM5.74 15.23A2 2 0 0 0 7.73 17h4.54a2 2 0 0 0 1.99-1.77L15.44 5H4.56l1.18 10.23ZM8.5 7.5c.28 0 .5.22.5.5v6a.5.5 0 0 1-1 0V8c0-.28.22-.5.5-.5ZM12 8a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V8Z"]);
  var DismissRegular = /* @__PURE__ */ createFluentIcon("DismissRegular", "1em", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
  var DismissCircleFilled = /* @__PURE__ */ createFluentIcon("DismissCircleFilled", "1em", ["M10 2a8 8 0 1 1 0 16 8 8 0 0 1 0-16ZM7.8 7.11a.5.5 0 0 0-.63.06l-.06.07a.5.5 0 0 0 .06.64L9.3 10l-2.12 2.12-.06.07a.5.5 0 0 0 .06.64l.07.06c.2.13.47.11.64-.06L10 10.7l2.12 2.12.07.06c.2.13.46.11.64-.06l.06-.07a.5.5 0 0 0-.06-.64L10.7 10l2.12-2.12.06-.07a.5.5 0 0 0-.06-.64l-.07-.06a.5.5 0 0 0-.64.06L10 9.3 7.88 7.17l-.07-.06Z"]);
  var DocumentRegular = /* @__PURE__ */ createFluentIcon("DocumentRegular", "1em", ["M6 2a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V7.41c0-.4-.16-.78-.44-1.06l-3.91-3.91A1.5 1.5 0 0 0 10.59 2H6ZM5 4a1 1 0 0 1 1-1h4v3.5c0 .83.67 1.5 1.5 1.5H15v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4Zm9.8 3h-3.3a.5.5 0 0 1-.5-.5V3.2L14.8 7Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-2.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var EditRegular = /* @__PURE__ */ createFluentIcon("EditRegular", "1em", ["M17.18 2.93a2.97 2.97 0 0 0-4.26-.06l-9.37 9.38c-.33.33-.56.74-.66 1.2l-.88 3.94a.5.5 0 0 0 .6.6l3.93-.87c.46-.1.9-.34 1.23-.68l9.36-9.36a2.97 2.97 0 0 0 .05-4.15Zm-3.55.65a1.97 1.97 0 1 1 2.8 2.8l-.68.66-2.8-2.79.68-.67Zm-1.38 1.38 2.8 2.8-7.99 7.97c-.2.2-.46.35-.74.41l-3.16.7.7-3.18c.07-.27.2-.51.4-.7l8-8Z"]);
  var ImportantFilled = /* @__PURE__ */ createFluentIcon("ImportantFilled", "1em", ["M10 2a3 3 0 0 0-3 3c0 2.23.79 5.2 1.22 6.69.24.79.97 1.31 1.78 1.31s1.54-.52 1.78-1.31C12.2 10.2 13 7.25 13 5a3 3 0 0 0-3-3Zm0 12a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"]);
  var InfoFilled = /* @__PURE__ */ createFluentIcon("InfoFilled", "1em", ["M18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0ZM9.5 8.91a.5.5 0 0 1 1 0V13.6a.5.5 0 0 1-1 0V8.9Zm-.25-2.16a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-3.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var MentionFilled = /* @__PURE__ */ createFluentIcon("MentionFilled", "1em", ["M10 1.75c4.56 0 8.25 3.7 8.25 8.25 0 2.83-1.22 4.75-3.25 4.75-1.2 0-2.12-.68-2.67-1.82a3.5 3.5 0 0 1-2.83 1.32c-2.3 0-3.75-1.82-3.75-4.25 0-2.46 1.41-4.25 3.75-4.25.9 0 1.66.26 2.25.72a.75.75 0 0 1 1.49-.08l.01.11V10c0 2.1.73 3.25 1.75 3.25s1.75-1.15 1.75-3.25a6.75 6.75 0 1 0-4.45 6.35.75.75 0 0 1 .5 1.4A8.23 8.23 0 0 1 1.76 10c0-4.56 3.7-8.25 8.25-8.25Zm-.5 5.5C8.08 7.25 7.25 8.3 7.25 10c0 1.67.87 2.75 2.25 2.75s2.25-1.08 2.25-2.75c0-1.7-.83-2.75-2.25-2.75Z"]);
  var PeopleFilled = /* @__PURE__ */ createFluentIcon("PeopleFilled", "1em", ["M6.75 10a3.25 3.25 0 1 0 0-6.5 3.25 3.25 0 0 0 0 6.5Zm5.69 5.14c.53.22 1.2.36 2.06.36 4 0 4-3 4-3 0-.83-.67-1.5-1.5-1.5h-4.63c.4.48.63 1.09.63 1.75v.36a2.94 2.94 0 0 1-.02.25 4.62 4.62 0 0 1-.54 1.78ZM17 7.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM1.5 13c0-1.1.9-2 2-2H10a2 2 0 0 1 2 2s0 4-5.25 4-5.25-4-5.25-4Zm11.5.1v.07Z"]);
  var PersonRegular = /* @__PURE__ */ createFluentIcon("PersonRegular", "1em", ["M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM7 6a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-2 5a2 2 0 0 0-2 2c0 1.7.83 2.97 2.13 3.8A9.14 9.14 0 0 0 10 18c1.85 0 3.58-.39 4.87-1.2A4.35 4.35 0 0 0 17 13a2 2 0 0 0-2-2H5Zm-1 2a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1c0 1.3-.62 2.28-1.67 2.95A8.16 8.16 0 0 1 10 17a8.16 8.16 0 0 1-4.33-1.05A3.36 3.36 0 0 1 4 13Z"]);
  var PlugConnectedSettingsRegular = /* @__PURE__ */ createFluentIcon("PlugConnectedSettingsRegular", "1em", ["M17.85 2.85a.5.5 0 0 0-.7-.7L14.48 4.8a4.04 4.04 0 0 0-5.33.34l-.3.3a1.49 1.49 0 0 0 0 2.1l2.46 2.47c.28-.2.58-.38.9-.52L9.55 6.85c-.19-.2-.19-.5 0-.7l.3-.3a3.04 3.04 0 0 1 5.01 3.16c.35.02.68.08 1 .16.37-1.23.15-2.6-.67-3.65l2.66-2.67Zm-10.3 6 2.47 2.46c-.2.28-.38.58-.52.9L6.85 9.55c-.2-.19-.5-.19-.7 0l-.3.3a3.04 3.04 0 0 0 3.16 5.01c.02.35.08.68.16 1-1.23.37-2.6.15-3.65-.67l-2.67 2.66a.5.5 0 0 1-.7-.7l2.66-2.67a4.04 4.04 0 0 1 .34-5.33l.3-.3a1.49 1.49 0 0 1 2.1 0Zm3.09 5.07a2 2 0 0 0 1.43-2.48l-.16-.55c.25-.2.53-.37.82-.5l.34.36a2 2 0 0 0 2.9 0l.33-.35c.3.14.58.32.84.52l-.13.42a2 2 0 0 0 1.46 2.52l.35.09a4.7 4.7 0 0 1 0 1.01l-.45.12a2 2 0 0 0-1.43 2.48l.15.55c-.25.2-.53.37-.82.5l-.34-.36a2 2 0 0 0-2.9 0l-.33.35c-.3-.14-.58-.32-.84-.52l.13-.42a2 2 0 0 0-1.46-2.52l-.35-.09a4.71 4.71 0 0 1 0-1.01l.46-.12Zm2.86.58a1 1 0 1 0 2 0 1 1 0 0 0-2 0Z"]);
  var PromptRegular = /* @__PURE__ */ createFluentIcon("PromptRegular", "1em", ["M17 2.5a.5.5 0 0 0-1 0V3h-.5a.5.5 0 0 0 0 1h.5v.5a.5.5 0 0 0 1 0V4h.5a.5.5 0 0 0 0-1H17v-.5Zm-13 13a.5.5 0 0 0-1 0v.5h-.5a.5.5 0 0 0 0 1H3v.5a.5.5 0 0 0 1 0V17h.5a.5.5 0 0 0 0-1H4v-.5Zm3-1.56V15a3 3 0 0 0 3 3h5a3 3 0 0 0 3-3v-5a3 3 0 0 0-3-3h-1.06a2.13 2.13 0 0 1 0 1H15a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2v-1.06a2.13 2.13 0 0 1-1 0Zm3.5-.94a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3Zm-.5-1.5c0-.28.22-.5.5-.5H15a.5.5 0 0 1 0 1h-4.5a.5.5 0 0 1-.5-.5ZM7.24 3.26c.04-.17.18-.26.26-.26.09 0 .22.09.26.26a5.14 5.14 0 0 0 3.98 3.98c.17.04.26.17.26.26s-.09.22-.26.26c-.67.14-1.7.5-2.6 1.39-.89.9-1.24 1.92-1.38 2.59-.04.17-.17.26-.26.26s-.22-.09-.26-.26a5.14 5.14 0 0 0-3.98-3.98C3.1 7.72 3 7.59 3 7.5s.09-.22.26-.26a5.15 5.15 0 0 0 3.98-3.98ZM7.5 2c-.65 0-1.12.51-1.24 1.06-.11.55-.4 1.37-1.11 2.09-.72.71-1.54 1-2.09 1.11C2.51 6.37 2 6.86 2 7.5c0 .65.52 1.13 1.06 1.24.55.11 1.37.4 2.09 1.11.71.72 1 1.54 1.11 2.1.12.54.59 1.05 1.24 1.05s1.13-.51 1.24-1.06c.11-.55.4-1.37 1.11-2.09.72-.71 1.54-1 2.1-1.11.54-.11 1.05-.59 1.05-1.24s-.51-1.13-1.06-1.24a4.14 4.14 0 0 1-2.09-1.11c-.71-.72-1-1.54-1.11-2.1C8.63 2.52 8.15 2 7.5 2Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-4.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var SendRegular = /* @__PURE__ */ createFluentIcon("SendRegular", "1em", ["M2.18 2.11a.5.5 0 0 1 .54-.06l15 7.5a.5.5 0 0 1 0 .9l-15 7.5a.5.5 0 0 1-.7-.58L3.98 10 2.02 2.63a.5.5 0 0 1 .16-.52Zm2.7 8.39-1.61 6.06L16.38 10 3.27 3.44 4.88 9.5h6.62a.5.5 0 1 1 0 1H4.88Z"], {
    flipInRtl: true
  });
  var SettingsRegular = /* @__PURE__ */ createFluentIcon("SettingsRegular", "1em", ["M1.91 7.38A8.5 8.5 0 0 1 3.7 4.3a.5.5 0 0 1 .54-.13l1.92.68a1 1 0 0 0 1.32-.76l.36-2a.5.5 0 0 1 .4-.4 8.53 8.53 0 0 1 3.55 0c.2.04.35.2.38.4l.37 2a1 1 0 0 0 1.32.76l1.92-.68a.5.5 0 0 1 .54.13 8.5 8.5 0 0 1 1.78 3.08c.06.2 0 .4-.15.54l-1.56 1.32a1 1 0 0 0 0 1.52l1.56 1.32a.5.5 0 0 1 .15.54 8.5 8.5 0 0 1-1.78 3.08.5.5 0 0 1-.54.13l-1.92-.68a1 1 0 0 0-1.32.76l-.37 2a.5.5 0 0 1-.38.4 8.53 8.53 0 0 1-3.56 0 .5.5 0 0 1-.39-.4l-.36-2a1 1 0 0 0-1.32-.76l-1.92.68a.5.5 0 0 1-.54-.13 8.5 8.5 0 0 1-1.78-3.08.5.5 0 0 1 .15-.54l1.56-1.32a1 1 0 0 0 0-1.52L2.06 7.92a.5.5 0 0 1-.15-.54Zm1.06 0 1.3 1.1a2 2 0 0 1 0 3.04l-1.3 1.1c.3.79.72 1.51 1.25 2.16l1.6-.58a2 2 0 0 1 2.63 1.53l.3 1.67a7.56 7.56 0 0 0 2.5 0l.3-1.67a2 2 0 0 1 2.64-1.53l1.6.58a7.5 7.5 0 0 0 1.24-2.16l-1.3-1.1a2 2 0 0 1 0-3.04l1.3-1.1a7.5 7.5 0 0 0-1.25-2.16l-1.6.58a2 2 0 0 1-2.63-1.53l-.3-1.67a7.55 7.55 0 0 0-2.5 0l-.3 1.67A2 2 0 0 1 5.81 5.8l-1.6-.58a7.5 7.5 0 0 0-1.24 2.16ZM7.5 10a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Zm1 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/icons/chunk-5.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var WarningFilled = /* @__PURE__ */ createFluentIcon("WarningFilled", "1em", ["M8.68 2.79a1.5 1.5 0 0 1 2.64 0l6.5 12A1.5 1.5 0 0 1 16.5 17h-13a1.5 1.5 0 0 1-1.32-2.21l6.5-12ZM10.5 7.5a.5.5 0 0 0-1 0v4a.5.5 0 0 0 1 0v-4Zm.25 6.25a.75.75 0 1 0-1.5 0 .75.75 0 0 0 1.5 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-3.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Checkmark12Filled = /* @__PURE__ */ createFluentIcon("Checkmark12Filled", "12", ["M9.76 3.2c.3.29.32.76.04 1.06l-4.25 4.5a.75.75 0 0 1-1.08.02L2.22 6.53a.75.75 0 0 1 1.06-1.06l1.7 1.7L8.7 3.24a.75.75 0 0 1 1.06-.04Z"]);
  var CheckmarkCircle16Regular = /* @__PURE__ */ createFluentIcon("CheckmarkCircle16Regular", "16", ["M2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Zm6-7a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm2.85 5.85a.5.5 0 0 0-.7-.7l-2.9 2.9-1.4-1.4a.5.5 0 1 0-.7.7L6.9 10.1c.2.2.5.2.7 0l3.25-3.25Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-4.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Circle16Regular = /* @__PURE__ */ createFluentIcon("Circle16Regular", "16", ["M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12Zm0-1A5 5 0 1 1 8 3a5 5 0 0 1 0 10Z"]);
  var Clock16Regular = /* @__PURE__ */ createFluentIcon("Clock16Regular", "16", ["M2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Zm6-7a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm0 3.5a.5.5 0 0 0-1 0v4c0 .28.22.5.5.5h3a.5.5 0 0 0 0-1H8V4.5Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-6.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Dismiss20Regular = /* @__PURE__ */ createFluentIcon("Dismiss20Regular", "20", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
  var Dismiss24Regular = /* @__PURE__ */ createFluentIcon("Dismiss24Regular", "24", ["m4.4 4.55.07-.08a.75.75 0 0 1 .98-.07l.08.07L12 10.94l6.47-6.47a.75.75 0 1 1 1.06 1.06L13.06 12l6.47 6.47c.27.27.3.68.07.98l-.07.08a.75.75 0 0 1-.98.07l-.08-.07L12 13.06l-6.47 6.47a.75.75 0 0 1-1.06-1.06L10.94 12 4.47 5.53a.75.75 0 0 1-.07-.98l.07-.08-.07.08Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-7.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Eye16Filled = /* @__PURE__ */ createFluentIcon("Eye16Filled", "16", ["M2.98 8.62a.5.5 0 0 1-.6.36c-.44-.11-.36-.6-.36-.6l.01-.07.05-.14A6.7 6.7 0 0 1 3.2 6.19C4.1 5.08 5.6 4 8 4s3.9 1.09 4.8 2.18a6.7 6.7 0 0 1 1.18 2.17v.02a.5.5 0 0 1-.96.26L13 8.6a3.05 3.05 0 0 0-.2-.52 5.7 5.7 0 0 0-.78-1.26A4.96 4.96 0 0 0 8 5c-2.04 0-3.29.91-4.03 1.82A5.7 5.7 0 0 0 3 8.6v.02Zm2.52.88a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z"]);
  var Flag16Filled = /* @__PURE__ */ createFluentIcon("Flag16Filled", "16", ["M4 10h9a.5.5 0 0 0 .4-.8L11.12 6l2.3-3.2A.5.5 0 0 0 13 2H3.5a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 1 0V10Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-13.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var PresenceAvailable10Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm2.1-5.9L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 0 1 .7-.7l.65.64 1.9-1.9a.5.5 0 0 1 .7.71Z"]);
  var PresenceAvailable10Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm6.1-1.6c.2.2.2.5 0 .7L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 1 1 .7-.7l.65.64 1.9-1.9c.2-.19.5-.19.7 0Z"]);
  var PresenceAvailable12Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm2.53-6.72L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22a.75.75 0 0 1 1.06 1.06Z"]);
  var PresenceAvailable12Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Zm7.03-1.78c.3.3.3.77 0 1.06L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22c.3-.3.77-.3 1.06 0Z"]);
  var PresenceAvailable16Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm3.7-9.3-4 4a1 1 0 0 1-1.41 0l-2-2a1 1 0 1 1 1.42-1.4L7 8.58l3.3-3.3a1 1 0 0 1 1.4 1.42Z"]);
  var PresenceAvailable16Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Regular", "16", ["M11.7 6.7a1 1 0 0 0-1.4-1.4L7 8.58l-1.3-1.3a1 1 0 0 0-1.4 1.42l2 2a1 1 0 0 0 1.4 0l4-4ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceAvailable20Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm4.2-11.8-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 1 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 1 1 1.4 1.42Z"]);
  var PresenceAvailable20Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm12.2-3.2a1 1 0 0 1 0 1.4l-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 0 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 0 1 1.4 0Z"]);
  var PresenceAway10Filled = /* @__PURE__ */ createFluentIcon("PresenceAway10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm0-7v1.8l1.35 1.35a.5.5 0 1 1-.7.7l-1.5-1.5A.5.5 0 0 1 4 5V3a.5.5 0 0 1 1 0Z"]);
  var PresenceAway12Filled = /* @__PURE__ */ createFluentIcon("PresenceAway12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm.5-8.75v2.4l1.49 1.28A.75.75 0 1 1 7 8.07l-1.75-1.5A.75.75 0 0 1 5 6V3.25a.75.75 0 0 1 1.5 0Z"]);
  var PresenceAway16Filled = /* @__PURE__ */ createFluentIcon("PresenceAway16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm.5-11.5v3.02l2.12 1.7a1 1 0 1 1-1.24 1.56l-2.5-2A1 1 0 0 1 6.5 8V4.5a1 1 0 0 1 2 0Z"]);
  var PresenceAway20Filled = /* @__PURE__ */ createFluentIcon("PresenceAway20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm0-14V9.6l2.7 2.7a1 1 0 0 1-1.4 1.42l-3-3A1 1 0 0 1 8 10V6a1 1 0 1 1 2 0Z"]);
  var PresenceBlocked10Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked10Regular", "10", ["M10 5A5 5 0 1 0 0 5a5 5 0 0 0 10 0ZM9 5a4 4 0 0 1-6.45 3.16l5.61-5.61C8.69 3.22 9 4.08 9 5ZM7.45 1.84 1.84 7.45a4 4 0 0 1 5.61-5.61Z"]);
  var PresenceBlocked12Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked12Regular", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Zm-1.5 0c0-.97-.3-1.87-.83-2.6L3.39 9.66A4.5 4.5 0 0 0 10.5 6ZM8.6 2.33a4.5 4.5 0 0 0-6.28 6.28l6.29-6.28Z"]);
  var PresenceBlocked16Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked16Regular", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-2 0c0-1.3-.41-2.5-1.1-3.48L4.51 12.9A6 6 0 0 0 14 8Zm-2.52-4.9a6 6 0 0 0-8.37 8.37l8.37-8.36Z"]);
  var PresenceBlocked20Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked20Regular", "20", ["M20 10a10 10 0 1 0-20 0 10 10 0 0 0 20 0Zm-2 0a8 8 0 0 1-12.9 6.32L16.31 5.09A7.97 7.97 0 0 1 18 10Zm-3.1-6.32L3.69 14.91A8 8 0 0 1 14.91 3.68Z"]);
  var PresenceBusy10Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy10Filled", "10", ["M10 5A5 5 0 1 1 0 5a5 5 0 0 1 10 0Z"]);
  var PresenceBusy12Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy12Filled", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Z"]);
  var PresenceBusy16Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy16Filled", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Z"]);
  var PresenceBusy20Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy20Filled", "20", ["M20 10a10 10 0 1 1-20 0 10 10 0 0 1 20 0Z"]);
  var PresenceDnd10Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10ZM3.5 4.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1Z"]);
  var PresenceDnd10Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm2 0c0-.28.22-.5.5-.5h3a.5.5 0 0 1 0 1h-3A.5.5 0 0 1 3 5Z"]);
  var PresenceDnd12Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12ZM3.75 5.25h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5Z"]);
  var PresenceDnd12Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0ZM3 6c0-.41.34-.75.75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5A.75.75 0 0 1 3 6Z"]);
  var PresenceDnd16Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16ZM5.25 7h5.5a1 1 0 1 1 0 2h-5.5a1 1 0 1 1 0-2Z"]);
  var PresenceDnd16Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd16Regular", "16", ["M5.25 7a1 1 0 0 0 0 2h5.5a1 1 0 1 0 0-2h-5.5ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceDnd20Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20ZM7 9h6a1 1 0 1 1 0 2H7a1 1 0 1 1 0-2Z"]);
  var PresenceDnd20Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Z"]);
  var PresenceOffline10Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline10Regular", "10", ["M6.85 3.15c.2.2.2.5 0 .7L5.71 5l1.14 1.15a.5.5 0 1 1-.7.7L5 5.71 3.85 6.85a.5.5 0 1 1-.7-.7L4.29 5 3.15 3.85a.5.5 0 1 1 .7-.7L5 4.29l1.15-1.14c.2-.2.5-.2.7 0ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Zm5-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z"]);
  var PresenceOffline12Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline12Regular", "12", ["M8.03 3.97c.3.3.3.77 0 1.06L7.06 6l.97.97a.75.75 0 0 1-1.06 1.06L6 7.06l-.97.97a.75.75 0 0 1-1.06-1.06L4.94 6l-.97-.97a.75.75 0 0 1 1.06-1.06l.97.97.97-.97c.3-.3.77-.3 1.06 0ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Zm6-4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"]);
  var PresenceOffline16Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline16Regular", "16", ["M10.7 5.3a1 1 0 0 1 0 1.4L9.42 8l1.3 1.3a1 1 0 0 1-1.42 1.4L8 9.42l-1.3 1.3a1 1 0 0 1-1.4-1.42L6.58 8l-1.3-1.3a1 1 0 0 1 1.42-1.4L8 6.58l1.3-1.3a1 1 0 0 1 1.4 0ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
  var PresenceOffline20Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline20Regular", "20", ["M13.7 6.3a1 1 0 0 1 0 1.4L11.42 10l2.3 2.3a1 1 0 0 1-1.42 1.4L10 11.42l-2.3 2.3a1 1 0 0 1-1.4-1.42L8.58 10l-2.3-2.3a1 1 0 0 1 1.42-1.4L10 8.58l2.3-2.3a1 1 0 0 1 1.4 0ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Zm10-8a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
  var PresenceOof10Regular = /* @__PURE__ */ createFluentIcon("PresenceOof10Regular", "10", ["M5.35 3.85a.5.5 0 1 0-.7-.7l-1.5 1.5a.5.5 0 0 0 0 .7l1.5 1.5a.5.5 0 1 0 .7-.7L4.7 5.5h1.8a.5.5 0 1 0 0-1H4.7l.65-.65ZM5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z"]);
  var PresenceOof12Regular = /* @__PURE__ */ createFluentIcon("PresenceOof12Regular", "12", ["M6.28 4.53a.75.75 0 0 0-1.06-1.06l-2 2c-.3.3-.3.77 0 1.06l2 2a.75.75 0 0 0 1.06-1.06l-.72-.72h2.69a.75.75 0 1 0 0-1.5h-2.7l.73-.72ZM6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Z"]);
  var PresenceOof16Regular = /* @__PURE__ */ createFluentIcon("PresenceOof16Regular", "16", ["M8.2 6.2a1 1 0 1 0-1.4-1.4L4.3 7.3a1 1 0 0 0 0 1.4l2.5 2.5a1 1 0 0 0 1.4-1.4L7.42 9H11a1 1 0 1 0 0-2H7.41l.8-.8ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
  var PresenceOof20Regular = /* @__PURE__ */ createFluentIcon("PresenceOof20Regular", "20", ["M10.7 7.7A1 1 0 1 0 9.28 6.3l-3 3a1 1 0 0 0 0 1.41l3 3a1 1 0 1 0 1.42-1.41l-1.3-1.3H13a1 1 0 1 0 0-2H9.4l1.3-1.29ZM10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Z"]);
  var PresenceUnknown10Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown10Regular", "10", ["M5 1a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Z"]);
  var PresenceUnknown12Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown12Regular", "12", ["M6 1.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Z"]);
  var PresenceUnknown16Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown16Regular", "16", ["M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Z"]);
  var PresenceUnknown20Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown20Regular", "20", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Z"]);

  // ../../node_modules/@fluentui/react-icons/lib/sizedIcons/chunk-18.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Warning16Filled = /* @__PURE__ */ createFluentIcon("Warning16Filled", "16", ["M9.1 2.64a1.25 1.25 0 0 0-2.19 0l-4.75 8.5c-.47.83.13 1.86 1.09 1.86h9.5c.96 0 1.56-1.03 1.1-1.86l-4.76-8.5Zm-.35 7.61a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM7.5 8V5.5a.5.5 0 0 1 1 0V8a.5.5 0 0 1-1 0Z"]);

  // ../../node_modules/@fluentui/react-motion/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-motion/lib/motions/motionTokens.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var durations2 = {
    durationUltraFast: 50,
    durationFaster: 100,
    durationFast: 150,
    durationNormal: 200,
    durationGentle: 250,
    durationSlow: 300,
    durationSlower: 400,
    durationUltraSlow: 500
  };
  var curves2 = {
    curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
    curveAccelerateMid: "cubic-bezier(1,0,1,1)",
    curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
    curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
    curveDecelerateMid: "cubic-bezier(0,0,0,1)",
    curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
    curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
    curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
    curveLinear: "cubic-bezier(0,0,1,1)"
  };
  var motionTokens = {
    ...durations2,
    ...curves2
  };

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React69 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-motion/lib/utils/isAnimationRunning.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function isAnimationRunning(animation) {
    if (animation.playState === "running") {
      var _animation_effect;
      if (animation.overallProgress !== void 0) {
        var _animation_overallProgress;
        const overallProgress = (_animation_overallProgress = animation.overallProgress) !== null && _animation_overallProgress !== void 0 ? _animation_overallProgress : 0;
        return overallProgress > 0 && overallProgress < 1;
      }
      var _animation_currentTime;
      const currentTime = Number((_animation_currentTime = animation.currentTime) !== null && _animation_currentTime !== void 0 ? _animation_currentTime : 0);
      var _animation_effect_getTiming_duration;
      const totalTime = Number((_animation_effect_getTiming_duration = (_animation_effect = animation.effect) === null || _animation_effect === void 0 ? void 0 : _animation_effect.getTiming().duration) !== null && _animation_effect_getTiming_duration !== void 0 ? _animation_effect_getTiming_duration : 0);
      return currentTime > 0 && currentTime < totalTime;
    }
    return false;
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
  var DEFAULT_ANIMATION_OPTIONS = {
    fill: "forwards"
  };
  var DEFAULT_REDUCED_MOTION_ATOM = {
    duration: 1
  };
  function useAnimateAtomsInSupportedEnvironment() {
    var _window_Animation;
    const SUPPORTS_PERSIST = typeof window !== "undefined" && typeof ((_window_Animation = window.Animation) === null || _window_Animation === void 0 ? void 0 : _window_Animation.prototype.persist) === "function";
    return React69.useCallback((element4, value, options) => {
      const atoms = Array.isArray(value) ? value : [
        value
      ];
      const { isReducedMotion } = options;
      const animations = atoms.map((motion) => {
        const { keyframes: motionKeyframes, reducedMotion = DEFAULT_REDUCED_MOTION_ATOM, ...params } = motion;
        const { keyframes: reducedMotionKeyframes = motionKeyframes, ...reducedMotionParams } = reducedMotion;
        const animationKeyframes = isReducedMotion ? reducedMotionKeyframes : motionKeyframes;
        const animationParams = {
          ...DEFAULT_ANIMATION_OPTIONS,
          ...params,
          // Use reduced motion overrides (e.g. duration, easing) when reduced motion is enabled
          ...isReducedMotion && reducedMotionParams
        };
        try {
          const animation = element4.animate(animationKeyframes, animationParams);
          if (SUPPORTS_PERSIST) {
            animation === null || animation === void 0 ? void 0 : animation.persist();
          } else {
            const resultKeyframe = animationKeyframes[animationKeyframes.length - 1];
            var _element_style;
            Object.assign((_element_style = element4.style) !== null && _element_style !== void 0 ? _element_style : {}, resultKeyframe);
          }
          return animation;
        } catch (e) {
          return null;
        }
      }).filter((animation) => !!animation);
      return {
        set playbackRate(rate) {
          animations.forEach((animation) => {
            animation.playbackRate = rate;
          });
        },
        setMotionEndCallbacks(onfinish, oncancel) {
          const promises = animations.map((animation) => {
            return new Promise((resolve, reject) => {
              animation.onfinish = () => resolve();
              animation.oncancel = () => reject();
            });
          });
          Promise.all(promises).then(() => {
            onfinish();
          }).catch(() => {
            oncancel();
          });
        },
        isRunning() {
          return animations.some((animation) => isAnimationRunning(animation));
        },
        cancel: () => {
          animations.forEach((animation) => {
            animation.cancel();
          });
        },
        pause: () => {
          animations.forEach((animation) => {
            animation.pause();
          });
        },
        play: () => {
          animations.forEach((animation) => {
            animation.play();
          });
        },
        finish: () => {
          animations.forEach((animation) => {
            animation.finish();
          });
        },
        reverse: () => {
          animations.forEach((animation) => {
            animation.reverse();
          });
        }
      };
    }, [
      SUPPORTS_PERSIST
    ]);
  }
  function useAnimateAtoms() {
    "use no memo";
    if (false) {
      return useAnimateAtomsInTestEnvironment();
    }
    return useAnimateAtomsInSupportedEnvironment();
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useMotionImperativeRef.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React70 = __toESM(require_react());
  function useMotionImperativeRef(imperativeRef) {
    const animationRef = React70.useRef();
    React70.useImperativeHandle(imperativeRef, () => ({
      setPlayState: (state) => {
        if (state === "running") {
          var _animationRef_current;
          (_animationRef_current = animationRef.current) === null || _animationRef_current === void 0 ? void 0 : _animationRef_current.play();
        }
        if (state === "paused") {
          var _animationRef_current1;
          (_animationRef_current1 = animationRef.current) === null || _animationRef_current1 === void 0 ? void 0 : _animationRef_current1.pause();
        }
      },
      setPlaybackRate: (rate) => {
        if (animationRef.current) {
          animationRef.current.playbackRate = rate;
        }
      }
    }));
    return animationRef;
  }

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useIsReducedMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React71 = __toESM(require_react());
  var REDUCED_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
  function useIsReducedMotion() {
    const { targetDocument } = useFluent();
    var _targetDocument_defaultView;
    const targetWindow = (_targetDocument_defaultView = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) !== null && _targetDocument_defaultView !== void 0 ? _targetDocument_defaultView : null;
    const queryValue = React71.useRef(false);
    const isEnabled = React71.useCallback(() => queryValue.current, []);
    useIsomorphicLayoutEffect2(() => {
      if (targetWindow === null || typeof targetWindow.matchMedia !== "function") {
        return;
      }
      const queryMatch = targetWindow.matchMedia(REDUCED_MEDIA_QUERY);
      if (queryMatch.matches) {
        queryValue.current = true;
      }
      const matchListener = (e) => {
        queryValue.current = e.matches;
      };
      queryMatch.addEventListener("change", matchListener);
      return () => {
        queryMatch.removeEventListener("change", matchListener);
      };
    }, [
      targetWindow
    ]);
    return isEnabled;
  }

  // ../../node_modules/@fluentui/react-motion/lib/utils/useChildElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React72 = __toESM(require_react());
  var IS_REACT_19 = React72.version.startsWith("19.");
  var CHILD_ERROR_MESSAGE = [
    "@fluentui/react-motion: Invalid child element.",
    "\n",
    "Motion factories require a single child element to be passed. ",
    "That element element should support ref forwarding i.e. it should be either an intrinsic element (e.g. div) or a component that uses React.forwardRef()."
  ].join("");
  function getRefFromReactElement(element4) {
    if (IS_REACT_19) {
      return element4.props.ref;
    }
    return element4.ref;
  }
  function useChildElement(children2, mounted = true) {
    const childRef = React72.useRef(null);
    React72.useEffect(() => {
      if (false) {
        if (mounted && !childRef.current) {
          console.error(CHILD_ERROR_MESSAGE);
        }
      }
    }, [
      mounted
    ]);
    try {
      const child = React72.Children.only(children2);
      if (React72.isValidElement(child)) {
        return [
          React72.cloneElement(child, {
            ref: useMergedRefs(childRef, getRefFromReactElement(child))
          }),
          childRef
        ];
      }
    } catch {
    }
    throw new Error(CHILD_ERROR_MESSAGE);
  }

  // ../../node_modules/@fluentui/react-motion/lib/contexts/MotionBehaviourContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React73 = __toESM(require_react());
  var MotionBehaviourContext = React73.createContext(void 0);
  var MotionBehaviourProvider = MotionBehaviourContext.Provider;
  var useMotionBehaviourContext = () => {
    var _React_useContext;
    return (_React_useContext = React73.useContext(MotionBehaviourContext)) !== null && _React_useContext !== void 0 ? _React_useContext : "default";
  };

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React76 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-motion/lib/contexts/PresenceGroupChildContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React74 = __toESM(require_react());
  var PresenceGroupChildContext = React74.createContext(void 0);
  var PresenceGroupChildProvider = PresenceGroupChildContext.Provider;

  // ../../node_modules/@fluentui/react-motion/lib/hooks/useMountedState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React75 = __toESM(require_react());
  function useMountedState(visible = false, unmountOnExit = false) {
    const mountedRef = React75.useRef(unmountOnExit ? visible : true);
    const forceUpdate = useForceUpdate();
    const setMounted = React75.useCallback((newValue) => {
      if (mountedRef.current !== newValue) {
        mountedRef.current = newValue;
        forceUpdate();
      }
    }, [
      forceUpdate
    ]);
    React75.useEffect(() => {
      if (visible) {
        mountedRef.current = visible;
      }
    });
    return [
      visible || mountedRef.current,
      setMounted
    ];
  }

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
  var MOTION_DEFINITION = Symbol("MOTION_DEFINITION");
  var INTERRUPTABLE_MOTION_SYMBOL = Symbol.for("interruptablePresence");
  function createPresenceComponent(value) {
    return Object.assign((props) => {
      "use no memo";
      const itemContext = React76.useContext(PresenceGroupChildContext);
      const merged = {
        ...itemContext,
        ...props
      };
      const skipMotions = useMotionBehaviourContext() === "skip";
      const { appear, children: children2, imperativeRef, onExit, onMotionFinish, onMotionStart, onMotionCancel, visible, unmountOnExit, ..._rest } = merged;
      const params = _rest;
      const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
      const [child, childRef] = useChildElement(children2, mounted);
      const handleRef = useMotionImperativeRef(imperativeRef);
      const optionsRef = React76.useRef({
        appear,
        params,
        skipMotions
      });
      const animateAtoms = useAnimateAtoms();
      const isFirstMount = useFirstMount();
      const isReducedMotion = useIsReducedMotion();
      const handleMotionStart = useEventCallback((direction) => {
        onMotionStart === null || onMotionStart === void 0 ? void 0 : onMotionStart(null, {
          direction
        });
      });
      const handleMotionFinish = useEventCallback((direction) => {
        onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(null, {
          direction
        });
        if (direction === "exit" && unmountOnExit) {
          setMounted(false);
          onExit === null || onExit === void 0 ? void 0 : onExit();
        }
      });
      const handleMotionCancel = useEventCallback((direction) => {
        onMotionCancel === null || onMotionCancel === void 0 ? void 0 : onMotionCancel(null, {
          direction
        });
      });
      useIsomorphicLayoutEffect2(() => {
        optionsRef.current = {
          appear,
          params,
          skipMotions
        };
      });
      useIsomorphicLayoutEffect2(
        () => {
          const element4 = childRef.current;
          if (!element4) {
            return;
          }
          let handle2;
          function cleanup() {
            if (!handle2) {
              return;
            }
            if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION && handle2.isRunning()) {
              return;
            }
            handle2.cancel();
            handleRef.current = void 0;
          }
          const presenceMotion = typeof value === "function" ? value({
            element: element4,
            ...optionsRef.current.params
          }) : value;
          const IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION = presenceMotion[INTERRUPTABLE_MOTION_SYMBOL];
          if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION) {
            handle2 = handleRef.current;
            if (handle2 && handle2.isRunning()) {
              handle2.reverse();
              return cleanup;
            }
          }
          const atoms = visible ? presenceMotion.enter : presenceMotion.exit;
          const direction = visible ? "enter" : "exit";
          const applyInitialStyles = !optionsRef.current.appear && isFirstMount;
          const skipAnimationByConfig = optionsRef.current.skipMotions;
          if (!applyInitialStyles) {
            handleMotionStart(direction);
          }
          handle2 = animateAtoms(element4, atoms, {
            isReducedMotion: isReducedMotion()
          });
          if (applyInitialStyles) {
            handle2.finish();
            return cleanup;
          }
          handleRef.current = handle2;
          handle2.setMotionEndCallbacks(() => handleMotionFinish(direction), () => handleMotionCancel(direction));
          if (skipAnimationByConfig) {
            handle2.finish();
          }
          return cleanup;
        },
        // Excluding `isFirstMount` from deps to prevent re-triggering the animation on subsequent renders
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
          animateAtoms,
          childRef,
          handleRef,
          isReducedMotion,
          handleMotionFinish,
          handleMotionStart,
          handleMotionCancel,
          visible
        ]
      );
      if (mounted) {
        return child;
      }
      return null;
    }, {
      // Heads up!
      // Always normalize it to a function to simplify types
      [MOTION_DEFINITION]: typeof value === "function" ? value : () => value
    });
  }

  // ../../node_modules/@fluentui/react-motion/lib/factories/createPresenceComponentVariant.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createPresenceFnVariant(presenceFn, variantParams) {
    const variantFn = (runtimeParams) => presenceFn({
      ...variantParams,
      ...runtimeParams
    });
    return variantFn;
  }
  function createPresenceComponentVariant(component, variantParams) {
    const originalFn = component[MOTION_DEFINITION];
    const variantFn = createPresenceFnVariant(originalFn, variantParams);
    return createPresenceComponent(variantFn);
  }

  // ../../node_modules/@fluentui/react-motion/lib/slots/presenceMotionSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React77 = __toESM(require_react());
  function presenceMotionSlot(motion, options) {
    const { as, children: children2, ...rest } = motion !== null && motion !== void 0 ? motion : {};
    if (false) {
      if (typeof as !== "undefined") {
        throw new Error(`@fluentui/react-motion: "as" property is not supported on motion slots.`);
      }
    }
    if (motion === null) {
      const isUnmounted = !options.defaultProps.visible && options.defaultProps.unmountOnExit;
      const renderFn = (_, props) => isUnmounted ? null : /* @__PURE__ */ React77.createElement(React77.Fragment, null, props.children);
      return {
        [SLOT_RENDER_FUNCTION_SYMBOL]: renderFn,
        [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
      };
    }
    const propsWithMetadata = {
      ...options.defaultProps,
      ...rest,
      [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
    };
    if (typeof children2 === "function") {
      propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = children2;
    }
    return propsWithMetadata;
  }

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/atoms/fade-atom.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var fadeAtom = ({ direction, duration, easing = motionTokens.curveLinear, fromValue = 0 }) => {
    const keyframes2 = [
      {
        opacity: fromValue
      },
      {
        opacity: 1
      }
    ];
    if (direction === "exit") {
      keyframes2.reverse();
    }
    return {
      keyframes: keyframes2,
      duration,
      easing
    };
  };

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/Fade.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var fadePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEase, exitDuration = duration, exitEasing = easing }) => {
    return {
      enter: fadeAtom({
        direction: "enter",
        duration,
        easing
      }),
      exit: fadeAtom({
        direction: "exit",
        duration: exitDuration,
        easing: exitEasing
      })
    };
  };
  var Fade = createPresenceComponent(fadePresenceFn);
  var FadeSnappy = createPresenceComponentVariant(Fade, {
    duration: motionTokens.durationFast
  });
  var FadeRelaxed = createPresenceComponentVariant(Fade, {
    duration: motionTokens.durationGentle
  });

  // ../../node_modules/@fluentui/react-avatar/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-avatar/lib/Avatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React85 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderAvatar_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.initials && /* @__PURE__ */ jsx2(state.initials, {}),
        state.icon && /* @__PURE__ */ jsx2(state.icon, {}),
        state.image && /* @__PURE__ */ jsx2(state.image, {}),
        state.badge && /* @__PURE__ */ jsx2(state.badge, {}),
        state.activeAriaLabelElement
      ]
    });
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React84 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-avatar/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
  var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
  var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
  var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
  var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
  function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
    let initials = "";
    const splits = displayName.split(" ");
    if (splits.length !== 0) {
      initials += splits[0].charAt(0).toUpperCase();
    }
    if (!firstInitialOnly) {
      if (splits.length === 2) {
        initials += splits[1].charAt(0).toUpperCase();
      } else if (splits.length === 3) {
        initials += splits[2].charAt(0).toUpperCase();
      }
    }
    if (isRtl && initials.length > 1) {
      return initials.charAt(1) + initials.charAt(0);
    }
    return initials;
  }
  function cleanupDisplayName(displayName) {
    displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
    displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
    displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
    displayName = displayName.trim();
    return displayName;
  }
  function getInitials(displayName, isRtl, options) {
    if (!displayName) {
      return "";
    }
    displayName = cleanupDisplayName(displayName);
    if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
      return "";
    }
    return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
  }

  // ../../node_modules/@fluentui/react-badge/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-badge/lib/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React79 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React78 = __toESM(require_react());
  var useBadge_unstable = (props, ref) => {
    const { shape = "circular", size: size3 = "medium", iconPosition = "before", appearance = "filled", color: color2 = "brand" } = props;
    const state = {
      shape,
      size: size3,
      iconPosition,
      appearance,
      color: color2,
      components: {
        root: "div",
        icon: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      icon: slot_exports.optional(props.icon, {
        elementType: "span"
      })
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var badgeClassNames = {
    root: "fui-Badge",
    icon: "fui-Badge__icon"
  };
  var textPadding = tokens.spacingHorizontalXXS;
  var useRootClassName = /* @__PURE__ */ __resetStyles2("r1iycov", "r115jdol", [".r1iycov{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r1iycov::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}', ".r115jdol{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r115jdol::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}']);
  var useRootStyles2 = /* @__PURE__ */ __styles2({
    fontSmallToTiny: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "f13mqy1h",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "fcpl73t"
    },
    tiny: {
      a9b677: "f16dn6v3",
      Bqenvij: "f3mu39s",
      Be2twd7: "f130uwy9",
      Bg96gwp: "fod1mrr",
      Bf4jedk: "f18p0k4z",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f19jm9xf"
    },
    "extra-small": {
      a9b677: "fpd43o0",
      Bqenvij: "f30q22z",
      Be2twd7: "f1tccstq",
      Bg96gwp: "f1y3arg5",
      Bf4jedk: "f18p0k4z",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f19jm9xf"
    },
    small: {
      Bf4jedk: "fq2vo04",
      Bqenvij: "fd461yt",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fupdldz"
    },
    medium: {},
    large: {
      Bf4jedk: "f17fgpbq",
      Bqenvij: "frvgh55",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1996nqw"
    },
    "extra-large": {
      Bf4jedk: "fwbmr0d",
      Bqenvij: "f1d2rq10",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fty64o7"
    },
    square: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1fabniw"
    },
    rounded: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5"
    },
    roundedSmallToTiny: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fq9zq91"
    },
    circular: {},
    borderGhost: {
      ap17g6: "f10ludwy"
    },
    filled: {},
    "filled-brand": {
      De3pzq: "ffp7eso",
      sj55zd: "f1phragk"
    },
    "filled-danger": {
      De3pzq: "fdl5y0r",
      sj55zd: "f1phragk"
    },
    "filled-important": {
      De3pzq: "f1c73kur",
      sj55zd: "fr0bkrk"
    },
    "filled-informative": {
      De3pzq: "f3vzo32",
      sj55zd: "f11d4kpn"
    },
    "filled-severe": {
      De3pzq: "f1s438gw",
      sj55zd: "f1phragk"
    },
    "filled-subtle": {
      De3pzq: "fxugw4r",
      sj55zd: "f19n0e5"
    },
    "filled-success": {
      De3pzq: "flxk52p",
      sj55zd: "f1phragk"
    },
    "filled-warning": {
      De3pzq: "ffq97bm",
      sj55zd: "ff5vbop"
    },
    ghost: {},
    "ghost-brand": {
      sj55zd: "f16muhyy"
    },
    "ghost-danger": {
      sj55zd: "f1whyuy6"
    },
    "ghost-important": {
      sj55zd: "f19n0e5"
    },
    "ghost-informative": {
      sj55zd: "f11d4kpn"
    },
    "ghost-severe": {
      sj55zd: "f1l8vj45"
    },
    "ghost-subtle": {
      sj55zd: "fonrgv7"
    },
    "ghost-success": {
      sj55zd: "f1m7fhi8"
    },
    "ghost-warning": {
      sj55zd: "fpti2h4"
    },
    outline: {
      g2u3we: "f23ftbb",
      h3c5rm: ["f1gkuv52", "f1p1bl80"],
      B9xav0g: "fioka3i",
      zhjwy3: ["f1p1bl80", "f1gkuv52"]
    },
    "outline-brand": {
      sj55zd: "f16muhyy"
    },
    "outline-danger": {
      sj55zd: "f1whyuy6",
      g2u3we: "fyqpifd",
      h3c5rm: ["f3ukxca", "f1k7dugc"],
      B9xav0g: "f1njxb2b",
      zhjwy3: ["f1k7dugc", "f3ukxca"]
    },
    "outline-important": {
      sj55zd: "f11d4kpn",
      g2u3we: "fq0vr37",
      h3c5rm: ["f1byw159", "f11cr0be"],
      B9xav0g: "f1c1zstj",
      zhjwy3: ["f11cr0be", "f1byw159"]
    },
    "outline-informative": {
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "outline-severe": {
      sj55zd: "f1l8vj45"
    },
    "outline-subtle": {
      sj55zd: "fonrgv7"
    },
    "outline-success": {
      sj55zd: "f1m7fhi8",
      g2u3we: "f1mmhl11",
      h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
      B9xav0g: "f1gjv25d",
      zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
    },
    "outline-warning": {
      sj55zd: "fpti2h4"
    },
    tint: {},
    "tint-brand": {
      De3pzq: "f16xkysk",
      sj55zd: "faj9fo0",
      g2u3we: "f161y7kd",
      h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
      B9xav0g: "f1619yhw",
      zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
    },
    "tint-danger": {
      De3pzq: "ff0poqj",
      sj55zd: "f1hcrxcs",
      g2u3we: "f1oqjm8o",
      h3c5rm: ["fkgrb8g", "frb5wm0"],
      B9xav0g: "f1iai1ph",
      zhjwy3: ["frb5wm0", "fkgrb8g"]
    },
    "tint-important": {
      De3pzq: "f945g0u",
      sj55zd: "fr0bkrk",
      g2u3we: "fghlq4f",
      h3c5rm: ["f1gn591s", "fjscplz"],
      B9xav0g: "fb073pr",
      zhjwy3: ["fjscplz", "f1gn591s"]
    },
    "tint-informative": {
      De3pzq: "f1ctqxl6",
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "tint-severe": {
      De3pzq: "f1xzsg4",
      sj55zd: "f1k5f75o",
      g2u3we: "fxy9dsj",
      h3c5rm: ["f54u6j2", "fcm23ze"],
      B9xav0g: "f4vf0uq",
      zhjwy3: ["fcm23ze", "f54u6j2"]
    },
    "tint-subtle": {
      De3pzq: "fxugw4r",
      sj55zd: "f11d4kpn",
      g2u3we: "f68mrw8",
      h3c5rm: ["f7pw515", "fw35ms5"],
      B9xav0g: "frpde29",
      zhjwy3: ["fw35ms5", "f7pw515"]
    },
    "tint-success": {
      De3pzq: "f2vsrz6",
      sj55zd: "ffmvakt",
      g2u3we: "fdmic9h",
      h3c5rm: ["f196y6m", "fetptd8"],
      B9xav0g: "f1pev5xq",
      zhjwy3: ["fetptd8", "f196y6m"]
    },
    "tint-warning": {
      De3pzq: "f10s6hli",
      sj55zd: "f42v8de",
      g2u3we: "fn9i3n",
      h3c5rm: ["f1aw8cx4", "f51if14"],
      B9xav0g: "fvq8iai",
      zhjwy3: ["f51if14", "f1aw8cx4"]
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f130uwy9{font-size:4px;}", ".fod1mrr{line-height:4px;}", ".f18p0k4z{min-width:unset;}", [".f19jm9xf{padding:unset;}", {
      p: -1
    }], ".fpd43o0{width:10px;}", ".f30q22z{height:10px;}", ".f1tccstq{font-size:6px;}", ".f1y3arg5{line-height:6px;}", [".f19jm9xf{padding:unset;}", {
      p: -1
    }], ".fq2vo04{min-width:16px;}", ".fd461yt{height:16px;}", [".fupdldz{padding:0 calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f17fgpbq{min-width:24px;}", ".frvgh55{height:24px;}", [".f1996nqw{padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".fwbmr0d{min-width:32px;}", ".f1d2rq10{height:32px;}", [".fty64o7{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], ".f10ludwy::after{display:none;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1c73kur{background-color:var(--colorNeutralForeground1);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f3vzo32{background-color:var(--colorNeutralBackground5);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}", ".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}", ".ff5vbop{color:var(--colorNeutralForeground1Static);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".f23ftbb{border-top-color:currentColor;}", ".f1gkuv52{border-right-color:currentColor;}", ".f1p1bl80{border-left-color:currentColor;}", ".fioka3i{border-bottom-color:currentColor;}", ".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}", ".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}", ".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}", ".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}", ".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}", ".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}", ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f68mrw8{border-top-color:var(--colorNeutralStroke2);}", ".f7pw515{border-right-color:var(--colorNeutralStroke2);}", ".fw35ms5{border-left-color:var(--colorNeutralStroke2);}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}", ".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}", ".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}", ".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f161y7kd{border-top-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}", ".ff0poqj{background-color:var(--colorPaletteRedBackground1);}", ".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}", ".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}", ".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}", ".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}", ".f945g0u{background-color:var(--colorNeutralForeground3);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}", ".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}", ".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}", ".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}", ".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}", ".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}", ".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}", ".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}", ".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}", ".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}", ".f42v8de{color:var(--colorPaletteYellowForeground1);}", ".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}", ".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}", ".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}", ".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"]
  });
  var useIconRootClassName = /* @__PURE__ */ __resetStyles2("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
  var useIconStyles = /* @__PURE__ */ __styles2({
    beforeText: {
      t21cq0: ["f1t8l4o1", "f11juvx6"]
    },
    afterText: {
      Frg6f3: ["f11juvx6", "f1t8l4o1"]
    },
    beforeTextXL: {
      t21cq0: ["f1rs9grm", "f1kwmkpi"]
    },
    afterTextXL: {
      Frg6f3: ["f1kwmkpi", "f1rs9grm"]
    },
    tiny: {
      Be2twd7: "f1tccstq"
    },
    "extra-small": {
      Be2twd7: "fnmn6fi"
    },
    small: {
      Be2twd7: "f1ugzwwg"
    },
    medium: {},
    large: {
      Be2twd7: "f4ybsrx"
    },
    "extra-large": {
      Be2twd7: "fe5j1ua"
    }
  }, {
    d: [".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1tccstq{font-size:6px;}", ".fnmn6fi{font-size:10px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
  });
  var useBadgeStyles_unstable = (state) => {
    "use no memo";
    const rootClassName = useRootClassName();
    const rootStyles = useRootStyles2();
    const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
    state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
    const iconRootClassName = useIconRootClassName();
    const iconStyles = useIconStyles();
    if (state.icon) {
      let iconPositionClass;
      if (state.root.children) {
        if (state.size === "extra-large") {
          iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
        } else {
          iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
        }
      }
      state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderBadge_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.iconPosition === "before" && state.icon && /* @__PURE__ */ jsx2(state.icon, {}),
        state.root.children,
        state.iconPosition === "after" && state.icon && /* @__PURE__ */ jsx2(state.icon, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
  var Badge = /* @__PURE__ */ React79.forwardRef((props, ref) => {
    const state = useBadge_unstable(props, ref);
    useBadgeStyles_unstable(state);
    useCustomStyleHook("useBadgeStyles_unstable")(state);
    return renderBadge_unstable(state);
  });
  Badge.displayName = "Badge";

  // ../../node_modules/@fluentui/react-badge/lib/PresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React82 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React81 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React80 = __toESM(require_react());
  var presenceAwayFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAway10Filled,
    "extra-small": PresenceAway10Filled,
    small: PresenceAway12Filled,
    medium: PresenceAway16Filled,
    large: PresenceAway20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAway20Filled
  };
  var presenceAvailableRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAvailable10Regular,
    "extra-small": PresenceAvailable10Regular,
    small: PresenceAvailable12Regular,
    medium: PresenceAvailable16Regular,
    large: PresenceAvailable20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAvailable20Regular
  };
  var presenceAvailableFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceAvailable10Filled,
    "extra-small": PresenceAvailable10Filled,
    small: PresenceAvailable12Filled,
    medium: PresenceAvailable16Filled,
    large: PresenceAvailable20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceAvailable20Filled
  };
  var presenceBlockedRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceBlocked10Regular,
    "extra-small": PresenceBlocked10Regular,
    small: PresenceBlocked12Regular,
    medium: PresenceBlocked16Regular,
    large: PresenceBlocked20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceBlocked20Regular
  };
  var presenceBusyFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceBusy10Filled,
    "extra-small": PresenceBusy10Filled,
    small: PresenceBusy12Filled,
    medium: PresenceBusy16Filled,
    large: PresenceBusy20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceBusy20Filled
  };
  var presenceDndFilled = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceDnd10Filled,
    "extra-small": PresenceDnd10Filled,
    small: PresenceDnd12Filled,
    medium: PresenceDnd16Filled,
    large: PresenceDnd20Filled,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceDnd20Filled
  };
  var presenceDndRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceDnd10Regular,
    "extra-small": PresenceDnd10Regular,
    small: PresenceDnd12Regular,
    medium: PresenceDnd16Regular,
    large: PresenceDnd20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceDnd20Regular
  };
  var presenceOofRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceOof10Regular,
    "extra-small": PresenceOof10Regular,
    small: PresenceOof12Regular,
    medium: PresenceOof16Regular,
    large: PresenceOof20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceOof20Regular
  };
  var presenceOfflineRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceOffline10Regular,
    "extra-small": PresenceOffline10Regular,
    small: PresenceOffline12Regular,
    medium: PresenceOffline16Regular,
    large: PresenceOffline20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceOffline20Regular
  };
  var presenceUnknownRegular = {
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    tiny: PresenceUnknown10Regular,
    "extra-small": PresenceUnknown10Regular,
    small: PresenceUnknown12Regular,
    medium: PresenceUnknown16Regular,
    large: PresenceUnknown20Regular,
    // FIXME not all presence icon sizes are available
    // https://github.com/microsoft/fluentui/issues/20650
    "extra-large": PresenceUnknown20Regular
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
  var iconMap = (status, outOfOffice, size3) => {
    switch (status) {
      case "available":
        return outOfOffice ? presenceAvailableRegular[size3] : presenceAvailableFilled[size3];
      case "away":
        return outOfOffice ? presenceOofRegular[size3] : presenceAwayFilled[size3];
      case "blocked":
        return presenceBlockedRegular[size3];
      case "busy":
        return outOfOffice ? presenceUnknownRegular[size3] : presenceBusyFilled[size3];
      case "do-not-disturb":
        return outOfOffice ? presenceDndRegular[size3] : presenceDndFilled[size3];
      case "offline":
        return outOfOffice ? presenceOofRegular[size3] : presenceOfflineRegular[size3];
      case "out-of-office":
        return presenceOofRegular[size3];
      case "unknown":
        return presenceUnknownRegular[size3];
    }
  };
  var DEFAULT_STRINGS = {
    busy: "busy",
    "out-of-office": "out of office",
    away: "away",
    available: "available",
    offline: "offline",
    "do-not-disturb": "do not disturb",
    unknown: "unknown",
    blocked: "blocked"
  };
  var usePresenceBadge_unstable = (props, ref) => {
    const { size: size3 = "medium", status = "available", outOfOffice = false } = props;
    const statusText = DEFAULT_STRINGS[status];
    const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS["out-of-office"]}` : "";
    const IconElement = iconMap(status, outOfOffice, size3);
    const state = {
      ...useBadge_unstable({
        "aria-label": statusText + oofText,
        role: "img",
        ...props,
        size: size3,
        icon: slot_exports.optional(props.icon, {
          defaultProps: {
            children: IconElement ? /* @__PURE__ */ React81.createElement(IconElement, null) : null
          },
          renderByDefault: true,
          elementType: "span"
        })
      }, ref),
      status,
      outOfOffice
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var presenceBadgeClassNames = {
    root: "fui-PresenceBadge",
    icon: "fui-PresenceBadge__icon"
  };
  var getIsBusy = (status) => {
    if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
      return true;
    }
    return false;
  };
  var useRootClassName2 = /* @__PURE__ */ __resetStyles2("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
  var useIconClassName = /* @__PURE__ */ __resetStyles2("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
  var useStyles2 = /* @__PURE__ */ __styles2({
    statusBusy: {
      sj55zd: "fvi85wt"
    },
    statusAway: {
      sj55zd: "f14k8a89"
    },
    statusAvailable: {
      sj55zd: "fqa5hgp"
    },
    statusOffline: {
      sj55zd: "f11d4kpn"
    },
    statusOutOfOffice: {
      sj55zd: "fdce8r3"
    },
    statusUnknown: {
      sj55zd: "f11d4kpn"
    },
    outOfOffice: {
      sj55zd: "fr0bkrk"
    },
    outOfOfficeAvailable: {
      sj55zd: "fqa5hgp"
    },
    outOfOfficeBusy: {
      sj55zd: "fvi85wt"
    },
    outOfOfficeUnknown: {
      sj55zd: "f11d4kpn"
    },
    tiny: {
      Bubjx69: "f9ikmtg",
      a9b677: "f16dn6v3",
      B2eet1l: "f1w2irj7",
      B5pe6w7: "fab5kbq",
      p4uzdd: "f1ms1d91"
    },
    large: {
      Bubjx69: "f9ikmtg",
      a9b677: "f64fuq3",
      B5pe6w7: "f1vfi1yj",
      p4uzdd: "f15s34gz"
    },
    extraLarge: {
      Bubjx69: "f9ikmtg",
      a9b677: "f1w9dchk",
      B5pe6w7: "f14efy9b",
      p4uzdd: "fhipgdu"
    }
  }, {
    d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
  });
  var usePresenceBadgeStyles_unstable = (state) => {
    "use no memo";
    const rootClassName = useRootClassName2();
    const iconClassName = useIconClassName();
    const styles = useStyles2();
    const isBusy = getIsBusy(state.status);
    state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles.statusBusy, state.status === "away" && styles.statusAway, state.status === "available" && styles.statusAvailable, state.status === "offline" && styles.statusOffline, state.status === "out-of-office" && styles.statusOutOfOffice, state.status === "unknown" && styles.statusUnknown, state.outOfOffice && styles.outOfOffice, state.outOfOffice && state.status === "available" && styles.outOfOfficeAvailable, state.outOfOffice && isBusy && styles.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles.outOfOfficeUnknown, state.size === "tiny" && styles.tiny, state.size === "large" && styles.large, state.size === "extra-large" && styles.extraLarge, state.root.className);
    if (state.icon) {
      state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
  var PresenceBadge = /* @__PURE__ */ React82.forwardRef((props, ref) => {
    const state = usePresenceBadge_unstable(props, ref);
    usePresenceBadgeStyles_unstable(state);
    useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
    return renderBadge_unstable(state);
  });
  PresenceBadge.displayName = "PresenceBadge";

  // ../../node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React83 = __toESM(require_react());
  var avatarContext = React83.createContext(void 0);
  var avatarContextDefaultValue = {};
  var AvatarContextProvider = avatarContext.Provider;
  var useAvatarContext = () => {
    var _React_useContext;
    return (_React_useContext = React83.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
  var DEFAULT_STRINGS2 = {
    active: "active",
    inactive: "inactive"
  };
  var useAvatar_unstable = (props, ref) => {
    const { dir } = useFluent();
    const { shape: contextShape, size: contextSize } = useAvatarContext();
    const { name: name21, size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
    let { color: color2 = "neutral" } = props;
    if (color2 === "colorful") {
      var _ref;
      color2 = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name21) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
    }
    const baseId = useId4("avatar-");
    const root5 = slot_exports.always(getIntrinsicElementProps(
      "span",
      {
        role: "img",
        id: baseId,
        // aria-label and/or aria-labelledby are resolved below
        ...props,
        ref
      },
      /* excludedPropNames: */
      [
        "name"
      ]
    ), {
      elementType: "span"
    });
    const [imageHidden, setImageHidden] = React84.useState(void 0);
    let image3 = slot_exports.optional(props.image, {
      defaultProps: {
        alt: "",
        role: "presentation",
        "aria-hidden": true,
        hidden: imageHidden
      },
      elementType: "img"
    });
    if (!(image3 === null || image3 === void 0 ? void 0 : image3.src)) {
      image3 = void 0;
    }
    if (image3) {
      image3.onError = mergeCallbacks(image3.onError, () => setImageHidden(true));
      image3.onLoad = mergeCallbacks(image3.onLoad, () => setImageHidden(void 0));
    }
    let initials = slot_exports.optional(props.initials, {
      renderByDefault: true,
      defaultProps: {
        children: getInitials(name21, dir === "rtl", {
          firstInitialOnly: size3 <= 16
        }),
        id: baseId + "__initials"
      },
      elementType: "span"
    });
    if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
      initials = void 0;
    }
    let icon = void 0;
    if (!initials && (!image3 || imageHidden)) {
      icon = slot_exports.optional(props.icon, {
        renderByDefault: true,
        defaultProps: {
          children: /* @__PURE__ */ React84.createElement(PersonRegular, null),
          "aria-hidden": true
        },
        elementType: "span"
      });
    }
    const badge = slot_exports.optional(props.badge, {
      defaultProps: {
        size: getBadgeSize(size3),
        id: baseId + "__badge"
      },
      elementType: PresenceBadge
    });
    let activeAriaLabelElement;
    if (!root5["aria-label"] && !root5["aria-labelledby"]) {
      if (name21) {
        root5["aria-label"] = name21;
        if (badge) {
          root5["aria-labelledby"] = root5.id + " " + badge.id;
        }
      } else if (initials) {
        root5["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
      }
      if (active === "active" || active === "inactive") {
        const activeText = DEFAULT_STRINGS2[active];
        if (root5["aria-labelledby"]) {
          const activeId = baseId + "__active";
          root5["aria-labelledby"] += " " + activeId;
          activeAriaLabelElement = /* @__PURE__ */ React84.createElement("span", {
            hidden: true,
            id: activeId
          }, activeText);
        } else if (root5["aria-label"]) {
          root5["aria-label"] += " " + activeText;
        }
      }
    }
    return {
      size: size3,
      shape,
      active,
      activeAppearance,
      activeAriaLabelElement,
      color: color2,
      components: {
        root: "span",
        initials: "span",
        icon: "span",
        image: "img",
        badge: PresenceBadge
      },
      root: root5,
      initials,
      icon,
      image: image3,
      badge
    };
  };
  var getBadgeSize = (size3) => {
    if (size3 >= 96) {
      return "extra-large";
    } else if (size3 >= 64) {
      return "large";
    } else if (size3 >= 56) {
      return "medium";
    } else if (size3 >= 40) {
      return "small";
    } else if (size3 >= 28) {
      return "extra-small";
    } else {
      return "tiny";
    }
  };
  var avatarColors = [
    "dark-red",
    "cranberry",
    "red",
    "pumpkin",
    "peach",
    "marigold",
    "gold",
    "brass",
    "brown",
    "forest",
    "seafoam",
    "dark-green",
    "light-teal",
    "teal",
    "steel",
    "blue",
    "royal-blue",
    "cornflower",
    "navy",
    "lavender",
    "purple",
    "grape",
    "lilac",
    "pink",
    "magenta",
    "plum",
    "beige",
    "mink",
    "platinum",
    "anchor"
  ];
  var getHashCode = (str) => {
    let hashCode = 0;
    for (let len = str.length - 1; len >= 0; len--) {
      const ch = str.charCodeAt(len);
      const shift4 = len % 8;
      hashCode ^= (ch << shift4) + (ch >> 8 - shift4);
    }
    return hashCode;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var avatarClassNames = {
    root: "fui-Avatar",
    image: "fui-Avatar__image",
    initials: "fui-Avatar__initials",
    icon: "fui-Avatar__icon",
    badge: "fui-Avatar__badge"
  };
  var useRootClassName3 = /* @__PURE__ */ __resetStyles2("r81b29z", "r1aatmv", {
    r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
  });
  var useImageClassName = /* @__PURE__ */ __resetStyles2("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
  var useIconInitialsClassName = /* @__PURE__ */ __resetStyles2("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}"]);
  var useStyles3 = /* @__PURE__ */ __styles2({
    textCaption2Strong: {
      Be2twd7: "f13mqy1h"
    },
    textCaption1Strong: {
      Be2twd7: "fy9rknc"
    },
    textSubtitle2: {
      Be2twd7: "fod5ikn"
    },
    textSubtitle1: {
      Be2twd7: "f1pp30po"
    },
    textTitle3: {
      Be2twd7: "f1x0m3f5"
    },
    squareSmall: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fq9zq91"
    },
    squareMedium: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5"
    },
    squareLarge: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1o0qvyv"
    },
    squareXLarge: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1kijzfu"
    },
    activeOrInactive: {
      Bz10aip: "ftfx35i",
      Bmy1vo4: "fv0atk9",
      B3o57yi: "f1iry5bo",
      Bkqvd7p: "f15n41j8",
      Hwfdqs: "f1onx1g3"
    },
    ring: {
      Ftih45: "f1wl9k8s"
    },
    ringBadgeCutout: {
      f4a502: "fp2gujx"
    },
    ringThick: {
      of393c: "fq1w1vq"
    },
    ringThicker: {
      of393c: "fzg6ace"
    },
    ringThickest: {
      of393c: "f1nu8p71"
    },
    shadow: {
      Bsft5z2: "f13zj6fq"
    },
    shadow4: {
      Be6vj1x: "fcjn15l"
    },
    shadow8: {
      Be6vj1x: "f1tm8t9f"
    },
    shadow16: {
      Be6vj1x: "f1a1aohj"
    },
    shadow28: {
      Be6vj1x: "fond6v5"
    },
    inactive: {
      abs64n: "fp25eh",
      Bz10aip: "f1clczzi",
      Bkqvd7p: "f1l3s34x",
      Bfgortx: 0,
      Bnvr3x9: 0,
      b2tv09: 0,
      Bucmhp4: 0,
      iayac2: "flkahu5",
      b6ubon: "fw457kn",
      Bqinb2h: "f1wmllxl"
    },
    badge: {
      qhf8xq: "f1euv43f",
      B5kzvoi: "f1yab3r1",
      j35jbq: ["f1e31b4d", "f1vgc2s3"]
    },
    badgeCutout: {
      btxmck: "f1eugkqs"
    },
    badgeAlign: {
      Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
    },
    tiny: {
      Bdjeniz: "f1uwoubl",
      niu6jh: "fid048z"
    },
    "extra-small": {
      Bdjeniz: "f13ar0e0",
      niu6jh: "fid048z"
    },
    small: {
      Bdjeniz: "fwwuruf",
      niu6jh: "fid048z"
    },
    medium: {
      Bdjeniz: "f1af27q5",
      niu6jh: "fid048z"
    },
    large: {
      Bdjeniz: "f18yy57a",
      niu6jh: "f924bxt"
    },
    "extra-large": {
      Bdjeniz: "f2jg042",
      niu6jh: "f924bxt"
    },
    icon12: {
      Be2twd7: "f1ugzwwg"
    },
    icon16: {
      Be2twd7: "f4ybsrx"
    },
    icon20: {
      Be2twd7: "fe5j1ua"
    },
    icon24: {
      Be2twd7: "f1rt2boy"
    },
    icon28: {
      Be2twd7: "f24l1pt"
    },
    icon32: {
      Be2twd7: "ffl51b"
    },
    icon48: {
      Be2twd7: "f18m8u13"
    }
  }, {
    d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], [".f1o0qvyv{border-radius:var(--borderRadiusLarge);}", {
      p: -1
    }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
      p: -1
    }], ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", [".flkahu5::before,.flkahu5::after{margin:0;}", {
      p: -1
    }], ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
    m: [["@media screen and (prefers-reduced-motion: reduce){.f1onx1g3{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]]
  });
  var useSizeStyles = /* @__PURE__ */ __styles2({
    "16": {
      a9b677: "fjw5fx7",
      Bqenvij: "fd461yt"
    },
    "20": {
      a9b677: "f64fuq3",
      Bqenvij: "fjamq6b"
    },
    "24": {
      a9b677: "fq4mcun",
      Bqenvij: "frvgh55"
    },
    "28": {
      a9b677: "f1w9dchk",
      Bqenvij: "fxldao9"
    },
    "32": {
      a9b677: "f1szoe96",
      Bqenvij: "f1d2rq10"
    },
    "36": {
      a9b677: "fpdz1er",
      Bqenvij: "f8ljn23"
    },
    "40": {
      a9b677: "feqmc2u",
      Bqenvij: "fbhnoac"
    },
    "48": {
      a9b677: "f124akge",
      Bqenvij: "ff2sm71"
    },
    "56": {
      a9b677: "f1u66zr1",
      Bqenvij: "fzki0ko"
    },
    "64": {
      a9b677: "fa9ln6p",
      Bqenvij: "f16k9i2m"
    },
    "72": {
      a9b677: "fhcae8x",
      Bqenvij: "f1shusfg"
    },
    "96": {
      a9b677: "f1kyr2gn",
      Bqenvij: "fypu0ge"
    },
    "120": {
      a9b677: "fwfqyga",
      Bqenvij: "fjr5b71"
    },
    "128": {
      a9b677: "f1iksgmy",
      Bqenvij: "fele2au"
    }
  }, {
    d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
  });
  var useColorStyles = /* @__PURE__ */ __styles2({
    neutral: {
      sj55zd: "f11d4kpn",
      De3pzq: "f18f03hv"
    },
    brand: {
      sj55zd: "fonrgv7",
      De3pzq: "f1blnnmj"
    },
    "dark-red": {
      sj55zd: "fqjd1y1",
      De3pzq: "f1vq2oo4"
    },
    cranberry: {
      sj55zd: "fg9gses",
      De3pzq: "f1lwxszt"
    },
    red: {
      sj55zd: "f23f7i0",
      De3pzq: "f1q9qhfq"
    },
    pumpkin: {
      sj55zd: "fjnan08",
      De3pzq: "fz91bi3"
    },
    peach: {
      sj55zd: "fknu15p",
      De3pzq: "f1b9nr51"
    },
    marigold: {
      sj55zd: "f9603vw",
      De3pzq: "f3z4w6d"
    },
    gold: {
      sj55zd: "fmq0uwp",
      De3pzq: "fg50kya"
    },
    brass: {
      sj55zd: "f28g5vo",
      De3pzq: "f4w2gd0"
    },
    brown: {
      sj55zd: "ftl572b",
      De3pzq: "f14wu1f4"
    },
    forest: {
      sj55zd: "f1gymlvd",
      De3pzq: "f19ut4y6"
    },
    seafoam: {
      sj55zd: "fnnb6wn",
      De3pzq: "f1n057jc"
    },
    "dark-green": {
      sj55zd: "ff58qw8",
      De3pzq: "f11t05wk"
    },
    "light-teal": {
      sj55zd: "f1up9qbj",
      De3pzq: "f42feg1"
    },
    teal: {
      sj55zd: "f135dsb4",
      De3pzq: "f6hvv1p"
    },
    steel: {
      sj55zd: "f151dlcp",
      De3pzq: "f1lnp8zf"
    },
    blue: {
      sj55zd: "f1rjv50u",
      De3pzq: "f1ggcpy6"
    },
    "royal-blue": {
      sj55zd: "f1emykk5",
      De3pzq: "f12rj61f"
    },
    cornflower: {
      sj55zd: "fqsigj7",
      De3pzq: "f8k7hur"
    },
    navy: {
      sj55zd: "f1nj97xi",
      De3pzq: "f19gw0ux"
    },
    lavender: {
      sj55zd: "fwctg0i",
      De3pzq: "ff379vm"
    },
    purple: {
      sj55zd: "fjrsgpu",
      De3pzq: "f1mzf1e1"
    },
    grape: {
      sj55zd: "f1fiiydq",
      De3pzq: "f1o4k8oy"
    },
    lilac: {
      sj55zd: "f1res9jt",
      De3pzq: "f1x6mz1o"
    },
    pink: {
      sj55zd: "fv3fbbi",
      De3pzq: "fydlv6t"
    },
    magenta: {
      sj55zd: "f1f1fwnz",
      De3pzq: "f4xb6j5"
    },
    plum: {
      sj55zd: "f8ptl6j",
      De3pzq: "fqo8e26"
    },
    beige: {
      sj55zd: "f1ntv3ld",
      De3pzq: "f101elhj"
    },
    mink: {
      sj55zd: "f1fscmp",
      De3pzq: "f13g8o5c"
    },
    platinum: {
      sj55zd: "f1dr00v2",
      De3pzq: "fkh7blw"
    },
    anchor: {
      sj55zd: "f1f3ti53",
      De3pzq: "fu4yj0j"
    }
  }, {
    d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
  });
  var useRingColorStyles = /* @__PURE__ */ __styles2({
    neutral: {
      Bic5iru: "f1uuiafn"
    },
    brand: {
      Bic5iru: "f1uuiafn"
    },
    "dark-red": {
      Bic5iru: "f1t2x9on"
    },
    cranberry: {
      Bic5iru: "f1pvshc9"
    },
    red: {
      Bic5iru: "f1ectbk9"
    },
    pumpkin: {
      Bic5iru: "fvzpl0b"
    },
    peach: {
      Bic5iru: "fwj2kd7"
    },
    marigold: {
      Bic5iru: "fr120vy"
    },
    gold: {
      Bic5iru: "f8xmmar"
    },
    brass: {
      Bic5iru: "f1hbety2"
    },
    brown: {
      Bic5iru: "f1vg3s4g"
    },
    forest: {
      Bic5iru: "f1m3olm5"
    },
    seafoam: {
      Bic5iru: "f17xiqtr"
    },
    "dark-green": {
      Bic5iru: "fx32vyh"
    },
    "light-teal": {
      Bic5iru: "f1mkihwv"
    },
    teal: {
      Bic5iru: "fecnooh"
    },
    steel: {
      Bic5iru: "f15hfgzm"
    },
    blue: {
      Bic5iru: "fqproka"
    },
    "royal-blue": {
      Bic5iru: "f17v2w59"
    },
    cornflower: {
      Bic5iru: "fp0q1mo"
    },
    navy: {
      Bic5iru: "f1nlym55"
    },
    lavender: {
      Bic5iru: "f62vk8h"
    },
    purple: {
      Bic5iru: "f15zl69q"
    },
    grape: {
      Bic5iru: "f53w4j7"
    },
    lilac: {
      Bic5iru: "fu2771t"
    },
    pink: {
      Bic5iru: "fzflscs"
    },
    magenta: {
      Bic5iru: "fb6rmqc"
    },
    plum: {
      Bic5iru: "f1a4gm5b"
    },
    beige: {
      Bic5iru: "f1qpf9z1"
    },
    mink: {
      Bic5iru: "f1l7or83"
    },
    platinum: {
      Bic5iru: "fzrj0iu"
    },
    anchor: {
      Bic5iru: "f8oz6wf"
    }
  }, {
    d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
  });
  var useAvatarStyles_unstable = (state) => {
    "use no memo";
    const {
      size: size3,
      shape,
      active,
      activeAppearance,
      color: color2
    } = state;
    const rootClassName = useRootClassName3();
    const imageClassName = useImageClassName();
    const iconInitialsClassName = useIconInitialsClassName();
    const styles = useStyles3();
    const sizeStyles = useSizeStyles();
    const colorStyles = useColorStyles();
    const ringColorStyles = useRingColorStyles();
    const rootClasses = [rootClassName, size3 !== 32 && sizeStyles[size3]];
    if (state.badge) {
      rootClasses.push(styles.badgeAlign, styles[state.badge.size || "medium"]);
    }
    if (size3 <= 24) {
      rootClasses.push(styles.textCaption2Strong);
    } else if (size3 <= 28) {
      rootClasses.push(styles.textCaption1Strong);
    } else if (size3 <= 40) {
    } else if (size3 <= 56) {
      rootClasses.push(styles.textSubtitle2);
    } else if (size3 <= 96) {
      rootClasses.push(styles.textSubtitle1);
    } else {
      rootClasses.push(styles.textTitle3);
    }
    if (shape === "square") {
      if (size3 <= 24) {
        rootClasses.push(styles.squareSmall);
      } else if (size3 <= 48) {
        rootClasses.push(styles.squareMedium);
      } else if (size3 <= 72) {
        rootClasses.push(styles.squareLarge);
      } else {
        rootClasses.push(styles.squareXLarge);
      }
    }
    if (active === "active" || active === "inactive") {
      rootClasses.push(styles.activeOrInactive);
      if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
        rootClasses.push(styles.ring, ringColorStyles[color2]);
        if (state.badge) {
          rootClasses.push(styles.ringBadgeCutout);
        }
        if (size3 <= 48) {
          rootClasses.push(styles.ringThick);
        } else if (size3 <= 64) {
          rootClasses.push(styles.ringThicker);
        } else {
          rootClasses.push(styles.ringThickest);
        }
      }
      if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
        rootClasses.push(styles.shadow);
        if (size3 <= 28) {
          rootClasses.push(styles.shadow4);
        } else if (size3 <= 48) {
          rootClasses.push(styles.shadow8);
        } else if (size3 <= 64) {
          rootClasses.push(styles.shadow16);
        } else {
          rootClasses.push(styles.shadow28);
        }
      }
      if (active === "inactive") {
        rootClasses.push(styles.inactive);
      }
    }
    state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
    if (state.badge) {
      state.badge.className = mergeClasses(avatarClassNames.badge, styles.badge, state.badge.className);
    }
    if (state.image) {
      state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.image.className);
    }
    if (state.initials) {
      state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.initials.className);
    }
    if (state.icon) {
      let iconSizeClass;
      if (size3 <= 16) {
        iconSizeClass = styles.icon12;
      } else if (size3 <= 24) {
        iconSizeClass = styles.icon16;
      } else if (size3 <= 40) {
        iconSizeClass = styles.icon20;
      } else if (size3 <= 48) {
        iconSizeClass = styles.icon24;
      } else if (size3 <= 56) {
        iconSizeClass = styles.icon28;
      } else if (size3 <= 72) {
        iconSizeClass = styles.icon32;
      } else {
        iconSizeClass = styles.icon48;
      }
      state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color2], state.badge && styles.badgeCutout, state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
  var Avatar = /* @__PURE__ */ React85.forwardRef((props, ref) => {
    const state = useAvatar_unstable(props, ref);
    useAvatarStyles_unstable(state);
    useCustomStyleHook("useAvatarStyles_unstable")(state);
    return renderAvatar_unstable(state);
  });
  Avatar.displayName = "Avatar";

  // ../../node_modules/@fluentui/react-popover/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/constants.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
  var DATA_POSITIONING_ESCAPED = "data-popper-escaped";
  var DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
  var DATA_POSITIONING_PLACEMENT = "data-popper-placement";
  var POSITIONING_END_EVENT = "fui-positioningend";

  // ../../node_modules/@fluentui/react-positioning/lib/PositioningConfigurationContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React86 = __toESM(require_react());
  var DEFAULT_CONFIGURATION = ({ options }) => {
    return options;
  };
  var PositioningConfigurationContext = React86.createContext(void 0);
  var PositioningConfigurationProvider = PositioningConfigurationContext.Provider;
  var usePositioningConfiguration = () => {
    var _React_useContext;
    return (_React_useContext = React86.useContext(PositioningConfigurationContext)) !== null && _React_useContext !== void 0 ? _React_useContext : DEFAULT_CONFIGURATION;
  };

  // ../../node_modules/@fluentui/react-positioning/lib/usePositioning.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React89 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-positioning/lib/createPositionManager.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var sides = ["top", "right", "bottom", "left"];
  var min = Math.min;
  var max = Math.max;
  var round = Math.round;
  var createCoords = (v) => ({
    x: v,
    y: v
  });
  var oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  var oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp2(start2, value, end) {
    return max(start2, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length2 = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length2] > rects.floating[length2]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list4 = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list4 = list4.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list4 = list4.concat(list4.map(getOppositeAlignmentPlacement));
      }
    }
    return list4;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding3) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding3
    };
  }
  function getPaddingObject(padding3) {
    return typeof padding3 !== "number" ? expandPaddingObject(padding3) : {
      top: padding3,
      right: padding3,
      bottom: padding3,
      left: padding3
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }

  // ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  var computePosition = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware: middleware2 = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware2.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name: name21,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data: data2,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name21]: {
          ...middlewareData[name21],
          ...data2
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding: padding3 = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding3);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element4 = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element4))) != null ? _await$platform$isEle : true) ? element4 : element4.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var arrow = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element: element4,
        padding: padding3 = 0
      } = evaluate(options, state) || {};
      if (element4 == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding3);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length2 = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element4);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element4));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length2];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length2] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
      const offset4 = clamp2(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset4,
          centerOffset: center - offset4 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  var flip = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow2 = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow2[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow2[sides2[0]], overflow2[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            var _overflowsData$;
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
            if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow3) => overflow3 > 0).reduce((acc, overflow3) => acc + overflow3, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow2, rect) {
    return {
      top: overflow2.top - rect.height,
      right: overflow2.right - rect.width,
      bottom: overflow2.bottom - rect.height,
      left: overflow2.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow2) {
    return sides.some((side) => overflow2[side] >= 0);
  }
  var hide = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "hide",
      options,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow2 = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow2, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow2 = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow2, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  var offset = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  var shift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const overflow2 = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow2[minSide];
          const max2 = mainAxisCoord - overflow2[maxSide];
          mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow2[minSide];
          const max2 = crossAxisCoord - overflow2[maxSide];
          crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  var limitShift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state) {
        const {
          x,
          y,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset4 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset4, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  var size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow2 = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow2.top - overflow2.bottom;
        const maximumClippingWidth = width - overflow2.left - overflow2.right;
        const overflowAvailableHeight = min(height - overflow2[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow2[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow2.left, 0);
          const xMax = max(overflow2.right, 0);
          const yMin = max(overflow2.top, 0);
          const yMax = max(overflow2.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow2.left, overflow2.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow2.top, overflow2.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  // ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node3) {
    if (isNode(node3)) {
      return (node3.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node3) {
    var _node$ownerDocument;
    return (node3 == null || (_node$ownerDocument = node3.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node3) {
    var _ref;
    return (_ref = (isNode(node3) ? node3.ownerDocument : node3.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement3(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element4) {
    const {
      overflow: overflow2,
      overflowX,
      overflowY,
      display
    } = getComputedStyle(element4);
    return /auto|scroll|overlay|hidden|clip/.test(overflow2 + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element4) {
    return ["table", "td", "th"].includes(getNodeName(element4));
  }
  function isTopLayer(element4) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element4.matches(selector);
      } catch (e) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
    return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element4) {
    let currentNode = getParentNode(element4);
    while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node3) {
    return ["html", "body", "#document"].includes(getNodeName(node3));
  }
  function getComputedStyle(element4) {
    return getWindow(element4).getComputedStyle(element4);
  }
  function getNodeScroll(element4) {
    if (isElement(element4)) {
      return {
        scrollLeft: element4.scrollLeft,
        scrollTop: element4.scrollTop
      };
    }
    return {
      scrollLeft: element4.scrollX,
      scrollTop: element4.scrollY
    };
  }
  function getParentNode(node3) {
    if (getNodeName(node3) === "html") {
      return node3;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node3.assignedSlot || // DOM Element detected.
      node3.parentNode || // ShadowRoot detected.
      isShadowRoot(node3) && node3.host || // Fallback.
      getDocumentElement(node3)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node3) {
    const parentNode = getParentNode(node3);
    if (isLastTraversableNode(parentNode)) {
      return node3.ownerDocument ? node3.ownerDocument.body : node3.body;
    }
    if (isHTMLElement3(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node3, list4, traverseIframes) {
    var _node$ownerDocument2;
    if (list4 === void 0) {
      list4 = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node3);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node3.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list4.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list4.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  // ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element4) {
    const css = getComputedStyle(element4);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement3(element4);
    const offsetWidth = hasOffset ? element4.offsetWidth : width;
    const offsetHeight = hasOffset ? element4.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element4) {
    return !isElement(element4) ? element4.contextElement : element4;
  }
  function getScale(element4) {
    const domElement = unwrapElement(element4);
    if (!isHTMLElement3(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element4) {
    const win = getWindow(element4);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element4, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element4)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element4, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element4.getBoundingClientRect();
    const domElement = unwrapElement(element4);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element4);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y
    });
  }
  function getWindowScrollBarX(element4, rect) {
    const leftScroll = getNodeScroll(element4).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element4)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement3(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement3(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element4) {
    return Array.from(element4.getClientRects());
  }
  function getDocumentRect(element4) {
    const html5 = getDocumentElement(element4);
    const scroll = getNodeScroll(element4);
    const body = element4.ownerDocument.body;
    const width = max(html5.scrollWidth, html5.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html5.scrollHeight, html5.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element4);
    const y = -scroll.scrollTop;
    if (getComputedStyle(body).direction === "rtl") {
      x += max(html5.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getViewportRect(element4, strategy) {
    const win = getWindow(element4);
    const html5 = getDocumentElement(element4);
    const visualViewport = win.visualViewport;
    let width = html5.clientWidth;
    let height = html5.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getInnerBoundingClientRect(element4, strategy) {
    const clientRect = getBoundingClientRect(element4, true, strategy === "fixed");
    const top = clientRect.top + element4.clientTop;
    const left = clientRect.left + element4.clientLeft;
    const scale = isHTMLElement3(element4) ? getScale(element4) : createCoords(1);
    const width = element4.clientWidth * scale.x;
    const height = element4.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element4, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element4, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element4));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element4);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element4, stopNode) {
    const parentNode = getParentNode(element4);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element4, cache2) {
    const cachedResult = cache2.get(element4);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element4, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle(element4).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element4) : element4;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element4, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache2.set(element4, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element: element4,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element4) ? [] : getClippingElementAncestors(element4, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element4, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element4, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element4) {
    const {
      width,
      height
    } = getCssDimensions(element4);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element4, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement3(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element4, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element4) {
    return getComputedStyle(element4).position === "static";
  }
  function getTrueOffsetParent(element4, polyfill) {
    if (!isHTMLElement3(element4) || getComputedStyle(element4).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element4);
    }
    let rawOffsetParent = element4.offsetParent;
    if (getDocumentElement(element4) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element4, polyfill) {
    const win = getWindow(element4);
    if (isTopLayer(element4)) {
      return win;
    }
    if (!isHTMLElement3(element4)) {
      let svgOffsetParent = getParentNode(element4);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element4, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element4) || win;
  }
  var getElementRects = async function(data2) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data2.floating);
    return {
      reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element4) {
    return getComputedStyle(element4).direction === "rtl";
  }
  var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  var detectOverflow2 = detectOverflow;
  var offset2 = offset;
  var shift2 = shift;
  var flip2 = flip;
  var size2 = size;
  var hide2 = hide;
  var arrow2 = arrow;
  var limitShift2 = limitShift;
  var computePosition2 = (reference, floating, options) => {
    const cache2 = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache2
    };
    return computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  // ../../node_modules/@fluentui/react-positioning/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/utils/parseFloatingUIPlacement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function parseFloatingUIPlacement(placement) {
    const tokens2 = placement.split("-");
    return {
      side: tokens2[0],
      alignment: tokens2[1]
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/utils/getScrollParent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var getParentNode2 = (node3) => {
    if (node3.nodeName === "HTML") {
      return node3;
    }
    return node3.parentNode || node3.host;
  };
  var getStyleComputedProperty = (node3) => {
    var _node_ownerDocument;
    if (node3.nodeType !== 1) {
      return {};
    }
    const targetWindow = (_node_ownerDocument = node3.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
    if (targetWindow) {
      return targetWindow.getComputedStyle(node3, null);
    }
    return {};
  };
  var getScrollParent = (node3) => {
    const parentNode = node3 && getParentNode2(node3);
    if (!parentNode) return document.body;
    switch (parentNode.nodeName) {
      case "HTML":
      case "BODY":
        return parentNode.ownerDocument.body;
      case "#document":
        return parentNode.body;
    }
    const { overflow: overflow2, overflowX, overflowY } = getStyleComputedProperty(parentNode);
    if (/(auto|scroll|overlay)/.test(overflow2 + overflowY + overflowX)) {
      return parentNode;
    }
    return getScrollParent(parentNode);
  };
  var hasScrollParent = (node3) => {
    var _scrollParentElement_ownerDocument;
    const scrollParentElement = getScrollParent(node3);
    return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
  };

  // ../../node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
  function getBoundary(element4, boundary) {
    if (boundary === "window") {
      return element4 === null || element4 === void 0 ? void 0 : element4.ownerDocument.documentElement;
    }
    if (boundary === "clippingParents") {
      return "clippingAncestors";
    }
    if (boundary === "scrollParent") {
      let boundariesNode = getScrollParent(element4);
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = element4 === null || element4 === void 0 ? void 0 : element4.ownerDocument.documentElement;
      }
      return boundariesNode;
    }
    return boundary;
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPadding.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function toFloatingUIPadding(padding3, isRtl) {
    if (typeof padding3 === "number") {
      return padding3;
    }
    const { start: start2, end, ...verticalPadding } = padding3;
    const paddingObject = verticalPadding;
    const left = isRtl ? "end" : "start";
    const right = isRtl ? "start" : "end";
    if (padding3[left]) {
      paddingObject.left = padding3[left];
    }
    if (padding3[right]) {
      paddingObject.right = padding3[right];
    }
    return paddingObject;
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPlacement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var getPositionMap = (rtl) => ({
    above: "top",
    below: "bottom",
    before: rtl ? "right" : "left",
    after: rtl ? "left" : "right"
  });
  var getAlignmentMap = () => ({
    start: "start",
    end: "end",
    top: "start",
    bottom: "end",
    center: void 0
  });
  var shouldAlignToCenter = (p, a) => {
    const positionedVertically = p === "above" || p === "below";
    const alignedVertically = a === "top" || a === "bottom";
    return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
  };
  var toFloatingUIPlacement = (align, position4, rtl) => {
    const alignment = shouldAlignToCenter(position4, align) ? "center" : align;
    const computedPosition = position4 && getPositionMap(rtl)[position4];
    const computedAlignment = alignment && getAlignmentMap()[alignment];
    if (computedPosition && computedAlignment) {
      return `${computedPosition}-${computedAlignment}`;
    }
    return computedPosition;
  };

  // ../../node_modules/@fluentui/react-positioning/lib/utils/fromFloatingUIPlacement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var getPositionMap2 = () => ({
    top: "above",
    bottom: "below",
    right: "after",
    left: "before"
  });
  var getAlignmentMap2 = (position4) => {
    if (position4 === "above" || position4 === "below") {
      return {
        start: "start",
        end: "end"
      };
    }
    return {
      start: "top",
      end: "bottom"
    };
  };
  var fromFloatingUIPlacement = (placement) => {
    const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
    const position4 = getPositionMap2()[side];
    const alignment = floatingUIAlignment && getAlignmentMap2(position4)[floatingUIAlignment];
    return {
      position: position4,
      alignment
    };
  };

  // ../../node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var shorthandLookup = {
    above: {
      position: "above",
      align: "center"
    },
    "above-start": {
      position: "above",
      align: "start"
    },
    "above-end": {
      position: "above",
      align: "end"
    },
    below: {
      position: "below",
      align: "center"
    },
    "below-start": {
      position: "below",
      align: "start"
    },
    "below-end": {
      position: "below",
      align: "end"
    },
    before: {
      position: "before",
      align: "center"
    },
    "before-top": {
      position: "before",
      align: "top"
    },
    "before-bottom": {
      position: "before",
      align: "bottom"
    },
    after: {
      position: "after",
      align: "center"
    },
    "after-top": {
      position: "after",
      align: "top"
    },
    "after-bottom": {
      position: "after",
      align: "bottom"
    }
  };
  function resolvePositioningShorthand(shorthand) {
    if (shorthand === void 0 || shorthand === null) {
      return {};
    }
    if (typeof shorthand === "string") {
      return shorthandLookup[shorthand];
    }
    return shorthand;
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/useCallbackRef.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React87 = __toESM(require_react());
  function useCallbackRef(initialValue, callback, skipInitialResolve) {
    const isFirst = React87.useRef(true);
    const [ref] = React87.useState(() => ({
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          const last = ref.value;
          if (last !== value) {
            ref.value = value;
            if (skipInitialResolve && isFirst.current) {
              return;
            }
            ref.callback(value, last);
          }
        }
      }
    }));
    useIsomorphicLayoutEffect2(() => {
      isFirst.current = false;
    }, []);
    ref.callback = callback;
    return ref.facade;
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/debounce.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function debounce(fn) {
    let pending;
    return () => {
      if (!pending) {
        pending = new Promise((resolve) => {
          Promise.resolve().then(() => {
            pending = void 0;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/writeArrowUpdates.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function writeArrowUpdates(options) {
    const { arrow: arrow3, middlewareData } = options;
    if (!middlewareData.arrow || !arrow3) {
      return;
    }
    const { x: arrowX, y: arrowY } = middlewareData.arrow;
    Object.assign(arrow3.style, {
      left: arrowX !== null && arrowX !== void 0 ? `${arrowX}px` : "",
      top: arrowY !== null && arrowY !== void 0 ? `${arrowY}px` : ""
    });
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/writeContainerupdates.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function writeContainerUpdates(options) {
    var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
    const { container: container2, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
    if (!container2) {
      return;
    }
    container2.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
    container2.removeAttribute(DATA_POSITIONING_INTERSECTING);
    if (middlewareData.intersectionObserver.intersecting) {
      container2.setAttribute(DATA_POSITIONING_INTERSECTING, "");
    }
    container2.removeAttribute(DATA_POSITIONING_ESCAPED);
    if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) {
      container2.setAttribute(DATA_POSITIONING_ESCAPED, "");
    }
    container2.removeAttribute(DATA_POSITIONING_HIDDEN);
    if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) {
      container2.setAttribute(DATA_POSITIONING_HIDDEN, "");
    }
    const devicePixelRatio = ((_container_ownerDocument_defaultView = container2.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
    const x = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
    const y = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
    Object.assign(container2.style, {
      position: strategy
    });
    if (useTransform) {
      Object.assign(container2.style, {
        transform: lowPPI ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`
      });
      return;
    }
    Object.assign(container2.style, {
      left: `${x}px`,
      top: `${y}px`
    });
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/normalizeAutoSize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var normalizeAutoSize = (autoSize) => {
    switch (autoSize) {
      case "always":
      case true:
        return {
          applyMaxWidth: true,
          applyMaxHeight: true
        };
      case "width-always":
      case "width":
        return {
          applyMaxWidth: true,
          applyMaxHeight: false
        };
      case "height-always":
      case "height":
        return {
          applyMaxWidth: false,
          applyMaxHeight: true
        };
      default:
        return false;
    }
  };

  // ../../node_modules/@fluentui/react-positioning/lib/utils/listScrollParents.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function listScrollParents(node3) {
    const scrollParents = [];
    let cur = node3;
    while (cur) {
      const scrollParent = getScrollParent(cur);
      if (node3.ownerDocument.body === scrollParent) {
        scrollParents.push(scrollParent);
        break;
      }
      if (scrollParent.nodeName === "BODY" && scrollParent !== node3.ownerDocument.body) {
        if (false) {
          console.error("@fluentui/react-positioning: You are comparing two different documents! This is an unexpected error, please report this as a bug to the Fluent UI team ");
        }
        break;
      }
      scrollParents.push(scrollParent);
      cur = scrollParent;
    }
    return scrollParents;
  }

  // ../../node_modules/@fluentui/react-positioning/lib/utils/createResizeObserver.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function createResizeObserver(targetWindow, callback) {
    if (false) {
      targetWindow.ResizeObserver = class ResizeObserver {
        observe() {
        }
        unobserve() {
        }
        disconnect() {
        }
      };
    }
    return new targetWindow.ResizeObserver(callback);
  }

  // ../../node_modules/@fluentui/react-positioning/lib/createPositionManager.js
  function createPositionManager(options) {
    let isDestroyed = false;
    const { container: container2, target, arrow: arrow3, strategy, middleware: middleware2, placement, useTransform = true, disableUpdateOnResize = false } = options;
    const targetWindow = container2.ownerDocument.defaultView;
    if (!target || !container2 || !targetWindow) {
      return {
        updatePosition: () => void 0,
        dispose: () => void 0
      };
    }
    const resizeObserver = disableUpdateOnResize ? null : createResizeObserver(targetWindow, (entries) => {
      const shouldUpdateOnResize = entries.every((entry) => {
        return entry.contentRect.width > 0 && entry.contentRect.height > 0;
      });
      if (shouldUpdateOnResize) {
        updatePosition();
      }
    });
    let isFirstUpdate = true;
    const scrollParents = /* @__PURE__ */ new Set();
    Object.assign(container2.style, {
      position: "fixed",
      left: 0,
      top: 0,
      margin: 0
    });
    const forceUpdate = () => {
      if (isDestroyed) {
        return;
      }
      if (isFirstUpdate) {
        listScrollParents(container2).forEach((scrollParent) => scrollParents.add(scrollParent));
        if (isHTMLElement(target)) {
          listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
        }
        scrollParents.forEach((scrollParent) => {
          scrollParent.addEventListener("scroll", updatePosition, {
            passive: true
          });
        });
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(container2);
        if (isHTMLElement(target)) {
          resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(target);
        }
        isFirstUpdate = false;
      }
      Object.assign(container2.style, {
        position: strategy
      });
      computePosition2(target, container2, {
        placement,
        middleware: middleware2,
        strategy
      }).then(({ x, y, middlewareData, placement: computedPlacement }) => {
        if (isDestroyed) {
          return;
        }
        writeArrowUpdates({
          arrow: arrow3,
          middlewareData
        });
        writeContainerUpdates({
          container: container2,
          middlewareData,
          placement: computedPlacement,
          coordinates: {
            x,
            y
          },
          lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
          strategy,
          useTransform
        });
        container2.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT));
      }).catch((err) => {
        if (false) {
          console.error("[usePositioning]: Failed to calculate position", err);
        }
      });
    };
    const updatePosition = debounce(() => forceUpdate());
    const dispose = () => {
      isDestroyed = true;
      if (targetWindow) {
        targetWindow.removeEventListener("scroll", updatePosition);
        targetWindow.removeEventListener("resize", updatePosition);
      }
      scrollParents.forEach((scrollParent) => {
        scrollParent.removeEventListener("scroll", updatePosition);
      });
      scrollParents.clear();
      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
    };
    if (targetWindow) {
      targetWindow.addEventListener("scroll", updatePosition, {
        passive: true
      });
      targetWindow.addEventListener("resize", updatePosition);
    }
    updatePosition();
    return {
      updatePosition,
      dispose
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@floating-ui/devtools/dist/floating-ui.devtools.mjs
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
  var React88 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/coverTarget.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function coverTarget() {
    return {
      name: "coverTarget",
      fn: (middlewareArguments) => {
        const { placement, rects, x, y } = middlewareArguments;
        const basePlacement = parseFloatingUIPlacement(placement).side;
        const newCoords = {
          x,
          y
        };
        switch (basePlacement) {
          case "bottom":
            newCoords.y -= rects.reference.height;
            break;
          case "top":
            newCoords.y += rects.reference.height;
            break;
          case "left":
            newCoords.x += rects.reference.width;
            break;
          case "right":
            newCoords.x -= rects.reference.width;
            break;
        }
        return newCoords;
      }
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/flip.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function flip3(options) {
    const { hasScrollableElement, flipBoundary, container: container2, fallbackPositions = [], isRtl } = options;
    const fallbackPlacements = fallbackPositions.reduce((acc, shorthand) => {
      const { position: position4, align } = resolvePositioningShorthand(shorthand);
      const placement = toFloatingUIPlacement(align, position4, isRtl);
      if (placement) {
        acc.push(placement);
      }
      return acc;
    }, []);
    return flip2({
      ...hasScrollableElement && {
        boundary: "clippingAncestors"
      },
      ...flipBoundary && {
        altBoundary: true,
        boundary: getBoundary(container2, flipBoundary)
      },
      fallbackStrategy: "bestFit",
      ...fallbackPlacements.length && {
        fallbackPlacements
      }
    });
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/intersecting.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function intersecting() {
    return {
      name: "intersectionObserver",
      fn: async (middlewareArguments) => {
        const floatingRect = middlewareArguments.rects.floating;
        const altOverflow = await detectOverflow2(middlewareArguments, {
          altBoundary: true
        });
        const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
        const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
        const isIntersecting = isIntersectingTop || isIntersectingBottom;
        return {
          data: {
            intersecting: isIntersecting
          }
        };
      }
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/maxSize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var resetMaxSize = (autoSize) => ({
    name: "resetMaxSize",
    fn({ middlewareData, elements }) {
      var _middlewareData_resetMaxSize;
      if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) {
        return {};
      }
      const { applyMaxWidth, applyMaxHeight } = autoSize;
      if (applyMaxWidth) {
        elements.floating.style.removeProperty("box-sizing");
        elements.floating.style.removeProperty("max-width");
        elements.floating.style.removeProperty("width");
      }
      if (applyMaxHeight) {
        elements.floating.style.removeProperty("box-sizing");
        elements.floating.style.removeProperty("max-height");
        elements.floating.style.removeProperty("height");
      }
      return {
        data: {
          maxSizeAlreadyReset: true
        },
        reset: {
          rects: true
        }
      };
    }
  });
  function maxSize(autoSize, options) {
    const { container: container2, overflowBoundary, overflowBoundaryPadding, isRtl } = options;
    return size2({
      ...overflowBoundaryPadding && {
        padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
      },
      ...overflowBoundary && {
        altBoundary: true,
        boundary: getBoundary(container2, overflowBoundary)
      },
      apply({ availableHeight, availableWidth, elements, rects }) {
        const applyMaxSizeStyles = (apply, dimension, availableSize) => {
          if (!apply) {
            return;
          }
          elements.floating.style.setProperty("box-sizing", "border-box");
          elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
          if (rects.floating[dimension] > availableSize) {
            elements.floating.style.setProperty(dimension, `${availableSize}px`);
            const axis = dimension === "width" ? "x" : "y";
            if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) {
              elements.floating.style.setProperty(`overflow-${axis}`, "auto");
            }
          }
        };
        const { applyMaxWidth, applyMaxHeight } = autoSize;
        applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
        applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
      }
    });
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/offset.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-positioning/lib/utils/getFloatingUIOffset.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function getFloatingUIOffset(rawOffset) {
    if (!rawOffset) {
      return rawOffset;
    }
    if (typeof rawOffset === "number" || typeof rawOffset === "object") {
      return rawOffset;
    }
    return ({ rects: { floating, reference }, placement }) => {
      const { position: position4, alignment } = fromFloatingUIPlacement(placement);
      return rawOffset({
        positionedRect: floating,
        targetRect: reference,
        position: position4,
        alignment
      });
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/offset.js
  function offset3(offsetValue) {
    const floatingUIOffset = getFloatingUIOffset(offsetValue);
    return offset2(floatingUIOffset);
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/shift.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function shift3(options) {
    const { hasScrollableElement, shiftToCoverTarget, disableTether, overflowBoundary, container: container2, overflowBoundaryPadding, isRtl } = options;
    return shift2({
      ...hasScrollableElement && {
        boundary: "clippingAncestors"
      },
      ...shiftToCoverTarget && {
        crossAxis: true,
        limiter: limitShift2({
          crossAxis: true,
          mainAxis: false
        })
      },
      ...disableTether && {
        crossAxis: disableTether === "all",
        limiter: limitShift2({
          crossAxis: disableTether !== "all",
          mainAxis: false
        })
      },
      ...overflowBoundaryPadding && {
        padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
      },
      ...overflowBoundary && {
        altBoundary: true,
        boundary: getBoundary(container2, overflowBoundary)
      }
    });
  }

  // ../../node_modules/@fluentui/react-positioning/lib/middleware/matchTargetSize.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var matchTargetSizeCssVar = "--fui-match-target-size";
  function matchTargetSize() {
    return {
      name: "matchTargetSize",
      fn: async (middlewareArguments) => {
        const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
        if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) {
          return {};
        }
        const { width } = referenceRect;
        floatingElement.style.setProperty(matchTargetSizeCssVar, `${width}px`);
        if (!floatingElement.style.width) {
          floatingElement.style.width = `var(${matchTargetSizeCssVar})`;
        }
        return {
          data: {
            matchTargetSizeAttempt: true
          },
          reset: {
            rects: true
          }
        };
      }
    };
  }

  // ../../node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
  function usePositioningConfigFn(configFn, options) {
    const {
      align,
      arrowPadding,
      autoSize,
      coverTarget: coverTarget2,
      disableUpdateOnResize,
      flipBoundary,
      offset: offset4,
      overflowBoundary,
      pinned,
      position: position4,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_disableTether,
      strategy,
      overflowBoundaryPadding,
      fallbackPositions,
      useTransform,
      matchTargetSize: matchTargetSize2,
      shiftToCoverTarget
    } = options;
    return React88.useCallback((container2, arrow3) => {
      return configFn({
        container: container2,
        arrow: arrow3,
        options: {
          autoSize,
          disableUpdateOnResize,
          matchTargetSize: matchTargetSize2,
          offset: offset4,
          strategy,
          coverTarget: coverTarget2,
          flipBoundary,
          overflowBoundary,
          useTransform,
          overflowBoundaryPadding,
          pinned,
          arrowPadding,
          align,
          fallbackPositions,
          shiftToCoverTarget,
          position: position4,
          // eslint-disable-next-line @typescript-eslint/naming-convention
          unstable_disableTether
        }
      });
    }, [
      autoSize,
      disableUpdateOnResize,
      matchTargetSize2,
      offset4,
      strategy,
      coverTarget2,
      flipBoundary,
      overflowBoundary,
      useTransform,
      overflowBoundaryPadding,
      pinned,
      arrowPadding,
      align,
      fallbackPositions,
      shiftToCoverTarget,
      position4,
      unstable_disableTether,
      configFn
    ]);
  }
  function usePositioningOptions(options) {
    const { dir, targetDocument } = useFluent();
    const isRtl = dir === "rtl";
    const configFn = usePositioningConfigFn(usePositioningConfiguration(), options);
    const {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      positionFixed
    } = options;
    return React88.useCallback((container2, arrow3) => {
      const hasScrollableElement = hasScrollParent(container2);
      const optionsAfterEnhancement = configFn(container2, arrow3);
      const {
        autoSize,
        disableUpdateOnResize,
        matchTargetSize: matchTargetSize2,
        offset: offset4,
        coverTarget: coverTarget2,
        flipBoundary,
        overflowBoundary,
        useTransform,
        overflowBoundaryPadding,
        pinned,
        position: position4,
        arrowPadding,
        strategy,
        align,
        fallbackPositions,
        shiftToCoverTarget,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_disableTether
      } = optionsAfterEnhancement;
      const normalizedAutoSize = normalizeAutoSize(autoSize);
      const middleware2 = [
        normalizedAutoSize && resetMaxSize(normalizedAutoSize),
        matchTargetSize2 && matchTargetSize(),
        offset4 && offset3(offset4),
        coverTarget2 && coverTarget(),
        !pinned && flip3({
          container: container2,
          flipBoundary,
          hasScrollableElement,
          isRtl,
          fallbackPositions
        }),
        shift3({
          container: container2,
          hasScrollableElement,
          overflowBoundary,
          disableTether: unstable_disableTether,
          overflowBoundaryPadding,
          isRtl,
          shiftToCoverTarget
        }),
        normalizedAutoSize && maxSize(normalizedAutoSize, {
          container: container2,
          overflowBoundary,
          overflowBoundaryPadding,
          isRtl
        }),
        intersecting(),
        arrow3 && arrow2({
          element: arrow3,
          padding: arrowPadding
        }),
        hide2({
          strategy: "referenceHidden"
        }),
        hide2({
          strategy: "escaped"
        }),
        false
      ].filter(Boolean);
      const placement = toFloatingUIPlacement(align, position4, isRtl);
      return {
        placement,
        middleware: middleware2,
        strategy: (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute",
        disableUpdateOnResize,
        useTransform
      };
    }, [
      configFn,
      isRtl,
      targetDocument,
      positionFixed
    ]);
  }

  // ../../node_modules/@fluentui/react-positioning/lib/usePositioning.js
  function usePositioning(options) {
    "use no memo";
    const managerRef = React89.useRef(null);
    const targetRef = React89.useRef(null);
    const overrideTargetRef = React89.useRef(null);
    const containerRef = React89.useRef(null);
    const arrowRef = React89.useRef(null);
    const { enabled = true } = options;
    const resolvePositioningOptions = usePositioningOptions(options);
    const updatePositionManager = React89.useCallback(() => {
      if (managerRef.current) {
        managerRef.current.dispose();
      }
      managerRef.current = null;
      var _overrideTargetRef_current;
      const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
      if (enabled && canUseDOM2() && target && containerRef.current) {
        managerRef.current = createPositionManager({
          container: containerRef.current,
          target,
          arrow: arrowRef.current,
          ...resolvePositioningOptions(containerRef.current, arrowRef.current)
        });
      }
    }, [
      enabled,
      resolvePositioningOptions
    ]);
    const setOverrideTarget = useEventCallback((target) => {
      overrideTargetRef.current = target;
      updatePositionManager();
    });
    React89.useImperativeHandle(options.positioningRef, () => ({
      updatePosition: () => {
        var _managerRef_current;
        return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
      },
      setTarget: (target) => {
        if (options.target && false) {
          const err = new Error();
          console.warn("Imperative setTarget should not be used at the same time as target option");
          console.warn(err.stack);
        }
        setOverrideTarget(target);
      }
    }), [
      options.target,
      setOverrideTarget
    ]);
    useIsomorphicLayoutEffect2(() => {
      var _options_target;
      setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
    }, [
      options.target,
      setOverrideTarget
    ]);
    useIsomorphicLayoutEffect2(() => {
      updatePositionManager();
    }, [
      updatePositionManager
    ]);
    if (false) {
      React89.useEffect(() => {
        if (containerRef.current) {
          var _contentNode_ownerDocument;
          const contentNode = containerRef.current;
          const treeWalker = (_contentNode_ownerDocument = contentNode.ownerDocument) === null || _contentNode_ownerDocument === void 0 ? void 0 : _contentNode_ownerDocument.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
            acceptNode: hasAutofocusFilter
          });
          while (treeWalker.nextNode()) {
            const node3 = treeWalker.currentNode;
            console.warn("usePositioning():", node3);
            console.warn([
              'usePositioning(): ^ this node contains "autoFocus" prop on a React element. This can break the initial',
              "positioning of an element and cause a window jump effect. This issue occurs because React polyfills",
              '"autoFocus" behavior to solve inconsistencies between different browsers:',
              "https://github.com/facebook/react/issues/11851#issuecomment-351787078",
              "\n",
              'However, ".focus()" in this case occurs before any other React effects will be executed',
              "(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really",
              'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
              '"Popper".',
              `In general, it's not recommended to use "autoFocus" as it may break accessibility aspects:`,
              "https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md",
              "\n",
              'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
              '"ref.current.focus" in React.useEffect():',
              "https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"
            ].join(" "));
          }
        }
      }, []);
    }
    const setTarget = useCallbackRef(null, (target) => {
      if (targetRef.current !== target) {
        targetRef.current = target;
        updatePositionManager();
      }
    });
    const onPositioningEnd = useEventCallback(() => {
      var _options_onPositioningEnd;
      return (_options_onPositioningEnd = options.onPositioningEnd) === null || _options_onPositioningEnd === void 0 ? void 0 : _options_onPositioningEnd.call(options);
    });
    const setContainer = useCallbackRef(null, (container2) => {
      if (containerRef.current !== container2) {
        var _containerRef_current;
        (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.removeEventListener(POSITIONING_END_EVENT, onPositioningEnd);
        container2 === null || container2 === void 0 ? void 0 : container2.addEventListener(POSITIONING_END_EVENT, onPositioningEnd);
        containerRef.current = container2;
        updatePositionManager();
      }
    });
    const setArrow = useCallbackRef(null, (arrow3) => {
      if (arrowRef.current !== arrow3) {
        arrowRef.current = arrow3;
        updatePositionManager();
      }
    });
    return {
      targetRef: setTarget,
      containerRef: setContainer,
      arrowRef: setArrow
    };
  }

  // ../../node_modules/@fluentui/react-popover/lib/popoverContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var PopoverContext = createContext20(void 0);
  var popoverContextDefaultValue = {
    open: false,
    setOpen: () => null,
    toggleOpen: () => null,
    triggerRef: {
      current: null
    },
    contentRef: {
      current: null
    },
    arrowRef: {
      current: null
    },
    openOnContext: false,
    openOnHover: false,
    size: "medium",
    trapFocus: false,
    inline: false
  };
  var PopoverProvider = PopoverContext.Provider;
  var usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));

  // ../../node_modules/@fluentui/react-portal/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React93 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React91 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function toMountNodeProps(mountNode) {
    if (isHTMLElement(mountNode)) {
      return {
        element: mountNode
      };
    }
    if (typeof mountNode === "object") {
      if (mountNode === null) {
        return {
          element: null
        };
      }
      return mountNode;
    }
    return {};
  }

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React90 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var usePortalMountNodeStylesStyles = /* @__PURE__ */ __styles2({
    root: {
      qhf8xq: "f1euv43f",
      Bhzewxz: "f15twtuk",
      oyh7mz: ["f1vgc2s3", "f1e31b4d"],
      j35jbq: ["f1e31b4d", "f1vgc2s3"],
      Bj3rh1h: "f494woh"
    }
  }, {
    d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
  });

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
  var useInsertionEffect6 = React90["useInsertionEffect"];
  var useLegacyElementFactory = (options) => {
    const { className, dir, focusVisibleRef, targetNode } = options;
    const targetElement = React90.useMemo(() => {
      if (targetNode === void 0 || options.disabled) {
        return null;
      }
      const element4 = targetNode.ownerDocument.createElement("div");
      targetNode.appendChild(element4);
      return element4;
    }, [
      targetNode,
      options.disabled
    ]);
    React90.useMemo(() => {
      if (!targetElement) {
        return;
      }
      targetElement.className = className;
      targetElement.setAttribute("dir", dir);
      targetElement.setAttribute("data-portal-node", "true");
      focusVisibleRef.current = targetElement;
    }, [
      className,
      dir,
      targetElement,
      focusVisibleRef
    ]);
    React90.useEffect(() => {
      return () => {
        targetElement === null || targetElement === void 0 ? void 0 : targetElement.remove();
      };
    }, [
      targetElement
    ]);
    return targetElement;
  };
  var useModernElementFactory = (options) => {
    const { className, dir, focusVisibleRef, targetNode } = options;
    const [elementFactory] = React90.useState(() => {
      let currentElement = void 0;
      function get(targetRoot, forceCreation) {
        if (currentElement) {
          return currentElement;
        }
        if (forceCreation) {
          currentElement = targetRoot.ownerDocument.createElement("div");
          targetRoot.appendChild(currentElement);
        }
        return currentElement;
      }
      function dispose() {
        if (currentElement) {
          currentElement.remove();
          currentElement = void 0;
        }
      }
      return {
        get,
        dispose
      };
    });
    const elementProxy = React90.useMemo(() => {
      if (targetNode === void 0 || options.disabled) {
        return null;
      }
      return new Proxy({}, {
        get(_, property) {
          if (property === "remove") {
            const targetElement2 = elementFactory.get(targetNode, false);
            if (targetElement2) {
              const portalHasNoChildren = targetElement2.childNodes.length === 0;
              if (portalHasNoChildren) {
                return targetElement2.remove.bind(targetElement2);
              }
            }
            return () => {
            };
          }
          const targetElement = elementFactory.get(targetNode, true);
          const targetProperty = targetElement[property];
          if (typeof targetProperty === "function") {
            return targetProperty.bind(targetElement);
          }
          return targetProperty;
        },
        set(_, property, value) {
          const targetElement = elementFactory.get(targetNode, true);
          if (targetElement) {
            Object.assign(targetElement, {
              [property]: value
            });
            return true;
          }
          return false;
        }
      });
    }, [
      elementFactory,
      targetNode,
      options.disabled
    ]);
    React90.useEffect(() => {
      return () => {
        elementProxy === null || elementProxy === void 0 ? void 0 : elementProxy.remove();
      };
    }, [
      elementProxy
    ]);
    useInsertionEffect6(() => {
      if (!elementProxy) {
        return;
      }
      const classesToApply = className.split(" ").filter(Boolean);
      elementProxy.classList.add(...classesToApply);
      elementProxy.setAttribute("dir", dir);
      elementProxy.setAttribute("data-portal-node", "true");
      focusVisibleRef.current = elementProxy;
      return () => {
        elementProxy.classList.remove(...classesToApply);
        elementProxy.removeAttribute("dir");
      };
    }, [
      className,
      dir,
      elementProxy,
      focusVisibleRef
    ]);
    return elementProxy;
  };
  var usePortalMountNode2 = (options) => {
    "use no memo";
    const { targetDocument, dir } = useFluent();
    const mountNode = usePortalMountNode();
    const focusVisibleRef = useFocusVisible();
    const classes = usePortalMountNodeStylesStyles();
    const themeClassName = useThemeClassName();
    const factoryOptions = {
      dir,
      disabled: options.disabled,
      focusVisibleRef,
      className: mergeClasses(themeClassName, classes.root, options.className),
      targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
    };
    if (useInsertionEffect6) {
      return useModernElementFactory(factoryOptions);
    }
    return useLegacyElementFactory(factoryOptions);
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
  var usePortal_unstable = (props) => {
    const { element: element4, className } = toMountNodeProps(props.mountNode);
    const virtualParentRootRef = React91.useRef(null);
    const fallbackElement = usePortalMountNode2({
      disabled: !!element4,
      className
    });
    const mountNode = element4 !== null && element4 !== void 0 ? element4 : fallbackElement;
    const state = {
      children: props.children,
      mountNode,
      virtualParentRootRef
    };
    React91.useEffect(() => {
      if (!mountNode) {
        return;
      }
      const virtualParent = virtualParentRootRef.current;
      const isVirtualParentInsideChild = mountNode.contains(virtualParent);
      if (virtualParent && !isVirtualParentInsideChild) {
        setVirtualParent(mountNode, virtualParent);
        return () => {
          setVirtualParent(mountNode, void 0);
        };
      }
    }, [
      mountNode
    ]);
    return state;
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ReactDOM = __toESM(require_react_dom());
  var React92 = __toESM(require_react());
  var renderPortal_unstable = (state) => {
    return /* @__PURE__ */ React92.createElement("span", {
      hidden: true,
      ref: state.virtualParentRootRef
    }, state.mountNode && /* @__PURE__ */ ReactDOM.createPortal(state.children, state.mountNode));
  };

  // ../../node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
  var Portal = (props) => {
    const state = usePortal_unstable(props);
    return renderPortal_unstable(state);
  };
  Portal.displayName = "Portal";

  // ../../node_modules/@fluentui/react-button/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-button/lib/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-button/lib/components/Button/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-button/lib/components/Button/Button.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React96 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-button/lib/components/Button/renderButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderButton_unstable = (state) => {
    assertSlots(state);
    const { iconOnly, iconPosition } = state;
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        iconPosition !== "after" && state.icon && /* @__PURE__ */ jsx2(state.icon, {}),
        !iconOnly && state.root.children,
        iconPosition === "after" && state.icon && /* @__PURE__ */ jsx2(state.icon, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React95 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-button/lib/contexts/ButtonContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React94 = __toESM(require_react());
  var buttonContext = React94.createContext(void 0);
  var buttonContextDefaultValue = {};
  var ButtonContextProvider = buttonContext.Provider;
  var useButtonContext = () => {
    var _React_useContext;
    return (_React_useContext = React94.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButton.js
  var useButton_unstable = (props, ref) => {
    const { size: contextSize } = useButtonContext();
    const { appearance = "secondary", as = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
    const iconShorthand = slot_exports.optional(icon, {
      elementType: "span"
    });
    return {
      // Props passed at the top-level
      appearance,
      disabled,
      disabledFocusable,
      iconPosition,
      shape,
      size: size3,
      iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
      components: {
        root: "button",
        icon: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
        elementType: "button",
        defaultProps: {
          ref,
          type: as === "button" ? "button" : void 0
        }
      }),
      icon: iconShorthand
    };
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/useButtonStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var buttonClassNames = {
    root: "fui-Button",
    icon: "fui-Button__icon"
  };
  var boxShadowStrokeWidthThinMoz = `calc(${tokens.strokeWidthThin} + 0.25px)`;
  var useRootBaseClassName = /* @__PURE__ */ __resetStyles2("r1alrhcs", null, {
    r: [".r1alrhcs{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}", ".r1alrhcs:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}", ".r1alrhcs:hover:active{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}", ".r1alrhcs[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1alrhcs{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1alrhcs:focus{border-color:ButtonText;}.r1alrhcs:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1alrhcs:hover:active{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}", "@supports (-moz-appearance:button){.r1alrhcs[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
  });
  var useIconBaseClassName = /* @__PURE__ */ __resetStyles2("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
  var useRootStyles3 = /* @__PURE__ */ __styles2({
    outline: {
      De3pzq: "f1c21dwh",
      Jwef8y: "fjxutwb",
      iro3zm: "fwiml72"
    },
    primary: {
      De3pzq: "ffp7eso",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "f1phragk",
      Jwef8y: "f15wkkf3",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "f1rq72xc",
      iro3zm: "fnp9lpt",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1d6v5y2",
      Bsw6fvg: "f1rirnrt",
      Bjwas2f: "f1uu00uk",
      Bn1d65q: ["fkvaka8", "f9a0qzu"],
      Bxeuatn: "f1ux7til",
      n51gp8: ["f9a0qzu", "fkvaka8"],
      Bbusuzp: "f1lkg8j3",
      ycbfsm: "fkc42ay",
      Bqrx1nm: "fq7113v",
      pgvf35: "ff1wgvm",
      Bh7lczh: ["fiob0tu", "f1x4h75k"],
      dpv3f4: "f1j6scgf",
      Bpnjhaq: ["f1x4h75k", "fiob0tu"],
      ze5xyy: "f4xjyn1",
      g2kj27: "fbgcvur",
      Bf756sw: "f1ks1yx8",
      Bow2dr7: ["f1o6qegi", "fmxjhhp"],
      Bvhedfk: "fcnxywj",
      Gye4lf: ["fmxjhhp", "f1o6qegi"],
      pc6evw: "f9ddjv3"
    },
    secondary: {},
    subtle: {
      De3pzq: "fhovq9v",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "fkfq4zb",
      Jwef8y: "f1t94bn6",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "fnwyq0v",
      Bk3fhr4: "ft1hn21",
      Bmfj8id: "fuxngvv",
      Bbdnnc7: "fy5bs14",
      iro3zm: "fsv2rcd",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1omzyqd",
      em6i61: "f1dfjoow",
      vm6p8p: "f1j98vj9",
      x3br3k: "fj8yq94",
      ze5xyy: "f4xjyn1",
      Bx3q9su: "f1et0tmh",
      pc6evw: "f9ddjv3",
      xd2cci: "f1wi8ngl"
    },
    transparent: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      sj55zd: "fkfq4zb",
      Jwef8y: "fjxutwb",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      Bi91k9c: "f139oj5f",
      Bk3fhr4: "ft1hn21",
      Bmfj8id: "fuxngvv",
      iro3zm: "fwiml72",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"],
      B2d53fq: "f1fg1p5m",
      em6i61: "f1dfjoow",
      vm6p8p: "f1j98vj9",
      Bqrx1nm: "f1tme0vf",
      ze5xyy: "f4xjyn1",
      g2kj27: "f18onu3q",
      pc6evw: "f9ddjv3"
    },
    circular: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f44lkw9"
    },
    rounded: {},
    square: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1fabniw"
    },
    small: {
      Bf4jedk: "fh7ncta",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fneth5b",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    smallWithIcon: {
      Byoj8tv: "f1brlhvm",
      z8tnut: "f1sl3k7w"
    },
    medium: {},
    large: {
      Bf4jedk: "f14es27b",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f4db1ww",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    largeWithIcon: {
      Byoj8tv: "fy7v416",
      z8tnut: "f1a1bwwz"
    }
  }, {
    d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], ".fh7ncta{min-width:64px;}", [".fneth5b{padding:3px var(--spacingHorizontalS);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1brlhvm{padding-bottom:1px;}", ".f1sl3k7w{padding-top:1px;}", ".f14es27b{min-width:96px;}", [".f4db1ww{padding:8px var(--spacingHorizontalL);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fy7v416{padding-bottom:7px;}", ".f1a1bwwz{padding-top:7px;}"],
    h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}", ".fsv2rcd:hover:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1omzyqd:hover:active{color:var(--colorNeutralForeground2Pressed);}", ".f1dfjoow:hover:active .fui-Icon-filled{display:inline;}", ".f1j98vj9:hover:active .fui-Icon-regular{display:none;}", ".fj8yq94:hover:active .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
    m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1uu00uk{border-top-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f9a0qzu{border-left-color:HighlightText;}.fkvaka8{border-right-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1ux7til{border-bottom-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fbgcvur:hover:active{background-color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1ks1yx8:hover:active{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1o6qegi:hover:active{border-right-color:Highlight;}.fmxjhhp:hover:active{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fcnxywj:hover:active{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f9ddjv3:hover:active{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1et0tmh:hover .fui-Button__icon{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wi8ngl:hover:active .fui-Button__icon{color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1tme0vf:hover{background-color:var(--colorTransparentBackground);}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18onu3q:hover:active{background-color:var(--colorTransparentBackground);}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useRootDisabledStyles = /* @__PURE__ */ __styles2({
    base: {
      De3pzq: "f1bg9a2p",
      g2u3we: "f1jj8ep1",
      h3c5rm: ["f15xbau", "fy0fskl"],
      B9xav0g: "f4ikngz",
      zhjwy3: ["fy0fskl", "f15xbau"],
      sj55zd: "f1s2aq7o",
      Bceei9c: "fdrzuqr",
      Bfinmwp: "f15x8b5r",
      Jwef8y: "f1falr9n",
      Bgoe8wy: "f12mpcsy",
      Bwzppfd: ["f1gwvigk", "f18rmfxp"],
      oetu4i: "f1jnshp0",
      gg5e9n: ["f18rmfxp", "f1gwvigk"],
      Bi91k9c: "fvgxktp",
      eoavqd: "fphbwmw",
      Bk3fhr4: "f19vpps7",
      Bmfj8id: "fv5swzo",
      Bbdnnc7: "f1al02dq",
      iro3zm: "f1t6o4dc",
      b661bw: "f10ztigi",
      Bk6r4ia: ["f1ft5sdu", "f1gzf82w"],
      B9zn80p: "f12zbtn2",
      Bpld233: ["f1gzf82w", "f1ft5sdu"],
      B2d53fq: "fcvwxyo",
      c3iz72: "f8w4c43",
      em6i61: "f1ol4fw6",
      vm6p8p: "f1q1lw4e",
      x3br3k: "f1dwjv2g"
    },
    highContrast: {
      Bsw6fvg: "f4lkoma",
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"],
      Bbusuzp: "f1dcs8yz",
      Bm2fdqk: "fuigjrg",
      G867l3: "fjwq6ea",
      gdbnj: ["f1lr3nhc", "f1mbxvi6"],
      mxns5l: "fn5gmvv",
      o3nasb: ["f1mbxvi6", "f1lr3nhc"],
      Bqrx1nm: "f1vmkb5g",
      pgvf35: "f53ppgq",
      Bh7lczh: ["f1663y11", "f80fkiy"],
      dpv3f4: "f18v5270",
      Bpnjhaq: ["f80fkiy", "f1663y11"],
      ze5xyy: "f1kc2mi9",
      Bx3q9su: "f4dhi0o",
      g2kj27: "f1y0svfh",
      Bf756sw: "fihuait",
      Bow2dr7: ["fnxhupq", "fyd6l6x"],
      Bvhedfk: "fx507ft",
      Gye4lf: ["fyd6l6x", "fnxhupq"],
      pc6evw: "fb3rf2x",
      xd2cci: "fequ9m0"
    },
    outline: {
      De3pzq: "f1c21dwh",
      Jwef8y: "f9ql6rf",
      iro3zm: "f3h1zc4"
    },
    primary: {
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    },
    secondary: {},
    subtle: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Jwef8y: "f9ql6rf",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      iro3zm: "f3h1zc4",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    },
    transparent: {
      De3pzq: "f1c21dwh",
      g2u3we: "f1p3nwhy",
      h3c5rm: ["f11589ue", "f1pdflbu"],
      B9xav0g: "f1q5o8ev",
      zhjwy3: ["f1pdflbu", "f11589ue"],
      Jwef8y: "f9ql6rf",
      Bgoe8wy: "f1s2uweq",
      Bwzppfd: ["fr80ssc", "fecsdlb"],
      oetu4i: "f1ukrpxl",
      gg5e9n: ["fecsdlb", "fr80ssc"],
      iro3zm: "f3h1zc4",
      b661bw: "f1h0usnq",
      Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
      B9zn80p: "f16h9ulv",
      Bpld233: ["fx2bmrt", "fs4ktlq"]
    }
  }, {
    d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}"],
    h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1t6o4dc:hover:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".f10ztigi:hover:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ft5sdu:hover:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1gzf82w:hover:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12zbtn2:hover:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f8w4c43:hover:active{cursor:not-allowed;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}", ".f1dwjv2g:hover:active .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}"],
    m: [["@media (forced-colors: active){.f4lkoma{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fuigjrg .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fjwq6ea:focus{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lr3nhc:focus{border-right-color:GrayText;}.f1mbxvi6:focus{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fn5gmvv:focus{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1vmkb5g:hover{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f53ppgq:hover{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1663y11:hover{border-right-color:GrayText;}.f80fkiy:hover{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18v5270:hover{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f4dhi0o:hover .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1y0svfh:hover:active{background-color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fihuait:hover:active{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fnxhupq:hover:active{border-right-color:GrayText;}.fyd6l6x:hover:active{border-left-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fx507ft:hover:active{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fb3rf2x:hover:active{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fequ9m0:hover:active .fui-Button__icon{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useRootFocusStyles = /* @__PURE__ */ __styles2({
    circular: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "f1062rbf"
    },
    rounded: {},
    square: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "fj0ryk1"
    },
    primary: {
      B8q5s1w: "f17t0x8g",
      Bci5o5g: ["f194v5ow", "fk7jm04"],
      n8qw10: "f1qgg65p",
      Bdrgwmp: ["fk7jm04", "f194v5ow"],
      j6ew2k: ["fhgccpy", "fjo7pq6"],
      he4mth: "f32wu9k",
      Byr4aka: "fu5nqqq",
      lks7q5: ["f13prjl2", "f1nl83rv"],
      Bnan3qt: "f1czftr5",
      k1dn9: ["f1nl83rv", "f13prjl2"],
      Boium3a: ["f12k37oa", "fdnykm2"],
      tm8e47: "fr96u23"
    },
    small: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "fazmxh"
    },
    medium: {},
    large: {
      Bw81rd7: 0,
      kdpuga: 0,
      dm238s: 0,
      B6xbmo0: 0,
      B3whbx2: "f1b6alqh"
    }
  }, {
    d: [[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}", ".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}", ".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}", ".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}", ".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}", [".fazmxh[data-fui-focus-visible]{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], [".f1b6alqh[data-fui-focus-visible]{border-radius:var(--borderRadiusLarge);}", {
      p: -1
    }]],
    t: ["@supports (-moz-appearance:button){.f12k37oa[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fdnykm2[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.fr96u23[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
  });
  var useRootIconOnlyStyles = /* @__PURE__ */ __styles2({
    small: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fu97m5z",
      Bf4jedk: "f17fgpbq",
      B2u0y6b: "f1jt17bm"
    },
    medium: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f18ktai2",
      Bf4jedk: "fwbmr0d",
      B2u0y6b: "f44c6la"
    },
    large: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1hbd1aw",
      Bf4jedk: "f12clzc2",
      B2u0y6b: "fjy1crr"
    }
  }, {
    d: [[".fu97m5z{padding:1px;}", {
      p: -1
    }], ".f17fgpbq{min-width:24px;}", ".f1jt17bm{max-width:24px;}", [".f18ktai2{padding:5px;}", {
      p: -1
    }], ".fwbmr0d{min-width:32px;}", ".f44c6la{max-width:32px;}", [".f1hbd1aw{padding:7px;}", {
      p: -1
    }], ".f12clzc2{min-width:40px;}", ".fjy1crr{max-width:40px;}"]
  });
  var useIconStyles2 = /* @__PURE__ */ __styles2({
    small: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3",
      Bqrlyyl: "fbaiahx"
    },
    medium: {},
    large: {
      Be2twd7: "f1rt2boy",
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun",
      Bqrlyyl: "f1exjqw5"
    },
    before: {
      t21cq0: ["f1nizpg2", "f1a695kz"]
    },
    after: {
      Frg6f3: ["f1a695kz", "f1nizpg2"]
    }
  }, {
    d: [".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}", ".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}", ".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"]
  });
  var useButtonStyles_unstable = (state) => {
    "use no memo";
    const rootBaseClassName = useRootBaseClassName();
    const iconBaseClassName = useIconBaseClassName();
    const rootStyles = useRootStyles3();
    const rootDisabledStyles = useRootDisabledStyles();
    const rootFocusStyles = useRootFocusStyles();
    const rootIconOnlyStyles = useRootIconOnlyStyles();
    const iconStyles = useIconStyles2();
    const {
      appearance,
      disabled,
      disabledFocusable,
      icon,
      iconOnly,
      iconPosition,
      shape,
      size: size3
    } = state;
    state.root.className = mergeClasses(
      buttonClassNames.root,
      rootBaseClassName,
      appearance && rootStyles[appearance],
      rootStyles[size3],
      icon && size3 === "small" && rootStyles.smallWithIcon,
      icon && size3 === "large" && rootStyles.largeWithIcon,
      rootStyles[shape],
      // Disabled styles
      (disabled || disabledFocusable) && rootDisabledStyles.base,
      (disabled || disabledFocusable) && rootDisabledStyles.highContrast,
      appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
      // Focus styles
      appearance === "primary" && rootFocusStyles.primary,
      rootFocusStyles[size3],
      rootFocusStyles[shape],
      // Icon-only styles
      iconOnly && rootIconOnlyStyles[size3],
      // User provided class name
      state.root.className
    );
    if (state.icon) {
      state.icon.className = mergeClasses(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size3], state.icon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-button/lib/components/Button/Button.js
  var Button = /* @__PURE__ */ React96.forwardRef((props, ref) => {
    const state = useButton_unstable(props, ref);
    useButtonStyles_unstable(state);
    useCustomStyleHook("useButtonStyles_unstable")(state);
    return renderButton_unstable(state);
  });
  Button.displayName = "Button";

  // ../../node_modules/@fluentui/react-field/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-field/lib/contexts/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React97 = __toESM(require_react());
  var FieldContext = React97.createContext(void 0);
  var FieldContextProvider = FieldContext.Provider;
  var useFieldContext_unstable = () => React97.useContext(FieldContext);

  // ../../node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useFieldControlProps_unstable(props, options) {
    return getFieldControlProps(useFieldContext_unstable(), props, options);
  }
  function getFieldControlProps(context, props, options) {
    if (!context) {
      return props;
    }
    props = {
      ...props
    };
    const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
    if (generatedControlId) {
      var _props;
      var _id;
      (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
    }
    if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
      var _props1, _arialabelledby;
      var _;
      (_ = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _props1[_arialabelledby] = labelId;
    }
    if (validationMessageId || hintId) {
      props["aria-describedby"] = [
        validationMessageId,
        hintId,
        props === null || props === void 0 ? void 0 : props["aria-describedby"]
      ].filter(Boolean).join(" ");
    }
    if (validationState === "error") {
      var _props2, _ariainvalid;
      var _1;
      (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
    }
    if (required) {
      if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
        var _props3;
        var _required;
        (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
      } else {
        var _props4, _ariarequired;
        var _2;
        (_2 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _2 !== void 0 ? _2 : _props4[_ariarequired] = true;
      }
    }
    if (options === null || options === void 0 ? void 0 : options.supportsSize) {
      var _props5;
      var _size;
      (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
    }
    return props;
  }

  // ../../node_modules/@fluentui/react-label/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-label/lib/Label.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-label/lib/components/Label/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-label/lib/components/Label/Label.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React99 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React98 = __toESM(require_react());
  var useLabel_unstable = (props, ref) => {
    const { disabled = false, required = false, weight = "regular", size: size3 = "medium" } = props;
    return {
      disabled,
      required: slot_exports.optional(required === true ? "*" : required || void 0, {
        defaultProps: {
          "aria-hidden": "true"
        },
        elementType: "span"
      }),
      weight,
      size: size3,
      components: {
        root: "label",
        required: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("label", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "label"
      })
    };
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderLabel_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.root.children,
        state.required && /* @__PURE__ */ jsx2(state.required, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var labelClassNames = {
    root: "fui-Label",
    required: "fui-Label__required"
  };
  var useStyles4 = /* @__PURE__ */ __styles2({
    root: {
      Bahqtrf: "fk6fouc",
      sj55zd: "f19n0e5"
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      Bbusuzp: "f1dcs8yz"
    },
    required: {
      sj55zd: "f1whyuy6",
      uwmqm3: ["fruq291", "f7x41pl"]
    },
    small: {
      Be2twd7: "fy9rknc",
      Bg96gwp: "fwrc4pm"
    },
    medium: {
      Be2twd7: "fkhj508",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      Be2twd7: "fod5ikn",
      Bg96gwp: "faaz57k",
      Bhrd7zp: "fl43uef"
    },
    semibold: {
      Bhrd7zp: "fl43uef"
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
    m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useLabelStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles4();
    state.root.className = mergeClasses(labelClassNames.root, styles.root, state.disabled && styles.disabled, styles[state.size], state.weight === "semibold" && styles.semibold, state.root.className);
    if (state.required) {
      state.required.className = mergeClasses(labelClassNames.required, styles.required, state.disabled && styles.disabled, state.required.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-label/lib/components/Label/Label.js
  var Label = /* @__PURE__ */ React99.forwardRef((props, ref) => {
    const state = useLabel_unstable(props, ref);
    useLabelStyles_unstable(state);
    useCustomStyleHook("useLabelStyles_unstable")(state);
    return renderLabel_unstable(state);
  });
  Label.displayName = "Label";

  // ../../node_modules/@fluentui/react-combobox/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/contexts/ComboboxContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var ComboboxContext = createContext20({
    activeOption: void 0,
    appearance: "outline",
    focusVisible: false,
    open: false,
    registerOption() {
      return () => void 0;
    },
    selectedOptions: [],
    selectOption() {
    },
    setActiveOption() {
    },
    setOpen() {
    },
    size: "medium"
  });
  var ComboboxProvider = ComboboxContext.Provider;

  // ../../node_modules/@fluentui/react-combobox/lib/contexts/ListboxContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React100 = __toESM(require_react());
  var listboxContextDefaultValue = {
    activeOption: void 0,
    focusVisible: false,
    multiselect: false,
    getOptionById() {
      return void 0;
    },
    getOptionsMatchingValue() {
      return [];
    },
    registerOption() {
      return () => void 0;
    },
    selectedOptions: [],
    onOptionClick() {
    },
    onActiveDescendantChange() {
    },
    selectOption() {
    },
    setActiveOption() {
    }
  };
  var ListboxContext = createContext20(void 0);
  var useListboxContext_unstable = (selector) => useContextSelector(ListboxContext, (ctx = listboxContextDefaultValue) => selector(ctx));
  var ListboxProvider = ListboxContext.Provider;

  // ../../node_modules/@fluentui/react-combobox/lib/contexts/useComboboxContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React101 = __toESM(require_react());
  function useComboboxContextValues(state) {
    const { appearance, open, getOptionById, getOptionsMatchingValue, registerOption, selectedOptions, selectOption, setOpen, size: size3, activeDescendantController, onOptionClick, onActiveDescendantChange } = state;
    const combobox = {
      activeOption: void 0,
      appearance,
      focusVisible: false,
      open,
      registerOption,
      selectedOptions,
      selectOption,
      setActiveOption: () => null,
      setOpen,
      size: size3
    };
    const listbox = {
      activeOption: void 0,
      focusVisible: false,
      getOptionById,
      getOptionsMatchingValue,
      registerOption,
      selectedOptions,
      selectOption,
      setActiveOption: () => null,
      onOptionClick,
      onActiveDescendantChange
    };
    const activeDescendant = React101.useMemo(() => ({
      controller: activeDescendantController
    }), [
      activeDescendantController
    ]);
    return {
      combobox,
      activeDescendant,
      listbox
    };
  }

  // ../../node_modules/@fluentui/react-combobox/lib/contexts/useListboxContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React102 = __toESM(require_react());
  function useListboxContextValues(state) {
    const hasListboxContext = useHasParentContext(ListboxContext);
    const { getOptionById, getOptionsMatchingValue, multiselect, registerOption, selectedOptions, selectOption, activeDescendantController } = state;
    const parentRegisterOption = useListboxContext_unstable((ctx) => ctx.registerOption);
    const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
    const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
    const registerOptionValue = hasListboxContext ? parentRegisterOption : registerOption;
    const listbox = {
      activeOption: void 0,
      focusVisible: false,
      getOptionById,
      getOptionsMatchingValue,
      multiselect,
      registerOption: registerOptionValue,
      selectedOptions,
      selectOption,
      setActiveOption: () => void 0,
      onOptionClick,
      onActiveDescendantChange
    };
    const activeDescendant = React102.useMemo(() => ({
      controller: activeDescendantController
    }), [
      activeDescendantController
    ]);
    return {
      listbox,
      activeDescendant
    };
  }

  // ../../node_modules/@fluentui/react-combobox/lib/Listbox.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React107 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React106 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-combobox/lib/utils/dropdownKeyActions.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React103 = __toESM(require_react());
  function getDropdownActionFromKey(e, options = {}) {
    const { open = true, multiselect = false } = options;
    const code4 = e.key;
    const { altKey, ctrlKey, key, metaKey } = e;
    if (key.length === 1 && code4 !== Space && !altKey && !ctrlKey && !metaKey) {
      return "Type";
    }
    if (!open) {
      if (code4 === ArrowDown || code4 === ArrowUp || code4 === Enter || code4 === Space) {
        return "Open";
      }
      return "None";
    }
    if (code4 === ArrowUp && altKey || code4 === Enter || !multiselect && code4 === Space) {
      return "CloseSelect";
    }
    if (multiselect && code4 === Space) {
      return "Select";
    }
    if (code4 === Escape) {
      return "Close";
    }
    if (code4 === ArrowDown) {
      return "Next";
    }
    if (code4 === ArrowUp) {
      return "Previous";
    }
    if (code4 === Home) {
      return "First";
    }
    if (code4 === End) {
      return "Last";
    }
    if (code4 === PageUp) {
      return "PageUp";
    }
    if (code4 === PageDown) {
      return "PageDown";
    }
    if (code4 === Tab) {
      return "Tab";
    }
    return "None";
  }

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useOptionCollection.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React104 = __toESM(require_react());
  var useOptionCollection = () => {
    const optionsById = React104.useRef(/* @__PURE__ */ new Map());
    const collectionAPI = React104.useMemo(() => {
      const getCount = () => optionsById.current.size;
      const getOptionAtIndex = () => void 0;
      const getIndexOfId = () => -1;
      const getOptionById = (id) => {
        return optionsById.current.get(id);
      };
      const getOptionsMatchingText = (matcher) => {
        return Array.from(optionsById.current.values()).filter(({ text: text9 }) => matcher(text9));
      };
      const getOptionsMatchingValue = (matcher) => {
        const matches = [];
        for (const option of optionsById.current.values()) {
          if (matcher(option.value)) {
            matches.push(option);
          }
        }
        return matches;
      };
      return {
        getCount,
        getOptionAtIndex,
        getIndexOfId,
        getOptionById,
        getOptionsMatchingText,
        getOptionsMatchingValue
      };
    }, []);
    const registerOption = React104.useCallback((option) => {
      optionsById.current.set(option.id, option);
      return () => optionsById.current.delete(option.id);
    }, []);
    return {
      ...collectionAPI,
      options: Array.from(optionsById.current.values()),
      registerOption
    };
  };

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useSelection.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React105 = __toESM(require_react());
  var useSelection = (props) => {
    const { defaultSelectedOptions, multiselect, onOptionSelect } = props;
    const [selectedOptions, setSelectedOptions] = useControllableState({
      state: props.selectedOptions,
      defaultState: defaultSelectedOptions,
      initialState: []
    });
    const selectOption = React105.useCallback((event, option) => {
      if (option.disabled) {
        return;
      }
      let newSelection = [
        option.value
      ];
      if (multiselect) {
        const selectedIndex = selectedOptions.findIndex((o) => o === option.value);
        if (selectedIndex > -1) {
          newSelection = [
            ...selectedOptions.slice(0, selectedIndex),
            ...selectedOptions.slice(selectedIndex + 1)
          ];
        } else {
          newSelection = [
            ...selectedOptions,
            option.value
          ];
        }
      }
      setSelectedOptions(newSelection);
      onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
        optionValue: option.value,
        optionText: option.text,
        selectedOptions: newSelection
      });
    }, [
      onOptionSelect,
      multiselect,
      selectedOptions,
      setSelectedOptions
    ]);
    const clearSelection = (event) => {
      setSelectedOptions([]);
      onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
        optionValue: void 0,
        optionText: void 0,
        selectedOptions: []
      });
    };
    return {
      clearSelection,
      selectOption,
      selectedOptions
    };
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/useOptionStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var optionClassNames = {
    root: "fui-Option",
    checkIcon: "fui-Option__checkIcon"
  };
  var useStyles5 = /* @__PURE__ */ __styles2({
    root: {
      Bt984gj: "f122n59",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      sj55zd: "f19n0e5",
      i8kkvl: "f1ufnopg",
      Bceei9c: "f1k6fduh",
      mc9l5x: "f22iagw",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bg96gwp: "f1i3iumi",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fm5eomj",
      qhf8xq: "f10pi13n",
      Jwef8y: "f1knas48",
      Bi91k9c: "feu1g3u",
      zqbkvg: "fo79ri9",
      h82x05: ["f1osiabc", "f1e8le25"],
      cqj998: "f1yusjty",
      j3hlsh: ["f1e8le25", "f1osiabc"],
      ecr2s2: "fb40n2d",
      lj723h: "f1g4hkjv",
      Btxx2vb: "f1lnr2zp",
      sltcwy: ["f1ogfk9z", "f1g7j8ec"],
      dnwvvm: "fiuf46r",
      Blyvkvs: ["f1g7j8ec", "f1ogfk9z"]
    },
    active: {
      Bowz1zl: "f11vrvdw",
      oxogb1: "f17hxjb7",
      Ix2sn8: "f1dha69c",
      q7v32p: "f1lm7500",
      B7cbj04: 0,
      Bewtojm: 0,
      b50fsz: 0,
      B1wzb3v: 0,
      Bqwk70n: 0,
      B37u8z8: 0,
      avt0cx: 0,
      f0sref: 0,
      B9fkznv: 0,
      Be3o27t: 0,
      Bertapg: 0,
      B53xpsf: 0,
      Bsv72rj: 0,
      B39dzdd: 0,
      Btq9bd3: 0,
      Bqfxd14: 0,
      atup0s: "fo7xqb",
      Fffuxt: 0,
      Bttcd12: 0,
      Beitzug: 0,
      Bqougee: 0,
      B86i8pi: "f1kurthe",
      Bhijsxg: "fwq15dy",
      kktds4: "f1pb3wry",
      Bmau3bo: ["ftjv2f4", "f1flhb1f"],
      npektv: ["f1flhb1f", "ftjv2f4"]
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      Jwef8y: "f9ql6rf",
      Bi91k9c: "fvgxktp",
      zqbkvg: "f185j3qj",
      h82x05: ["f1dligi3", "f1vydzie"],
      cqj998: "fjw1di3",
      j3hlsh: ["f1vydzie", "f1dligi3"],
      ecr2s2: "fgj9um3",
      lj723h: "f19wldhg",
      Btxx2vb: "f1ss0kt2",
      sltcwy: ["f1t6oli3", "fjy9ci8"],
      dnwvvm: "fresaxk",
      Blyvkvs: ["fjy9ci8", "f1t6oli3"],
      Bbusuzp: "f1dcs8yz"
    },
    selected: {},
    checkIcon: {
      Bnnss6s: "fi64zpg",
      Be2twd7: "fod5ikn",
      Frg6f3: ["f18b9hdq", "fn6qj8t"],
      t21cq0: ["f1xk557c", "f1h9en5y"],
      Bcdw1i0: "fd7fpy0",
      Bo70h7d: "fvc9v3g"
    },
    selectedCheck: {
      Bcdw1i0: "f1022m68"
    },
    multiselectCheck: {
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1l3cf7o",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fq9zq91",
      B7ck84d: "f1ewtqcl",
      mc9l5x: "f22iagw",
      Bt984gj: "f122n59",
      Brf1p80: "f4d9j23",
      Bkfmm31: "f1w9h62z",
      Be2twd7: "f1ugzwwg",
      Bqenvij: "fd461yt",
      a9b677: "fjw5fx7",
      Bcdw1i0: "f1022m68"
    },
    selectedMultiselectCheck: {
      De3pzq: "ftywsgz",
      sj55zd: "fqpbvvt",
      g2u3we: "f3xi7mh",
      h3c5rm: ["ftovhe4", "f1wczvin"],
      B9xav0g: "f68vbr6",
      zhjwy3: ["f1wczvin", "ftovhe4"]
    },
    checkDisabled: {
      sj55zd: "f1s2aq7o",
      Bbusuzp: "f1dcs8yz"
    },
    multiselectCheckDisabled: {
      g2u3we: "f1r1t4y1",
      h3c5rm: ["fmj8ijw", "figx54m"],
      B9xav0g: "f360ss8",
      zhjwy3: ["figx54m", "fmj8ijw"]
    }
  }, {
    d: [".f122n59{align-items:center;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f1k6fduh{cursor:pointer;}", ".f22iagw{display:flex;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fm5eomj{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalS);}", {
      p: -1
    }], ".f10pi13n{position:relative;}", '.f11vrvdw[data-activedescendant-focusvisible]::after{content:"";}', ".f17hxjb7[data-activedescendant-focusvisible]::after{position:absolute;}", ".f1dha69c[data-activedescendant-focusvisible]::after{pointer-events:none;}", ".f1lm7500[data-activedescendant-focusvisible]::after{z-index:1;}", [".fo7xqb[data-activedescendant-focusvisible]::after{border:2px solid var(--colorStrokeFocus2);}", {
      p: -2
    }], [".f1kurthe[data-activedescendant-focusvisible]::after{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fwq15dy[data-activedescendant-focusvisible]::after{top:-2px;}", ".f1pb3wry[data-activedescendant-focusvisible]::after{bottom:-2px;}", ".ftjv2f4[data-activedescendant-focusvisible]::after{left:-2px;}", ".f1flhb1f[data-activedescendant-focusvisible]::after{right:-2px;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fi64zpg{flex-shrink:0;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f18b9hdq{margin-left:calc(var(--spacingHorizontalXXS) * -1);}", ".fn6qj8t{margin-right:calc(var(--spacingHorizontalXXS) * -1);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".fd7fpy0{visibility:hidden;}", ".fvc9v3g svg{display:block;}", ".f1022m68{visibility:visible;}", [".f1l3cf7o{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
      p: -2
    }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
      p: -1
    }], ".f1ewtqcl{box-sizing:border-box;}", ".f4d9j23{justify-content:center;}", ".f1w9h62z{fill:currentColor;}", ".f1ugzwwg{font-size:12px;}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".f3xi7mh{border-top-color:var(--colorCompoundBrandBackground);}", ".ftovhe4{border-right-color:var(--colorCompoundBrandBackground);}", ".f1wczvin{border-left-color:var(--colorCompoundBrandBackground);}", ".f68vbr6{border-bottom-color:var(--colorCompoundBrandBackground);}", ".f1r1t4y1{border-top-color:var(--colorNeutralForegroundDisabled);}", ".fmj8ijw{border-right-color:var(--colorNeutralForegroundDisabled);}", ".figx54m{border-left-color:var(--colorNeutralForegroundDisabled);}", ".f360ss8{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
    h: [".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".fo79ri9:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1osiabc:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1e8le25:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".f1yusjty:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f185j3qj:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1dligi3:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".f1vydzie:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fjw1di3:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
    a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1lnr2zp:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1ogfk9z:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1g7j8ec:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".fiuf46r:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".fgj9um3:active{background-color:var(--colorTransparentBackground);}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f1ss0kt2:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1t6oli3:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".fjy9ci8:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fresaxk:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
    m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useOptionStyles_unstable = (state) => {
    "use no memo";
    const {
      disabled,
      multiselect,
      selected
    } = state;
    const styles = useStyles5();
    state.root.className = mergeClasses(optionClassNames.root, styles.root, styles.active, disabled && styles.disabled, selected && styles.selected, state.root.className);
    if (state.checkIcon) {
      state.checkIcon.className = mergeClasses(optionClassNames.checkIcon, styles.checkIcon, multiselect && styles.multiselectCheck, selected && styles.selectedCheck, selected && multiselect && styles.selectedMultiselectCheck, disabled && styles.checkDisabled, disabled && multiselect && styles.multiselectCheckDisabled, state.checkIcon.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
  var UNSAFE_noLongerUsed = {
    activeOption: void 0,
    focusVisible: false,
    setActiveOption: () => null
  };
  var useListbox_unstable = (props, ref) => {
    "use no memo";
    const { multiselect, disableAutoFocus = false } = props;
    const optionCollection = useOptionCollection();
    const { listboxRef: activeDescendantListboxRef, activeParentRef, controller } = useActiveDescendant({
      matchOption: (el) => el.classList.contains(optionClassNames.root)
    });
    const hasListboxContext = useHasParentContext(ListboxContext);
    const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
    const contextGetOptionById = useListboxContext_unstable((ctx) => ctx.getOptionById);
    const contextGetOptionsMatchingValue = useListboxContext_unstable((ctx) => ctx.getOptionsMatchingValue);
    const getOptionById = hasListboxContext ? contextGetOptionById : optionCollection.getOptionById;
    const getOptionsMatchingValue = hasListboxContext ? contextGetOptionsMatchingValue : optionCollection.getOptionsMatchingValue;
    const listenerRef = React106.useMemo(() => {
      let element4 = null;
      const listener = (untypedEvent) => {
        const event = untypedEvent;
        onActiveDescendantChange === null || onActiveDescendantChange === void 0 ? void 0 : onActiveDescendantChange(event);
      };
      return (el) => {
        if (!el) {
          element4 === null || element4 === void 0 ? void 0 : element4.removeEventListener("activedescendantchange", listener);
          return;
        }
        element4 = el;
        element4.addEventListener("activedescendantchange", listener);
      };
    }, [
      onActiveDescendantChange
    ]);
    const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = React106.useState(false);
    useOnKeyboardNavigationChange(setIsNavigatingWithKeyboard);
    const activeDescendantContext = useActiveDescendantContext();
    const hasParentActiveDescendantContext = useHasParentActiveDescendantContext();
    const activeDescendantController = hasParentActiveDescendantContext ? activeDescendantContext.controller : controller;
    const { clearSelection, selectedOptions, selectOption } = useSelection(props);
    const onKeyDown = (event) => {
      const action = getDropdownActionFromKey(event, {
        open: true
      });
      const activeOptionId = activeDescendantController.active();
      const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
      switch (action) {
        case "First":
        case "Last":
        case "Next":
        case "Previous":
        case "PageDown":
        case "PageUp":
        case "CloseSelect":
        case "Select":
          event.preventDefault();
          break;
      }
      switch (action) {
        case "Next":
          if (activeOption) {
            activeDescendantController.next();
          } else {
            activeDescendantController.first();
          }
          break;
        case "Previous":
          if (activeOption) {
            activeDescendantController.prev();
          } else {
            activeDescendantController.first();
          }
          break;
        case "PageUp":
        case "First":
          activeDescendantController.first();
          break;
        case "PageDown":
        case "Last":
          activeDescendantController.last();
          break;
        case "Select":
        case "CloseSelect":
          activeOption && selectOption(event, activeOption);
          break;
      }
    };
    const contextSelectedOptions = useListboxContext_unstable((ctx) => ctx.selectedOptions);
    const contextSelectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
    const optionContextValues = hasListboxContext ? {
      selectedOptions: contextSelectedOptions,
      selectOption: contextSelectOption,
      ...UNSAFE_noLongerUsed
    } : {
      selectedOptions,
      selectOption,
      ...UNSAFE_noLongerUsed
    };
    React106.useEffect(() => {
      if (hasParentActiveDescendantContext) {
        return;
      }
      activeDescendantController.hideFocusVisibleAttributes();
      if (!disableAutoFocus) {
        if (!multiselect && optionContextValues.selectedOptions.length > 0) {
          const selectedOption = getOptionsMatchingValue((v) => v === optionContextValues.selectedOptions[0]).pop();
          if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
            activeDescendantController.focus(selectedOption.id);
          }
        } else {
          activeDescendantController.first();
        }
      }
      return () => {
        activeDescendantController.blur();
      };
    }, []);
    const onFocus = React106.useCallback(() => {
      if (hasParentActiveDescendantContext) {
        return;
      }
      activeDescendantController.showFocusVisibleAttributes();
      if (isNavigatingWithKeyboard) {
        activeDescendantController.scrollActiveIntoView();
      }
    }, [
      activeDescendantController,
      hasParentActiveDescendantContext,
      isNavigatingWithKeyboard
    ]);
    const onBlur = React106.useCallback(() => {
      if (hasParentActiveDescendantContext) {
        return;
      }
      activeDescendantController.hideFocusVisibleAttributes();
    }, [
      activeDescendantController,
      hasParentActiveDescendantContext
    ]);
    const state = {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, activeParentRef, activeDescendantListboxRef, listenerRef),
        role: multiselect ? "menu" : "listbox",
        tabIndex: 0,
        ...props
      }), {
        elementType: "div"
      }),
      standalone: !hasListboxContext,
      multiselect,
      clearSelection,
      activeDescendantController,
      onActiveDescendantChange,
      ...optionCollection,
      ...optionContextValues
    };
    state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, onKeyDown));
    state.root.onFocus = useEventCallback(mergeCallbacks(state.root.onFocus, onFocus));
    state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlur));
    return state;
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/renderListbox.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderListbox_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(ActiveDescendantContextProvider, {
      value: contextValues.activeDescendant,
      children: /* @__PURE__ */ jsx2(ListboxContext.Provider, {
        value: contextValues.listbox,
        children: /* @__PURE__ */ jsx2(state.root, {})
      })
    });
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/useListboxStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var listboxClassNames = {
    root: "fui-Listbox"
  };
  var useStyles6 = /* @__PURE__ */ __styles2({
    root: {
      De3pzq: "fxugw4r",
      B7ck84d: "f1ewtqcl",
      mc9l5x: "f22iagw",
      Beiy3e4: "f1vx9l62",
      Bf4jedk: "f3hsy1e",
      Bmxbyg5: "f5zp4f",
      Bw0xxkn: 0,
      oeaueh: 0,
      Bpd4iqm: 0,
      Befb4lg: "f1iepc6i",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1t35pdg",
      Belr9w4: "fiut8dr"
    }
  }, {
    d: [".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f3hsy1e{min-width:160px;}", ".f5zp4f{overflow-y:auto;}", [".f1iepc6i{outline:1px solid var(--colorTransparentStroke);}", {
      p: -1
    }], [".f1t35pdg{padding:var(--spacingHorizontalXS);}", {
      p: -1
    }], ".fiut8dr{row-gap:var(--spacingHorizontalXXS);}"]
  });
  var useListboxStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles6();
    state.root.className = mergeClasses(listboxClassNames.root, styles.root, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
  var Listbox = /* @__PURE__ */ React107.forwardRef((props, ref) => {
    const state = useListbox_unstable(props, ref);
    const contextValues = useListboxContextValues(state);
    useListboxStyles_unstable(state);
    useCustomStyleHook("useListboxStyles_unstable")(state);
    return renderListbox_unstable(state, contextValues);
  });
  Listbox.displayName = "Listbox";

  // ../../node_modules/@fluentui/react-combobox/lib/Option.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React109 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/useOption.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React108 = __toESM(require_react());
  function getTextString(text9, children2) {
    if (text9 !== void 0) {
      return text9;
    }
    let textString = "";
    let hasNonStringChild = false;
    React108.Children.forEach(children2, (child) => {
      if (typeof child === "string") {
        textString += child;
      } else {
        hasNonStringChild = true;
      }
    });
    if (hasNonStringChild) {
      console.warn("Provide a `text` prop to Option components when they contain non-string children.");
    }
    return textString;
  }
  var useOption_unstable = (props, ref) => {
    const { children: children2, disabled, text: text9, value } = props;
    const optionRef = React108.useRef(null);
    const optionText = getTextString(text9, children2);
    const optionValue = value !== null && value !== void 0 ? value : optionText;
    const id = useId4("fluent-option", props.id);
    const optionData = React108.useMemo(() => ({
      id,
      disabled,
      text: optionText,
      value: optionValue
    }), [
      id,
      disabled,
      optionText,
      optionValue
    ]);
    const { controller: activeDescendantController } = useActiveDescendantContext();
    const multiselect = useListboxContext_unstable((ctx) => ctx.multiselect);
    const registerOption = useListboxContext_unstable((ctx) => ctx.registerOption);
    const selected = useListboxContext_unstable((ctx) => {
      const selectedOptions = ctx.selectedOptions;
      return optionValue !== void 0 && selectedOptions.find((o) => o === optionValue) !== void 0;
    });
    const selectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
    const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
    let CheckIcon = /* @__PURE__ */ React108.createElement(CheckmarkFilled, null);
    if (multiselect) {
      CheckIcon = selected ? /* @__PURE__ */ React108.createElement(Checkmark12Filled, null) : "";
    }
    const onClick = (event) => {
      var _props_onClick;
      if (disabled) {
        event.preventDefault();
        return;
      }
      activeDescendantController.focus(id);
      selectOption(event, optionData);
      onOptionClick(event);
      (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
    };
    React108.useEffect(() => {
      if (id && optionRef.current) {
        return registerOption(optionData, optionRef.current);
      }
    }, [
      id,
      optionData,
      registerOption
    ]);
    const semanticProps = multiselect ? {
      role: "menuitemcheckbox",
      "aria-checked": selected
    } : {
      role: "option",
      "aria-selected": selected
    };
    return {
      components: {
        root: "div",
        checkIcon: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, optionRef),
        "aria-disabled": disabled ? "true" : void 0,
        id,
        ...semanticProps,
        ...props,
        onClick
      }), {
        elementType: "div"
      }),
      checkIcon: slot_exports.optional(props.checkIcon, {
        renderByDefault: true,
        defaultProps: {
          "aria-hidden": "true",
          children: CheckIcon
        },
        elementType: "span"
      }),
      disabled,
      multiselect,
      selected,
      // no longer used
      focusVisible: false,
      active: false
    };
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/renderOption.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderOption_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.checkIcon && /* @__PURE__ */ jsx2(state.checkIcon, {}),
        state.root.children
      ]
    });
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
  var Option = /* @__PURE__ */ React109.forwardRef((props, ref) => {
    const state = useOption_unstable(props, ref);
    useOptionStyles_unstable(state);
    useCustomStyleHook("useOptionStyles_unstable")(state);
    return renderOption_unstable(state);
  });
  Option.displayName = "Option";

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useComboboxBaseState.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React110 = __toESM(require_react());
  var ReactDOM2 = __toESM(require_react_dom());
  var useComboboxBaseState = (props) => {
    "use no memo";
    const { appearance = "outline", disableAutoFocus, children: children2, clearable = false, editable = false, inlinePopup = false, mountNode = void 0, multiselect, onOpenChange, size: size3 = "medium", activeDescendantController, freeform = false, disabled = false, onActiveOptionChange = null } = props;
    const optionCollection = useOptionCollection();
    const { getOptionsMatchingValue } = optionCollection;
    const { getOptionById } = optionCollection;
    const getActiveOption = React110.useCallback(() => {
      const activeOptionId = activeDescendantController.active();
      return activeOptionId ? getOptionById(activeOptionId) : void 0;
    }, [
      activeDescendantController,
      getOptionById
    ]);
    const UNSAFE_activeOption = getActiveOption();
    const UNSAFE_setActiveOption = React110.useCallback((option) => {
      let nextOption = void 0;
      if (typeof option === "function") {
        const activeOption = getActiveOption();
        nextOption = option(activeOption);
      }
      if (nextOption) {
        activeDescendantController.focus(nextOption.id);
      } else {
        activeDescendantController.blur();
      }
    }, [
      activeDescendantController,
      getActiveOption
    ]);
    const [focusVisible, setFocusVisible] = React110.useState(false);
    const [hasFocus, setHasFocus] = React110.useState(false);
    const ignoreNextBlur = React110.useRef(false);
    const isFirstMount = useFirstMount();
    const [controllableValue, setValue] = useControllableState({
      state: props.value,
      initialState: void 0
    });
    const { selectedOptions, selectOption: baseSelectOption, clearSelection } = useSelection(props);
    const selectOption = React110.useCallback((ev, option) => {
      ReactDOM2.unstable_batchedUpdates(() => {
        setValue(void 0);
        baseSelectOption(ev, option);
      });
    }, [
      setValue,
      baseSelectOption
    ]);
    const value = React110.useMemo(() => {
      if (controllableValue !== void 0) {
        return controllableValue;
      }
      if (isFirstMount && props.defaultValue !== void 0) {
        return props.defaultValue;
      }
      const selectedOptionsText = getOptionsMatchingValue((optionValue) => {
        return selectedOptions.includes(optionValue);
      }).map((option) => option.text);
      if (multiselect) {
        return editable ? "" : selectedOptionsText.join(", ");
      }
      return selectedOptionsText[0];
    }, [
      controllableValue,
      editable,
      getOptionsMatchingValue,
      multiselect,
      selectedOptions
    ]);
    const [open, setOpenState] = useControllableState({
      state: props.open,
      defaultState: props.defaultOpen,
      initialState: false
    });
    const setOpen = React110.useCallback((event, newState) => {
      if (disabled) {
        return;
      }
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
        open: newState
      });
      ReactDOM2.unstable_batchedUpdates(() => {
        if (!newState && !freeform) {
          setValue(void 0);
        }
        setOpenState(newState);
      });
    }, [
      onOpenChange,
      setOpenState,
      setValue,
      freeform,
      disabled
    ]);
    React110.useEffect(() => {
      if (open) {
        if (!multiselect && selectedOptions.length > 0) {
          const selectedOption = getOptionsMatchingValue((v) => v === selectedOptions[0]).pop();
          if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
            activeDescendantController.focus(selectedOption.id);
          }
        }
      } else {
        activeDescendantController.blur();
      }
    }, [
      open,
      activeDescendantController
    ]);
    React110.useEffect(() => {
      if (open && !disableAutoFocus && !activeDescendantController.active()) {
        activeDescendantController.first();
      }
    }, [
      open,
      children2,
      disableAutoFocus,
      activeDescendantController,
      getOptionById
    ]);
    const onActiveDescendantChange = useEventCallback((event) => {
      const previousOption = event.detail.previousId ? optionCollection.getOptionById(event.detail.previousId) : null;
      const nextOption = optionCollection.getOptionById(event.detail.id);
      onActiveOptionChange === null || onActiveOptionChange === void 0 ? void 0 : onActiveOptionChange(event, {
        event,
        type: "change",
        previousOption,
        nextOption
      });
    });
    return {
      ...optionCollection,
      freeform,
      disabled,
      selectOption,
      clearSelection,
      selectedOptions,
      activeOption: UNSAFE_activeOption,
      appearance,
      clearable,
      focusVisible,
      ignoreNextBlur,
      inlinePopup,
      mountNode,
      open,
      hasFocus,
      setActiveOption: UNSAFE_setActiveOption,
      setFocusVisible,
      setHasFocus,
      setOpen,
      setValue,
      size: size3,
      value,
      multiselect,
      onOptionClick: useEventCallback((e) => {
        if (!multiselect) {
          setOpen(e, false);
        }
      }),
      onActiveDescendantChange
    };
  };

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useComboboxPositioning.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React111 = __toESM(require_react());
  function useComboboxPositioning(props) {
    const { positioning } = props;
    const fallbackPositions = [
      "above",
      "after",
      "after-top",
      "before",
      "before-top"
    ];
    const popperOptions = {
      position: "below",
      align: "start",
      offset: {
        crossAxis: 0,
        mainAxis: 2
      },
      fallbackPositions,
      matchTargetSize: "width",
      autoSize: true,
      ...resolvePositioningShorthand(positioning)
    };
    const { targetRef, containerRef } = usePositioning(popperOptions);
    return [
      containerRef,
      targetRef
    ];
  }

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useListboxSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React112 = __toESM(require_react());
  function useListboxSlot(listboxSlotFromProp, ref, options) {
    const { state: { multiselect }, triggerRef, defaultProps } = options;
    const listboxId = useId4("fluent-listbox", isResolvedShorthand(listboxSlotFromProp) ? listboxSlotFromProp.id : void 0);
    const listboxSlot = slot_exports.optional(listboxSlotFromProp, {
      renderByDefault: true,
      elementType: Listbox,
      defaultProps: {
        id: listboxId,
        multiselect,
        tabIndex: void 0,
        ...defaultProps
      }
    });
    const fieldControlProps = useFieldControlProps_unstable({
      id: listboxId
    }, {
      supportsLabelFor: true
    });
    if (listboxSlot && !listboxSlot["aria-label"] && !listboxSlot["aria-labelledby"] && fieldControlProps["aria-labelledby"]) {
      listboxSlot["aria-labelledby"] = fieldControlProps["aria-labelledby"];
    }
    const onMouseDown = useEventCallback(mergeCallbacks((event) => {
      event.preventDefault();
    }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onMouseDown));
    const onClick = useEventCallback(mergeCallbacks((event) => {
      var _triggerRef_current;
      event.preventDefault();
      (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onClick));
    const listboxRef = useMergedRefs(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, ref);
    if (listboxSlot) {
      listboxSlot.ref = listboxRef;
      listboxSlot.onMouseDown = onMouseDown;
      listboxSlot.onClick = onClick;
    }
    return listboxSlot;
  }

  // ../../node_modules/@fluentui/react-combobox/lib/utils/useTriggerSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React113 = __toESM(require_react());
  function useTriggerSlot(triggerSlotFromProp, ref, options) {
    const { state: { open, setOpen, setHasFocus }, defaultProps, elementType, activeDescendantController } = options;
    const trigger = slot_exports.always(triggerSlotFromProp, {
      defaultProps: {
        type: "text",
        "aria-expanded": open,
        role: "combobox",
        ...typeof defaultProps === "object" && defaultProps
      },
      elementType
    });
    const triggerRef = React113.useRef(null);
    trigger.ref = useMergedRefs(triggerRef, trigger.ref, ref);
    trigger.onBlur = mergeCallbacks((event) => {
      setOpen(event, false);
      setHasFocus(false);
    }, trigger.onBlur);
    trigger.onFocus = mergeCallbacks((event) => {
      if (event.target === event.currentTarget) {
        setHasFocus(true);
      }
    }, trigger.onFocus);
    trigger.onClick = mergeCallbacks((event) => {
      setOpen(event, !open);
    }, trigger.onClick);
    trigger.onKeyDown = mergeCallbacks(useTriggerKeydown({
      activeDescendantController,
      ...options.state
    }), trigger.onKeyDown);
    return trigger;
  }
  function useTriggerKeydown(options) {
    const { activeDescendantController, getOptionById, setOpen, selectOption, multiselect, open } = options;
    const getActiveOption = React113.useCallback(() => {
      const activeOptionId = activeDescendantController.active();
      return activeOptionId ? getOptionById(activeOptionId) : void 0;
    }, [
      activeDescendantController,
      getOptionById
    ]);
    const first = () => {
      activeDescendantController.first();
    };
    const last = () => {
      activeDescendantController.last();
    };
    const next2 = (activeOption) => {
      if (activeOption) {
        activeDescendantController.next();
      } else {
        activeDescendantController.first();
      }
    };
    const previous3 = (activeOption) => {
      if (activeOption) {
        activeDescendantController.prev();
      } else {
        activeDescendantController.first();
      }
    };
    const pageUp = () => {
      for (let i = 0; i < 10; i++) {
        activeDescendantController.prev();
      }
    };
    const pageDown = () => {
      for (let i = 0; i < 10; i++) {
        activeDescendantController.next();
      }
    };
    const setKeyboardNavigation = useSetKeyboardNavigation();
    return useEventCallback((e) => {
      const action = getDropdownActionFromKey(e, {
        open,
        multiselect
      });
      const activeOption = getActiveOption();
      switch (action) {
        case "First":
        case "Last":
        case "Next":
        case "Previous":
        case "PageDown":
        case "PageUp":
        case "Open":
        case "Close":
        case "CloseSelect":
        case "Select":
          e.preventDefault();
          break;
      }
      setKeyboardNavigation(true);
      switch (action) {
        case "First":
          first();
          break;
        case "Last":
          last();
          break;
        case "Next":
          next2(activeOption);
          break;
        case "Previous":
          previous3(activeOption);
          break;
        case "PageDown":
          pageDown();
          break;
        case "PageUp":
          pageUp();
          break;
        case "Open":
          setOpen(e, true);
          break;
        case "Close":
          e.stopPropagation();
          setOpen(e, false);
          break;
        case "CloseSelect":
          !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(e, false);
        // fallthrough
        case "Select":
          activeOption && selectOption(e, activeOption);
          break;
        case "Tab":
          !multiselect && activeOption && selectOption(e, activeOption);
          break;
      }
    });
  }

  // ../../node_modules/@fluentui/react-combobox/lib/Dropdown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React116 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React115 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/useButtonTriggerSlot.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React114 = __toESM(require_react());
  function useButtonTriggerSlot(triggerFromProps, ref, options) {
    "use no memo";
    const { state: { open, setOpen, getOptionById }, defaultProps, activeDescendantController } = options;
    const searchString = React114.useRef("");
    const [setKeyTimeout, clearKeyTimeout] = useTimeout();
    const moveToNextMatchingOption = (matcher, opt = {
      startFromNext: false
    }) => {
      const { startFromNext } = opt;
      const activeOptionId = activeDescendantController.active();
      const nextInOrder = activeDescendantController.find((id) => {
        const option = getOptionById(id);
        return !!option && matcher(option.text);
      }, {
        startFrom: startFromNext ? activeDescendantController.next({
          passive: true
        }) : activeOptionId
      });
      if (nextInOrder) {
        return nextInOrder;
      }
      return activeDescendantController.find((id) => {
        const option = getOptionById(id);
        return !!option && matcher(option.text);
      });
    };
    const moveToNextMatchingOptionWithSameCharacterHandling = () => {
      if (moveToNextMatchingOption((optionText) => {
        return optionText.toLocaleLowerCase().indexOf(searchString.current) === 0;
      }, {
        // Slowly pressing the same key will cycle through options
        startFromNext: searchString.current.length === 1
      })) {
        return;
      }
      if (allCharactersSame(searchString.current) && moveToNextMatchingOption((optionText) => {
        return optionText.toLocaleLowerCase().indexOf(searchString.current[0]) === 0;
      }, {
        // if the search is all the same letter, cycle through options starting with that letter
        startFromNext: true
      })) {
        return;
      }
      activeDescendantController.blur();
    };
    const onTriggerKeyDown = (ev) => {
      clearKeyTimeout();
      if (getDropdownActionFromKey(ev) === "Type") {
        searchString.current += ev.key.toLowerCase();
        setKeyTimeout(() => {
          searchString.current = "";
        }, 500);
        if (open) {
          moveToNextMatchingOptionWithSameCharacterHandling();
        }
        !open && setOpen(ev, true);
      }
    };
    const trigger = useTriggerSlot(triggerFromProps, ref, {
      state: options.state,
      defaultProps,
      elementType: "button",
      activeDescendantController
    });
    trigger.onKeyDown = mergeCallbacks(onTriggerKeyDown, trigger.onKeyDown);
    return trigger;
  }
  function allCharactersSame(str) {
    for (let i = 1; i < str.length; i++) {
      if (str[i] !== str[i - 1]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
  var useDropdown_unstable = (props, ref) => {
    "use no memo";
    var _state_clearButton;
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsSize: true
    });
    const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({
      matchOption: (el) => el.classList.contains(optionClassNames.root)
    });
    const baseState = useComboboxBaseState({
      ...props,
      activeDescendantController,
      freeform: false
    });
    const { clearable, clearSelection, disabled, hasFocus, multiselect, open, selectedOptions, setOpen } = baseState;
    const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
      props,
      primarySlotTagName: "button",
      excludedPropNames: [
        "children"
      ]
    });
    const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
    const triggerRef = React115.useRef(null);
    const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
      state: baseState,
      triggerRef,
      defaultProps: {
        children: props.children
      }
    });
    const { targetDocument } = useFluent();
    useOnClickOutside({
      element: targetDocument,
      callback: (event) => setOpen(event, false),
      refs: [
        triggerRef,
        comboboxPopupRef,
        comboboxTargetRef
      ],
      disabled: !open
    });
    var _props_button;
    const trigger = useButtonTriggerSlot((_props_button = props.button) !== null && _props_button !== void 0 ? _props_button : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
      state: baseState,
      defaultProps: {
        type: "button",
        // tabster navigation breaks if the button is disabled and tabIndex is 0
        tabIndex: triggerNativeProps.disabled ? void 0 : 0,
        children: baseState.value || props.placeholder,
        "aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
        ...triggerNativeProps
      },
      activeDescendantController
    });
    const rootSlot = slot_exports.always(props.root, {
      defaultProps: {
        "aria-owns": !props.inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
        children: props.children,
        ...rootNativeProps
      },
      elementType: "div"
    });
    rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
    const showClearButton = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
    const state = {
      components: {
        root: "div",
        button: "button",
        clearButton: "button",
        expandIcon: "span",
        listbox: Listbox
      },
      root: rootSlot,
      button: trigger,
      listbox: open || hasFocus ? listbox : void 0,
      clearButton: slot_exports.optional(props.clearButton, {
        defaultProps: {
          "aria-label": "Clear selection",
          children: /* @__PURE__ */ React115.createElement(DismissRegular, null),
          // Safari doesn't allow to focus an element with this
          // when the element is not visible (display: none) we need to remove it to avoid tabster issues
          tabIndex: showClearButton ? 0 : void 0,
          type: "button"
        },
        elementType: "button",
        renderByDefault: true
      }),
      expandIcon: slot_exports.optional(props.expandIcon, {
        renderByDefault: true,
        defaultProps: {
          children: /* @__PURE__ */ React115.createElement(ChevronDownRegular, null)
        },
        elementType: "span"
      }),
      placeholderVisible: !baseState.value && !!props.placeholder,
      showClearButton,
      activeDescendantController,
      ...baseState
    };
    const onClearButtonClick = useEventCallback(mergeCallbacks((_state_clearButton = state.clearButton) === null || _state_clearButton === void 0 ? void 0 : _state_clearButton.onClick, (ev) => {
      var _triggerRef_current;
      clearSelection(ev);
      (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }));
    if (state.clearButton) {
      state.clearButton.onClick = onClearButtonClick;
    }
    if (multiselect) {
      state.clearButton = void 0;
    }
    if (false) {
      React115.useEffect(() => {
        if (clearable && multiselect) {
          console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
        }
      }, [
        clearable,
        multiselect
      ]);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/renderDropdown.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDropdown_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {
      children: /* @__PURE__ */ jsx2(ActiveDescendantContextProvider, {
        value: contextValues.activeDescendant,
        children: /* @__PURE__ */ jsx2(ListboxContext.Provider, {
          value: contextValues.listbox,
          children: /* @__PURE__ */ jsxs2(ComboboxContext.Provider, {
            value: contextValues.combobox,
            children: [
              /* @__PURE__ */ jsxs2(state.button, {
                children: [
                  state.button.children,
                  state.expandIcon && /* @__PURE__ */ jsx2(state.expandIcon, {})
                ]
              }),
              state.clearButton && /* @__PURE__ */ jsx2(state.clearButton, {}),
              state.listbox && (state.inlinePopup ? /* @__PURE__ */ jsx2(state.listbox, {}) : /* @__PURE__ */ jsx2(Portal, {
                mountNode: state.mountNode,
                children: /* @__PURE__ */ jsx2(state.listbox, {})
              }))
            ]
          })
        })
      })
    });
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdownStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var dropdownClassNames = {
    root: "fui-Dropdown",
    button: "fui-Dropdown__button",
    clearButton: "fui-Dropdown__clearButton",
    expandIcon: "fui-Dropdown__expandIcon",
    listbox: "fui-Dropdown__listbox"
  };
  var useStyles7 = /* @__PURE__ */ __styles2({
    root: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      B7ck84d: "f1ewtqcl",
      mc9l5x: "ftuwxu6",
      Bf4jedk: "f1exfvgq",
      qhf8xq: "f10pi13n",
      ha4doy: "fmrv4ls",
      Bbr2w1p: "f14a1fxs",
      Bduesf4: "f3e99gv",
      Bpq79vn: "fhljsf7",
      li1rpt: "f1gw3sf2",
      Bsft5z2: "f13zj6fq",
      E3zdtr: "f1mdlcz9",
      Eqx8gd: ["f1a7op3", "f1cjjd47"],
      By385i5: "f1gboi2j",
      B1piin3: ["f1cjjd47", "f1a7op3"],
      Dlnsje: "ffyw7fx",
      d9w3h3: ["f1kp91vd", "f1ibwz09"],
      B3778ie: ["f1ibwz09", "f1kp91vd"],
      B1q35kw: 0,
      Bw17bha: 0,
      Bcgy8vk: 0,
      Bjuhk93: "f1mnjydx",
      Gjdm7m: "f13evtba",
      b1kco5: "f1yk9hq",
      Ba2ppi3: "fhwpy7i",
      F2fol1: "f14ee0xe",
      lck23g: "f1xhbsuh",
      df92cz: "fv8e3ye",
      I188md: "ftb5wc6",
      umuwi5: "fjw5xc1",
      Blcqepd: "f1xdyd5c",
      nplu4u: "fatpbeo",
      Bioka5o: "fb7uyps",
      H713fs: "f1cmft4k",
      B9ooomg: "f1x58t8o",
      Bercvud: "f1ibeo51",
      Bz04dq9: "f132nw8t",
      Budl3uf: "f1htdosj"
    },
    listbox: {
      B7ck84d: "f1ewtqcl",
      E5pizo: "f1hg901r",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Bxyxcbc: "fmmk62d"
    },
    listboxCollapsed: {
      mc9l5x: "fjseox"
    },
    inlineListbox: {
      Bj3rh1h: "f19g0ac"
    },
    button: {
      Bt984gj: "f122n59",
      De3pzq: "f1c21dwh",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f3bhgqh",
      B7ck84d: "f1ewtqcl",
      sj55zd: "f19n0e5",
      i8kkvl: "f14mj54c",
      Bceei9c: "f1k6fduh",
      mc9l5x: "f13qh94s",
      Bahqtrf: "fk6fouc",
      Budl1dq: "f12nh0o2",
      Brf1p80: "f1869bpl",
      fsow6f: ["f1o700av", "fes3tcz"],
      a9b677: "fly5x3f",
      Brovlpu: "ftqa4ok"
    },
    placeholder: {
      sj55zd: "fxc4j92"
    },
    small: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: ["fye6m5k", "f3cq2dl"]
    },
    medium: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: ["f14ev680", "f58uxzw"]
    },
    large: {
      i8kkvl: "f1rjii52",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: ["f139mn7i", "f1v3q0m"]
    },
    outline: {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: "f1c1zstj",
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fhz96rm"
    },
    outlineInteractive: {
      Bgoe8wy: "fvcxoqz",
      Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
      oetu4i: "f1l4zc64",
      gg5e9n: ["f1m52nbi", "f1ub3y4t"],
      B6oc9vd: "fvs00aa",
      ak43y8: ["f1assf6x", "f4ruux4"],
      wmxk5l: "f1z0osm6",
      B50zh58: ["f4ruux4", "f1assf6x"],
      Bvq3b66: "f1b473iu",
      Brahy3i: ["f381qr8", "ft4skwv"],
      zoxjo1: "f1qzcrsd",
      an54nd: ["ft4skwv", "f381qr8"]
    },
    underline: {
      De3pzq: "f1c21dwh",
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      Bgfg5da: "f9ez7ne",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fokr779"
    },
    "filled-lighter": {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fs2rfia"
    },
    "filled-darker": {
      De3pzq: "f16xq7d1",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fs2rfia"
    },
    invalid: {
      tvckwq: "fs4k3qj",
      gk2u95: ["fcee079", "fmyw78r"],
      hhx65j: "f1fgmyf4",
      Bxowmz0: ["fmyw78r", "fcee079"]
    },
    invalidUnderline: {
      hhx65j: "f1fgmyf4"
    },
    disabled: {
      Bceei9c: "fdrzuqr",
      De3pzq: "f1c21dwh",
      g2u3we: "f1jj8ep1",
      h3c5rm: ["f15xbau", "fy0fskl"],
      B9xav0g: "f4ikngz",
      zhjwy3: ["fy0fskl", "f15xbau"],
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"]
    },
    disabledText: {
      sj55zd: "f1s2aq7o",
      Bceei9c: "fdrzuqr"
    },
    hidden: {
      mc9l5x: "fjseox"
    }
  }, {
    d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f1ewtqcl{box-sizing:border-box;}", ".ftuwxu6{display:inline-flex;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
      p: -1
    }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f19g0ac{z-index:1;}", ".f122n59{align-items:center;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
      p: -2
    }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1k6fduh{cursor:pointer;}", ".f13qh94s{display:grid;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f12nh0o2{grid-template-columns:[content] 1fr [icon] auto [end];}", ".f1869bpl{justify-content:space-between;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fly5x3f{width:100%;}", ".fxc4j92{color:var(--colorNeutralForeground4);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], [".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", {
      p: -1
    }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], [".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", {
      p: -1
    }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
      p: -1
    }], [".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", {
      p: -1
    }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
      p: -2
    }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
      p: -1
    }], [".fokr779{border-radius:0;}", {
      p: -1
    }], [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
      p: -2
    }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
      p: -2
    }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
    w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
    m: [["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]],
    t: ["@supports selector(:has(*)){.f132nw8t:has(.fui-Dropdown__clearButton:focus)::after{border-bottom-color:initial;}}", "@supports selector(:has(*)){.f1htdosj:has(.fui-Dropdown__clearButton:focus)::after{transform:scaleX(0);}}"],
    f: [".ftqa4ok:focus{outline-style:none;}"],
    h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
    a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
  });
  var useIconStyles3 = /* @__PURE__ */ __styles2({
    icon: {
      B7ck84d: "f1ewtqcl",
      sj55zd: "fxkbij4",
      mc9l5x: "ftgm304",
      Be2twd7: "f1pp30po",
      Br312pm: "f12w6cgp",
      Bw0ie65: "f8bv1bt",
      Bo70h7d: "fvc9v3g"
    },
    small: {
      Be2twd7: "f4ybsrx",
      Frg6f3: ["f1h9en5y", "f1xk557c"]
    },
    medium: {
      Be2twd7: "fe5j1ua",
      Frg6f3: ["f1h9en5y", "f1xk557c"]
    },
    large: {
      Be2twd7: "f1rt2boy",
      Frg6f3: ["f1t5qyk5", "f1ikr372"]
    },
    disabled: {
      sj55zd: "f1s2aq7o"
    }
  }, {
    d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".ftgm304{display:block;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f12w6cgp{grid-column-start:icon;}", ".f8bv1bt{grid-column-end:end;}", ".fvc9v3g svg{display:block;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"]
  });
  var useBaseClearButtonStyle = /* @__PURE__ */ __resetStyles2("rticfuj", "r1vp6jef", {
    r: [".rticfuj{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-right:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".rticfuj:focus{outline-style:none;}", ".rticfuj:focus-visible{outline-style:none;}", ".rticfuj[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rticfuj[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r1vp6jef{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-left:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".r1vp6jef:focus{outline-style:none;}", ".r1vp6jef:focus-visible{outline-style:none;}", ".r1vp6jef[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r1vp6jef[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.rticfuj[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r1vp6jef[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
  });
  var useDropdownStyles_unstable = (state) => {
    "use no memo";
    const {
      appearance,
      open,
      placeholderVisible,
      showClearButton,
      size: size3
    } = state;
    const invalid = `${state.button["aria-invalid"]}` === "true";
    const disabled = state.button.disabled;
    const styles = useStyles7();
    const iconStyles = useIconStyles3();
    const clearButtonStyle = useBaseClearButtonStyle();
    state.root.className = mergeClasses(dropdownClassNames.root, styles.root, styles[appearance], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
    state.button.className = mergeClasses(dropdownClassNames.button, styles.button, styles[size3], placeholderVisible && styles.placeholder, disabled && styles.disabledText, state.button.className);
    if (state.listbox) {
      state.listbox.className = mergeClasses(dropdownClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
    }
    if (state.expandIcon) {
      state.expandIcon.className = mergeClasses(dropdownClassNames.expandIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, showClearButton && styles.hidden, state.expandIcon.className);
    }
    if (state.clearButton) {
      state.clearButton.className = mergeClasses(dropdownClassNames.clearButton, clearButtonStyle, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, !showClearButton && styles.hidden, state.clearButton.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
  var Dropdown = /* @__PURE__ */ React116.forwardRef((props, ref) => {
    const state = useDropdown_unstable(props, ref);
    const contextValues = useComboboxContextValues(state);
    useDropdownStyles_unstable(state);
    useCustomStyleHook("useDropdownStyles_unstable")(state);
    return renderDropdown_unstable(state, contextValues);
  });
  Dropdown.displayName = "Dropdown";

  // ../../node_modules/@fluentui/react-input/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-input/lib/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-input/lib/components/Input/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-input/lib/components/Input/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React118 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-input/lib/components/Input/useInput.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React117 = __toESM(require_react());
  var useInput_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true,
      supportsSize: true
    });
    const overrides = useOverrides();
    var _overrides_inputDefaultAppearance;
    const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
    if (false) {
      console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
    }
    const [value, setValue] = useControllableState({
      state: props.value,
      defaultState: props.defaultValue,
      initialState: ""
    });
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "input",
      excludedPropNames: [
        "size",
        "onChange",
        "value",
        "defaultValue"
      ]
    });
    const state = {
      size: size3,
      appearance,
      components: {
        root: "span",
        input: "input",
        contentBefore: "span",
        contentAfter: "span"
      },
      input: slot_exports.always(props.input, {
        defaultProps: {
          type: "text",
          ref,
          ...nativeProps.primary
        },
        elementType: "input"
      }),
      contentAfter: slot_exports.optional(props.contentAfter, {
        elementType: "span"
      }),
      contentBefore: slot_exports.optional(props.contentBefore, {
        elementType: "span"
      }),
      root: slot_exports.always(props.root, {
        defaultProps: nativeProps.root,
        elementType: "span"
      })
    };
    state.input.value = value;
    state.input.onChange = useEventCallback((ev) => {
      const newValue = ev.target.value;
      onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
        value: newValue
      });
      setValue(newValue);
    });
    return state;
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/renderInput.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderInput_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.contentBefore && /* @__PURE__ */ jsx2(state.contentBefore, {}),
        /* @__PURE__ */ jsx2(state.input, {}),
        state.contentAfter && /* @__PURE__ */ jsx2(state.contentAfter, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/useInputStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var inputClassNames = {
    root: "fui-Input",
    input: "fui-Input__input",
    contentBefore: "fui-Input__contentBefore",
    contentAfter: "fui-Input__contentAfter"
  };
  var horizontalPadding = {
    root: {
      small: tokens.spacingHorizontalSNudge,
      medium: tokens.spacingHorizontalMNudge,
      large: tokens.spacingHorizontalM
    },
    input: {
      small: tokens.spacingHorizontalXXS,
      medium: tokens.spacingHorizontalXXS,
      large: tokens.spacingHorizontalSNudge
    },
    combined: {
      small: tokens.spacingHorizontalS,
      medium: tokens.spacingHorizontalM,
      large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
    }
  };
  var useRootClassName4 = /* @__PURE__ */ __resetStyles2("r1oeeo9n", "r9sxh5", {
    r: [".r1oeeo9n{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r1oeeo9n::after{box-sizing:border-box;content:"";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1oeeo9n:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1oeeo9n:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1oeeo9n:focus-within{outline:2px solid transparent;}", ".r9sxh5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r9sxh5::after{box-sizing:border-box;content:"";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r9sxh5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r9sxh5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r9sxh5:focus-within{outline:2px solid transparent;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
  });
  var useRootStyles4 = /* @__PURE__ */ __styles2({
    small: {
      sshi5w: "f1pha7fy",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    medium: {},
    large: {
      sshi5w: "f1w5jphr",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k",
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "f1eyhf9v"
    },
    outline: {},
    outlineInteractive: {
      Bgoe8wy: "fvcxoqz",
      Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
      oetu4i: "f1l4zc64",
      gg5e9n: ["f1m52nbi", "f1ub3y4t"],
      Drbcw7: "f8vnjqi",
      udz0bu: ["fz1etlk", "f1hc16gm"],
      Be8ivqh: "f1klwx88",
      ofdepl: ["f1hc16gm", "fz1etlk"]
    },
    underline: {
      De3pzq: "f1c21dwh",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "fokr779",
      icvyot: "f1ern45e",
      vrafjx: ["f1n71otn", "f1deefiw"],
      wvpqe5: ["f1deefiw", "f1n71otn"],
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      B1piin3: ["f15yvnhg", "f1n6gb5g"]
    },
    underlineInteractive: {
      oetu4i: "f1l4zc64",
      Be8ivqh: "f1klwx88",
      d9w3h3: 0,
      B3778ie: 0,
      B4j8arr: 0,
      Bl18szs: 0,
      Blrzh8d: "f2ale1x"
    },
    filled: {
      g2u3we: "fghlq4f",
      h3c5rm: ["f1gn591s", "fjscplz"],
      B9xav0g: "fb073pr",
      zhjwy3: ["fjscplz", "f1gn591s"]
    },
    filledInteractive: {
      q7v0qe: "ftmjh5b",
      kmh5ft: ["f17blpuu", "fsrcdbj"],
      nagaa4: "f1tpwn32",
      B1yhkcb: ["fsrcdbj", "f17blpuu"]
    },
    invalid: {
      tvckwq: "fs4k3qj",
      gk2u95: ["fcee079", "fmyw78r"],
      hhx65j: "f1fgmyf4",
      Bxowmz0: ["fmyw78r", "fcee079"]
    },
    "filled-darker": {
      De3pzq: "f16xq7d1"
    },
    "filled-lighter": {
      De3pzq: "fxugw4r"
    },
    "filled-darker-shadow": {
      De3pzq: "f16xq7d1",
      E5pizo: "fyed02w"
    },
    "filled-lighter-shadow": {
      De3pzq: "fxugw4r",
      E5pizo: "fyed02w"
    },
    disabled: {
      Bceei9c: "fdrzuqr",
      De3pzq: "f1c21dwh",
      g2u3we: "f1jj8ep1",
      h3c5rm: ["f15xbau", "fy0fskl"],
      B9xav0g: "f4ikngz",
      zhjwy3: ["fy0fskl", "f15xbau"],
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"],
      Bsft5z2: "fhr9occ",
      Bduesf4: "f99w1ws"
    },
    smallWithContentBefore: {
      uwmqm3: ["fk8j09s", "fdw0yi8"]
    },
    smallWithContentAfter: {
      z189sj: ["fdw0yi8", "fk8j09s"]
    },
    mediumWithContentBefore: {
      uwmqm3: ["f1ng84yb", "f11gcy0p"]
    },
    mediumWithContentAfter: {
      z189sj: ["f11gcy0p", "f1ng84yb"]
    },
    largeWithContentBefore: {
      uwmqm3: ["f1uw59to", "fw5db7e"]
    },
    largeWithContentAfter: {
      z189sj: ["fw5db7e", "f1uw59to"]
    }
  }, {
    d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1w5jphr{min-height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
      p: -1
    }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".fokr779{border-radius:0;}", {
      p: -1
    }], ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", [".f2ale1x::after{border-radius:0;}", {
      p: -1
    }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fyed02w{box-shadow:var(--shadow2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhr9occ::after{content:unset;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}"],
    h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
    a: [".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
    m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }]],
    w: [".f99w1ws:focus-within{outline-style:none;}"]
  });
  var useInputClassName = /* @__PURE__ */ __resetStyles2("r12stul0", null, [".r12stul0{align-self:stretch;box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalM);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}", ".r12stul0::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
  var useInputElementStyles = /* @__PURE__ */ __styles2({
    small: {
      uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
      z189sj: ["f1vdfbxk", "f1f5gg8d"]
    },
    medium: {},
    large: {
      uwmqm3: ["fnphzt9", "flt1dlf"],
      z189sj: ["flt1dlf", "fnphzt9"]
    },
    smallWithContentBefore: {
      uwmqm3: ["fgiv446", "ffczdla"]
    },
    smallWithContentAfter: {
      z189sj: ["ffczdla", "fgiv446"]
    },
    mediumWithContentBefore: {
      uwmqm3: ["fgiv446", "ffczdla"]
    },
    mediumWithContentAfter: {
      z189sj: ["ffczdla", "fgiv446"]
    },
    largeWithContentBefore: {
      uwmqm3: ["fk8j09s", "fdw0yi8"]
    },
    largeWithContentAfter: {
      z189sj: ["fdw0yi8", "fk8j09s"]
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      De3pzq: "f1c21dwh",
      Bceei9c: "fdrzuqr",
      yvdlaj: "fahhnxm"
    }
  }, {
    d: [".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
  });
  var useContentClassName = /* @__PURE__ */ __resetStyles2("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
  var useContentStyles = /* @__PURE__ */ __styles2({
    disabled: {
      sj55zd: "f1s2aq7o"
    },
    small: {
      Duoase: "f3qv9w"
    },
    medium: {},
    large: {
      Duoase: "f16u2scb"
    }
  }, {
    d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
  });
  var useInputStyles_unstable = (state) => {
    "use no memo";
    const {
      size: size3,
      appearance
    } = state;
    const disabled = state.input.disabled;
    const invalid = `${state.input["aria-invalid"]}` === "true";
    const filled = appearance.startsWith("filled");
    const rootStyles = useRootStyles4();
    const inputStyles = useInputElementStyles();
    const contentStyles = useContentStyles();
    state.root.className = mergeClasses(inputClassNames.root, useRootClassName4(), rootStyles[size3], state.contentBefore && rootStyles[`${size3}WithContentBefore`], state.contentAfter && rootStyles[`${size3}WithContentAfter`], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
    state.input.className = mergeClasses(inputClassNames.input, useInputClassName(), inputStyles[size3], state.contentBefore && inputStyles[`${size3}WithContentBefore`], state.contentAfter && inputStyles[`${size3}WithContentAfter`], disabled && inputStyles.disabled, state.input.className);
    const contentClasses = [useContentClassName(), disabled && contentStyles.disabled, contentStyles[size3]];
    if (state.contentBefore) {
      state.contentBefore.className = mergeClasses(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
    }
    if (state.contentAfter) {
      state.contentAfter.className = mergeClasses(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-input/lib/components/Input/Input.js
  var Input = /* @__PURE__ */ React118.forwardRef((props, ref) => {
    const state = useInput_unstable(props, ref);
    useInputStyles_unstable(state);
    useCustomStyleHook("useInputStyles_unstable")(state);
    return renderInput_unstable(state);
  });
  Input.displayName = "Input";

  // ../../node_modules/@fluentui/react-image/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-image/lib/Image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-image/lib/components/Image/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-image/lib/components/Image/Image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React120 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-image/lib/components/Image/renderImage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderImage_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {});
  };

  // ../../node_modules/@fluentui/react-image/lib/components/Image/useImage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React119 = __toESM(require_react());
  var useImage_unstable = (props, ref) => {
    const { bordered = false, fit = "default", block = false, shape = "square", shadow = false } = props;
    const state = {
      bordered,
      fit,
      block,
      shape,
      shadow,
      components: {
        root: "img"
      },
      root: slot_exports.always(getIntrinsicElementProps("img", {
        ref,
        ...props
      }), {
        elementType: "img"
      })
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-image/lib/components/Image/useImageStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var imageClassNames = {
    root: "fui-Image"
  };
  var useStyles8 = /* @__PURE__ */ __styles2({
    base: {
      g2u3we: "fj3muxo",
      h3c5rm: ["f1akhkt", "f1lxtadh"],
      B9xav0g: "f1aperda",
      zhjwy3: ["f1lxtadh", "f1akhkt"],
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f1fabniw",
      B7ck84d: "f1ewtqcl",
      mc9l5x: "f14t3ns0"
    },
    bordered: {
      icvyot: "fzkkow9",
      vrafjx: ["fcdblym", "fjik90z"],
      oivjwe: "fg706s2",
      wvpqe5: ["fjik90z", "fcdblym"],
      B4j52fo: "f192inf7",
      Bekrc4i: ["f5tn483", "f1ojsxk5"],
      Bn0qgzm: "f1vxd6vx",
      ibv6hh: ["f1ojsxk5", "f5tn483"]
    },
    circular: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f44lkw9"
    },
    rounded: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5"
    },
    square: {},
    shadow: {
      E5pizo: "f1whvlc6"
    },
    center: {
      st4lth: "f1plgu50",
      Ermj5k: "f14xojzb",
      Bqenvij: "f1l02sjl",
      a9b677: "fly5x3f"
    },
    contain: {
      st4lth: "f1kle4es",
      Ermj5k: "f14xojzb",
      Bqenvij: "f1l02sjl",
      a9b677: "fly5x3f"
    },
    "default": {},
    cover: {
      st4lth: "f1ps3kmd",
      Ermj5k: "f14xojzb",
      Bqenvij: "f1l02sjl",
      a9b677: "fly5x3f"
    },
    none: {
      st4lth: "f1plgu50",
      Ermj5k: ["f13uwng7", "fjmyj0p"],
      Bqenvij: "f1l02sjl",
      a9b677: "fly5x3f"
    },
    block: {
      a9b677: "fly5x3f"
    }
  }, {
    d: [".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
      p: -1
    }], ".f1ewtqcl{box-sizing:border-box;}", ".f14t3ns0{display:inline-block;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".f1plgu50{object-fit:none;}", ".f14xojzb{object-position:center;}", ".f1l02sjl{height:100%;}", ".fly5x3f{width:100%;}", ".f1kle4es{object-fit:contain;}", ".f1ps3kmd{object-fit:cover;}", ".f13uwng7{object-position:left top;}", ".fjmyj0p{object-position:right top;}"]
  });
  var useImageStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles8();
    state.root.className = mergeClasses(imageClassNames.root, styles.base, state.block && styles.block, state.bordered && styles.bordered, state.shadow && styles.shadow, styles[state.fit], styles[state.shape], state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-image/lib/components/Image/Image.js
  var Image = /* @__PURE__ */ React120.forwardRef((props, ref) => {
    const state = useImage_unstable(props, ref);
    useImageStyles_unstable(state);
    useCustomStyleHook("useImageStyles_unstable")(state);
    return renderImage_unstable(state);
  });
  Image.displayName = "Image";

  // ../../node_modules/@fluentui/react-spinner/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-spinner/lib/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React123 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React122 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-spinner/lib/contexts/SpinnerContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React121 = __toESM(require_react());
  var SpinnerContext = React121.createContext(void 0);
  var SpinnerContextDefaultValue = {};
  var SpinnerContextProvider = SpinnerContext.Provider;
  var useSpinnerContext = () => {
    var _React_useContext;
    return (_React_useContext = React121.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
  var useSpinner_unstable = (props, ref) => {
    const { size: contextSize } = useSpinnerContext();
    const { appearance = "primary", labelPosition = "after", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay: delay2 = 0 } = props;
    const baseId = useId4("spinner");
    const { role = "progressbar", ...rest } = props;
    const nativeRoot = slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role,
      ...rest
    }, [
      "size"
    ]), {
      elementType: "div"
    });
    const [isShownAfterDelay, setIsShownAfterDelay] = React122.useState(false);
    const [setDelayTimeout, clearDelayTimeout] = useTimeout();
    React122.useEffect(() => {
      if (delay2 <= 0) {
        return;
      }
      setDelayTimeout(() => {
        setIsShownAfterDelay(true);
      }, delay2);
      return () => {
        clearDelayTimeout();
      };
    }, [
      setDelayTimeout,
      clearDelayTimeout,
      delay2
    ]);
    const labelShorthand = slot_exports.optional(props.label, {
      defaultProps: {
        id: baseId
      },
      renderByDefault: false,
      elementType: Label
    });
    const spinnerShortHand = slot_exports.optional(props.spinner, {
      renderByDefault: true,
      elementType: "span"
    });
    if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) {
      nativeRoot["aria-labelledby"] = labelShorthand.id;
    }
    const state = {
      appearance,
      delay: delay2,
      labelPosition,
      size: size3,
      shouldRenderSpinner: !delay2 || isShownAfterDelay,
      components: {
        root: "div",
        spinner: "span",
        spinnerTail: "span",
        label: Label
      },
      root: nativeRoot,
      spinner: spinnerShortHand,
      spinnerTail: slot_exports.always(props.spinnerTail, {
        elementType: "span"
      }),
      label: labelShorthand
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/renderSpinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderSpinner_unstable = (state) => {
    assertSlots(state);
    const { labelPosition, shouldRenderSpinner } = state;
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && /* @__PURE__ */ jsx2(state.label, {}),
        state.spinner && shouldRenderSpinner && /* @__PURE__ */ jsx2(state.spinner, {
          children: state.spinnerTail && /* @__PURE__ */ jsx2(state.spinnerTail, {})
        }),
        state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && /* @__PURE__ */ jsx2(state.label, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinnerStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var spinnerClassNames = {
    root: "fui-Spinner",
    spinner: "fui-Spinner__spinner",
    spinnerTail: "fui-Spinner__spinnerTail",
    label: "fui-Spinner__label"
  };
  var useRootBaseClassName2 = /* @__PURE__ */ __resetStyles2("r82apo5", null, [".r82apo5{display:flex;align-items:center;justify-content:center;line-height:0;gap:8px;overflow:hidden;}"]);
  var useRootStyles5 = /* @__PURE__ */ __styles2({
    vertical: {
      Beiy3e4: "f1vx9l62"
    }
  }, {
    d: [".f1vx9l62{flex-direction:column;}"]
  });
  var useSpinnerBaseClassName = /* @__PURE__ */ __resetStyles2("rvgcg50", "r15nd2jo", {
    r: [".rvgcg50{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:rb7n1on;}", "@keyframes rb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}", ".r15nd2jo{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:r1gx3jof;}", "@keyframes r1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"],
    s: ["@media screen and (forced-colors: active){.rvgcg50{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.rvgcg50{animation-duration:1.8s;}}", "@media screen and (forced-colors: active){.r15nd2jo{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r15nd2jo{animation-duration:1.8s;}}"]
  });
  var useSpinnerTailBaseClassName = /* @__PURE__ */ __resetStyles2("rxov3xa", "r1o544mv", {
    r: [".rxov3xa{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r15mim6k;}", '.rxov3xa::before,.rxov3xa::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r15mim6k{0%{transform:rotate(-135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(225deg);}}", ".rxov3xa::before{animation-name:r18vhmn8;}", "@keyframes r18vhmn8{0%{transform:rotate(0deg);}50%{transform:rotate(105deg);}100%{transform:rotate(0deg);}}", ".rxov3xa::after{animation-name:rkgrvoi;}", "@keyframes rkgrvoi{0%{transform:rotate(0deg);}50%{transform:rotate(225deg);}100%{transform:rotate(0deg);}}", ".r1o544mv{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r109gmi5;}", '.r1o544mv::before,.r1o544mv::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r109gmi5{0%{transform:rotate(135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(-225deg);}}", ".r1o544mv::before{animation-name:r17whflh;}", "@keyframes r17whflh{0%{transform:rotate(0deg);}50%{transform:rotate(-105deg);}100%{transform:rotate(0deg);}}", ".r1o544mv::after{animation-name:re4odhl;}", "@keyframes re4odhl{0%{transform:rotate(0deg);}50%{transform:rotate(-225deg);}100%{transform:rotate(0deg);}}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.rxov3xa{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.rxov3xa::before,.rxov3xa::after{content:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1o544mv{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.r1o544mv::before,.r1o544mv::after{content:none;}}"]
  });
  var useSpinnerStyles = /* @__PURE__ */ __styles2({
    inverted: {
      De3pzq: "fr407j0",
      sj55zd: "f1f7voed"
    },
    rtlTail: {
      btxmck: "f179dep3",
      gb5jj2: "fbz9ihp",
      Br2kee7: "f1wkkxo7"
    },
    "extra-tiny": {
      Bqenvij: "fd461yt",
      a9b677: "fjw5fx7",
      qmp6fs: "f1v3ph3m"
    },
    tiny: {
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3",
      qmp6fs: "f1v3ph3m"
    },
    "extra-small": {
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun",
      qmp6fs: "f1v3ph3m"
    },
    small: {
      Bqenvij: "fxldao9",
      a9b677: "f1w9dchk",
      qmp6fs: "f1v3ph3m"
    },
    medium: {
      Bqenvij: "f1d2rq10",
      a9b677: "f1szoe96",
      qmp6fs: "fb52u90"
    },
    large: {
      Bqenvij: "f8ljn23",
      a9b677: "fpdz1er",
      qmp6fs: "fb52u90"
    },
    "extra-large": {
      Bqenvij: "fbhnoac",
      a9b677: "feqmc2u",
      qmp6fs: "fb52u90"
    },
    huge: {
      Bqenvij: "f1ft4266",
      a9b677: "fksc0bp",
      qmp6fs: "fa3u9ii"
    }
  }, {
    d: [".fr407j0{background-color:var(--colorNeutralStrokeAlpha2);}", ".f1f7voed{color:var(--colorNeutralStrokeOnBrand2);}", ".f179dep3{-webkit-mask-image:conic-gradient(white 255deg, transparent 255deg);mask-image:conic-gradient(white 255deg, transparent 255deg);}", ".fbz9ihp::before,.fbz9ihp::after{background-image:conic-gradient(transparent 225deg, currentcolor 225deg);}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".f1v3ph3m{--fui-Spinner--strokeWidth:var(--strokeWidthThick);}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxldao9{height:28px;}", ".f1w9dchk{width:28px;}", ".f1d2rq10{height:32px;}", ".f1szoe96{width:32px;}", ".fb52u90{--fui-Spinner--strokeWidth:var(--strokeWidthThicker);}", ".f8ljn23{height:36px;}", ".fpdz1er{width:36px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".f1ft4266{height:44px;}", ".fksc0bp{width:44px;}", ".fa3u9ii{--fui-Spinner--strokeWidth:var(--strokeWidthThickest);}"],
    m: [["@media screen and (prefers-reduced-motion: reduce){.f1wkkxo7{background-image:conic-gradient(currentcolor 0deg, transparent 240deg);}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]]
  });
  var useLabelStyles = /* @__PURE__ */ __styles2({
    inverted: {
      sj55zd: "fonrgv7"
    },
    "extra-tiny": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    tiny: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    "extra-small": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    small: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    medium: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    large: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    "extra-large": {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    huge: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "f1pp30po",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "f106mvju"
    }
  }, {
    d: [".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
  });
  var useSpinnerStyles_unstable = (state) => {
    "use no memo";
    const {
      labelPosition,
      size: size3,
      appearance
    } = state;
    const {
      dir
    } = useFluent();
    const rootBaseClassName = useRootBaseClassName2();
    const rootStyles = useRootStyles5();
    const spinnerBaseClassName = useSpinnerBaseClassName();
    const spinnerStyles = useSpinnerStyles();
    const spinnerTailBaseClassName = useSpinnerTailBaseClassName();
    const labelStyles = useLabelStyles();
    state.root.className = mergeClasses(spinnerClassNames.root, rootBaseClassName, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, state.root.className);
    if (state.spinner) {
      state.spinner.className = mergeClasses(spinnerClassNames.spinner, spinnerBaseClassName, spinnerStyles[size3], appearance === "inverted" && spinnerStyles.inverted, state.spinner.className);
    }
    if (state.spinnerTail) {
      state.spinnerTail.className = mergeClasses(spinnerClassNames.spinnerTail, spinnerTailBaseClassName, dir === "rtl" && spinnerStyles.rtlTail, state.spinnerTail.className);
    }
    if (state.label) {
      state.label.className = mergeClasses(spinnerClassNames.label, labelStyles[size3], appearance === "inverted" && labelStyles.inverted, state.label.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
  var Spinner = /* @__PURE__ */ React123.forwardRef((props, ref) => {
    const state = useSpinner_unstable(props, ref);
    useSpinnerStyles_unstable(state);
    useCustomStyleHook("useSpinnerStyles_unstable")(state);
    return renderSpinner_unstable(state);
  });
  Spinner.displayName = "Spinner";

  // ../../node_modules/@fluentui/react-switch/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-switch/lib/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React125 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/useSwitch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React124 = __toESM(require_react());
  var useSwitch_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true
    });
    const { checked, defaultChecked, disabled, labelPosition = "after", onChange, required } = props;
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "input",
      excludedPropNames: [
        "checked",
        "defaultChecked",
        "onChange"
      ]
    });
    const id = useId4("switch-", nativeProps.primary.id);
    const root5 = slot_exports.always(props.root, {
      defaultProps: {
        ref: useFocusWithin(),
        ...nativeProps.root
      },
      elementType: "div"
    });
    const indicator = slot_exports.always(props.indicator, {
      defaultProps: {
        "aria-hidden": true,
        children: /* @__PURE__ */ React124.createElement(CircleFilled, null)
      },
      elementType: "div"
    });
    const input = slot_exports.always(props.input, {
      defaultProps: {
        checked,
        defaultChecked,
        id,
        ref,
        role: "switch",
        type: "checkbox",
        ...nativeProps.primary
      },
      elementType: "input"
    });
    input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: ev.currentTarget.checked
    }));
    const label = slot_exports.optional(props.label, {
      defaultProps: {
        disabled,
        htmlFor: id,
        required,
        size: "medium"
      },
      elementType: Label
    });
    return {
      labelPosition,
      components: {
        root: "div",
        indicator: "div",
        input: "input",
        label: Label
      },
      root: root5,
      indicator,
      input,
      label
    };
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/renderSwitch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderSwitch_unstable = (state) => {
    assertSlots(state);
    const { labelPosition } = state;
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        /* @__PURE__ */ jsx2(state.input, {}),
        labelPosition !== "after" && state.label && /* @__PURE__ */ jsx2(state.label, {}),
        /* @__PURE__ */ jsx2(state.indicator, {}),
        labelPosition === "after" && state.label && /* @__PURE__ */ jsx2(state.label, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/useSwitchStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var switchClassNames = {
    root: "fui-Switch",
    indicator: "fui-Switch__indicator",
    input: "fui-Switch__input",
    label: "fui-Switch__label"
  };
  var switchClassName = switchClassNames.root;
  var spaceBetweenThumbAndTrack = 2;
  var trackHeight = 20;
  var thumbSize = trackHeight - spaceBetweenThumbAndTrack;
  var useRootBaseClassName3 = /* @__PURE__ */ __resetStyles2("r2i81i2", "rofhmb8", {
    r: [".r2i81i2{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".r2i81i2:focus{outline-style:none;}", ".r2i81i2:focus-visible{outline-style:none;}", ".r2i81i2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2i81i2[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rofhmb8{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rofhmb8:focus{outline-style:none;}", ".rofhmb8:focus-visible{outline-style:none;}", ".rofhmb8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rofhmb8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.r2i81i2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rofhmb8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
  });
  var useRootStyles6 = /* @__PURE__ */ __styles2({
    vertical: {
      Beiy3e4: "f1vx9l62"
    }
  }, {
    d: [".f1vx9l62{flex-direction:column;}"]
  });
  var useIndicatorBaseClassName = /* @__PURE__ */ __resetStyles2("r1c3hft5", null, {
    r: [".r1c3hft5{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r1c3hft5>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
    s: ["@media screen and (prefers-reduced-motion: reduce){.r1c3hft5{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1c3hft5{color:CanvasText;}.r1c3hft5>i{forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1c3hft5>*{transition-duration:0.01ms;}}"]
  });
  var useIndicatorStyles = /* @__PURE__ */ __styles2({
    labelAbove: {
      B6of3ja: "f1hu3pq6"
    }
  }, {
    d: [".f1hu3pq6{margin-top:0;}"]
  });
  var useInputBaseClassName = /* @__PURE__ */ __resetStyles2("rsji9ng", "r15xih98", {
    r: [".rsji9ng{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".rsji9ng:checked~.fui-Switch__indicator>*{transform:translateX(20px);}", ".rsji9ng:disabled{cursor:default;}", ".rsji9ng:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".rsji9ng:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsji9ng:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".rsji9ng:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}", ".r15xih98{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".r15xih98:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}", ".r15xih98:disabled{cursor:default;}", ".r15xih98:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".r15xih98:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r15xih98:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r15xih98:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".r15xih98:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"],
    s: ["@media (forced-colors: active){.rsji9ng:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rsji9ng:disabled~.fui-Switch__label{color:GrayText;}.rsji9ng:hover{color:CanvasText;}.rsji9ng:hover:active{color:CanvasText;}.rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r15xih98:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r15xih98:disabled~.fui-Switch__label{color:GrayText;}.r15xih98:hover{color:CanvasText;}.r15xih98:hover:active{color:CanvasText;}.r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
  });
  var useInputStyles = /* @__PURE__ */ __styles2({
    before: {
      j35jbq: ["f1e31b4d", "f1vgc2s3"],
      Bhzewxz: "f15twtuk"
    },
    after: {
      oyh7mz: ["f1vgc2s3", "f1e31b4d"],
      Bhzewxz: "f15twtuk"
    },
    above: {
      B5kzvoi: "f1yab3r1",
      Bqenvij: "f1aar7gd",
      a9b677: "fly5x3f"
    }
  }, {
    d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}", ".fly5x3f{width:100%;}"]
  });
  var useLabelStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bceei9c: "f1k6fduh",
      jrapky: "f49ad5g",
      B6of3ja: "f1xlvstr",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1f5q0n8"
    },
    above: {
      z8tnut: "f1ywm7hm",
      Byoj8tv: "f14wxoun",
      a9b677: "fly5x3f"
    },
    after: {
      uwmqm3: ["fruq291", "f7x41pl"]
    },
    before: {
      z189sj: ["f7x41pl", "fruq291"]
    }
  }, {
    d: [".f1k6fduh{cursor:pointer;}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
      p: -1
    }], ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".fly5x3f{width:100%;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}"]
  });
  var useSwitchStyles_unstable = (state) => {
    "use no memo";
    const rootBaseClassName = useRootBaseClassName3();
    const rootStyles = useRootStyles6();
    const indicatorBaseClassName = useIndicatorBaseClassName();
    const indicatorStyles = useIndicatorStyles();
    const inputBaseClassName = useInputBaseClassName();
    const inputStyles = useInputStyles();
    const labelStyles = useLabelStyles2();
    const {
      label,
      labelPosition
    } = state;
    state.root.className = mergeClasses(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
    state.indicator.className = mergeClasses(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, state.indicator.className);
    state.input.className = mergeClasses(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], state.input.className);
    if (state.label) {
      state.label.className = mergeClasses(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
  var Switch = /* @__PURE__ */ React125.forwardRef((props, ref) => {
    const state = useSwitch_unstable(props, ref);
    useSwitchStyles_unstable(state);
    useCustomStyleHook("useSwitchStyles_unstable")(state);
    return renderSwitch_unstable(state);
  });
  Switch.displayName = "Switch";

  // ../../node_modules/@fluentui/react-tabs/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React128 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React126 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabListContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tabListContextDefaultValue = {
    appearance: "transparent",
    reserveSelectedTabSpace: true,
    selectTabOnFocus: false,
    disabled: false,
    selectedValue: void 0,
    onRegister: () => {
    },
    onUnregister: () => {
    },
    onSelect: () => {
    },
    getRegisteredTabs: () => {
      return {
        registeredTabs: {}
      };
    },
    size: "medium",
    vertical: false
  };
  var TabListContext = createContext20(void 0);
  var TabListProvider = TabListContext.Provider;
  var useTabListContext_unstable = (selector) => useContextSelector(TabListContext, (ctx = tabListContextDefaultValue) => selector(ctx));

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
  var useTab_unstable = (props, ref) => {
    const { content: content3, disabled: tabDisabled = false, icon, onClick, onFocus, value } = props;
    const appearance = useTabListContext_unstable((ctx) => ctx.appearance);
    const reserveSelectedTabSpace = useTabListContext_unstable((ctx) => ctx.reserveSelectedTabSpace);
    const selectTabOnFocus = useTabListContext_unstable((ctx) => ctx.selectTabOnFocus);
    const listDisabled = useTabListContext_unstable((ctx) => ctx.disabled);
    const selected = useTabListContext_unstable((ctx) => ctx.selectedValue === value);
    const onRegister = useTabListContext_unstable((ctx) => ctx.onRegister);
    const onUnregister = useTabListContext_unstable((ctx) => ctx.onUnregister);
    const onSelect = useTabListContext_unstable((ctx) => ctx.onSelect);
    const size3 = useTabListContext_unstable((ctx) => ctx.size);
    const vertical = useTabListContext_unstable((ctx) => !!ctx.vertical);
    const disabled = listDisabled || tabDisabled;
    const innerRef = React126.useRef(null);
    const onSelectCallback = (event) => onSelect(event, {
      value
    });
    const onTabClick = useEventCallback(mergeCallbacks(onClick, onSelectCallback));
    const onTabFocus = useEventCallback(mergeCallbacks(onFocus, onSelectCallback));
    const focusProps = useTabsterAttributes({
      focusable: {
        isDefault: selected
      }
    });
    React126.useEffect(() => {
      onRegister({
        value,
        ref: innerRef
      });
      return () => {
        onUnregister({
          value,
          ref: innerRef
        });
      };
    }, [
      onRegister,
      onUnregister,
      innerRef,
      value
    ]);
    const iconSlot = slot_exports.optional(icon, {
      elementType: "span"
    });
    const contentSlot = slot_exports.always(content3, {
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    });
    const contentReservedSpace = content3 && typeof content3 === "object" ? omit(content3, [
      "ref"
    ]) : content3;
    const iconOnly = Boolean((iconSlot === null || iconSlot === void 0 ? void 0 : iconSlot.children) && !contentSlot.children);
    return {
      components: {
        root: "button",
        icon: "span",
        content: "span",
        contentReservedSpace: "span"
      },
      root: slot_exports.always(getIntrinsicElementProps("button", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLButtonElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, innerRef),
        role: "tab",
        type: "button",
        // aria-selected undefined indicates it is not selectable
        // according to https://www.w3.org/TR/wai-aria-1.1/#aria-selected
        "aria-selected": disabled ? void 0 : `${selected}`,
        ...focusProps,
        ...props,
        disabled,
        onClick: onTabClick,
        onFocus: selectTabOnFocus ? onTabFocus : onFocus
      }), {
        elementType: "button"
      }),
      icon: iconSlot,
      iconOnly,
      content: contentSlot,
      contentReservedSpace: slot_exports.optional(contentReservedSpace, {
        renderByDefault: !selected && !iconOnly && reserveSelectedTabSpace,
        defaultProps: {
          children: props.children
        },
        elementType: "span"
      }),
      appearance,
      disabled,
      selected,
      size: size3,
      value,
      vertical
    };
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/renderTab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderTab_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.icon && /* @__PURE__ */ jsx2(state.icon, {}),
        !state.iconOnly && /* @__PURE__ */ jsx2(state.content, {}),
        state.contentReservedSpace && /* @__PURE__ */ jsx2(state.contentReservedSpace, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabAnimatedIndicator.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React127 = __toESM(require_react());
  var tabIndicatorCssVars_unstable = {
    offsetVar: "--fui-Tab__indicator--offset",
    scaleVar: "--fui-Tab__indicator--scale"
  };
  var useActiveIndicatorStyles = /* @__PURE__ */ __styles2({
    base: {
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1gl81tg"
    },
    animated: {
      Ba2ppi3: "fhwpy7i",
      F2fol1: "f6zz20j",
      B1dyfl9: "f1ai4sc1",
      B0vmy72: "f9qxlq5",
      u9bimw: "f1aql376"
    },
    horizontal: {
      sjv3b2: ["fug4aj8", "f1i5xzg7"],
      b1kco5: "f1q7ujh"
    },
    vertical: {
      sjv3b2: "f1hqboyk",
      b1kco5: "f1dxupa6"
    }
  }, {
    d: [[".f1gl81tg{overflow:visible;}", {
      p: -1
    }], ".fhwpy7i::after{transition-property:transform;}", ".f6zz20j::after{transition-duration:var(--durationSlow);}", ".f1ai4sc1::after{transition-timing-function:var(--curveDecelerateMax);}", ".fug4aj8::after{transform-origin:left;}", ".f1i5xzg7::after{transform-origin:right;}", ".f1q7ujh::after{transform:translateX(var(--fui-Tab__indicator--offset)) scaleX(var(--fui-Tab__indicator--scale));}", ".f1hqboyk::after{transform-origin:top;}", ".f1dxupa6::after{transform:translateY(var(--fui-Tab__indicator--offset)) scaleY(var(--fui-Tab__indicator--scale));}"],
    m: [["@media (prefers-reduced-motion: reduce){.f9qxlq5::after{transition-property:none;}}", {
      m: "(prefers-reduced-motion: reduce)"
    }], ["@media (prefers-reduced-motion: reduce){.f1aql376::after{transition-duration:0.01ms;}}", {
      m: "(prefers-reduced-motion: reduce)"
    }]]
  });
  var calculateTabRect = (element4) => {
    if (element4) {
      var _element_parentElement;
      const parentRect = ((_element_parentElement = element4.parentElement) === null || _element_parentElement === void 0 ? void 0 : _element_parentElement.getBoundingClientRect()) || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      const tabRect = element4.getBoundingClientRect();
      return {
        x: tabRect.x - parentRect.x,
        y: tabRect.y - parentRect.y,
        width: tabRect.width,
        height: tabRect.height
      };
    }
    return void 0;
  };
  var getRegisteredTabRect = (registeredTabs, value) => {
    var _registeredTabs_JSON_stringify;
    const element4 = isValueDefined(value) ? (_registeredTabs_JSON_stringify = registeredTabs[JSON.stringify(value)]) === null || _registeredTabs_JSON_stringify === void 0 ? void 0 : _registeredTabs_JSON_stringify.ref.current : void 0;
    return element4 ? calculateTabRect(element4) : void 0;
  };
  var isValueDefined = (value) => value != null;
  var useTabAnimatedIndicatorStyles_unstable = (state) => {
    const {
      disabled,
      selected,
      vertical
    } = state;
    const activeIndicatorStyles = useActiveIndicatorStyles();
    const [lastAnimatedFrom, setLastAnimatedFrom] = React127.useState();
    const [animationValues, setAnimationValues] = React127.useState({
      offset: 0,
      scale: 1
    });
    const getRegisteredTabs = useTabListContext_unstable((ctx) => ctx.getRegisteredTabs);
    const [requestAnimationFrame2] = useAnimationFrame();
    if (selected) {
      const {
        previousSelectedValue,
        selectedValue,
        registeredTabs
      } = getRegisteredTabs();
      if (isValueDefined(previousSelectedValue) && lastAnimatedFrom !== previousSelectedValue) {
        const previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
        const selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
        if (selectedTabRect && previousSelectedTabRect) {
          const offset4 = vertical ? previousSelectedTabRect.y - selectedTabRect.y : previousSelectedTabRect.x - selectedTabRect.x;
          const scale = vertical ? previousSelectedTabRect.height / selectedTabRect.height : previousSelectedTabRect.width / selectedTabRect.width;
          setAnimationValues({
            offset: offset4,
            scale
          });
          setLastAnimatedFrom(previousSelectedValue);
          requestAnimationFrame2(() => setAnimationValues({
            offset: 0,
            scale: 1
          }));
        }
      }
    } else if (isValueDefined(lastAnimatedFrom)) {
      setLastAnimatedFrom(void 0);
    }
    if (disabled) {
      return state;
    }
    const animating = animationValues.offset === 0 && animationValues.scale === 1;
    state.root.className = mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
    const rootCssVars = {
      [tabIndicatorCssVars_unstable.offsetVar]: `${animationValues.offset}px`,
      [tabIndicatorCssVars_unstable.scaleVar]: `${animationValues.scale}`
    };
    state.root.style = {
      ...rootCssVars,
      ...state.root.style
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
  var tabClassNames = {
    root: "fui-Tab",
    icon: "fui-Tab__icon",
    content: "fui-Tab__content"
  };
  var reservedSpaceClassNames = {
    content: "fui-Tab__content--reserved-space"
  };
  var useRootStyles7 = /* @__PURE__ */ __styles2({
    root: {
      Bt984gj: "f122n59",
      mc9l5x: "f13qh94s",
      Bnnss6s: "fi64zpg",
      Bxotwcr: "f1u07yai",
      Budl1dq: "frn2hmy",
      wkccdc: "f1olsevy",
      oeaueh: "f1s6fcnf",
      qhf8xq: "f10pi13n"
    },
    button: {
      Bt984gj: "f122n59",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f3bhgqh",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      Bceei9c: "f1k6fduh",
      mc9l5x: "f13qh94s",
      Bnnss6s: "fi64zpg",
      Bxotwcr: "f1u07yai",
      Budl1dq: "frn2hmy",
      wkccdc: "f1olsevy",
      Bahqtrf: "fk6fouc",
      Bg96gwp: "f1i3iumi",
      oeaueh: "f1s6fcnf",
      qhf8xq: "f10pi13n",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      B9bfxx9: "f1cxpek8"
    },
    horizontal: {
      Brf1p80: "f4d9j23"
    },
    vertical: {
      Brf1p80: "f1s9ku6b"
    },
    smallHorizontal: {
      i8kkvl: "f14mj54c",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1wmopi4"
    },
    smallVertical: {
      i8kkvl: "f14mj54c",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f12or63q"
    },
    mediumHorizontal: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1w08f2p"
    },
    mediumVertical: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fymxs25"
    },
    largeHorizontal: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1ssfvub"
    },
    largeVertical: {
      i8kkvl: "f1rjii52",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "fwkd1rq"
    },
    transparent: {
      De3pzq: "f1c21dwh",
      B95qlz1: "f9rvdkv",
      B7xitij: "f1051ucx",
      Bptxc3x: "fmmjozx",
      Bwqhzpy: "fqhzt5g",
      iyk698: "f7l5cgy",
      cl4aha: "fpkze5g",
      B0q3jbp: "f1iywnoi",
      Be9ayug: "f9n45c4"
    },
    subtle: {
      De3pzq: "fhovq9v",
      B95qlz1: "f1bifk9c",
      B7xitij: "fo6hitd",
      Bptxc3x: "fmmjozx",
      Bwqhzpy: "fqhzt5g",
      iyk698: "f7l5cgy",
      cl4aha: "fpkze5g",
      B0q3jbp: "f1iywnoi",
      Be9ayug: "f9n45c4"
    },
    disabledCursor: {
      Bceei9c: "fdrzuqr"
    },
    disabled: {
      De3pzq: "f1c21dwh",
      Bptxc3x: "fato7r6",
      cl4aha: "fao1bnu"
    },
    selected: {
      Bptxc3x: "f1cadz5z",
      Bwqhzpy: "fwhdxxj",
      iyk698: "fintccb",
      cl4aha: "ffplhdr",
      B0q3jbp: "fjo17wb",
      Be9ayug: "f148789c"
    }
  }, {
    d: [".f122n59{align-items:center;}", ".f13qh94s{display:grid;}", ".fi64zpg{flex-shrink:0;}", ".f1u07yai{grid-auto-flow:column;}", ".frn2hmy{grid-template-columns:auto;}", ".f1olsevy{grid-template-rows:auto;}", ".f1s6fcnf{outline-style:none;}", ".f10pi13n{position:relative;}", [".f3bhgqh{border:none;}", {
      p: -2
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".f1cxpek8{text-transform:none;}", ".f4d9j23{justify-content:center;}", ".f1s9ku6b{justify-content:start;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", [".f1wmopi4{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalSNudge);}", {
      p: -1
    }], [".f12or63q{padding:var(--spacingVerticalXXS) var(--spacingHorizontalSNudge);}", {
      p: -1
    }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", [".f1w08f2p{padding:var(--spacingVerticalM) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".fymxs25{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".f1ssfvub{padding:var(--spacingVerticalL) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], [".fwkd1rq{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
      p: -1
    }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f9rvdkv:enabled:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1051ucx:enabled:active{background-color:var(--colorTransparentBackgroundPressed);}", ".fmmjozx .fui-Tab__icon{color:var(--colorNeutralForeground2);}", ".fqhzt5g:enabled:hover .fui-Tab__icon{color:var(--colorNeutralForeground2Hover);}", ".f7l5cgy:enabled:active .fui-Tab__icon{color:var(--colorNeutralForeground2Pressed);}", ".fpkze5g .fui-Tab__content{color:var(--colorNeutralForeground2);}", ".f1iywnoi:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground2Hover);}", ".f9n45c4:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground2Pressed);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fdrzuqr{cursor:not-allowed;}", ".fato7r6 .fui-Tab__icon{color:var(--colorNeutralForegroundDisabled);}", ".fao1bnu .fui-Tab__content{color:var(--colorNeutralForegroundDisabled);}", ".f1cadz5z .fui-Tab__icon{color:var(--colorCompoundBrandForeground1);}", ".fwhdxxj:enabled:hover .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Hover);}", ".fintccb:enabled:active .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Pressed);}", ".ffplhdr .fui-Tab__content{color:var(--colorNeutralForeground1);}", ".fjo17wb:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground1Hover);}", ".f148789c:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground1Pressed);}"]
  });
  var useCircularAppearanceStyles = /* @__PURE__ */ __styles2({
    base: {
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "f44lkw9",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fp7rvkm",
      Bptxc3x: "ftorr8m",
      cl4aha: "f16lqpmv"
    },
    medium: {
      Dbcxam: 0,
      rjzwhg: 0,
      Bblux5w: "f1lj1ynd"
    },
    subtle: {
      De3pzq: "fhovq9v",
      sj55zd: "fkfq4zb",
      B95qlz1: "f1bifk9c",
      Eo63ln: 0,
      r9osk6: 0,
      Itrz8y: 0,
      zeg6vx: 0,
      l65xgk: 0,
      Bw4olcx: 0,
      Folb0i: 0,
      I2h8y4: 0,
      Bgxgoyi: 0,
      Bvlkotb: 0,
      Fwyncl: 0,
      Byh5edv: 0,
      Becqvjq: 0,
      uumbiq: 0,
      B73q3dg: 0,
      Bblwbaf: 0,
      B0ezav: "ft57sj0",
      r4wkhp: "f1fcoy83",
      B7xitij: "fo6hitd",
      d3wsvi: 0,
      Hdqn7s: 0,
      zu5y1p: 0,
      owqphb: 0,
      g9c53k: 0,
      Btmu08z: 0,
      Bthxvy6: 0,
      gluvuq: 0,
      tb88gp: 0,
      wns6jk: 0,
      kdfdk4: 0,
      Bbw008l: 0,
      Bayi1ib: 0,
      B1kkfu3: 0,
      J1oqyp: 0,
      kem6az: 0,
      goa3yj: "fhn220o",
      p743kt: "f15qf7sh",
      uu68id: 0,
      Bxeuatn: 0,
      felo30: 0,
      Bc736ss: 0,
      Bhz882k: 0,
      n51gp8: 0,
      Eshu5l: 0,
      Bk6ri7n: 0,
      v49c4f: 0,
      Bn1d65q: 0,
      c4eypz: 0,
      v3aym: 0,
      hft9gk: 0,
      Bjwas2f: 0,
      Bk5ld8o: 0,
      gwxt9v: 0,
      B6k8go: "f130w16x"
    },
    subtleSelected: {
      De3pzq: "f16xkysk",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1c2pc3t",
      sj55zd: "faj9fo0",
      B95qlz1: "fsm7zmf",
      Eo63ln: 0,
      r9osk6: 0,
      Itrz8y: 0,
      zeg6vx: 0,
      l65xgk: 0,
      Bw4olcx: 0,
      Folb0i: 0,
      I2h8y4: 0,
      Bgxgoyi: 0,
      Bvlkotb: 0,
      Fwyncl: 0,
      Byh5edv: 0,
      Becqvjq: 0,
      uumbiq: 0,
      B73q3dg: 0,
      Bblwbaf: 0,
      B0ezav: "f1wo0sfq",
      r4wkhp: "f1afuynh",
      B7xitij: "f94ddyl",
      d3wsvi: 0,
      Hdqn7s: 0,
      zu5y1p: 0,
      owqphb: 0,
      g9c53k: 0,
      Btmu08z: 0,
      Bthxvy6: 0,
      gluvuq: 0,
      tb88gp: 0,
      wns6jk: 0,
      kdfdk4: 0,
      Bbw008l: 0,
      Bayi1ib: 0,
      B1kkfu3: 0,
      J1oqyp: 0,
      kem6az: 0,
      goa3yj: "fmle6oo",
      p743kt: "f1d3itm4",
      uu68id: 0,
      Bxeuatn: 0,
      felo30: 0,
      Bc736ss: 0,
      Bhz882k: 0,
      n51gp8: 0,
      Eshu5l: 0,
      Bk6ri7n: 0,
      v49c4f: 0,
      Bn1d65q: 0,
      c4eypz: 0,
      v3aym: 0,
      hft9gk: 0,
      Bjwas2f: 0,
      Bk5ld8o: 0,
      gwxt9v: 0,
      B6k8go: "f19qjb1h"
    },
    subtleDisabled: {
      De3pzq: "fhovq9v",
      sj55zd: "f1s2aq7o"
    },
    subtleDisabledSelected: {
      De3pzq: "f1bg9a2p",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fegtqic",
      sj55zd: "f1s2aq7o"
    },
    filled: {
      De3pzq: "f16xq7d1",
      sj55zd: "fkfq4zb",
      B95qlz1: "fwwxidx",
      r4wkhp: "f1fcoy83",
      B7xitij: "f14i52sd",
      p743kt: "f15qf7sh",
      Bw5j0gk: "f159yq2d",
      Baikq8m: "ful0ncq",
      B2ndh17: "f2rulcp",
      w0x64w: "f19p5z4e",
      Bdzpij4: "fo1bcu3"
    },
    filledSelected: {
      De3pzq: "ffp7eso",
      sj55zd: "f1phragk",
      B95qlz1: "f1lm9dni",
      r4wkhp: "f1mn5ei1",
      B7xitij: "f1g6ncd0",
      p743kt: "fl71aob",
      bml8oc: "f13s88zn",
      qew46a: "f16zjd40",
      B84x17g: "f1mr3uue",
      Jetwu1: "f196ywdt"
    },
    filledDisabled: {
      De3pzq: "f1bg9a2p",
      sj55zd: "f1s2aq7o"
    },
    filledDisabledSelected: {
      De3pzq: "f1bg9a2p",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fegtqic",
      sj55zd: "f1s2aq7o"
    }
  }, {
    d: [[".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], [".fp7rvkm{border:solid var(--strokeWidthThin) var(--colorTransparentStroke);}", {
      p: -2
    }], ".ftorr8m .fui-Tab__icon{color:inherit;}", ".f16lqpmv .fui-Tab__content{color:inherit;}", [".f1lj1ynd{padding-block:var(--spacingVerticalSNudge);}", {
      p: -1
    }], ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", [".ft57sj0:enabled:hover{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Hover);}", {
      p: -2
    }], ".f1fcoy83:enabled:hover{color:var(--colorNeutralForeground2Hover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", [".fhn220o:enabled:active{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f15qf7sh:enabled:active{color:var(--colorNeutralForeground2Pressed);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", [".f1c2pc3t{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStroke);}", {
      p: -2
    }], ".faj9fo0{color:var(--colorBrandForeground2);}", ".fsm7zmf:enabled:hover{background-color:var(--colorBrandBackground2Hover);}", [".f1wo0sfq:enabled:hover{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokeHover);}", {
      p: -2
    }], ".f1afuynh:enabled:hover{color:var(--colorBrandForeground2Hover);}", ".f94ddyl:enabled:active{background-color:var(--colorBrandBackground2Pressed);}", [".fmle6oo:enabled:active{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokePressed);}", {
      p: -2
    }], ".f1d3itm4:enabled:active{color:var(--colorBrandForeground2Pressed);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1lm9dni:enabled:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1mn5ei1:enabled:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1g6ncd0:enabled:active{background-color:var(--colorBrandBackgroundPressed);}", ".fl71aob:enabled:active{color:var(--colorNeutralForegroundOnBrand);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }]],
    m: [["@media (forced-colors: active){.f130w16x{border:solid var(--strokeWidthThin) Canvas;}}", {
      p: -2,
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f19qjb1h{border:solid var(--strokeWidthThin) Highlight;}}", {
      p: -2,
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f159yq2d:enabled:hover{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.ful0ncq:enabled:hover{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f2rulcp:enabled:hover .fui-Tab__content{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f19p5z4e:enabled:hover .fui-Icon-filled{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fo1bcu3:enabled:hover .fui-Icon-regular{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f13s88zn:enabled{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16zjd40:enabled .fui-Tab__content{color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1mr3uue:enabled .fui-Tab__content{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f196ywdt:enabled .fui-Tab__icon{color:ButtonFace;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useFocusStyles = /* @__PURE__ */ __styles2({
    base: {
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bn4voq9: "f1p7hgxw",
      Bfpq7zp: "f1way5bb",
      g9k6zt: "f9znhxp",
      j6ew2k: ["fqa318h", "fqa318h"],
      Bhxq17a: "f1vjpng2"
    },
    circular: {
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bn4voq9: "f1p7hgxw",
      Bfpq7zp: "f1way5bb",
      g9k6zt: "f9znhxp",
      j6ew2k: ["fzgyhws", "fqxug60"],
      Bhxq17a: "f1vjpng2"
    }
  }, {
    d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1p7hgxw[data-fui-focus-visible]{outline-width:var(--strokeWidthThick);}", ".f1way5bb[data-fui-focus-visible]{outline-color:transparent;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqa318h[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2);}", ".f1vjpng2[data-fui-focus-visible]{z-index:1;}", ".fzgyhws[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}", ".fqxug60[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}"]
  });
  var usePendingIndicatorStyles = /* @__PURE__ */ __styles2({
    base: {
      az7l2e: "fhw179n",
      vqofr: 0,
      Bv4n3vi: 0,
      Bgqb9hq: 0,
      B0uxbk8: 0,
      Bf3jju6: "fg9j5n4",
      amg5m6: "f1kmhr4c",
      zkfqfm: "fl1ydde",
      Bkydozb: "f1y7maxz",
      Bka2azo: 0,
      vzq8l0: 0,
      csmgbd: 0,
      Br4ovkg: 0,
      aelrif: "fceyvr4",
      y36c18: "f16cxu0",
      B1ctymy: "f1nwgacf",
      Bgvrrv0: "f15ovonk",
      ddr6p5: "fvje46l"
    },
    disabled: {
      az7l2e: "f1ut20fw",
      Bkydozb: "fhrzcfn",
      Bgvrrv0: "f1v15rkt",
      ddr6p5: "f3nwrnk"
    },
    smallHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1r53b5e",
      Fbdkly: ["f1s6rxz5", "fo35v8s"],
      mdwyqc: ["fo35v8s", "f1s6rxz5"]
    },
    smallVertical: {
      lawp4y: "fze4zud",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "fdp32p8",
      Ccq8qp: "f1aij3q"
    },
    mediumHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1s2r9ax",
      Fbdkly: ["f1o0nnkk", "fxb7rol"],
      mdwyqc: ["fxb7rol", "f1o0nnkk"]
    },
    mediumVertical: {
      lawp4y: "f17jracn",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "f117lcb2",
      Ccq8qp: "f1aij3q"
    },
    largeHorizontal: {
      lawp4y: "fchca7p",
      Baz25je: "f1s2r9ax",
      Fbdkly: ["f1o0nnkk", "fxb7rol"],
      mdwyqc: ["fxb7rol", "f1o0nnkk"]
    },
    largeVertical: {
      lawp4y: "fel9d3z",
      Fbdkly: ["f1fzr1x6", "f1f351id"],
      Bciustq: "f6vqlre",
      Ccq8qp: "f1aij3q"
    }
  }, {
    h: [".fhw179n:hover::before{background-color:var(--colorNeutralStroke1Hover);}", [".fg9j5n4:hover::before{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f1kmhr4c:hover::before{content:"";}', ".fl1ydde:hover::before{position:absolute;}", ".f1ut20fw:hover::before{background-color:var(--colorTransparentStroke);}"],
    a: [".f1y7maxz:active::before{background-color:var(--colorNeutralStroke1Pressed);}", [".fceyvr4:active::before{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f16cxu0:active::before{content:"";}', ".f1nwgacf:active::before{position:absolute;}", ".fhrzcfn:active::before{background-color:var(--colorTransparentStroke);}"],
    m: [["@media (forced-colors: active){.f15ovonk:hover::before{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fvje46l:active::before{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1v15rkt:hover::before{background-color:transparent;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f3nwrnk:active::before{background-color:transparent;}}", {
      m: "(forced-colors: active)"
    }]],
    d: [".fchca7p::before{bottom:0;}", ".f1r53b5e::before{height:var(--strokeWidthThick);}", ".f1s6rxz5::before{left:var(--spacingHorizontalSNudge);}", ".fo35v8s::before{right:var(--spacingHorizontalSNudge);}", ".fze4zud::before{bottom:var(--spacingVerticalXS);}", ".f1fzr1x6::before{left:0;}", ".f1f351id::before{right:0;}", ".fdp32p8::before{top:var(--spacingVerticalXS);}", ".f1aij3q::before{width:var(--strokeWidthThicker);}", ".f1s2r9ax::before{height:var(--strokeWidthThicker);}", ".f1o0nnkk::before{left:var(--spacingHorizontalM);}", ".fxb7rol::before{right:var(--spacingHorizontalM);}", ".f17jracn::before{bottom:var(--spacingVerticalS);}", ".f117lcb2::before{top:var(--spacingVerticalS);}", ".fel9d3z::before{bottom:var(--spacingVerticalMNudge);}", ".f6vqlre::before{top:var(--spacingVerticalMNudge);}"]
  });
  var useActiveIndicatorStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bjyk6c5: "f1rp0jgh",
      d9w3h3: 0,
      B3778ie: 0,
      B4j8arr: 0,
      Bl18szs: 0,
      Blrzh8d: "f3b9emi",
      Bsft5z2: "f13zj6fq",
      E3zdtr: "f1mdlcz9"
    },
    selected: {
      Bjyk6c5: "f1ksivud",
      Bej4dhw: "f1476jrx",
      B7wqxwa: "f18q216b",
      f7digc: "fy7ktjt",
      Bvuzv5k: "f1033yux",
      k4sdgo: "fkh9b8o"
    },
    disabled: {
      Bjyk6c5: "f13lkzet"
    },
    smallHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f9bb2ob",
      Eqx8gd: ["f1q70ajw", "f18rbzdx"],
      B1piin3: ["f18rbzdx", "f1q70ajw"]
    },
    smallVertical: {
      By385i5: "fqbue9b",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "fk1klkt",
      a2br6o: "f1o25lip"
    },
    mediumHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f1vx7lu8",
      Eqx8gd: ["fna7m5n", "f1oxpfwv"],
      B1piin3: ["f1oxpfwv", "fna7m5n"]
    },
    mediumVertical: {
      By385i5: "fipylg0",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "fqchiol",
      a2br6o: "f1o25lip"
    },
    largeHorizontal: {
      By385i5: "fo72kxq",
      Dlnsje: "f1vx7lu8",
      Eqx8gd: ["fna7m5n", "f1oxpfwv"],
      B1piin3: ["f1oxpfwv", "fna7m5n"]
    },
    largeVertical: {
      By385i5: "f1w7dm5g",
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      bn5sak: "f1p6em4m",
      a2br6o: "f1o25lip"
    }
  }, {
    d: [".f1rp0jgh::after{background-color:var(--colorTransparentStroke);}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
      p: -1
    }], '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1ksivud::after{background-color:var(--colorCompoundBrandStroke);}", ".f1476jrx:enabled:hover::after{background-color:var(--colorCompoundBrandStrokeHover);}", ".f18q216b:enabled:active::after{background-color:var(--colorCompoundBrandStrokePressed);}", ".f13lkzet::after{background-color:var(--colorNeutralForegroundDisabled);}", ".fo72kxq::after{bottom:0;}", ".f9bb2ob::after{height:var(--strokeWidthThick);}", ".f1q70ajw::after{left:var(--spacingHorizontalSNudge);}", ".f18rbzdx::after{right:var(--spacingHorizontalSNudge);}", ".fqbue9b::after{bottom:var(--spacingVerticalXS);}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".fk1klkt::after{top:var(--spacingVerticalXS);}", ".f1o25lip::after{width:var(--strokeWidthThicker);}", ".f1vx7lu8::after{height:var(--strokeWidthThicker);}", ".fna7m5n::after{left:var(--spacingHorizontalM);}", ".f1oxpfwv::after{right:var(--spacingHorizontalM);}", ".fipylg0::after{bottom:var(--spacingVerticalS);}", ".fqchiol::after{top:var(--spacingVerticalS);}", ".f1w7dm5g::after{bottom:var(--spacingVerticalMNudge);}", ".f1p6em4m::after{top:var(--spacingVerticalMNudge);}"],
    m: [["@media (forced-colors: active){.fy7ktjt::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1033yux:enabled:hover::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkh9b8o:enabled:active::after{background-color:ButtonText;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useIconStyles4 = /* @__PURE__ */ __styles2({
    base: {
      Br312pm: "fwpfdsa",
      Ijaq50: "f16hsg94",
      Bt984gj: "f122n59",
      mc9l5x: "ftuwxu6",
      Brf1p80: "f4d9j23",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      D0sxk3: "f16u1re",
      t6yez3: "f8bsbmo"
    },
    small: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3"
    },
    medium: {
      Be2twd7: "fe5j1ua",
      Bqenvij: "fjamq6b",
      a9b677: "f64fuq3"
    },
    large: {
      Be2twd7: "f1rt2boy",
      Bqenvij: "frvgh55",
      a9b677: "fq4mcun"
    },
    selected: {
      D0sxk3: "fxoiby5",
      t6yez3: "f15q0o9g"
    }
  }, {
    d: [".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".f16u1re .fui-Icon-filled{display:none;}", ".f8bsbmo .fui-Icon-regular{display:inline;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}"]
  });
  var useContentStyles2 = /* @__PURE__ */ __styles2({
    base: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi",
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1bwptpd"
    },
    selected: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k"
    },
    largeSelected: {
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "fl43uef",
      Bg96gwp: "faaz57k"
    },
    noIconBefore: {
      Br312pm: "fwpfdsa",
      Ijaq50: "f16hsg94"
    },
    iconBefore: {
      Br312pm: "fd46tj4",
      Ijaq50: "f16hsg94"
    },
    placeholder: {
      Bcdw1i0: "fd7fpy0"
    }
  }, {
    d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], [".f1bwptpd{padding:var(--spacingVerticalNone) var(--spacingHorizontalXXS);}", {
      p: -1
    }], ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".fd46tj4{grid-column-start:2;}", ".fd7fpy0{visibility:hidden;}"]
  });
  var useTabStyles_unstable = (state) => {
    "use no memo";
    useTabIndicatorStyles_unstable(state);
    useTabButtonStyles_unstable(state, state.root);
    useTabContentStyles_unstable(state);
    return state;
  };
  var useTabIndicatorStyles_unstable = (state) => {
    "use no memo";
    const rootStyles = useRootStyles7();
    const pendingIndicatorStyles = usePendingIndicatorStyles();
    const activeIndicatorStyles = useActiveIndicatorStyles2();
    const {
      appearance,
      disabled,
      selected,
      size: size3,
      vertical
    } = state;
    const classes = [tabClassNames.root, rootStyles.root];
    if (appearance !== "subtle-circular" && appearance !== "filled-circular") {
      classes.push(
        // pending indicator (before pseudo element)
        pendingIndicatorStyles.base,
        size3 === "small" && (vertical ? pendingIndicatorStyles.smallVertical : pendingIndicatorStyles.smallHorizontal),
        size3 === "medium" && (vertical ? pendingIndicatorStyles.mediumVertical : pendingIndicatorStyles.mediumHorizontal),
        size3 === "large" && (vertical ? pendingIndicatorStyles.largeVertical : pendingIndicatorStyles.largeHorizontal),
        disabled && pendingIndicatorStyles.disabled,
        // active indicator (after pseudo element)
        selected && activeIndicatorStyles.base,
        selected && !disabled && activeIndicatorStyles.selected,
        selected && size3 === "small" && (vertical ? activeIndicatorStyles.smallVertical : activeIndicatorStyles.smallHorizontal),
        selected && size3 === "medium" && (vertical ? activeIndicatorStyles.mediumVertical : activeIndicatorStyles.mediumHorizontal),
        selected && size3 === "large" && (vertical ? activeIndicatorStyles.largeVertical : activeIndicatorStyles.largeHorizontal),
        selected && disabled && activeIndicatorStyles.disabled
      );
    }
    state.root.className = mergeClasses(...classes, state.root.className);
    useTabAnimatedIndicatorStyles_unstable(state);
    return state;
  };
  var useTabButtonStyles_unstable = (state, slot) => {
    "use no memo";
    const rootStyles = useRootStyles7();
    const focusStyles = useFocusStyles();
    const circularStyles = useCircularAppearanceStyles();
    const {
      appearance,
      disabled,
      selected,
      size: size3,
      vertical
    } = state;
    const isSubtleCircular = appearance === "subtle-circular";
    const isFilledCircular = appearance === "filled-circular";
    const isCircular = isSubtleCircular || isFilledCircular;
    const circularAppearance = [
      circularStyles.base,
      focusStyles.circular,
      // sizes
      size3 === "medium" && circularStyles.medium,
      // subtle-circular appearance
      isSubtleCircular && circularStyles.subtle,
      selected && isSubtleCircular && circularStyles.subtleSelected,
      disabled && isSubtleCircular && circularStyles.subtleDisabled,
      selected && disabled && isSubtleCircular && circularStyles.subtleDisabledSelected,
      // filled-circular appearance
      isFilledCircular && circularStyles.filled,
      selected && isFilledCircular && circularStyles.filledSelected,
      disabled && isFilledCircular && circularStyles.filledDisabled,
      selected && disabled && isFilledCircular && circularStyles.filledDisabledSelected
    ];
    const regularAppearance = [focusStyles.base, !disabled && appearance === "subtle" && rootStyles.subtle, !disabled && appearance === "transparent" && rootStyles.transparent, !disabled && selected && rootStyles.selected, disabled && rootStyles.disabled];
    slot.className = mergeClasses(
      rootStyles.button,
      // orientation
      vertical ? rootStyles.vertical : rootStyles.horizontal,
      // size
      size3 === "small" && (vertical ? rootStyles.smallVertical : rootStyles.smallHorizontal),
      size3 === "medium" && (vertical ? rootStyles.mediumVertical : rootStyles.mediumHorizontal),
      size3 === "large" && (vertical ? rootStyles.largeVertical : rootStyles.largeHorizontal),
      ...isCircular ? circularAppearance : regularAppearance,
      disabled && rootStyles.disabledCursor,
      slot.className
    );
    return state;
  };
  var useTabContentStyles_unstable = (state) => {
    "use no memo";
    const iconStyles = useIconStyles4();
    const contentStyles = useContentStyles2();
    const {
      selected,
      size: size3
    } = state;
    if (state.icon) {
      state.icon.className = mergeClasses(tabClassNames.icon, iconStyles.base, iconStyles[size3], selected && iconStyles.selected, state.icon.className);
    }
    if (state.contentReservedSpace) {
      state.contentReservedSpace.className = mergeClasses(reservedSpaceClassNames.content, contentStyles.base, size3 === "large" ? contentStyles.largeSelected : contentStyles.selected, state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, contentStyles.placeholder, state.content.className);
      state.contentReservedSpaceClassName = state.contentReservedSpace.className;
    }
    state.content.className = mergeClasses(tabClassNames.content, contentStyles.base, size3 === "large" && contentStyles.large, selected && (size3 === "large" ? contentStyles.largeSelected : contentStyles.selected), state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, state.content.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
  var Tab2 = /* @__PURE__ */ React128.forwardRef((props, ref) => {
    const state = useTab_unstable(props, ref);
    useTabStyles_unstable(state);
    useCustomStyleHook("useTabStyles_unstable")(state);
    return renderTab_unstable(state);
  });
  Tab2.displayName = "Tab";

  // ../../node_modules/@fluentui/react-tabs/lib/TabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React130 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React129 = __toESM(require_react());
  var useTabList_unstable = (props, ref) => {
    const { appearance = "transparent", reserveSelectedTabSpace = true, disabled = false, onTabSelect, selectTabOnFocus = false, size: size3 = "medium", vertical = false } = props;
    const innerRef = React129.useRef(null);
    const focusAttributes = useArrowNavigationGroup({
      circular: true,
      axis: vertical ? "vertical" : "horizontal",
      memorizeCurrent: false,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_hasDefault: true
    });
    const [selectedValue, setSelectedValue] = useControllableState({
      state: props.selectedValue,
      defaultState: props.defaultSelectedValue,
      initialState: void 0
    });
    const currentSelectedValue = React129.useRef(void 0);
    const previousSelectedValue = React129.useRef(void 0);
    React129.useEffect(() => {
      previousSelectedValue.current = currentSelectedValue.current;
      currentSelectedValue.current = selectedValue;
    }, [
      selectedValue
    ]);
    const onSelect = useEventCallback((event, data2) => {
      setSelectedValue(data2.value);
      onTabSelect === null || onTabSelect === void 0 ? void 0 : onTabSelect(event, data2);
    });
    const registeredTabs = React129.useRef({});
    const onRegister = useEventCallback((data2) => {
      const key = JSON.stringify(data2.value);
      if (!key && false) {
        console.error([
          `[@fluentui/react-tabs] The value "${data2.value}" cannot be serialized to JSON string.`,
          "Tab component requires serializable values.",
          "Please provide a primitive value (string, number, boolean),",
          `or a plain object/array that doesn't contain functions, symbols, or circular references.`
        ].join(" "));
      }
      registeredTabs.current[key] = data2;
    });
    const onUnregister = useEventCallback((data2) => {
      delete registeredTabs.current[JSON.stringify(data2.value)];
    });
    const getRegisteredTabs = React129.useCallback(() => {
      return {
        selectedValue: currentSelectedValue.current,
        previousSelectedValue: previousSelectedValue.current,
        registeredTabs: registeredTabs.current
      };
    }, []);
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, innerRef),
        role: "tablist",
        "aria-orientation": vertical ? "vertical" : "horizontal",
        ...focusAttributes,
        ...props
      }), {
        elementType: "div"
      }),
      appearance,
      reserveSelectedTabSpace,
      disabled,
      selectTabOnFocus,
      selectedValue,
      size: size3,
      vertical,
      onRegister,
      onUnregister,
      onSelect,
      getRegisteredTabs
    };
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/renderTabList.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderTabList_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {
      children: /* @__PURE__ */ jsx2(TabListProvider, {
        value: contextValues.tabList,
        children: state.root.children
      })
    });
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tabListClassNames = {
    root: "fui-TabList"
  };
  var useStyles9 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Beiy3e4: "f1063pyq",
      Bnnss6s: "fi64zpg",
      Eh141a: "flvyvdh",
      qhf8xq: "f10pi13n"
    },
    horizontal: {
      Bt984gj: "f1q9h2pe",
      Beiy3e4: "f1063pyq"
    },
    vertical: {
      Bt984gj: "f1q9h2pe",
      Beiy3e4: "f1vx9l62"
    },
    roundedSmall: {
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "f1eyhf9v"
    },
    rounded: {
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "faqewft"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fi64zpg{flex-shrink:0;}", ".flvyvdh{flex-wrap:nowrap;}", ".f10pi13n{position:relative;}", ".f1q9h2pe{align-items:stretch;}", ".f1vx9l62{flex-direction:column;}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
      p: -1
    }], [".faqewft{gap:var(--spacingHorizontalS);}", {
      p: -1
    }]]
  });
  var useTabListStyles_unstable = (state) => {
    "use no memo";
    const {
      appearance,
      vertical,
      size: size3
    } = state;
    const styles = useStyles9();
    const isRounded = appearance === "subtle-circular" || appearance === "filled-circular";
    state.root.className = mergeClasses(tabListClassNames.root, styles.root, vertical ? styles.vertical : styles.horizontal, isRounded && (size3 === "small" ? styles.roundedSmall : styles.rounded), state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useTabListContextValues_unstable(state) {
    const { appearance, reserveSelectedTabSpace, disabled, selectTabOnFocus, selectedValue: selectedKey, onRegister, onUnregister, onSelect, getRegisteredTabs, size: size3, vertical } = state;
    const tabList = {
      appearance,
      reserveSelectedTabSpace,
      disabled,
      selectTabOnFocus,
      selectedValue: selectedKey,
      onSelect,
      onRegister,
      onUnregister,
      getRegisteredTabs,
      size: size3,
      vertical
    };
    return {
      tabList
    };
  }

  // ../../node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
  var TabList = /* @__PURE__ */ React130.forwardRef((props, ref) => {
    const state = useTabList_unstable(props, ref);
    const contextValues = useTabListContextValues_unstable(state);
    useTabListStyles_unstable(state);
    useCustomStyleHook("useTabListStyles_unstable")(state);
    return renderTabList_unstable(state, contextValues);
  });
  TabList.displayName = "TabList";

  // ../../node_modules/@fluentui/react-textarea/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-textarea/lib/Textarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React132 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/renderTextarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderTextarea_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {
      children: /* @__PURE__ */ jsx2(state.textarea, {})
    });
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextarea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React131 = __toESM(require_react());
  var useTextarea_unstable = (props, ref) => {
    props = useFieldControlProps_unstable(props, {
      supportsLabelFor: true,
      supportsRequired: true,
      supportsSize: true
    });
    const overrides = useOverrides();
    var _overrides_inputDefaultAppearance;
    const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", resize = "none", onChange } = props;
    if (false) {
      console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
    }
    const [value, setValue] = useControllableState({
      state: props.value,
      defaultState: props.defaultValue,
      initialState: void 0
    });
    const nativeProps = getPartitionedNativeProps({
      props,
      primarySlotTagName: "textarea",
      excludedPropNames: [
        "onChange",
        "value",
        "defaultValue"
      ]
    });
    const state = {
      size: size3,
      appearance,
      resize,
      components: {
        root: "span",
        textarea: "textarea"
      },
      textarea: slot_exports.always(props.textarea, {
        defaultProps: {
          ref,
          ...nativeProps.primary
        },
        elementType: "textarea"
      }),
      root: slot_exports.always(props.root, {
        defaultProps: nativeProps.root,
        elementType: "span"
      })
    };
    state.textarea.value = value;
    state.textarea.onChange = useEventCallback((ev) => {
      const newValue = ev.target.value;
      onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
        value: newValue
      });
      setValue(newValue);
    });
    return state;
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextareaStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var textareaClassNames = {
    root: "fui-Textarea",
    textarea: "fui-Textarea__textarea"
  };
  var useRootStyles8 = /* @__PURE__ */ __styles2({
    base: {
      mc9l5x: "ftuwxu6",
      B7ck84d: "f1ewtqcl",
      qhf8xq: "f10pi13n",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1yiegib",
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: "f1s184ao",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ft85np5",
      ha4doy: "f12kltsn"
    },
    disabled: {
      De3pzq: "f1c21dwh",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "ff3nzm7",
      Bjwas2f: "fg455y9",
      Bn1d65q: ["f1rvyvqg", "f14g86mu"],
      Bxeuatn: "f1cwzwz",
      n51gp8: ["f14g86mu", "f1rvyvqg"]
    },
    interactive: {
      li1rpt: "f1gw3sf2",
      Bsft5z2: "f13zj6fq",
      E3zdtr: "f1mdlcz9",
      Eqx8gd: ["f1a7op3", "f1cjjd47"],
      By385i5: "f1gboi2j",
      B1piin3: ["f1cjjd47", "f1a7op3"],
      Dlnsje: "ffyw7fx",
      d9w3h3: ["f1kp91vd", "f1ibwz09"],
      B3778ie: ["f1ibwz09", "f1kp91vd"],
      B1q35kw: 0,
      Bw17bha: 0,
      Bcgy8vk: 0,
      Bjuhk93: "f1mnjydx",
      Gjdm7m: "fj2g8qd",
      b1kco5: "f1yk9hq",
      Ba2ppi3: "fhwpy7i",
      F2fol1: "f14ee0xe",
      lck23g: "f1xhbsuh",
      df92cz: "fv8e3ye",
      I188md: "ftb5wc6",
      umuwi5: "fjw5xc1",
      Blcqepd: "f1xdyd5c",
      nplu4u: "fatpbeo",
      Bioka5o: "fb7uyps",
      H713fs: "f1cmft4k",
      B9ooomg: "f1x58t8o",
      Bercvud: "f1ibeo51",
      Bbr2w1p: "f1vnc8sk",
      Bduesf4: "f3e99gv",
      Bpq79vn: "fhljsf7"
    },
    filled: {
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f88035w",
      q7v0qe: "ftmjh5b",
      kmh5ft: ["f17blpuu", "fsrcdbj"],
      nagaa4: "f1tpwn32",
      B1yhkcb: ["fsrcdbj", "f17blpuu"]
    },
    "filled-darker": {
      De3pzq: "f16xq7d1"
    },
    "filled-lighter": {
      De3pzq: "fxugw4r"
    },
    "filled-darker-shadow": {
      De3pzq: "f16xq7d1",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1gmd7mu",
      E5pizo: "fyed02w"
    },
    "filled-lighter-shadow": {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f1gmd7mu",
      E5pizo: "fyed02w"
    },
    outline: {
      De3pzq: "fxugw4r",
      Bgfg5da: 0,
      B9xav0g: "f1c1zstj",
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "fhz96rm"
    },
    outlineInteractive: {
      kzujx5: 0,
      oetu4i: "f1l4zc64",
      gvrnp0: 0,
      xv9156: 0,
      jek2p4: 0,
      gg5e9n: 0,
      Beu9t3s: 0,
      dt87k2: 0,
      Bt1vbvt: 0,
      Bwzppfd: 0,
      Bop6t4b: 0,
      B2zwrfe: 0,
      Bwp2tzp: 0,
      Bgoe8wy: 0,
      Bf40cpq: 0,
      ckks6v: 0,
      Baalond: "f9mts5e",
      v2iqwr: 0,
      wmxk5l: "f1z0osm6",
      Bj33j0h: 0,
      Bs0cc2w: 0,
      qwjtx1: 0,
      B50zh58: 0,
      f7epvg: 0,
      e1hlit: 0,
      B7mkhst: 0,
      ak43y8: 0,
      Bbcopvn: 0,
      Bvecx4l: 0,
      lwioe0: 0,
      B6oc9vd: 0,
      e2sjt0: 0,
      uqwnxt: 0,
      asj8p9: "f1acnei2",
      Br8fjdy: 0,
      zoxjo1: "f1so894s",
      Bt3ojkv: 0,
      B7pmvfx: 0,
      Bfht2n1: 0,
      an54nd: 0,
      t1ykpo: 0,
      Belqbek: 0,
      bbt1vd: 0,
      Brahy3i: 0,
      r7b1zc: 0,
      rexu52: 0,
      ovtnii: 0,
      Bvq3b66: 0,
      Bawrxx6: 0,
      Bbs6y8j: 0,
      B2qpgjt: "f19ezbcq"
    },
    invalid: {
      tvckwq: "fs4k3qj",
      gk2u95: ["fcee079", "fmyw78r"],
      hhx65j: "f1fgmyf4",
      Bxowmz0: ["fmyw78r", "fcee079"]
    }
  }, {
    d: [".ftuwxu6{display:inline-flex;}", ".f1ewtqcl{box-sizing:border-box;}", ".f10pi13n{position:relative;}", [".f1yiegib{padding:0 0 var(--strokeWidthThick) 0;}", {
      p: -1
    }], [".f1s184ao{margin:0;}", {
      p: -1
    }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
      p: -1
    }], ".f12kltsn{vertical-align:top;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".ff3nzm7{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeDisabled);}", {
      p: -2
    }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
      p: -1
    }], ".fj2g8qd::after{clip-path:inset(calc(100% - var(--strokeWidthThick)) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -2
    }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
      p: -2
    }], ".fyed02w{box-shadow:var(--shadow2);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
      p: -2
    }], [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
      p: -2
    }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
    m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
      m: "(forced-colors: active)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
      m: "screen and (prefers-reduced-motion: reduce)"
    }]],
    w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1vnc8sk:focus-within{outline-width:var(--strokeWidthThick);}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", [".f19ezbcq:focus-within{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f1so894s:focus-within{border-bottom-color:var(--colorCompoundBrandStroke);}"],
    h: [".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}", [".f9mts5e:hover{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Hover);}", {
      p: -2
    }], ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
    a: [[".f1acnei2:active{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
      p: -2
    }], ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
  });
  var useTextareaStyles = /* @__PURE__ */ __styles2({
    base: {
      icvyot: "f1ern45e",
      vrafjx: ["f1n71otn", "f1deefiw"],
      oivjwe: "f1h8hb77",
      wvpqe5: ["f1deefiw", "f1n71otn"],
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: "f1s184ao",
      De3pzq: "f3rmtva",
      B7ck84d: "f1ewtqcl",
      sj55zd: "f19n0e5",
      Bh6795r: "fqerorx",
      Bahqtrf: "fk6fouc",
      Bqenvij: "f1l02sjl",
      yvdlaj: "fwyc1cq",
      B3o7kgh: "f13ta7ih",
      B4brmom: "f1vw9udw",
      Brrnbx2: "fbb3kq8",
      oeaueh: "f1s6fcnf"
    },
    disabled: {
      sj55zd: "f1s2aq7o",
      Bceei9c: "fdrzuqr",
      yvdlaj: "fahhnxm"
    },
    small: {
      sshi5w: "f1w5jphr",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1pnffij",
      Bxyxcbc: "f192z54u",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fy9rknc",
      Bhrd7zp: "figsok6",
      Bg96gwp: "fwrc4pm"
    },
    medium: {
      sshi5w: "fvmd9f",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1ww82xo",
      Bxyxcbc: "f1if7ixc",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fkhj508",
      Bhrd7zp: "figsok6",
      Bg96gwp: "f1i3iumi"
    },
    large: {
      sshi5w: "f1kfson",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f15hvtkj",
      Bxyxcbc: "f3kip1f",
      Bahqtrf: "fk6fouc",
      Be2twd7: "fod5ikn",
      Bhrd7zp: "figsok6",
      Bg96gwp: "faaz57k"
    }
  }, {
    d: [".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".f1s184ao{margin:0;}", {
      p: -1
    }], ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fqerorx{flex-grow:1;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1l02sjl{height:100%;}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".f1vw9udw::selection{color:var(--colorNeutralForegroundInverted);}", ".fbb3kq8::selection{background-color:var(--colorNeutralBackgroundInverted);}", ".f1s6fcnf{outline-style:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".f1w5jphr{min-height:40px;}", [".f1pnffij{padding:var(--spacingVerticalXS) calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f192z54u{max-height:200px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fvmd9f{min-height:52px;}", [".f1ww82xo{padding:var(--spacingVerticalSNudge) calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f1if7ixc{max-height:260px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1kfson{min-height:64px;}", [".f15hvtkj{padding:var(--spacingVerticalS) calc(var(--spacingHorizontalM) + var(--spacingHorizontalXXS));}", {
      p: -1
    }], ".f3kip1f{max-height:320px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
  });
  var useTextareaResizeStyles = /* @__PURE__ */ __styles2({
    none: {
      B3rzk8w: "f1o1s39h"
    },
    both: {
      B3rzk8w: "f1pxm0xe"
    },
    horizontal: {
      B3rzk8w: "fq6nmtn"
    },
    vertical: {
      B3rzk8w: "f1f5ktr4"
    }
  }, {
    d: [".f1o1s39h{resize:none;}", ".f1pxm0xe{resize:both;}", ".fq6nmtn{resize:horizontal;}", ".f1f5ktr4{resize:vertical;}"]
  });
  var useTextareaStyles_unstable = (state) => {
    "use no memo";
    const {
      size: size3,
      appearance,
      resize
    } = state;
    const disabled = state.textarea.disabled;
    const invalid = `${state.textarea["aria-invalid"]}` === "true";
    const filled = appearance.startsWith("filled");
    const rootStyles = useRootStyles8();
    state.root.className = mergeClasses(textareaClassNames.root, rootStyles.base, disabled && rootStyles.disabled, !disabled && filled && rootStyles.filled, !disabled && rootStyles[appearance], !disabled && rootStyles.interactive, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && invalid && rootStyles.invalid, state.root.className);
    const textareaStyles = useTextareaStyles();
    const textareaResizeStyles = useTextareaResizeStyles();
    state.textarea.className = mergeClasses(textareaClassNames.textarea, textareaStyles.base, textareaStyles[size3], textareaResizeStyles[resize], disabled && textareaStyles.disabled, state.textarea.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
  var Textarea = /* @__PURE__ */ React132.forwardRef((props, ref) => {
    const state = useTextarea_unstable(props, ref);
    useTextareaStyles_unstable(state);
    useCustomStyleHook("useTextareaStyles_unstable")(state);
    return renderTextarea_unstable(state);
  });
  Textarea.displayName = "Textarea";

  // ../../node_modules/@fluentui/react-dialog/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/Dialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React140 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React137 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/utils/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React133 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useHTMLNoScrollStyles = /* @__PURE__ */ __resetStyles2("r6pzz3z", null, [".r6pzz3z{overflow-y:hidden;overflow-y:clip;scrollbar-gutter:stable;}"]);
  var useBodyNoScrollStyles = /* @__PURE__ */ __resetStyles2("r144vlu9", null, [".r144vlu9{overflow-y:hidden;}"]);

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
  function useDisableBodyScroll() {
    const htmlNoScrollStyles = useHTMLNoScrollStyles();
    const bodyNoScrollStyles = useBodyNoScrollStyles();
    const { targetDocument } = useFluent();
    const disableBodyScroll = React133.useCallback(() => {
      var _targetDocument_defaultView;
      if (!targetDocument) {
        return;
      }
      var _targetDocument_defaultView_innerHeight;
      const isHorizontalScrollbarVisible = (
        // When the window is a fractional height, `innerHeight` always rounds down but `clientHeight` rounds either up or down depending on the value.
        // To properly compare the body clientHeight to the window innerHeight, manually round down the fractional value to match innerHeight's calculation.
        Math.floor(targetDocument.body.getBoundingClientRect().height) > ((_targetDocument_defaultView_innerHeight = (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.innerHeight) !== null && _targetDocument_defaultView_innerHeight !== void 0 ? _targetDocument_defaultView_innerHeight : 0)
      );
      if (!isHorizontalScrollbarVisible) {
        return;
      }
      targetDocument.documentElement.classList.add(htmlNoScrollStyles);
      targetDocument.body.classList.add(bodyNoScrollStyles);
      return;
    }, [
      targetDocument,
      htmlNoScrollStyles,
      bodyNoScrollStyles
    ]);
    const enableBodyScroll = React133.useCallback(() => {
      if (!targetDocument) {
        return;
      }
      targetDocument.documentElement.classList.remove(htmlNoScrollStyles);
      targetDocument.body.classList.remove(bodyNoScrollStyles);
    }, [
      targetDocument,
      htmlNoScrollStyles,
      bodyNoScrollStyles
    ]);
    return {
      disableBodyScroll,
      enableBodyScroll
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/utils/useFocusFirstElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React134 = __toESM(require_react());
  function useFocusFirstElement(open, modalType) {
    const { findFirstFocusable } = useFocusFinders();
    const { targetDocument } = useFluent();
    const dialogRef = React134.useRef(null);
    React134.useEffect(() => {
      if (!open) {
        return;
      }
      const element4 = dialogRef.current && findFirstFocusable(dialogRef.current);
      if (element4) {
        element4.focus();
      } else {
        var _dialogRef_current;
        (_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 ? void 0 : _dialogRef_current.focus();
        if (false) {
          console.warn(`@fluentui/react-dialog [useFocusFirstElement]:
A Dialog should have at least one focusable element inside DialogSurface.
Please add at least a close button either on \`DialogTitle\` action slot or inside \`DialogActions\``);
        }
      }
    }, [
      findFirstFocusable,
      open,
      modalType,
      targetDocument
    ]);
    return dialogRef;
  }

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/dialogContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React135 = __toESM(require_react());
  var defaultContextValue = {
    open: false,
    inertTrapFocus: false,
    modalType: "modal",
    isNestedDialog: false,
    dialogRef: {
      current: null
    },
    requestOpenChange() {
    }
  };
  var DialogContext = createContext20(void 0);
  var DialogProvider = DialogContext.Provider;
  var useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue) => selector(ctx));

  // ../../node_modules/@fluentui/react-dialog/lib/contexts/dialogSurfaceContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React136 = __toESM(require_react());
  var defaultContextValue2 = false;
  var DialogSurfaceContext = React136.createContext(void 0);
  var DialogSurfaceProvider = DialogSurfaceContext.Provider;
  var useDialogSurfaceContext_unstable = () => {
    var _React_useContext;
    return (_React_useContext = React136.useContext(DialogSurfaceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue2;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurfaceMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var keyframes = [
    {
      opacity: 0,
      boxShadow: "0px 0px 0px 0px rgba(0, 0, 0, 0.1)",
      transform: "scale(0.85) translateZ(0)"
    },
    {
      boxShadow: tokens.shadow64,
      transform: "scale(1) translateZ(0)",
      opacity: 1
    }
  ];
  var DialogSurfaceMotion = createPresenceComponent({
    enter: {
      keyframes,
      easing: motionTokens.curveDecelerateMid,
      duration: motionTokens.durationGentle
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      easing: motionTokens.curveAccelerateMin,
      duration: motionTokens.durationGentle
    }
  });

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
  var useDialog_unstable = (props) => {
    const { children: children2, modalType = "modal", onOpenChange, inertTrapFocus = false } = props;
    const [trigger, content3] = childrenToTriggerAndContent(children2);
    const [open, setOpen] = useControllableState({
      state: props.open,
      defaultState: props.defaultOpen,
      initialState: false
    });
    const requestOpenChange = useEventCallback((data2) => {
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data2.event, data2);
      if (!data2.event.isDefaultPrevented()) {
        setOpen(data2.open);
      }
    });
    const focusRef = useFocusFirstElement(open, modalType);
    const { modalAttributes, triggerAttributes } = useModalAttributes({
      trapFocus: modalType !== "non-modal",
      legacyTrapFocus: !inertTrapFocus
    });
    const isNestedDialog = useHasParentContext(DialogContext);
    return {
      components: {
        // TODO: remove once React v18 slot API is modified
        // This is a problem at the moment due to UnknownSlotProps assumption
        // that `children` property is `ReactNode`, which in this case is not valid
        // as PresenceComponentProps['children'] is `ReactElement`
        surfaceMotion: DialogSurfaceMotion
      },
      inertTrapFocus,
      open,
      modalType,
      content: content3,
      trigger,
      requestOpenChange,
      dialogTitleId: useId4("dialog-title-"),
      isNestedDialog,
      dialogRef: focusRef,
      modalAttributes,
      triggerAttributes,
      surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
        elementType: DialogSurfaceMotion,
        defaultProps: {
          appear: true,
          visible: open,
          unmountOnExit: true
        }
      })
    };
  };
  function childrenToTriggerAndContent(children2) {
    const childrenArray = React137.Children.toArray(children2);
    if (false) {
      if (childrenArray.length !== 1 && childrenArray.length !== 2) {
        console.warn(`@fluentui/react-dialog [useDialog]:
Dialog must contain at least one child <DialogSurface/>,
and at most two children <DialogTrigger/> <DialogSurface/> (in this order).`);
      }
    }
    switch (childrenArray.length) {
      // case where there's a trigger followed by content
      case 2:
        return childrenArray;
      // case where there's only content
      case 1:
        return [
          void 0,
          childrenArray[0]
        ];
      // unknown case
      default:
        return [
          void 0,
          void 0
        ];
    }
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React139 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/MotionRefForwarder.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React138 = __toESM(require_react());
  var MotionRefForwarderContext = /* @__PURE__ */ React138.createContext(void 0);
  function useMotionForwardedRef() {
    return React138.useContext(MotionRefForwarderContext);
  }
  var MotionRefForwarder = /* @__PURE__ */ React138.forwardRef((props, ref) => {
    return /* @__PURE__ */ React138.createElement(MotionRefForwarderContext.Provider, {
      value: ref
    }, props.children);
  });

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
  var renderDialog_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(DialogProvider, {
      value: contextValues.dialog,
      children: /* @__PURE__ */ jsxs2(DialogSurfaceProvider, {
        value: contextValues.dialogSurface,
        children: [
          state.trigger,
          state.content && /* @__PURE__ */ jsx2(state.surfaceMotion, {
            children: /* @__PURE__ */ jsx2(MotionRefForwarder, {
              children: state.content
            })
          })
        ]
      })
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialogContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useDialogContextValues_unstable(state) {
    const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes } = state;
    const dialog = {
      open,
      modalType,
      dialogRef,
      dialogTitleId,
      isNestedDialog,
      inertTrapFocus,
      modalAttributes,
      triggerAttributes,
      requestOpenChange
    };
    const dialogSurface = false;
    return {
      dialog,
      dialogSurface
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
  var Dialog = /* @__PURE__ */ React140.memo((props) => {
    const state = useDialog_unstable(props);
    const contextValues = useDialogContextValues_unstable(state);
    return renderDialog_unstable(state, contextValues);
  });
  Dialog.displayName = "Dialog";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React142 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/useDialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React141 = __toESM(require_react());
  var useDialogTrigger_unstable = (props) => {
    const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
    const { children: children2, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
    const child = getTriggerChild(children2);
    const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
    const { triggerAttributes } = useModalAttributes();
    const handleClick = useEventCallback((event) => {
      var _child_props_onClick, _child_props;
      child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, event);
      if (!event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          type: "triggerClick",
          open: action === "open"
        });
      }
    });
    const triggerChildProps = {
      ...child === null || child === void 0 ? void 0 : child.props,
      ref: child === null || child === void 0 ? void 0 : child.ref,
      onClick: handleClick,
      ...triggerAttributes
    };
    const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
      ...triggerChildProps,
      type: "button"
    });
    return {
      children: applyTriggerPropsToChildren(children2, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/renderDialogTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDialogTrigger_unstable = (state) => state.children;

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
  var DialogTrigger = (props) => {
    const state = useDialogTrigger_unstable(props);
    return renderDialogTrigger_unstable(state);
  };
  DialogTrigger.displayName = "DialogTrigger";
  DialogTrigger.isFluentTriggerComponent = true;

  // ../../node_modules/@fluentui/react-dialog/lib/DialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React144 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React143 = __toESM(require_react());
  var useDialogBody_unstable = (props, ref) => {
    var _props_as;
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/renderDialogBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDialogBody_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {});
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBodyStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var dialogBodyClassNames = {
    root: "fui-DialogBody"
  };
  var useResetStyles = /* @__PURE__ */ __resetStyles2("r1h3qql9", null, {
    r: [".r1h3qql9{overflow:unset;gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
    s: ["@media screen and (max-width: 480px){.r1h3qql9{max-width:100vw;grid-template-rows:auto 1fr auto;}}", "@media screen and (max-height: 359px){.r1h3qql9{max-height:unset;}}"]
  });
  var useDialogBodyStyles_unstable = (state) => {
    "use no memo";
    const resetStyles = useResetStyles();
    state.root.className = mergeClasses(dialogBodyClassNames.root, resetStyles, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
  var DialogBody = /* @__PURE__ */ React144.forwardRef((props, ref) => {
    const state = useDialogBody_unstable(props, ref);
    useDialogBodyStyles_unstable(state);
    useCustomStyleHook("useDialogBodyStyles_unstable")(state);
    return renderDialogBody_unstable(state);
  });
  DialogBody.displayName = "DialogBody";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React146 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React145 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitleStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var dialogTitleClassNames = {
    root: "fui-DialogTitle",
    action: "fui-DialogTitle__action"
  };
  var useRootResetStyles = /* @__PURE__ */ __resetStyles2("rxjm636", null, [".rxjm636{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
  var useStyles10 = /* @__PURE__ */ __styles2({
    rootWithoutAction: {
      Bw0ie65: "fsyjsko"
    }
  }, {
    d: [".fsyjsko{grid-column-end:4;}"]
  });
  var useActionResetStyles = /* @__PURE__ */ __resetStyles2("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
  var useDialogTitleInternalStyles = /* @__PURE__ */ __resetStyles2("r2avt6e", "roj2bbc", {
    r: [".r2avt6e{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".r2avt6e:focus{outline-style:none;}", ".r2avt6e:focus-visible{outline-style:none;}", ".r2avt6e[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2avt6e[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".roj2bbc{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".roj2bbc:focus{outline-style:none;}", ".roj2bbc:focus-visible{outline-style:none;}", ".roj2bbc[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.roj2bbc[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.r2avt6e[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.roj2bbc[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
  });
  var useDialogTitleStyles_unstable = (state) => {
    "use no memo";
    const rootResetStyles = useRootResetStyles();
    const actionResetStyles = useActionResetStyles();
    const styles = useStyles10();
    state.root.className = mergeClasses(dialogTitleClassNames.root, rootResetStyles, !state.action && styles.rootWithoutAction, state.root.className);
    if (state.action) {
      state.action.className = mergeClasses(dialogTitleClassNames.action, actionResetStyles, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
  var useDialogTitle_unstable = (props, ref) => {
    const { action } = props;
    const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
    const internalStyles = useDialogTitleInternalStyles();
    return {
      components: {
        root: "h2",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("h2", {
        ref,
        id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
        ...props
      }), {
        elementType: "h2"
      }),
      action: slot_exports.optional(action, {
        renderByDefault: modalType === "non-modal",
        defaultProps: {
          children: /* @__PURE__ */ React145.createElement(DialogTrigger, {
            disableButtonEnhancement: true,
            action: "close"
          }, /* @__PURE__ */ React145.createElement("button", {
            type: "button",
            className: internalStyles,
            // TODO: find a better way to add internal labels
            "aria-label": "close"
          }, /* @__PURE__ */ React145.createElement(Dismiss20Regular, null)))
        },
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/renderDialogTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDialogTitle_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(import_react36.Fragment, {
      children: [
        /* @__PURE__ */ jsx2(state.root, {
          children: state.root.children
        }),
        state.action && /* @__PURE__ */ jsx2(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
  var DialogTitle = /* @__PURE__ */ React146.forwardRef((props, ref) => {
    const state = useDialogTitle_unstable(props, ref);
    useDialogTitleStyles_unstable(state);
    useCustomStyleHook("useDialogTitleStyles_unstable")(state);
    return renderDialogTitle_unstable(state);
  });
  DialogTitle.displayName = "DialogTitle";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React148 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React147 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogBackdropMotion.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var DialogBackdropMotion = FadeRelaxed;

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
  var useDialogSurface_unstable = (props, ref) => {
    const contextRef = useMotionForwardedRef();
    const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
    const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
    const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
    const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
    const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
    const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
    const open = useDialogContext_unstable((ctx) => ctx.open);
    const handledBackdropClick = useEventCallback((event) => {
      if (isResolvedShorthand(props.backdrop)) {
        var _props_backdrop_onClick, _props_backdrop;
        (_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 ? void 0 : _props_backdrop_onClick.call(_props_backdrop, event);
      }
      if (modalType === "modal" && !event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          open: false,
          type: "backdropClick"
        });
      }
    });
    const handleKeyDown = useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if (event.key === Escape && !event.isDefaultPrevented()) {
        requestOpenChange({
          event,
          open: false,
          type: "escapeKeyDown"
        });
        event.preventDefault();
      }
    });
    const backdrop = slot_exports.optional(props.backdrop, {
      renderByDefault: modalType !== "non-modal",
      defaultProps: {
        "aria-hidden": "true"
      },
      elementType: "div"
    });
    if (backdrop) {
      backdrop.onClick = handledBackdropClick;
    }
    const { disableBodyScroll, enableBodyScroll } = useDisableBodyScroll();
    useIsomorphicLayoutEffect2(() => {
      if (isNestedDialog || modalType === "non-modal") {
        return;
      }
      disableBodyScroll();
      return () => {
        enableBodyScroll();
      };
    }, [
      enableBodyScroll,
      isNestedDialog,
      disableBodyScroll,
      modalType
    ]);
    return {
      components: {
        backdrop: "div",
        root: "div",
        // TODO: remove once React v18 slot API is modified
        // This is a problem at the moment due to UnknownSlotProps assumption
        // that `children` property is `ReactNode`, which in this case is not valid
        // as PresenceComponentProps['children'] is `ReactElement`
        backdropMotion: DialogBackdropMotion
      },
      open,
      backdrop,
      isNestedDialog,
      mountNode: props.mountNode,
      root: slot_exports.always(getIntrinsicElementProps("div", {
        tabIndex: -1,
        "aria-modal": modalType !== "non-modal",
        role: modalType === "alert" ? "alertdialog" : "dialog",
        "aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
        ...props,
        ...modalAttributes,
        onKeyDown: handleKeyDown,
        // FIXME:
        // `DialogSurfaceElement` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, contextRef, dialogRef)
      }), {
        elementType: "div"
      }),
      backdropMotion: presenceMotionSlot(props.backdropMotion, {
        elementType: DialogBackdropMotion,
        defaultProps: {
          appear: true,
          visible: open
        }
      }),
      // Deprecated properties
      transitionStatus: void 0
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/renderDialogSurface.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDialogSurface_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(Portal, {
      mountNode: state.mountNode,
      children: [
        state.backdrop && // TODO: state.backdropMotion is non nullable, but assertSlots asserts it as nullable
        // FIXME: this should be resolved by properly splitting props and state slots declaration
        state.backdropMotion && /* @__PURE__ */ jsx2(state.backdropMotion, {
          children: /* @__PURE__ */ jsx2(state.backdrop, {})
        }),
        /* @__PURE__ */ jsx2(DialogSurfaceProvider, {
          value: contextValues.dialogSurface,
          children: /* @__PURE__ */ jsx2(state.root, {})
        })
      ]
    });
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var dialogSurfaceClassNames = {
    root: "fui-DialogSurface",
    backdrop: "fui-DialogSurface__backdrop"
  };
  var useRootBaseStyle = /* @__PURE__ */ __resetStyles2("rsmdyd3", "rup8wml", {
    r: [".rsmdyd3{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".rsmdyd3:focus{outline-style:none;}", ".rsmdyd3:focus-visible{outline-style:none;}", ".rsmdyd3[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rsmdyd3[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rup8wml{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".rup8wml:focus{outline-style:none;}", ".rup8wml:focus-visible{outline-style:none;}", ".rup8wml[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rup8wml[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
    s: ["@media (forced-colors: active){.rsmdyd3[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media screen and (max-width: 480px){.rsmdyd3{max-width:100vw;}}", "@media screen and (max-height: 359px){.rsmdyd3{overflow-y:auto;padding-right:calc(24px - 4px);border-right-width:4px;border-top-width:4px;border-bottom-width:4px;}}", "@media (forced-colors: active){.rup8wml[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}", "@media screen and (max-width: 480px){.rup8wml{max-width:100vw;}}", "@media screen and (max-height: 359px){.rup8wml{overflow-y:auto;padding-left:calc(24px - 4px);border-left-width:4px;border-top-width:4px;border-bottom-width:4px;}}"]
  });
  var useBackdropBaseStyle = /* @__PURE__ */ __resetStyles2("r1e18s3l", null, [".r1e18s3l{inset:0px;background-color:var(--colorBackgroundOverlay);position:fixed;}"]);
  var useBackdropStyles = /* @__PURE__ */ __styles2({
    nestedDialogBackdrop: {
      De3pzq: "f1c21dwh"
    }
  }, {
    d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}"]
  });
  var useDialogSurfaceStyles_unstable = (state) => {
    "use no memo";
    const {
      isNestedDialog,
      root: root5,
      backdrop
    } = state;
    const rootBaseStyle = useRootBaseStyle();
    const backdropBaseStyle = useBackdropBaseStyle();
    const backdropStyles = useBackdropStyles();
    root5.className = mergeClasses(dialogSurfaceClassNames.root, rootBaseStyle, root5.className);
    if (backdrop) {
      backdrop.className = mergeClasses(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && backdropStyles.nestedDialogBackdrop, backdrop.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useDialogSurfaceContextValues_unstable(state) {
    const dialogSurface = true;
    return {
      dialogSurface
    };
  }

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
  var DialogSurface = /* @__PURE__ */ React148.forwardRef((props, ref) => {
    const state = useDialogSurface_unstable(props, ref);
    const contextValues = useDialogSurfaceContextValues_unstable(state);
    useDialogSurfaceStyles_unstable(state);
    useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
    return renderDialogSurface_unstable(state, contextValues);
  });
  DialogSurface.displayName = "DialogSurface";

  // ../../node_modules/@fluentui/react-dialog/lib/DialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React150 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React149 = __toESM(require_react());
  var useDialogContent_unstable = (props, ref) => {
    var _props_as;
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/renderDialogContent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDialogContent_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {});
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContentStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var dialogContentClassNames = {
    root: "fui-DialogContent"
  };
  var useStyles11 = /* @__PURE__ */ __resetStyles2("r1v5zwsm", null, {
    r: [".r1v5zwsm{padding:var(--strokeWidthThick);margin:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"],
    s: ["@media screen and (max-height: 359px){.r1v5zwsm{overflow-y:unset;}}"]
  });
  var useDialogContentStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles11();
    state.root.className = mergeClasses(dialogContentClassNames.root, styles, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
  var DialogContent = /* @__PURE__ */ React150.forwardRef((props, ref) => {
    const state = useDialogContent_unstable(props, ref);
    useDialogContentStyles_unstable(state);
    useCustomStyleHook("useDialogContentStyles_unstable")(state);
    return renderDialogContent_unstable(state);
  });
  DialogContent.displayName = "DialogContent";

  // ../../node_modules/@fluentui/react-table/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-table/lib/contexts/tableContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React151 = __toESM(require_react());
  var tableContext = React151.createContext(void 0);
  var TableContextProvider = tableContext.Provider;

  // ../../node_modules/@fluentui/react-table/lib/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-table/lib/components/Table/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-table/lib/components/Table/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React154 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React152 = __toESM(require_react());
  var useTable_unstable = (props, ref) => {
    var _props_as;
    const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
    var _props_size, _props_noNativeElements, _props_sortable;
    return {
      components: {
        root: rootComponent
      },
      root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        role: rootComponent === "div" ? "table" : void 0,
        ...props
      }), {
        elementType: rootComponent
      }),
      size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
      noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
      sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
    };
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderTable_unstable = (state, contextValues) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(TableContextProvider, {
      value: contextValues.table,
      children: /* @__PURE__ */ jsx2(state.root, {})
    });
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var tableClassName = "fui-Table";
  var useTableLayoutStyles = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f1w4nmp0",
      ha4doy: "fmrv4ls",
      a9b677: "fly5x3f",
      B73mfa3: "f14m3nip"
    }
  }, {
    d: [".f1w4nmp0{display:table;}", ".fmrv4ls{vertical-align:middle;}", ".fly5x3f{width:100%;}", ".f14m3nip{table-layout:fixed;}"]
  });
  var useFlexLayoutStyles = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "ftgm304"
    }
  }, {
    d: [".ftgm304{display:block;}"]
  });
  var useStyles12 = /* @__PURE__ */ __styles2({
    root: {
      po53p8: "fgkb47j",
      De3pzq: "fhovq9v"
    }
  }, {
    d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"]
  });
  var useTableStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles12();
    const layoutStyles = {
      table: useTableLayoutStyles(),
      flex: useFlexLayoutStyles()
    };
    state.root.className = mergeClasses(tableClassName, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React153 = __toESM(require_react());
  function useTableContextValues_unstable(state) {
    const { size: size3, noNativeElements, sortable } = state;
    const tableContext2 = React153.useMemo(() => ({
      noNativeElements,
      size: size3,
      sortable
    }), [
      noNativeElements,
      size3,
      sortable
    ]);
    return {
      table: tableContext2
    };
  }

  // ../../node_modules/@fluentui/react-table/lib/components/Table/Table.js
  var Table = /* @__PURE__ */ React154.forwardRef((props, ref) => {
    const state = useTable_unstable(props, ref);
    useTableStyles_unstable(state);
    useCustomStyleHook("useTableStyles_unstable")(state);
    return renderTable_unstable(state, useTableContextValues_unstable(state));
  });
  Table.displayName = "Table";

  // ../../node_modules/@fluentui/react-card/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/Card/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/Card/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React159 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React157 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardSelectable.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React155 = __toESM(require_react());
  var useCardSelectable = (props, { referenceLabel, referenceId }, cardRef) => {
    const { checkbox = {}, onSelectionChange, floatingAction, onClick, onKeyDown } = props;
    const { findAllFocusable } = useFocusFinders();
    const checkboxRef = React155.useRef(null);
    const [selected, setSelected] = useControllableState({
      state: props.selected,
      defaultState: props.defaultSelected,
      initialState: false
    });
    const selectable = [
      props.selected,
      props.defaultSelected,
      onSelectionChange
    ].some((prop) => typeof prop !== "undefined");
    const [selectFocused, setSelectFocused] = React155.useState(false);
    const shouldRestrictTriggerAction = React155.useCallback((event) => {
      if (!cardRef.current) {
        return false;
      }
      const focusableElements = findAllFocusable(cardRef.current);
      const target = event.target;
      const isElementInFocusableGroup = focusableElements.some((element4) => element4.contains(target));
      const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
      return isElementInFocusableGroup && !isCheckboxSlot;
    }, [
      cardRef,
      findAllFocusable
    ]);
    const onChangeHandler = React155.useCallback((event) => {
      if (shouldRestrictTriggerAction(event)) {
        return;
      }
      const newCheckedValue = !selected;
      setSelected(newCheckedValue);
      if (onSelectionChange) {
        onSelectionChange(event, {
          selected: newCheckedValue
        });
      }
    }, [
      onSelectionChange,
      selected,
      setSelected,
      shouldRestrictTriggerAction
    ]);
    const onKeyDownHandler = React155.useCallback((event) => {
      if ([
        Enter
      ].includes(event.key)) {
        event.preventDefault();
        onChangeHandler(event);
      }
    }, [
      onChangeHandler
    ]);
    const checkboxSlot = React155.useMemo(() => {
      if (!selectable || floatingAction) {
        return;
      }
      const selectableCheckboxProps = {};
      if (referenceId) {
        selectableCheckboxProps["aria-labelledby"] = referenceId;
      } else if (referenceLabel) {
        selectableCheckboxProps["aria-label"] = referenceLabel;
      }
      return slot_exports.optional(checkbox, {
        defaultProps: {
          ref: checkboxRef,
          type: "checkbox",
          checked: selected,
          onChange: (event) => onChangeHandler(event),
          onFocus: () => setSelectFocused(true),
          onBlur: () => setSelectFocused(false),
          ...selectableCheckboxProps
        },
        elementType: "input"
      });
    }, [
      checkbox,
      floatingAction,
      selected,
      selectable,
      onChangeHandler,
      referenceId,
      referenceLabel
    ]);
    const floatingActionSlot = React155.useMemo(() => {
      if (!floatingAction) {
        return;
      }
      return slot_exports.optional(floatingAction, {
        defaultProps: {
          ref: checkboxRef
        },
        elementType: "div"
      });
    }, [
      floatingAction
    ]);
    const selectableCardProps = React155.useMemo(() => {
      if (!selectable) {
        return null;
      }
      return {
        onClick: mergeCallbacks(onClick, onChangeHandler),
        onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
      };
    }, [
      selectable,
      onChangeHandler,
      onClick,
      onKeyDown,
      onKeyDownHandler
    ]);
    return {
      selected,
      selectable,
      selectFocused,
      selectableCardProps,
      checkboxSlot,
      floatingActionSlot
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/CardContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React156 = __toESM(require_react());
  var cardContext = React156.createContext(void 0);
  var cardContextDefaultValue = {
    selectableA11yProps: {
      referenceId: void 0,
      setReferenceId() {
      },
      referenceLabel: void 0,
      setReferenceLabel() {
      }
    }
  };
  var CardProvider = cardContext.Provider;
  var useCardContext_unstable = () => {
    var _React_useContext;
    return (_React_useContext = React156.useContext(cardContext)) !== null && _React_useContext !== void 0 ? _React_useContext : cardContextDefaultValue;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCard.js
  var focusMap = {
    off: void 0,
    "no-tab": "limited-trap-focus",
    "tab-exit": "limited",
    "tab-only": "unlimited"
  };
  var useCardInteractive = ({ focusMode: initialFocusMode, ...props }) => {
    const interactive = [
      "onClick",
      "onDoubleClick",
      "onMouseUp",
      "onMouseDown",
      "onPointerUp",
      "onPointerDown",
      "onTouchStart",
      "onTouchEnd",
      "onDragStart",
      "onDragEnd"
    ].some((prop) => props[prop]);
    const focusMode = initialFocusMode !== null && initialFocusMode !== void 0 ? initialFocusMode : interactive ? "no-tab" : "off";
    const groupperAttrs = useFocusableGroup({
      tabBehavior: focusMap[focusMode]
    });
    const interactiveFocusAttributes = {
      ...groupperAttrs,
      tabIndex: 0
    };
    return {
      interactive,
      focusAttributes: focusMode === "off" ? null : interactiveFocusAttributes
    };
  };
  var useCard_unstable = (props, ref) => {
    const { appearance = "filled", orientation = "vertical", size: size3 = "medium" } = props;
    const [referenceId, setReferenceId] = React157.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
    const [referenceLabel, setReferenceLabel] = React157.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
    const cardBaseRef = useFocusWithin();
    const { selectable, selected, selectableCardProps, selectFocused, checkboxSlot, floatingActionSlot } = useCardSelectable(props, {
      referenceId,
      referenceLabel
    }, cardBaseRef);
    const cardRef = useMergedRefs(cardBaseRef, ref);
    const { interactive, focusAttributes } = useCardInteractive(props);
    return {
      appearance,
      orientation,
      size: size3,
      interactive,
      selectable,
      selectFocused,
      selected,
      selectableA11yProps: {
        setReferenceId,
        referenceId,
        referenceLabel,
        setReferenceLabel
      },
      components: {
        root: "div",
        floatingAction: "div",
        checkbox: "input"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref: cardRef,
        role: "group",
        ...!selectable ? focusAttributes : null,
        ...props,
        ...selectableCardProps
      }), {
        elementType: "div"
      }),
      floatingAction: floatingActionSlot,
      checkbox: checkboxSlot
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/renderCard.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderCard_unstable = (state, cardContextValue) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {
      children: /* @__PURE__ */ jsxs2(CardProvider, {
        value: cardContextValue,
        children: [
          state.checkbox ? /* @__PURE__ */ jsx2(state.checkbox, {}) : null,
          state.floatingAction ? /* @__PURE__ */ jsx2(state.floatingAction, {}) : null,
          state.root.children
        ]
      })
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React158 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreviewStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cardPreviewClassNames = {
    root: "fui-CardPreview",
    logo: "fui-CardPreview__logo"
  };
  var useStyles13 = /* @__PURE__ */ __styles2({
    root: {
      qhf8xq: "f10pi13n",
      Byfpedg: "fgourly",
      Btj6oj6: "f1vui7lx",
      B1m4t4s: "fda5zwx"
    },
    logo: {
      qhf8xq: "f1euv43f",
      B5kzvoi: "f1gcvs1y",
      oyh7mz: ["f1t6tvco", "ffrfxm3"],
      a9b677: "f1szoe96",
      Bqenvij: "f1d2rq10"
    }
  }, {
    d: [".f10pi13n{position:relative;}", ".fgourly>:not(.fui-CardPreview__logo){display:block;}", ".f1vui7lx>:not(.fui-CardPreview__logo){height:100%;}", ".fda5zwx>:not(.fui-CardPreview__logo){width:100%;}", ".f1euv43f{position:absolute;}", ".f1gcvs1y{bottom:12px;}", ".f1t6tvco{left:12px;}", ".ffrfxm3{right:12px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
  });
  var useCardPreviewStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles13();
    state.root.className = mergeClasses(cardPreviewClassNames.root, styles.root, state.root.className);
    if (state.logo) {
      state.logo.className = mergeClasses(cardPreviewClassNames.logo, styles.logo, state.logo.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeaderStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cardHeaderClassNames = {
    root: "fui-CardHeader",
    image: "fui-CardHeader__image",
    header: "fui-CardHeader__header",
    description: "fui-CardHeader__description",
    action: "fui-CardHeader__action"
  };
  var useStyles14 = /* @__PURE__ */ __styles2({
    root: {
      Bkc6ea2: "fkufhic",
      Bt984gj: "f122n59"
    },
    image: {
      mc9l5x: "ftuwxu6",
      t21cq0: ["fql5097", "f6yss9k"]
    },
    header: {
      mc9l5x: "f22iagw"
    },
    description: {
      mc9l5x: "f22iagw"
    },
    action: {
      Frg6f3: ["f6yss9k", "fql5097"],
      B7frvx2: "f1ndzpm5",
      B06c7xf: ["f1fkeggc", "f1u45u6i"],
      B8uq84v: "f16eyofs",
      snkdo8: ["f1u45u6i", "f1fkeggc"],
      Bpf22ct: "f1wkmkig",
      apjfyd: "f18alut9"
    }
  }, {
    d: [".fkufhic{--fui-CardHeader--gap:12px;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fql5097{margin-right:var(--fui-CardHeader--gap);}", ".f6yss9k{margin-left:var(--fui-CardHeader--gap);}", ".f22iagw{display:flex;}"],
    m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useStylesGrid = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f13qh94s",
      t4k1zu: "f8a668j"
    },
    image: {
      Br312pm: "fwpfdsa",
      Ijaq50: "fldnz9j"
    },
    header: {
      Br312pm: "fd46tj4",
      Ijaq50: "f16hsg94"
    },
    description: {
      Br312pm: "fd46tj4",
      Ijaq50: "faunodf"
    },
    action: {
      Br312pm: "fis13di",
      Ijaq50: "fldnz9j"
    }
  }, {
    d: [".f13qh94s{display:grid;}", ".f8a668j{grid-auto-columns:min-content 1fr min-content;}", ".fwpfdsa{grid-column-start:1;}", ".fldnz9j{grid-row-start:span 2;}", ".fd46tj4{grid-column-start:2;}", ".f16hsg94{grid-row-start:1;}", ".faunodf{grid-row-start:2;}", ".fis13di{grid-column-start:3;}"]
  });
  var useStylesFlex = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw"
    },
    header: {
      Bh6795r: "fqerorx"
    },
    image: {},
    description: {},
    action: {}
  }, {
    d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}"]
  });
  var useCardHeaderStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles14();
    const stylesGrid = useStylesGrid();
    const stylesFlex = useStylesFlex();
    const boxModelStyles = state.description ? stylesGrid : stylesFlex;
    const getSlotStyles = (slotName) => {
      var _state_slotName;
      return mergeClasses(cardHeaderClassNames[slotName], styles[slotName], boxModelStyles[slotName], (_state_slotName = state[slotName]) === null || _state_slotName === void 0 ? void 0 : _state_slotName.className);
    };
    state.root.className = getSlotStyles("root");
    if (state.image) {
      state.image.className = getSlotStyles("image");
    }
    if (state.header) {
      state.header.className = getSlotStyles("header");
    }
    if (state.description) {
      state.description.className = getSlotStyles("description");
    }
    if (state.action) {
      state.action.className = getSlotStyles("action");
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooterStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var cardFooterClassNames = {
    root: "fui-CardFooter",
    action: "fui-CardFooter__action"
  };
  var useStyles15 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Beiy3e4: "f1063pyq",
      i8kkvl: 0,
      Belr9w4: 0,
      rmohyg: "fsbu5mz"
    },
    action: {
      Frg6f3: ["fcgxt0o", "f1ujusj6"],
      B7frvx2: "f1ndzpm5",
      B06c7xf: ["f1fkeggc", "f1u45u6i"],
      B8uq84v: "f16eyofs",
      snkdo8: ["f1u45u6i", "f1fkeggc"],
      Bpf22ct: "f1wkmkig",
      apjfyd: "f18alut9"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", [".fsbu5mz{gap:12px;}", {
      p: -1
    }], ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}"],
    m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
      m: "(forced-colors: active)"
    }]]
  });
  var useCardFooterStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles15();
    state.root.className = mergeClasses(cardFooterClassNames.root, styles.root, state.root.className);
    if (state.action) {
      state.action.className = mergeClasses(cardFooterClassNames.action, styles.action, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
  var cardClassNames = {
    root: "fui-Card",
    floatingAction: "fui-Card__floatingAction",
    checkbox: "fui-Card__checkbox"
  };
  var cardCSSVars = {
    cardSizeVar: "--fui-Card--size",
    cardBorderRadiusVar: "--fui-Card--border-radius"
  };
  var focusOutlineStyle = {
    outlineRadius: `var(${cardCSSVars.cardBorderRadiusVar})`,
    outlineWidth: tokens.strokeWidthThick,
    outlineOffset: "-2px"
  };
  var useCardResetStyles = /* @__PURE__ */ __resetStyles2("rfxo2k2", "rgle7w9", [".rfxo2k2{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rfxo2k2::after{position:absolute;top:0;left:0;right:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rfxo2k2>.fui-CardHeader,.rfxo2k2>.fui-CardFooter{flex-shrink:0;}", ".rgle7w9{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rgle7w9::after{position:absolute;top:0;right:0;left:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rgle7w9>.fui-CardHeader,.rgle7w9>.fui-CardFooter{flex-shrink:0;}"]);
  var useCardStyles = /* @__PURE__ */ __styles2({
    focused: {
      Brovlpu: "ftqa4ok",
      B486eqv: "f2hkw1w",
      B8q5s1w: "f8hki3x",
      Bci5o5g: ["f1d2448m", "ffh67wi"],
      n8qw10: "f1bjia2o",
      Bdrgwmp: ["ffh67wi", "f1d2448m"],
      Bb7d1vk: "f226i61",
      zhwhgb: ["f13kzufm", "fsx75g8"],
      dhy2o1: "flujwa2",
      Gfyso: ["fsx75g8", "f13kzufm"],
      Bm4h7ae: "f15bsgw9",
      B7ys5i9: "f14e48fq",
      Busjfv9: "f18yb2kv",
      Bhk32uz: "fd6o370",
      f6g5ot: 0,
      Boxcth7: 0,
      Bhdgwq3: 0,
      hgwjuy: 0,
      Bshpdp8: 0,
      Bsom6fd: 0,
      Blkhhs4: 0,
      Bonggc9: 0,
      Ddfuxk: 0,
      i03rao: 0,
      kclons: 0,
      clg4pj: 0,
      Bpqj9nj: 0,
      B6dhp37: 0,
      Bf4ptjt: 0,
      Bqtpl0w: 0,
      i4rwgc: "fpqizxz",
      Dah5zi: 0,
      B1tsrr9: 0,
      qqdqy8: 0,
      Bkh64rk: 0,
      e3fwne: "fnd8nzh",
      J0r882: "f15fr7a0",
      Bule8hv: ["fwsq40z", "fy0y4wt"],
      Bjwuhne: "f34ld9f",
      Ghsupd: ["fy0y4wt", "fwsq40z"]
    },
    selectableFocused: {
      Brovlpu: "ftqa4ok",
      B486eqv: "f2hkw1w",
      Bssx7fj: "f1b1k54r",
      uh7if5: ["f4ne723", "fqqcjud"],
      clntm0: "fh7aioi",
      Dlk2r6: ["fqqcjud", "f4ne723"],
      Bm3wd5j: "f1k55ka9",
      Bbrhkcr: ["fgclinu", "f16pcs8n"],
      f1oku: "fycbxed",
      aywvf2: ["f16pcs8n", "fgclinu"],
      B2j2mmj: "ffht0p2",
      wigs8: "f1p0ul1q",
      pbfy6t: "f1c901ms",
      B0v4ure: "f1alokd7",
      Byrf0fs: 0,
      Bsiemmq: 0,
      Bwckmig: 0,
      skfxo0: 0,
      Iidy0u: 0,
      B98u21t: 0,
      Bvwlmkc: 0,
      jo1ztg: 0,
      Ba1iezr: 0,
      Blmvk6g: 0,
      B24cy0v: 0,
      Bil7v7r: 0,
      Br3gin4: 0,
      nr063g: 0,
      ghq09: 0,
      Bbgo44z: 0,
      Bseh09z: "f1i978nd",
      az1dzo: 0,
      Ba3ybja: 0,
      B6352mv: 0,
      vppk2z: 0,
      Biaj6j7: "f1nh8hsq",
      B2pnrqr: "f1amxum7",
      B29w5g4: ["f1cec8w7", "f554mv0"],
      Bhhzhcn: "f1sj6kbr",
      Bec0n69: ["f554mv0", "f1cec8w7"]
    },
    orientationHorizontal: {
      Beiy3e4: "f1063pyq",
      Bt984gj: "f122n59",
      Binpb3b: "ftrw7vg",
      qrt8p2: "f18opajm",
      k6ws3r: ["f13002it", "fqo182t"],
      Btcwela: ["f18yna97", "f1kd6wh7"],
      Fer9m8: "f4i4759"
    },
    orientationVertical: {
      Beiy3e4: "f1vx9l62",
      B5nvv7i: ["f14k419y", "f1fgo9fz"],
      Baxg94k: ["f1fgo9fz", "f14k419y"],
      tn21ii: "fvqmfsm",
      B0ud6bj: "f3am6yf",
      Bgdo4j: "f1r5wgso"
    },
    sizeSmall: {
      B7balbw: "f1pi9uxy",
      B1h88n7: "f1h1zgly"
    },
    sizeMedium: {
      B7balbw: "frsmuga",
      B1h88n7: "fuldkky"
    },
    sizeLarge: {
      B7balbw: "f1qua4xo",
      B1h88n7: "fimkt6v"
    },
    interactive: {
      rhjd8f: "f1epqm3e"
    },
    filled: {
      De3pzq: "fxugw4r",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    filledInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "fxugw4r",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "f1knas48",
      Bvxd0ez: "f1m145df",
      ecr2s2: "fb40n2d"
    },
    filledInteractiveSelected: {
      De3pzq: "f1nfm20t",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "f1kz6goq"
    },
    filledAlternative: {
      De3pzq: "f1dmdbja",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    filledAlternativeInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "f1dmdbja",
      E5pizo: "f1whvlc6",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "fnwyq0v",
      Jwef8y: "f1uvynv3",
      Bvxd0ez: "f1m145df",
      ecr2s2: "f1yhgkbh"
    },
    filledAlternativeInteractiveSelected: {
      De3pzq: "fjxa0vh",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "f1luvkty",
      Jwef8y: "fehi0vp"
    },
    outline: {
      De3pzq: "f1c21dwh",
      E5pizo: "f1couhl3",
      B0n5ga8: "ft83z1f",
      s924m2: ["f1g4150c", "f192dr6e"],
      B1q35kw: "f1qnawh6",
      Gp14am: ["f192dr6e", "f1g4150c"]
    },
    outlineInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "f1c21dwh",
      E5pizo: "f1couhl3",
      B0n5ga8: "ft83z1f",
      s924m2: ["f1g4150c", "f192dr6e"],
      B1q35kw: "f1qnawh6",
      Gp14am: ["f192dr6e", "f1g4150c"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "fjxutwb",
      Be0v6ae: "f1llr77y",
      B5kxglz: ["fzk0khw", "fjj8tog"],
      B3pwyw6: "fb1u8ub",
      Bymgtzf: ["fjj8tog", "fzk0khw"],
      ecr2s2: "fophhak",
      dmfk: "f1uohb70",
      B4ofi8: ["f1jm7v1n", "f1bus3rq"],
      jgq6uv: "f1fbu7rr",
      Baxewws: ["f1bus3rq", "f1jm7v1n"]
    },
    outlineInteractiveSelected: {
      De3pzq: "f1q9pm1r",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "fg59vm4"
    },
    subtle: {
      De3pzq: "fhovq9v",
      E5pizo: "f1couhl3",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"]
    },
    subtleInteractive: {
      Bceei9c: "f1k6fduh",
      De3pzq: "fhovq9v",
      E5pizo: "f1couhl3",
      B0n5ga8: "f16gxe2i",
      s924m2: ["fpgykix", "fzybk4o"],
      B1q35kw: "f1osi826",
      Gp14am: ["fzybk4o", "fpgykix"],
      Bi91k9c: "feu1g3u",
      Jwef8y: "f1t94bn6",
      ecr2s2: "f1wfn5kd"
    },
    subtleInteractiveSelected: {
      De3pzq: "fq5gl1p",
      B0n5ga8: "f16eln5f",
      s924m2: ["fa2okxs", "fg4zq3l"],
      B1q35kw: "ff6932p",
      Gp14am: ["fg4zq3l", "fa2okxs"],
      Bi91k9c: "fx9teim",
      Jwef8y: "f1uqaxdt"
    },
    highContrastSelected: {
      ycbfsm: "fkc42ay",
      Bsw6fvg: "f1rirnrt",
      Bbusuzp: "f1lkg8j3",
      xgfqdd: "f1nkj0oa",
      Bmmdzwq: "fey3rwa",
      zkpvhj: ["f5jhx11", "fff9uym"],
      B20bydw: "fm7n0jy",
      Bwwwggl: ["fff9uym", "f5jhx11"]
    },
    highContrastInteractive: {
      h1vhog: "fpfvv3l",
      kslmdy: "f1oamsm6",
      Baaf6ca: "f1il21bs",
      x9zz3d: "fnn5dk0",
      Bmmdzwq: "fey3rwa",
      zkpvhj: ["f5jhx11", "fff9uym"],
      B20bydw: "fm7n0jy",
      Bwwwggl: ["fff9uym", "f5jhx11"]
    },
    select: {
      qhf8xq: "f1euv43f",
      Bhzewxz: "fqclxi7",
      j35jbq: ["fiv86kb", "f36uhnt"],
      Bj3rh1h: "f19g0ac"
    },
    hiddenCheckbox: {
      B68tc82: 0,
      Bmxbyg5: 0,
      Bpg54ce: "f1a3p1vp",
      a9b677: "frkrog8",
      Bqenvij: "f1mpe4l3",
      qhf8xq: "f1euv43f",
      Bh84pgu: "fmf1zke",
      Bgl5zvf: "f1wch0ki",
      Huce71: "fz5stix"
    }
  }, {
    f: [".ftqa4ok:focus{outline-style:none;}"],
    i: [".f2hkw1w:focus-visible{outline-style:none;}"],
    d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".fpqizxz[data-fui-focus-visible]::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
      p: -2
    }], [".fnd8nzh[data-fui-focus-visible]::after{border-radius:var(--fui-Card--border-radius);}", {
      p: -1
    }], ".f15fr7a0[data-fui-focus-visible]::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".fwsq40z[data-fui-focus-visible]::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".fy0y4wt[data-fui-focus-visible]::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f34ld9f[data-fui-focus-visible]::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
      p: -2
    }], [".f1nh8hsq[data-fui-focus-within]:focus-within::after{border-radius:var(--fui-Card--border-radius);}", {
      p: -1
    }], ".f1amxum7[data-fui-focus-within]:focus-within::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1cec8w7[data-fui-focus-within]:focus-within::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".f554mv0[data-fui-focus-within]:focus-within::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1sj6kbr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".ftrw7vg>.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", ".f18opajm>.fui-CardPreview{margin-bottom:calc(var(--fui-Card--size) * -1);}", '.f13002it>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', '.fqo182t>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f18yna97>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f1kd6wh7>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', ".f4i4759>.fui-CardHeader:last-of-type,.f4i4759>.fui-CardFooter:last-of-type{flex-grow:1;}", ".f1vx9l62{flex-direction:column;}", ".f14k419y>.fui-CardPreview{margin-left:calc(var(--fui-Card--size) * -1);}", ".f1fgo9fz>.fui-CardPreview{margin-right:calc(var(--fui-Card--size) * -1);}", '.fvqmfsm>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-top:calc(var(--fui-Card--size) * -1);}', ".f3am6yf>.fui-Card__floatingAction+.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", '.f1r5wgso>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-bottom:calc(var(--fui-Card--size) * -1);}', ".f1pi9uxy{--fui-Card--size:8px;}", ".f1h1zgly{--fui-Card--border-radius:var(--borderRadiusSmall);}", ".frsmuga{--fui-Card--size:12px;}", ".fuldkky{--fui-Card--border-radius:var(--borderRadiusMedium);}", ".f1qua4xo{--fui-Card--size:16px;}", ".fimkt6v{--fui-Card--border-radius:var(--borderRadiusLarge);}", ".f1epqm3e .fui-Text{color:currentColor;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1whvlc6{box-shadow:var(--shadow4);}", ".f16gxe2i::after{border-top-color:var(--colorTransparentStroke);}", ".fpgykix::after{border-right-color:var(--colorTransparentStroke);}", ".fzybk4o::after{border-left-color:var(--colorTransparentStroke);}", ".f1osi826::after{border-bottom-color:var(--colorTransparentStroke);}", ".f1k6fduh{cursor:pointer;}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f16eln5f::after{border-top-color:var(--colorNeutralStroke1Selected);}", ".fa2okxs::after{border-right-color:var(--colorNeutralStroke1Selected);}", ".fg4zq3l::after{border-left-color:var(--colorNeutralStroke1Selected);}", ".ff6932p::after{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1dmdbja{background-color:var(--colorNeutralBackground2);}", ".fjxa0vh{background-color:var(--colorNeutralBackground2Selected);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1couhl3{box-shadow:none;}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1euv43f{position:absolute;}", ".fqclxi7{top:4px;}", ".fiv86kb{right:4px;}", ".f36uhnt{left:4px;}", ".f19g0ac{z-index:1;}", [".f1a3p1vp{overflow:hidden;}", {
      p: -1
    }], ".frkrog8{width:1px;}", ".f1mpe4l3{height:1px;}", ".fmf1zke{clip:rect(0 0 0 0);}", ".f1wch0ki{clip-path:inset(50%);}", ".fz5stix{white-space:nowrap;}"],
    m: [["@media (forced-colors: active){.f226i61[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f13kzufm[data-fui-focus-visible]::after{border-right-color:Highlight;}.fsx75g8[data-fui-focus-visible]::after{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.flujwa2[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1nkj0oa .fui-CardPreview,.f1nkj0oa .fui-CardFooter{forced-color-adjust:auto;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fey3rwa::after{border-top-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f5jhx11::after{border-right-color:Highlight;}.fff9uym::after{border-left-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fm7n0jy::after{border-bottom-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fpfvv3l:hover,.fpfvv3l :active{forced-color-adjust:none;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1oamsm6:hover,.f1oamsm6 :active{background-color:Highlight;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.f1il21bs:hover,.f1il21bs :active{color:HighlightText;}}", {
      m: "(forced-colors: active)"
    }], ["@media (forced-colors: active){.fnn5dk0:hover .fui-CardPreview,.fnn5dk0 :active .fui-CardPreview,.fnn5dk0:hover .fui-CardFooter,.fnn5dk0 :active .fui-CardFooter{forced-color-adjust:auto;}}", {
      m: "(forced-colors: active)"
    }]],
    h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".f1m145df:hover{box-shadow:var(--shadow8);}", ".fx9teim:hover{color:var(--colorNeutralForeground1Selected);}", ".f1kz6goq:hover{background-color:var(--colorNeutralBackground1Selected);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1uvynv3:hover{background-color:var(--colorNeutralBackground2Hover);}", ".f1luvkty:hover{color:var(--colorNeutralForeground2Selected);}", ".fehi0vp:hover{background-color:var(--colorNeutralBackground2Selected);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1llr77y:hover::after{border-top-color:var(--colorNeutralStroke1Hover);}", ".fzk0khw:hover::after{border-right-color:var(--colorNeutralStroke1Hover);}", ".fjj8tog:hover::after{border-left-color:var(--colorNeutralStroke1Hover);}", ".fb1u8ub:hover::after{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".fg59vm4:hover{background-color:var(--colorTransparentBackgroundSelected);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}"],
    a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1yhgkbh:active{background-color:var(--colorNeutralBackground2Pressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1uohb70:active::after{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1jm7v1n:active::after{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1bus3rq:active::after{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1fbu7rr:active::after{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
  });
  var useCardStyles_unstable = (state) => {
    "use no memo";
    const resetStyles = useCardResetStyles();
    const styles = useCardStyles();
    const orientationMap = {
      horizontal: styles.orientationHorizontal,
      vertical: styles.orientationVertical
    };
    const sizeMap2 = {
      small: styles.sizeSmall,
      medium: styles.sizeMedium,
      large: styles.sizeLarge
    };
    const appearanceMap = {
      filled: styles.filled,
      "filled-alternative": styles.filledAlternative,
      outline: styles.outline,
      subtle: styles.subtle
    };
    const selectedMap = {
      filled: styles.filledInteractiveSelected,
      "filled-alternative": styles.filledAlternativeInteractiveSelected,
      outline: styles.outlineInteractiveSelected,
      subtle: styles.subtleInteractiveSelected
    };
    const interactiveMap = {
      filled: styles.filledInteractive,
      "filled-alternative": styles.filledAlternativeInteractive,
      outline: styles.outlineInteractive,
      subtle: styles.subtleInteractive
    };
    const isSelectableOrInteractive = state.interactive || state.selectable;
    const focusedClassName = React158.useMemo(() => {
      if (state.selectable) {
        if (state.selectFocused) {
          return styles.selectableFocused;
        }
        return "";
      }
      return styles.focused;
    }, [state.selectFocused, state.selectable, styles.focused, styles.selectableFocused]);
    state.root.className = mergeClasses(cardClassNames.root, resetStyles, orientationMap[state.orientation], sizeMap2[state.size], appearanceMap[state.appearance], isSelectableOrInteractive && styles.interactive, isSelectableOrInteractive && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], focusedClassName, isSelectableOrInteractive && styles.highContrastInteractive, state.selected && styles.highContrastSelected, state.root.className);
    if (state.floatingAction) {
      state.floatingAction.className = mergeClasses(cardClassNames.floatingAction, styles.select, state.floatingAction.className);
    }
    if (state.checkbox) {
      state.checkbox.className = mergeClasses(cardClassNames.checkbox, styles.hiddenCheckbox, state.checkbox.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-card/lib/components/Card/useCardContextValue.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useCardContextValue({ selectableA11yProps }) {
    return {
      selectableA11yProps
    };
  }

  // ../../node_modules/@fluentui/react-card/lib/components/Card/Card.js
  var Card = /* @__PURE__ */ React159.forwardRef((props, ref) => {
    const state = useCard_unstable(props, ref);
    const cardContextValue = useCardContextValue(state);
    useCardStyles_unstable(state);
    useCustomStyleHook("useCardStyles_unstable")(state);
    return renderCard_unstable(state, cardContextValue);
  });
  Card.displayName = "Card";

  // ../../node_modules/@fluentui/react-card/lib/CardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React161 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React160 = __toESM(require_react());
  var useCardFooter_unstable = (props, ref) => {
    const { action } = props;
    return {
      components: {
        root: "div",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      action: slot_exports.optional(action, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/renderCardFooter.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderCardFooter_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.root.children,
        state.action && /* @__PURE__ */ jsx2(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
  var CardFooter = /* @__PURE__ */ React161.forwardRef((props, ref) => {
    const state = useCardFooter_unstable(props, ref);
    useCardFooterStyles_unstable(state);
    useCustomStyleHook("useCardFooterStyles_unstable")(state);
    return renderCardFooter_unstable(state);
  });
  CardFooter.displayName = "CardFooter";

  // ../../node_modules/@fluentui/react-card/lib/CardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React163 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React162 = __toESM(require_react());
  function getChildWithId(header) {
    function isReactElementWithIdProp(element4) {
      return React162.isValidElement(element4) && Boolean(element4.props.id);
    }
    return React162.Children.toArray(header).find(isReactElementWithIdProp);
  }
  function getReferenceId(headerId, childWithId, generatedId) {
    if (headerId) {
      return headerId;
    }
    if (childWithId === null || childWithId === void 0 ? void 0 : childWithId.props.id) {
      return childWithId.props.id;
    }
    return generatedId;
  }
  var useCardHeader_unstable = (props, ref) => {
    const { image: image3, header, description, action } = props;
    const { selectableA11yProps: { referenceId, setReferenceId } } = useCardContext_unstable();
    const headerRef = React162.useRef(null);
    const hasChildId = React162.useRef(false);
    const generatedId = useId4(cardHeaderClassNames.header, referenceId);
    const headerSlot = slot_exports.optional(header, {
      renderByDefault: true,
      defaultProps: {
        ref: headerRef,
        id: !hasChildId.current ? referenceId : void 0
      },
      elementType: "div"
    });
    React162.useEffect(() => {
      var _headerRef_current;
      const headerId = !hasChildId.current ? (_headerRef_current = headerRef.current) === null || _headerRef_current === void 0 ? void 0 : _headerRef_current.id : void 0;
      const childWithId = getChildWithId(headerSlot === null || headerSlot === void 0 ? void 0 : headerSlot.children);
      hasChildId.current = Boolean(childWithId);
      setReferenceId(getReferenceId(headerId, childWithId, generatedId));
    }, [
      generatedId,
      header,
      headerSlot,
      setReferenceId
    ]);
    return {
      components: {
        root: "div",
        image: "div",
        header: "div",
        description: "div",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      image: slot_exports.optional(image3, {
        elementType: "div"
      }),
      header: headerSlot,
      description: slot_exports.optional(description, {
        elementType: "div"
      }),
      action: slot_exports.optional(action, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/renderCardHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderCardHeader_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.image && /* @__PURE__ */ jsx2(state.image, {}),
        state.header && /* @__PURE__ */ jsx2(state.header, {}),
        state.description && /* @__PURE__ */ jsx2(state.description, {}),
        state.action && /* @__PURE__ */ jsx2(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
  var CardHeader = /* @__PURE__ */ React163.forwardRef((props, ref) => {
    const state = useCardHeader_unstable(props, ref);
    useCardHeaderStyles_unstable(state);
    useCustomStyleHook("useCardHeaderStyles_unstable")(state);
    return renderCardHeader_unstable(state);
  });
  CardHeader.displayName = "CardHeader";

  // ../../node_modules/@fluentui/react-card/lib/CardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React165 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React164 = __toESM(require_react());
  var useCardPreview_unstable = (props, ref) => {
    const { logo } = props;
    const { selectableA11yProps: { referenceLabel, referenceId, setReferenceLabel, setReferenceId } } = useCardContext_unstable();
    const previewRef = useMergedRefs(ref, React164.useRef(null));
    React164.useEffect(() => {
      if (referenceLabel && referenceId) {
        return;
      }
      if (previewRef.current && previewRef.current.parentNode) {
        const img = previewRef.current.parentNode.querySelector(`.${cardPreviewClassNames.root} > img`);
        if (img) {
          const ariaLabel = img.getAttribute("aria-label");
          const ariaDescribedby = img.getAttribute("aria-describedby");
          if (ariaDescribedby) {
            setReferenceId(ariaDescribedby);
          } else if (img.alt) {
            setReferenceLabel(img.alt);
          } else if (ariaLabel) {
            setReferenceLabel(ariaLabel);
          }
        }
      }
    }, [
      setReferenceLabel,
      referenceLabel,
      previewRef,
      referenceId,
      setReferenceId
    ]);
    return {
      components: {
        root: "div",
        logo: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref: previewRef,
        ...props
      }), {
        elementType: "div"
      }),
      logo: slot_exports.optional(logo, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/renderCardPreview.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderCardPreview_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.root.children,
        state.logo && /* @__PURE__ */ jsx2(state.logo, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
  var CardPreview = /* @__PURE__ */ React165.forwardRef((props, ref) => {
    const state = useCardPreview_unstable(props, ref);
    useCardPreviewStyles_unstable(state);
    useCustomStyleHook("useCardPreviewStyles_unstable")(state);
    return renderCardPreview_unstable(state);
  });
  CardPreview.displayName = "CardPreview";

  // ../../node_modules/@fluentui/react-drawer/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/contexts/drawerContext.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React166 = __toESM(require_react());
  var defaultContextValue3 = {
    scrollState: "none",
    setScrollState: () => ({})
  };
  var drawerContext = React166.createContext(void 0);
  var DrawerProvider = drawerContext.Provider;
  var useDrawerContext_unstable = () => {
    var _React_useContext;
    return (_React_useContext = React166.useContext(drawerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue3;
  };
  var useDrawerContextValue = () => {
    const [scrollState, setScrollState] = React166.useState("none");
    return {
      setScrollState,
      scrollState
    };
  };

  // ../../node_modules/@fluentui/react-drawer/lib/shared/drawerMotions.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/shared/useDrawerBaseStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var drawerCSSVars = {
    drawerSizeVar: "--fui-Drawer--size"
  };
  var drawerDefaultStyles = {
    overflow: "hidden",
    width: `var(${drawerCSSVars.drawerSizeVar})`,
    maxWidth: "100vw",
    height: "auto",
    maxHeight: "100vh",
    boxSizing: "border-box",
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-start",
    justifyContent: "flex-start",
    backgroundColor: tokens.colorNeutralBackground1,
    color: tokens.colorNeutralForeground1
  };
  var useDrawerStyles = /* @__PURE__ */ __styles2({
    start: {
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      u1mtju: ["f1xteiwb", "fsqykmd"],
      oyh7mz: ["f1vgc2s3", "f1e31b4d"],
      j35jbq: ["fvfyk4", "frppm18"]
    },
    end: {
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      B4g9neb: ["fsqykmd", "f1xteiwb"],
      j35jbq: ["f1e31b4d", "f1vgc2s3"],
      oyh7mz: ["frppm18", "fvfyk4"]
    },
    bottom: {
      B5kzvoi: "f1yab3r1",
      Bhzewxz: "f198g47y"
    },
    small: {
      Bjr0ffy: "f1exhnwo"
    },
    medium: {
      Bjr0ffy: "fqofjzu"
    },
    large: {
      Bjr0ffy: "fce6y3m"
    },
    full: {
      Bjr0ffy: "fsdmzs6"
    }
  }, {
    d: [[".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -1
    }], [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -1
    }], ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".fvfyk4{right:auto;}", ".frppm18{left:auto;}", [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -1
    }], [".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
      p: -1
    }], ".f1yab3r1{bottom:0;}", ".f198g47y{top:auto;}", ".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".fsdmzs6{--fui-Drawer--size:100vw;}"]
  });
  var useDrawerBottomBaseStyles = /* @__PURE__ */ __styles2({
    small: {
      Bjr0ffy: "f1exhnwo"
    },
    medium: {
      Bjr0ffy: "fqofjzu"
    },
    large: {
      Bjr0ffy: "fce6y3m"
    },
    full: {
      Bjr0ffy: "f1rat34m"
    }
  }, {
    d: [".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".f1rat34m{--fui-Drawer--size:100%;}"]
  });
  var useDrawerBaseClassNames = ({
    position: position4,
    size: size3
  }) => {
    const baseStyles = useDrawerStyles();
    const bottomBaseStyles = useDrawerBottomBaseStyles();
    return mergeClasses(baseStyles[position4], position4 === "bottom" && bottomBaseStyles[size3], position4 !== "bottom" && baseStyles[size3]);
  };

  // ../../node_modules/@fluentui/react-drawer/lib/shared/drawerMotions.js
  var durations3 = {
    small: motionTokens.durationGentle,
    medium: motionTokens.durationSlow,
    large: motionTokens.durationSlower,
    full: motionTokens.durationUltraSlow
  };
  function getPositionTransform(position4, sizeVar, dir) {
    const leftToRightTransform = `translate3d(var(${sizeVar}), 0, 0)`;
    const rightToLeftTransform = `translate3d(calc(var(${sizeVar}) * -1), 0, 0)`;
    const bottomToTopTransform = `translate3d(0, var(${sizeVar}), 0)`;
    if (position4 === "start") {
      return dir === "ltr" ? rightToLeftTransform : leftToRightTransform;
    }
    if (position4 === "end") {
      return dir === "ltr" ? leftToRightTransform : rightToLeftTransform;
    }
    if (position4 === "bottom") {
      return bottomToTopTransform;
    }
    return "translate3d(0, 0, 0)";
  }
  var InlineDrawerMotion = createPresenceComponent(({ position: position4, size: size3, dir }) => {
    const keyframes2 = [
      {
        /**
        * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
        * The work will be done in the #32817
        */
        transform: getPositionTransform(position4, drawerCSSVars.drawerSizeVar, dir),
        opacity: 0
      },
      {
        transform: "translate3d(0, 0, 0)",
        opacity: 1
      }
    ];
    const duration = durations3[size3];
    return {
      enter: {
        keyframes: keyframes2,
        duration,
        easing: motionTokens.curveDecelerateMid
      },
      exit: {
        keyframes: [
          ...keyframes2
        ].reverse(),
        duration,
        easing: motionTokens.curveAccelerateMin
      }
    };
  });
  var OverlayDrawerMotion = createPresenceComponent(({ position: position4, size: size3, dir }) => {
    const keyframes2 = [
      {
        /**
        * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
        * The work will be done in the #32817
        */
        transform: getPositionTransform(position4, drawerCSSVars.drawerSizeVar, dir),
        boxShadow: `0px ${tokens.colorTransparentBackground}`,
        opacity: 0
      },
      {
        transform: "translate3d(0, 0, 0)",
        boxShadow: tokens.shadow64,
        opacity: 1
      }
    ];
    const duration = durations3[size3];
    return {
      enter: {
        keyframes: keyframes2,
        duration,
        easing: motionTokens.curveDecelerateMid
      },
      exit: {
        keyframes: [
          ...keyframes2
        ].reverse(),
        duration,
        easing: motionTokens.curveAccelerateMin
      }
    };
  });
  var OverlaySurfaceBackdropMotion = createPresenceComponent(({ size: size3 }) => {
    const keyframes2 = [
      {
        opacity: 0
      },
      {
        opacity: 1
      }
    ];
    const duration = durations3[size3];
    return {
      enter: {
        keyframes: keyframes2,
        easing: motionTokens.curveLinear,
        duration
      },
      exit: {
        keyframes: [
          ...keyframes2
        ].reverse(),
        easing: motionTokens.curveLinear,
        duration
      }
    };
  });

  // ../../node_modules/@fluentui/react-drawer/lib/shared/useDrawerDefaultProps.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function useDrawerDefaultProps(props) {
    const { open = false, size: size3 = "small", position: position4 = "start" } = props;
    return {
      size: size3,
      position: position4,
      open
    };
  }

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React168 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React167 = __toESM(require_react());
  var STATIC_MOTION = {
    active: true,
    canRender: true,
    ref: React167.createRef(),
    type: "idle"
  };
  var useInlineDrawer_unstable = (props, ref) => {
    const { size: size3, position: position4, open } = useDrawerDefaultProps(props);
    const { separator = false, surfaceMotion } = props;
    const { dir } = useFluent();
    const state = {
      components: {
        root: "div",
        // casting from internal type that has required properties
        // to external type that only has optional properties
        // converting to unknown first as both Function component signatures are not compatible
        surfaceMotion: InlineDrawerMotion
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ...props,
        ref
      }), {
        elementType: "div"
      }),
      open,
      position: position4,
      size: size3,
      separator,
      surfaceMotion: presenceMotionSlot(surfaceMotion, {
        elementType: InlineDrawerMotion,
        defaultProps: {
          position: position4,
          size: size3,
          dir,
          visible: open,
          unmountOnExit: true
        }
      }),
      // Deprecated props
      motion: STATIC_MOTION
    };
    return state;
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/renderInlineDrawer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderInlineDrawer_unstable = (state, contextValue) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(DrawerProvider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx2(state.surfaceMotion, {
        children: /* @__PURE__ */ jsx2(state.root, {})
      })
    });
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawerStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var inlineDrawerClassNames = {
    root: "fui-InlineDrawer"
  };
  var useDrawerResetStyles = /* @__PURE__ */ __resetStyles2("rkjj3x6", null, [".rkjj3x6{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:relative;}"]);
  var borderValue = `1px solid ${tokens.colorNeutralBackground3}`;
  var useDrawerRootStyles = /* @__PURE__ */ __styles2({
    separatorStart: {
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      u1mtju: ["f1cxmi7i", "f1j970fk"]
    },
    separatorEnd: {
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      B4g9neb: ["f1j970fk", "f1cxmi7i"]
    },
    separatorBottom: {
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      i8vvqc: "f1n3kblk"
    },
    start: {},
    end: {},
    bottom: {
      a9b677: "fly5x3f",
      Bqenvij: "fub80nq"
    }
  }, {
    d: [[".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
      p: -1
    }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
      p: -1
    }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
      p: -1
    }], [".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
      p: -1
    }], [".f1n3kblk{border-top:1px solid var(--colorNeutralBackground3);}", {
      p: -1
    }], ".fly5x3f{width:100%;}", ".fub80nq{height:var(--fui-Drawer--size);}"]
  });
  function getSeparatorClass(state, classNames) {
    if (!state.separator) {
      return void 0;
    }
    switch (state.position) {
      case "start":
        return classNames.separatorStart;
      case "end":
        return classNames.separatorEnd;
      case "bottom":
        return classNames.separatorBottom;
      default:
        return void 0;
    }
  }
  var useInlineDrawerStyles_unstable = (state) => {
    "use no memo";
    const resetStyles = useDrawerResetStyles();
    const baseClassNames = useDrawerBaseClassNames(state);
    const rootStyles = useDrawerRootStyles();
    state.root.className = mergeClasses(inlineDrawerClassNames.root, resetStyles, baseClassNames, getSeparatorClass(state, rootStyles), rootStyles[state.position], state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
  var InlineDrawer = /* @__PURE__ */ React168.forwardRef((props, ref) => {
    const state = useInlineDrawer_unstable(props, ref);
    const contextValue = useDrawerContextValue();
    useInlineDrawerStyles_unstable(state);
    useCustomStyleHook("useDrawerInlineStyles_unstable")(state);
    useCustomStyleHook("useInlineDrawerStyles_unstable")(state);
    return renderInlineDrawer_unstable(state, contextValue);
  });
  InlineDrawer.displayName = "InlineDrawer";

  // ../../node_modules/@fluentui/react-drawer/lib/InlineDrawer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/DrawerBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React170 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React169 = __toESM(require_react());
  var getScrollState = ({ scrollTop, scrollHeight, clientHeight }) => {
    if (scrollHeight <= clientHeight) {
      return "none";
    }
    if (scrollTop === 0) {
      return "top";
    }
    if (scrollTop + clientHeight === scrollHeight) {
      return "bottom";
    }
    return "middle";
  };
  var useDrawerBody_unstable = (props, ref) => {
    const { setScrollState } = useDrawerContext_unstable();
    const scrollRef = React169.useRef(null);
    const [setAnimationFrame, cancelAnimationFrame2] = useAnimationFrame();
    const updateScrollState = React169.useCallback(() => {
      if (!scrollRef.current) {
        return;
      }
      setScrollState(getScrollState(scrollRef.current));
    }, [
      setScrollState
    ]);
    const onScroll = React169.useCallback(() => {
      cancelAnimationFrame2();
      setAnimationFrame(() => updateScrollState());
    }, [
      cancelAnimationFrame2,
      setAnimationFrame,
      updateScrollState
    ]);
    useIsomorphicLayoutEffect2(() => {
      cancelAnimationFrame2();
      setAnimationFrame(() => updateScrollState());
      return () => cancelAnimationFrame2();
    }, [
      props.children,
      cancelAnimationFrame2,
      updateScrollState,
      setAnimationFrame
    ]);
    useIsomorphicLayoutEffect2(() => {
      cancelAnimationFrame2();
      setAnimationFrame(() => updateScrollState());
      return () => cancelAnimationFrame2();
    }, [
      cancelAnimationFrame2,
      updateScrollState,
      setAnimationFrame
    ]);
    return {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, scrollRef),
        ...props,
        onScroll: mergeCallbacks(props.onScroll, onScroll)
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/renderDrawerBody.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDrawerBody_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {});
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBodyStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var drawerBodyClassNames = {
    root: "fui-DrawerBody"
  };
  var useStyles16 = /* @__PURE__ */ __resetStyles2("ri6rvx7", null, [".ri6rvx7{padding:0 var(--spacingHorizontalXXL);flex:1;align-self:stretch;position:relative;z-index:1;overflow:auto;}", ".ri6rvx7:last-child{padding-bottom:calc(var(--spacingHorizontalXXL) + 1px);}", ".ri6rvx7:first-child{padding-top:calc(var(--spacingHorizontalXXL) + 1px);}"]);
  var useDrawerBodyStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles16();
    state.root.className = mergeClasses(drawerBodyClassNames.root, styles, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
  var DrawerBody = /* @__PURE__ */ React170.forwardRef((props, ref) => {
    const state = useDrawerBody_unstable(props, ref);
    useDrawerBodyStyles_unstable(state);
    useCustomStyleHook("useDrawerBodyStyles_unstable")(state);
    return renderDrawerBody_unstable(state);
  });
  DrawerBody.displayName = "DrawerBody";

  // ../../node_modules/@fluentui/react-drawer/lib/DrawerHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React172 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React171 = __toESM(require_react());
  var useDrawerHeader_unstable = (props, ref) => {
    const { scrollState } = useDrawerContext_unstable();
    return {
      components: {
        root: "header"
      },
      root: slot_exports.always(getIntrinsicElementProps("header", {
        ref,
        role: "none",
        ...props
      }), {
        elementType: "header"
      }),
      scrollState
    };
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/renderDrawerHeader.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDrawerHeader_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsx2(state.root, {});
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeaderStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var drawerHeaderClassNames = {
    root: "fui-DrawerHeader"
  };
  var useStyles17 = /* @__PURE__ */ __resetStyles2("r3ovn4i", null, [".r3ovn4i{width:100%;max-width:100%;padding:var(--spacingVerticalXXL) var(--spacingHorizontalXXL) var(--spacingVerticalS);gap:var(--spacingHorizontalS);align-self:stretch;display:flex;flex-direction:column;box-sizing:border-box;position:relative;z-index:2;}"]);
  var useDrawerHeaderStyles = /* @__PURE__ */ __styles2({
    separator: {
      Dlnsje: "fxnjyrl",
      E3zdtr: "f1mdlcz9",
      B1piin3: ["f15yvnhg", "f1n6gb5g"],
      Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
      Bp15pi3: "f1564nw5",
      Bjyk6c5: "fdlpgxj",
      F2fol1: "f15cmg8x",
      Ba2ppi3: "f3f8dgl",
      B1dyfl9: "fjvo4va",
      Bsft5z2: "f13zj6fq",
      By385i5: "fo72kxq"
    },
    separatorVisible: {
      Bp15pi3: "fjsqi2x"
    }
  }, {
    d: [".fxnjyrl::after{height:1px;}", ".f1mdlcz9::after{position:absolute;}", ".f15yvnhg::after{right:0;}", ".f1n6gb5g::after{left:0;}", ".f1564nw5::after{opacity:0;}", ".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}", ".f15cmg8x::after{transition-duration:var(--durationNormal);}", ".f3f8dgl::after{transition-property:opacity;}", ".fjvo4va::after{transition-timing-function:var(--curveEasyEase);}", '.f13zj6fq::after{content:"";}', ".fo72kxq::after{bottom:0;}", ".fjsqi2x::after{opacity:1;}"]
  });
  var useDrawerHeaderStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles17();
    const rootStyles = useDrawerHeaderStyles();
    state.root.className = mergeClasses(drawerHeaderClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "bottom"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
  var DrawerHeader = /* @__PURE__ */ React172.forwardRef((props, ref) => {
    const state = useDrawerHeader_unstable(props, ref);
    useDrawerHeaderStyles_unstable(state);
    useCustomStyleHook("useDrawerHeaderStyles_unstable")(state);
    return renderDrawerHeader_unstable(state);
  });
  DrawerHeader.displayName = "DrawerHeader";

  // ../../node_modules/@fluentui/react-drawer/lib/DrawerHeaderTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React174 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React173 = __toESM(require_react());
  var useDrawerHeaderTitle_unstable = (props, ref) => {
    const { children: children2, heading: heading3 } = props;
    const headingId = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
    return {
      components: {
        root: "div",
        heading: "h2",
        action: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref,
        ...props
      }), {
        elementType: "div"
      }),
      heading: slot_exports.optional(heading3, {
        defaultProps: {
          id: headingId,
          children: children2
        },
        renderByDefault: true,
        elementType: "h2"
      }),
      action: slot_exports.optional(props.action, {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/renderDrawerHeaderTitle.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderDrawerHeaderTitle_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.heading && /* @__PURE__ */ jsx2(state.heading, {}),
        state.action && /* @__PURE__ */ jsx2(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitleStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var drawerHeaderTitleClassNames = {
    root: "fui-DrawerHeaderTitle",
    heading: "fui-DrawerHeaderTitle__heading",
    action: "fui-DrawerHeaderTitle__action"
  };
  var useStyles18 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Brf1p80: "f1869bpl",
      Bt984gj: "f122n59",
      i8kkvl: "fsnqrgy"
    },
    action: {
      t21cq0: ["faqnl2i", "fd75udd"]
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f1869bpl{justify-content:space-between;}", ".f122n59{align-items:center;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".faqnl2i{margin-right:calc(var(--spacingHorizontalS) * -1);}", ".fd75udd{margin-left:calc(var(--spacingHorizontalS) * -1);}"]
  });
  var useDrawerHeaderTitleStyles_unstable = (state) => {
    "use no memo";
    const styles = useStyles18();
    const {
      heading: root5 = {},
      action,
      components
    } = state;
    useDialogTitleStyles_unstable({
      components: {
        root: components.heading,
        action: components.action
      },
      root: root5,
      action
    });
    state.root.className = mergeClasses(drawerHeaderTitleClassNames.root, styles.root, state.root.className);
    if (state.heading) {
      state.heading.className = mergeClasses(drawerHeaderTitleClassNames.heading, state.heading.className);
    }
    if (state.action) {
      state.action.className = mergeClasses(drawerHeaderTitleClassNames.action, styles.action, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
  var DrawerHeaderTitle = /* @__PURE__ */ React174.forwardRef((props, ref) => {
    const state = useDrawerHeaderTitle_unstable(props, ref);
    useDrawerHeaderTitleStyles_unstable(state);
    useCustomStyleHook("useDrawerHeaderTitleStyles_unstable")(state);
    return renderDrawerHeaderTitle_unstable(state);
  });
  DrawerHeaderTitle.displayName = "DrawerHeaderTitle";

  // ../../packages/aihappey-theme-fluent/dist/primitives/Button.js
  var iconMap2 = {
    add: (0, import_jsx_runtime61.jsx)(AddRegular, {}),
    edit: (0, import_jsx_runtime61.jsx)(EditRegular, {}),
    delete: (0, import_jsx_runtime61.jsx)(DeleteRegular, {}),
    prompts: (0, import_jsx_runtime61.jsx)(PromptRegular, {}),
    resources: (0, import_jsx_runtime61.jsx)(DocumentRegular, {}),
    mcpServer: (0, import_jsx_runtime61.jsx)(PlugConnectedSettingsRegular, {}),
    send: (0, import_jsx_runtime61.jsx)(SendRegular, {}),
    settings: (0, import_jsx_runtime61.jsx)(SettingsRegular, {}),
    chevronDown: (0, import_jsx_runtime61.jsx)(ChevronDownRegular, {}),
    chevronUp: (0, import_jsx_runtime61.jsx)(ChevronUpRegular, {})
  };
  var Button2 = ({ variant = "primary", size: size3 = "medium", icon, iconPosition = "left", children: children2, ...rest }) => {
    const iconElem = icon ? iconMap2[icon] : void 0;
    return (0, import_jsx_runtime61.jsx)(Button, { appearance: variant === "primary" ? "primary" : variant === "secondary" ? "secondary" : variant === "outline" ? "outline" : "transparent", size: size3 === "sm" || size3 === "small" ? "small" : size3 === "lg" || size3 === "large" ? "large" : "medium", icon: iconElem && iconPosition === "left" ? iconElem : void 0, iconAfter: iconElem && iconPosition === "right" ? iconElem : void 0, ...rest, children: children2 });
  };

  // ../../packages/aihappey-theme-fluent/dist/primitives/Input.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  var Input2 = (props) => {
    const { size: size3, ...rest } = props;
    const sizeProp = typeof size3 === "string" ? size3 === "sm" || size3 === "small" ? "small" : size3 === "lg" || size3 === "large" ? "large" : "medium" : "medium";
    return (0, import_jsx_runtime62.jsx)(Input, { size: sizeProp, ...rest });
  };

  // ../../packages/aihappey-theme-fluent/dist/primitives/Card.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  var Card2 = ({ title, text: text9, children: children2, actions }) => (0, import_jsx_runtime63.jsxs)(Card, { children: [(0, import_jsx_runtime63.jsx)(CardHeader, { header: (0, import_jsx_runtime63.jsx)("span", { children: title }) }), (0, import_jsx_runtime63.jsx)(CardPreview, { children: children2 ?? text9 }), actions && (0, import_jsx_runtime63.jsx)(CardFooter, { children: actions })] });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Alert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());

  // ../../node_modules/@fluentui/react-alert/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/Alert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React176 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/renderAlert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderAlert_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ jsxs2(state.root, {
      children: [
        state.icon && /* @__PURE__ */ jsx2(state.icon, {}),
        state.avatar && /* @__PURE__ */ jsx2(state.avatar, {}),
        state.root.children,
        state.action && /* @__PURE__ */ jsx2(state.action, {})
      ]
    });
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/useAlert.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React175 = __toESM(require_react());
  var useAlert_unstable = (props, ref) => {
    const { appearance = "primary", intent } = props;
    let defaultIcon;
    let defaultRole = "status";
    switch (intent) {
      case "success":
        defaultIcon = /* @__PURE__ */ React175.createElement(CheckmarkCircleFilled, null);
        break;
      case "error":
        defaultIcon = /* @__PURE__ */ React175.createElement(DismissCircleFilled, null);
        defaultRole = "alert";
        break;
      case "warning":
        defaultIcon = /* @__PURE__ */ React175.createElement(WarningFilled, null);
        defaultRole = "alert";
        break;
      case "info":
        defaultIcon = /* @__PURE__ */ React175.createElement(InfoFilled, null);
        break;
    }
    const action = slot_exports.optional(props.action, {
      defaultProps: {
        appearance: "transparent"
      },
      elementType: Button
    });
    const avatar = slot_exports.optional(props.avatar, {
      elementType: Avatar
    });
    let icon;
    if (!avatar) {
      icon = slot_exports.optional(props.icon, {
        defaultProps: {
          children: defaultIcon
        },
        renderByDefault: !!props.intent,
        elementType: "span"
      });
    }
    return {
      action,
      appearance,
      avatar,
      components: {
        root: "div",
        icon: "span",
        action: Button,
        avatar: Avatar
      },
      icon,
      intent,
      root: slot_exports.always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        role: defaultRole,
        children: props.children,
        ...props
      }), {
        elementType: "div"
      })
    };
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/useAlertStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var alertClassNames = {
    root: "fui-Alert",
    icon: "fui-Alert__icon",
    action: "fui-Alert__action",
    avatar: "fui-Alert__avatar"
  };
  var useStyles19 = /* @__PURE__ */ __styles2({
    root: {
      mc9l5x: "f22iagw",
      Bt984gj: "f122n59",
      sshi5w: "f5pgtk9",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f1oic3e7",
      Beyfa6y: 0,
      Bbmb7ep: 0,
      Btl43ni: 0,
      B7oj6ja: 0,
      Dimara: "ff3glw6",
      Bgfg5da: 0,
      B9xav0g: 0,
      oivjwe: 0,
      Bn0qgzm: 0,
      B4g9neb: 0,
      zhjwy3: 0,
      wvpqe5: 0,
      ibv6hh: 0,
      u1mtju: 0,
      h3c5rm: 0,
      vrafjx: 0,
      Bekrc4i: 0,
      i8vvqc: 0,
      g2u3we: 0,
      icvyot: 0,
      B4j52fo: 0,
      irswps: "f9ggezi",
      E5pizo: "fz58gqq",
      Be2twd7: "fkhj508",
      Bhrd7zp: "fl43uef",
      sj55zd: "f19n0e5",
      De3pzq: "fxugw4r"
    },
    inverted: {
      sj55zd: "f1w7i9ko",
      De3pzq: "f5pduvr"
    },
    icon: {
      Bqenvij: "fd461yt",
      Be2twd7: "f4ybsrx",
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: ["fhivll6", "f1cgepy8"]
    },
    avatar: {
      jrapky: 0,
      Frg6f3: 0,
      t21cq0: 0,
      B6of3ja: 0,
      B74szlk: ["fxal17o", "ftghr3s"]
    },
    action: {
      Byoj8tv: 0,
      uwmqm3: 0,
      z189sj: 0,
      z8tnut: 0,
      B0ocmuz: "f4jnnbt",
      Bf4jedk: "fy77jfu",
      Frg6f3: ["fcgxt0o", "f1ujusj6"],
      sj55zd: "f16muhyy"
    }
  }, {
    d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f5pgtk9{min-height:44px;}", [".f1oic3e7{padding:0 12px;}", {
      p: -1
    }], [".ff3glw6{border-radius:4px;}", {
      p: -1
    }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
      p: -2
    }], ".fz58gqq{box-shadow:var(--shadow8);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f5pduvr{background-color:var(--colorNeutralBackgroundInverted);}", ".fd461yt{height:16px;}", ".f4ybsrx{font-size:16px;}", [".fhivll6{padding:0 8px 0 0;}", {
      p: -1
    }], [".f1cgepy8{padding:0 0 0 8px;}", {
      p: -1
    }], [".fxal17o{margin:0 8px 0 0;}", {
      p: -1
    }], [".ftghr3s{margin:0 0 0 8px;}", {
      p: -1
    }], [".f4jnnbt{padding:5px 10px;}", {
      p: -1
    }], ".fy77jfu{min-width:0;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".f16muhyy{color:var(--colorBrandForeground1);}"]
  });
  var useIntentIconStyles = /* @__PURE__ */ __styles2({
    success: {
      sj55zd: "f1m7fhi8"
    },
    error: {
      sj55zd: "f1whyuy6"
    },
    warning: {
      sj55zd: "fpti2h4"
    },
    info: {
      sj55zd: "fkfq4zb"
    }
  }, {
    d: [".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}"]
  });
  var useIntentIconStylesInverted = /* @__PURE__ */ __styles2({
    success: {
      sj55zd: "f1pvjcpr"
    },
    error: {
      sj55zd: "fcrp5ll"
    },
    warning: {
      sj55zd: "f1r8f1cl"
    },
    info: {
      sj55zd: "f1w7i9ko"
    }
  }, {
    d: [".f1pvjcpr{color:var(--colorPaletteGreenForegroundInverted);}", ".fcrp5ll{color:var(--colorPaletteRedForegroundInverted);}", ".f1r8f1cl{color:var(--colorPaletteYellowForegroundInverted);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
  });
  var useActionButtonColorInverted = /* @__PURE__ */ __styles2({
    action: {
      sj55zd: "f1qz2gb0",
      B8q5s1w: "fa5e339",
      Bci5o5g: ["fk4svks", "fqzoz0o"],
      n8qw10: "fw8q0i0",
      Bdrgwmp: ["fqzoz0o", "fk4svks"],
      Bfpq7zp: "f1dlk4fq"
    }
  }, {
    d: [".f1qz2gb0{color:var(--colorBrandForegroundInverted);}", ".fa5e339[data-fui-focus-visible]{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fk4svks[data-fui-focus-visible]{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fqzoz0o[data-fui-focus-visible]{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fw8q0i0[data-fui-focus-visible]{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".f1dlk4fq[data-fui-focus-visible]{outline-color:var(--colorNeutralBackground5Pressed);}"]
  });
  var useAlertStyles_unstable = (state) => {
    const inverted = state.appearance === "inverted";
    const styles = useStyles19();
    const intentIconStylesPrimary = useIntentIconStyles();
    const intentIconStylesInverted = useIntentIconStylesInverted();
    const actionStylesInverted = useActionButtonColorInverted();
    state.root.className = mergeClasses(alertClassNames.root, styles.root, inverted && styles.inverted, state.root.className);
    if (state.icon) {
      state.icon.className = mergeClasses(alertClassNames.icon, styles.icon, state.intent && (inverted ? intentIconStylesInverted[state.intent] : intentIconStylesPrimary[state.intent]), state.icon.className);
    }
    if (state.avatar) {
      state.avatar.className = mergeClasses(alertClassNames.avatar, styles.avatar, state.avatar.className);
    }
    if (state.action) {
      state.action.className = mergeClasses(alertClassNames.action, styles.action, inverted && actionStylesInverted.action, state.action.className);
    }
    return state;
  };

  // ../../node_modules/@fluentui/react-alert/lib/components/Alert/Alert.js
  var Alert = /* @__PURE__ */ React176.forwardRef((props, ref) => {
    const state = useAlert_unstable(props, ref);
    useAlertStyles_unstable(state);
    return renderAlert_unstable(state);
  });
  Alert.displayName = "Alert";

  // ../../packages/aihappey-theme-fluent/dist/primitives/Alert.js
  var Alert2 = ({ variant, className, children: children2 }) => (0, import_jsx_runtime65.jsx)(Alert, { appearance: variant === "danger" || variant === "error" ? "primary" : variant === "warning" ? "inverted" : void 0, className, children: children2 });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Spinner.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var Spinner2 = ({ size: size3 = "tiny", className }) => (0, import_jsx_runtime66.jsx)(Spinner, { size: size3 === "sm" || size3 === "tiny" ? "tiny" : size3 === "xs" || size3 === "extra-small" ? "extra-small" : size3 === "md" || size3 === "medium" ? "medium" : size3 === "lg" || size3 === "large" ? "large" : "tiny", className });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Modal.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var Modal = ({ show, onHide, size: size3, title, centered, children: children2 }) => (0, import_jsx_runtime67.jsxs)(Dialog, { open: show, onOpenChange: (_, data2) => !data2.open && onHide(), children: [(0, import_jsx_runtime67.jsx)(DialogTrigger, { disableButtonEnhancement: true, children: (0, import_jsx_runtime67.jsx)("span", { style: { display: "none" } }) }), (0, import_jsx_runtime67.jsx)(DialogSurface, { style: centered ? {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  } : void 0, children: (0, import_jsx_runtime67.jsxs)(DialogBody, { style: { width: "100%" }, children: [(0, import_jsx_runtime67.jsx)(DialogTitle, { children: title }), (0, import_jsx_runtime67.jsx)(DialogContent, { children: children2 })] }) })] });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Tabs.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  var React177 = __toESM(require_react());
  var Tabs = ({ activeKey, onSelect, className, children: children2 }) => {
    const headers = [];
    let activePanel = null;
    React177.Children.forEach(children2, (child) => {
      if (!React177.isValidElement(child))
        return;
      const tab2 = child;
      const { eventKey, title } = tab2.props;
      headers.push((0, import_jsx_runtime68.jsx)(Tab2, { value: eventKey, children: title }, eventKey));
      if (eventKey === activeKey) {
        activePanel = (0, import_jsx_runtime68.jsx)("div", { style: { padding: "1em 0" }, children: tab2.props.children });
      }
    });
    return (0, import_jsx_runtime68.jsxs)("div", { className, children: [(0, import_jsx_runtime68.jsx)(TabList, { selectedValue: activeKey, onTabSelect: (_, data2) => onSelect(data2.value), children: headers }), activePanel] });
  };

  // ../../packages/aihappey-theme-fluent/dist/primitives/Tab.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var Tab3 = () => null;
  Tab3.displayName = "McpFluentTab";

  // ../../packages/aihappey-theme-fluent/dist/primitives/Badge.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var Badge2 = ({ bg, text: text9, children: children2 }) => (0, import_jsx_runtime69.jsx)(Badge, { color: bg == "primary" ? "brand" : bg, children: text9 ?? children2 });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Table.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  var Table2 = (props) => (0, import_jsx_runtime70.jsx)(Table, { ...props, children: props.children });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Chat.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/Chat.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React180 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/useChat.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/useChatMoverAttribute.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useChatMoverAttribute_unstable = () => useArrowNavigationGroup({
    axis: "vertical",
    memorizeCurrent: true,
    unstable_hasDefault: true
  });

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/useChat.js
  var useChat_unstable = (props, ref) => {
    const arrowAttrs = useChatMoverAttribute_unstable();
    const state = {
      components: {
        root: "div"
      },
      root: slot_exports.always(getIntrinsicElementProps("div", {
        ref,
        ...arrowAttrs,
        ...props
      }), {
        elementType: "div"
      })
    };
    return state;
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/renderChat.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/createElement.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React179 = __toESM(require_react());

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/jsx/createElementFromSlotComponent.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React178 = __toESM(require_react());
  function createElementFromSlotComponent(type, overrideChildren) {
    const { elementType, renderFunction, props } = getMetadataFromSlotComponent(type);
    if (renderFunction) {
      if (overrideChildren.length > 0) {
        props.children = React178.createElement(React178.Fragment, {}, ...overrideChildren);
      }
      return React178.createElement(React178.Fragment, {}, renderFunction(elementType, props));
    }
    return React178.createElement(elementType, props, ...overrideChildren);
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/createElement.js
  function createElement29(type, props, ...children2) {
    if (isSlot(props)) {
      return createElementFromSlotComponent(createCompatSlotComponent(type, props), children2);
    }
    if (isSlot(type)) {
      return createElementFromSlotComponent(type, children2);
    }
    return React179.createElement(type, props, ...children2);
  }

  // ../../node_modules/@fluentui/react-jsx-runtime/lib/index.js
  var import_react77 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/renderChat.js
  var renderChat_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ createElement29(state.root, null);
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/useChatStyles.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var chatClassNames = {
    root: "fui-Chat"
  };
  var useStyles20 = makeStyles2({
    base: {
      display: "flex",
      flexDirection: "column",
      listStyleType: "none",
      width: "100%",
      ...shorthands2.overflow("hidden")
    },
    comfy: {
      paddingLeft: `16px`,
      maxWidth: `1056px`,
      ...shorthands2.margin("auto")
    }
  });
  var useChatStyles_unstable = (state) => {
    const styles = useStyles20();
    state.root.className = mergeClasses(chatClassNames.root, styles.base, styles.comfy, state.root.className);
    return state;
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/Chat/Chat.js
  var Chat = /* @__PURE__ */ React180.forwardRef((props, ref) => {
    const state = useChat_unstable(props, ref);
    useChatStyles_unstable(state);
    return renderChat_unstable(state);
  });
  Chat.displayName = "Chat";

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/ChatMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React185 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/useChatMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React184 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/utils/getDecorationIcon.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React181 = __toESM(require_react());
  var getDecorationIcon = (decoration) => {
    switch (decoration) {
      case "important":
        return /* @__PURE__ */ React181.createElement(ImportantFilled, null);
      case "urgent":
        return /* @__PURE__ */ React181.createElement(AlertUrgentFilled, null);
      case "mention":
        return /* @__PURE__ */ React181.createElement(MentionFilled, null);
      case "mentionEveryone":
        return /* @__PURE__ */ React181.createElement(PeopleFilled, null);
      default:
        return null;
    }
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/utils/useChatMessagePopoverTrigger.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React183 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/utils/useEventCallback.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React182 = __toESM(require_react());
  var useEventCallback2 = (fn) => {
    const callbackRef = React182.useRef(() => {
      throw new Error("Cannot call an event handler while rendering");
    });
    useIsomorphicLayoutEffect2(() => {
      callbackRef.current = fn;
    }, [
      fn
    ]);
    return React182.useCallback((...args) => {
      const callback = callbackRef.current;
      return callback(...args);
    }, [
      callbackRef
    ]);
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/utils/mergeCallbacks.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  function mergeCallbacks2(callback1, callback2) {
    return (...args) => {
      callback1 == null ? void 0 : callback1(...args);
      callback2 == null ? void 0 : callback2(...args);
    };
  }

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/utils/useChatMessagePopoverTrigger.js
  var useChatMessagePopoverTrigger = (state) => {
    const setOpen = usePopoverContext_unstable((context) => context.setOpen);
    const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
    const onMouseEnter = (e) => {
      setOpen(e, true);
    };
    const onMouseLeave = (e) => {
      setOpen(e, false);
    };
    state.body.onMouseEnter = useEventCallback2(mergeCallbacks2(state.body.onMouseEnter, onMouseEnter));
    state.body.onMouseLeave = useEventCallback2(mergeCallbacks2(state.body.onMouseLeave, onMouseLeave));
    state.body.ref = useMergedRefs(state.body.ref, triggerRef);
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/useChatMessage.js
  var useChatMessage_unstable = (props, ref) => {
    const { attached, author, avatar, body, decoration, decorationIcon, decorationLabel, details, persistentTimestamp, reactions, root: root5, showAnimation, timestamp } = props;
    const nativeProps = getPartitionedNativeProps({
      primarySlotTagName: "div",
      props,
      excludedPropNames: [
        "tabIndex"
      ]
    });
    const groupperAttributes = useFocusableGroup({
      tabBehavior: "limited-trap-focus"
    });
    const state = {
      attached,
      decoration,
      persistentTimestamp,
      showAnimation,
      body: slot_exports.always(body, {
        defaultProps: {
          ref,
          ...groupperAttributes,
          ...nativeProps.primary,
          tabIndex: 0
        },
        elementType: "div"
      }),
      root: slot_exports.always(root5, {
        defaultProps: nativeProps.root,
        elementType: "div"
      }),
      author: slot_exports.optional(author, {
        elementType: "div"
      }),
      avatar: attached && attached !== "top" ? void 0 : slot_exports.optional(avatar, {
        elementType: "div"
      }),
      decorationIcon: slot_exports.optional(decorationIcon, {
        elementType: "div",
        defaultProps: {
          children: getDecorationIcon(decoration)
        },
        renderByDefault: !!decoration
      }),
      decorationLabel: slot_exports.optional(decorationLabel, {
        elementType: "div"
      }),
      details: slot_exports.optional(details, {
        elementType: "div"
      }),
      reactions: slot_exports.optional(reactions, {
        elementType: "div"
      }),
      timestamp: slot_exports.optional(timestamp, {
        elementType: "span"
      }),
      components: {
        author: "div",
        avatar: "div",
        body: "div",
        decorationIcon: "div",
        decorationLabel: "div",
        details: "div",
        reactions: "div",
        root: "div",
        timestamp: "span"
      }
    };
    useChatMessagePopoverTrigger(state);
    return state;
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/renderChatMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderChatMessage_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ createElement29(state.root, null, state.avatar && /* @__PURE__ */ createElement29(state.avatar, null), /* @__PURE__ */ createElement29(state.body, null, /* @__PURE__ */ createElement29("div", {
      className: state.nameLineClassName
    }, state.author && /* @__PURE__ */ createElement29(state.author, null), state.timestamp && /* @__PURE__ */ createElement29(state.timestamp, null), state.details && /* @__PURE__ */ createElement29(state.details, null)), state.decorationLabel && /* @__PURE__ */ createElement29(state.decorationLabel, null), state.body.children, state.decorationIcon && /* @__PURE__ */ createElement29(state.decorationIcon, null), state.reactions && /* @__PURE__ */ createElement29(state.reactions, null)));
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/ChatMessage.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/styles/shared.mixins.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var bodyBaseStyles = {
    position: "relative",
    ...createFocusOutlineStyle(),
    fontFamily: tokens.fontFamilyBase,
    fontWeight: tokens.fontWeightRegular,
    fontSize: tokens.fontSizeBase300,
    lineHeight: tokens.lineHeightBase300,
    color: tokens.colorNeutralForeground1,
    wordBreak: "break-word"
  };
  var isOnlyReadableByScreenReaderStyles = {
    clip: "rect(0px, 0px, 0px, 0px)",
    height: "1px",
    ...shorthands2.margin("-1px"),
    ...shorthands2.overflow("hidden"),
    ...shorthands2.padding("0px"),
    width: "1px",
    position: "absolute"
  };
  var statusRedStyles = {
    color: tokens.colorPaletteRedForeground3
  };
  var reactionsBaseStyles = {
    position: "relative",
    height: "0px",
    display: "flex"
  };
  var highlightAnimation = {
    animationIterationCount: "1",
    animationDuration: "4s",
    animationTimingFunction: "ease-out",
    animationName: {
      from: {
        backgroundColor: tokens.colorPaletteMarigoldBackground1,
        boxShadow: `inset 0 0 0 0.1rem ${tokens.colorPaletteDarkOrangeBorderActive}`
      },
      to: {
        boxShadow: `inset 0 0 0 0.1rem transparent`
      }
    }
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/styles/shared.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useDecorationClasses = makeStyles2({
    default: {
      color: tokens.colorPaletteRedForeground3
    },
    mention: {
      color: tokens.colorPaletteDarkOrangeForeground3
    },
    mentionContrast: {
      color: tokens.colorBrandForegroundLink
    }
  });

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/ChatMessage.styles.js
  var chatMessageClassNames = {
    root: "fui-ChatMessage",
    author: "fui-ChatMessage__author",
    avatar: "fui-ChatMessage__avatar",
    body: "fui-ChatMessage__body",
    decorationIcon: "fui-ChatMessage__decorationIcon",
    decorationLabel: "fui-ChatMessage__decorationLabel",
    details: "fui-ChatMessage__details",
    reactions: "fui-ChatMessage__reactions",
    timestamp: "fui-ChatMessage__timestamp"
  };
  var useChatMessageClasses = makeStyles2({
    container: {
      display: "flex",
      columnGap: "8px",
      paddingTop: "16px"
    },
    attachedContainer: {
      paddingTop: "2px"
    },
    avatarLessContainer: {
      marginLeft: "40px"
    },
    avatar: {
      minWidth: "32px"
    }
  });
  var useChatMessageBodyClasses = makeStyles2({
    base: {
      ...bodyBaseStyles,
      ...shorthands2.borderRadius("4px"),
      ...shorthands2.padding("8px", "16px", "16px", "16px"),
      maxWidth: "calc(100% - 100px)",
      backgroundColor: tokens.colorNeutralBackground3
    },
    hasReactions: {
      marginBottom: "12px"
    },
    hasDecorationIcon: {
      ...shorthands2.borderLeft("3px", "solid", tokens.colorPaletteRedForeground3)
    },
    nameLineWrapper: {
      display: "flex",
      columnGap: "12px",
      fontSize: "12px",
      lineHeight: "16px",
      color: tokens.colorNeutralForeground3,
      alignItems: "center"
    },
    details: {
      display: "flex",
      columnGap: "6px",
      alignItems: "center"
    },
    decorationLabel: {
      fontWeight: 700,
      fontSize: "12px",
      lineHeight: "16px",
      textTransform: "uppercase"
    },
    reactions: {
      ...reactionsBaseStyles,
      paddingRight: "20px"
    },
    decorationIcon: {
      color: "white",
      backgroundColor: tokens.colorPaletteRedForeground3,
      height: "24px",
      width: "24px",
      ...shorthands2.borderRadius("50%"),
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "20px",
      transform: "translateX(50%)",
      position: "absolute",
      top: "4px",
      right: "0px"
    },
    screenReaderContainer: isOnlyReadableByScreenReaderStyles,
    animation: highlightAnimation
  });
  var useChatMessageStyles_unstable = (state) => {
    const classes = useChatMessageClasses();
    state.root.className = mergeClasses(chatMessageClassNames.root, classes.container, state.attached && state.attached !== "top" && classes.attachedContainer, !state.avatar && classes.avatarLessContainer, state.root.className);
    if (state.avatar) {
      state.avatar.className = mergeClasses(chatMessageClassNames.avatar, classes.avatar, state.avatar.className);
    }
    const bodyClasses = useChatMessageBodyClasses();
    if (state.body) {
      state.body.className = mergeClasses(chatMessageClassNames.body, bodyClasses.base, state.reactions && bodyClasses.hasReactions, state.decorationIcon && bodyClasses.hasDecorationIcon, state.showAnimation && bodyClasses.animation, state.body.className);
    }
    if (state.author) {
      state.author.className = mergeClasses(chatMessageClassNames.author, state.attached && state.attached !== "top" && bodyClasses.screenReaderContainer, state.author.className);
    }
    if (state.timestamp) {
      state.timestamp.className = mergeClasses(chatMessageClassNames.timestamp, state.attached && state.attached !== "top" && bodyClasses.screenReaderContainer, state.timestamp.className);
    }
    if (state.details) {
      state.details.className = mergeClasses(chatMessageClassNames.details, bodyClasses.details, state.details.className);
    }
    const decorationClasses = useDecorationClasses();
    if (state.decorationLabel) {
      state.decorationLabel.className = mergeClasses(chatMessageClassNames.decorationLabel, bodyClasses.decorationLabel, state.decoration && decorationClasses.default, state.decoration === "mention" && decorationClasses.mention, state.decorationLabel.className);
    }
    if (state.decorationIcon) {
      state.decorationIcon.className = mergeClasses(chatMessageClassNames.decorationIcon, bodyClasses.decorationIcon, state.decorationIcon.className);
    }
    if (state.reactions) {
      state.reactions.className = mergeClasses(chatMessageClassNames.reactions, bodyClasses.reactions, state.reactions.className);
    }
    state.nameLineClassName = bodyClasses.nameLineWrapper;
    return state;
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMessage/ChatMessage.js
  var ChatMessage = /* @__PURE__ */ React185.forwardRef((props, ref) => {
    const state = useChatMessage_unstable(props, ref);
    useChatMessageStyles_unstable(state);
    return renderChatMessage_unstable(state);
  });
  ChatMessage.displayName = "ChatMessage";

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMyMessage/ChatMyMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React187 = __toESM(require_react());

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMyMessage/renderChatMyMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var renderChatMyMessage_unstable = (state) => {
    assertSlots(state);
    return /* @__PURE__ */ createElement29(state.root, null, /* @__PURE__ */ createElement29(state.body, null, /* @__PURE__ */ createElement29("div", {
      className: state.nameLineClassName
    }, state.author && /* @__PURE__ */ createElement29(state.author, null), state.timestamp && /* @__PURE__ */ createElement29(state.timestamp, null), state.details && !state.statusMessage && /* @__PURE__ */ createElement29(state.details, null), state.statusMessage && /* @__PURE__ */ createElement29(state.statusMessage, null)), state.decorationLabel && /* @__PURE__ */ createElement29(state.decorationLabel, null), state.body.children, state.decorationIcon && /* @__PURE__ */ createElement29(state.decorationIcon, null), state.reactions && /* @__PURE__ */ createElement29(state.reactions, null)), state.statusIcon && /* @__PURE__ */ createElement29(state.statusIcon, null), state.actions && /* @__PURE__ */ createElement29(state.actions, null));
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMyMessage/useChatMyMessage.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var React186 = __toESM(require_react());
  var useChatMyMessage_unstable = (props, ref) => {
    const { actions, attached, author, body, decoration, decorationIcon, decorationLabel, details, reactions, root: root5, showAnimation, status, statusIcon, statusMessage, timestamp } = props;
    const nativeProps = getPartitionedNativeProps({
      primarySlotTagName: "div",
      props,
      excludedPropNames: [
        "tabIndex"
      ]
    });
    const groupperAttributes = useFocusableGroup({
      tabBehavior: "limited-trap-focus"
    });
    const state = {
      attached,
      decoration,
      showAnimation,
      status,
      body: slot_exports.always(body, {
        defaultProps: {
          ref,
          ...groupperAttributes,
          ...nativeProps.primary,
          tabIndex: 0
        },
        elementType: "div"
      }),
      root: slot_exports.always(root5, {
        defaultProps: nativeProps.root,
        elementType: "div"
      }),
      actions: slot_exports.optional(actions, {
        elementType: "div"
      }),
      author: slot_exports.optional(author, {
        elementType: "div"
      }),
      decorationIcon: slot_exports.optional(decorationIcon, {
        elementType: "div",
        defaultProps: {
          children: getDecorationIcon(decoration)
        },
        renderByDefault: !!decoration
      }),
      decorationLabel: slot_exports.optional(decorationLabel, {
        elementType: "div"
      }),
      details: slot_exports.optional(details, {
        elementType: "div"
      }),
      reactions: slot_exports.optional(reactions, {
        elementType: "div"
      }),
      statusIcon: slot_exports.optional(statusIcon, {
        elementType: "div",
        defaultProps: {
          children: getStatusIcon(status)
        },
        renderByDefault: !!status
      }),
      statusMessage: slot_exports.optional(statusMessage, {
        elementType: "div"
      }),
      timestamp: slot_exports.optional(timestamp, {
        elementType: "span"
      }),
      components: {
        actions: "div",
        author: "div",
        body: "div",
        decorationIcon: "div",
        decorationLabel: "div",
        details: "div",
        reactions: "div",
        root: "div",
        statusIcon: "div",
        statusMessage: "div",
        timestamp: "span"
      }
    };
    useChatMessagePopoverTrigger(state);
    return state;
  };
  var getStatusIcon = (status) => {
    switch (status) {
      case "sending":
        return /* @__PURE__ */ React186.createElement(Circle16Regular, null);
      case "received":
        return /* @__PURE__ */ React186.createElement(CheckmarkCircle16Regular, null);
      case "read":
        return /* @__PURE__ */ React186.createElement(Eye16Filled, null);
      case "failed":
        return /* @__PURE__ */ React186.createElement(Warning16Filled, null);
      case "blocked":
        return /* @__PURE__ */ React186.createElement(Flag16Filled, null);
      case "scheduled":
        return /* @__PURE__ */ React186.createElement(Clock16Regular, null);
    }
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMyMessage/ChatMyMessage.styles.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var useChatMyMessageClasses = makeStyles2({
    container: {
      alignSelf: "end",
      marginLeft: "50px",
      columnGap: "8px",
      display: "grid",
      gridTemplateAreas: `
      "body    status"
      "actions .     "
    `,
      gridTemplateColumns: "auto 16px",
      paddingTop: "16px"
    },
    attachedContainer: {
      paddingTop: "2px"
    },
    statusIcon: {
      gridColumnStart: "status",
      gridColumnEnd: "status",
      gridRowStart: "status",
      gridRowEnd: "status",
      alignSelf: "end",
      color: tokens.colorBrandForeground1
    },
    statusIconFailed: statusRedStyles,
    actions: {
      gridColumnStart: "actions",
      gridColumnEnd: "actions",
      gridRowStart: "actions",
      gridRowEnd: "actions",
      justifySelf: "end"
    }
  });
  var useChatMyMessageBodyClasses = makeStyles2({
    base: {
      ...bodyBaseStyles,
      gridColumnStart: "body",
      gridColumnEnd: "body",
      gridRowStart: "body",
      gridRowEnd: "body",
      flexShrink: 0,
      ...shorthands2.borderRadius("4px"),
      ...shorthands2.padding("8px", "16px", "16px", "16px"),
      backgroundColor: tokens.colorBrandBackground2,
      justifySelf: "end"
    },
    hasReactions: {
      marginBottom: "12px"
    },
    hasDecorationIcon: {
      ...shorthands2.borderLeft("3px", "solid", tokens.colorPaletteRedForeground3)
    },
    details: {
      display: "flex",
      columnGap: "6px",
      alignItems: "center"
    },
    statusMessage: {
      color: tokens.colorPaletteRedForeground3
    },
    decorationLabel: {
      fontWeight: 700,
      fontSize: "12px",
      lineHeight: "16px",
      textTransform: "uppercase"
    },
    reactions: {
      ...reactionsBaseStyles,
      paddingLeft: "20px",
      right: "0px",
      justifyContent: "end"
    },
    decorationIcon: {
      color: "white",
      backgroundColor: tokens.colorPaletteRedForeground3,
      height: "24px",
      width: "24px",
      ...shorthands2.borderRadius("50%"),
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: "20px",
      transform: "translateX(50%)",
      position: "absolute",
      top: "4px",
      right: "0px"
    },
    nameLineWrapper: {
      display: "flex",
      columnGap: "12px",
      fontSize: "12px",
      lineHeight: "16px",
      color: tokens.colorNeutralForeground3,
      alignItems: "center"
    },
    screenReaderContainer: isOnlyReadableByScreenReaderStyles,
    animation: highlightAnimation
  });
  var chatMyMessageClassNames = {
    root: "fui-ChatMyMessage",
    actions: "fui-ChatMyMessage__actions",
    author: "fui-ChatMyMessage__author",
    body: "fui-ChatMyMessage__body",
    decorationIcon: "fui-ChatMyMessage__decorationIcon",
    decorationLabel: "fui-ChatMyMessage__decorationLabel",
    details: "fui-ChatMyMessage__details",
    reactions: "fui-ChatMyMessage__reactions",
    statusIcon: "fui-ChatMyMessage__statusIcon",
    statusMessage: "fui-ChatMyMessage__statusMessage",
    timestamp: "fui-ChatMyMessage__timestamp"
  };
  var useChatMyMessageStyles_unstable = (state) => {
    const classes = useChatMyMessageClasses();
    state.root.className = mergeClasses(chatMyMessageClassNames.root, classes.container, state.attached && state.attached !== "top" && classes.attachedContainer, state.root.className);
    const bodyClasses = useChatMyMessageBodyClasses();
    if (state.body) {
      state.body.className = mergeClasses(chatMyMessageClassNames.body, bodyClasses.base, state.reactions && bodyClasses.hasReactions, state.decorationIcon && bodyClasses.hasDecorationIcon, state.showAnimation && bodyClasses.animation, state.body.className);
    }
    if (state.timestamp) {
      state.timestamp.className = mergeClasses(chatMyMessageClassNames.timestamp, state.attached && state.attached !== "top" && bodyClasses.screenReaderContainer, state.timestamp.className);
    }
    if (state.details) {
      state.details.className = mergeClasses(chatMyMessageClassNames.details, bodyClasses.details, state.details.className);
    }
    if (state.statusMessage) {
      state.statusMessage.className = mergeClasses(chatMyMessageClassNames.statusMessage, bodyClasses.statusMessage, state.statusMessage.className);
    }
    const decorationClasses = useDecorationClasses();
    if (state.decorationLabel) {
      state.decorationLabel.className = mergeClasses(chatMyMessageClassNames.decorationLabel, bodyClasses.decorationLabel, state.decoration && decorationClasses.default, state.decorationLabel.className);
    }
    if (state.decorationIcon) {
      state.decorationIcon.className = mergeClasses(chatMyMessageClassNames.decorationIcon, bodyClasses.decorationIcon, state.decorationIcon.className);
    }
    if (state.reactions) {
      state.reactions.className = mergeClasses(chatMyMessageClassNames.reactions, bodyClasses.reactions, state.reactions.className);
    }
    if (state.author) {
      state.author.className = mergeClasses(chatMyMessageClassNames.author, bodyClasses.screenReaderContainer, state.author.className);
    }
    if (state.statusIcon) {
      state.statusIcon.className = mergeClasses(chatMyMessageClassNames.statusIcon, classes.statusIcon, (state.status === "failed" || state.status === "blocked") && classes.statusIconFailed, state.statusIcon.className);
    }
    if (state.actions) {
      state.actions.className = mergeClasses(chatMyMessageClassNames.actions, classes.actions, state.actions.className);
    }
    state.nameLineClassName = bodyClasses.nameLineWrapper;
    return state;
  };

  // ../../node_modules/@fluentui-contrib/react-chat/lib/components/ChatMyMessage/ChatMyMessage.js
  var ChatMyMessage = /* @__PURE__ */ React187.forwardRef((props, ref) => {
    const state = useChatMyMessage_unstable(props, ref);
    useChatMyMessageStyles_unstable(state);
    return renderChatMyMessage_unstable(state);
  });
  ChatMyMessage.displayName = "ChatMyMessage";

  // ../../packages/aihappey-theme-fluent/dist/primitives/Chat.js
  var Chat2 = ({ messages }) => (0, import_jsx_runtime71.jsx)(Chat, { children: messages?.map((a) => a.role == "user" ? (0, import_jsx_runtime71.jsx)(ChatMyMessage, { children: (0, import_jsx_runtime71.jsx)(Markdown2, { text: a.content }) }) : (0, import_jsx_runtime71.jsx)(ChatMessage, { children: (0, import_jsx_runtime71.jsx)(Markdown2, { text: a.content }) })) });

  // ../../packages/aihappey-theme-fluent/dist/primitives/CloseButton.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var CloseButton = ({ onClick, className, style, "aria-label": ariaLabel }) => (0, import_jsx_runtime72.jsx)(Button, { appearance: "subtle", shape: "circular", icon: (0, import_jsx_runtime72.jsx)(Dismiss24Regular, {}), "aria-label": ariaLabel || "Close", onClick, className, style });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Switch.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime73 = __toESM(require_jsx_runtime());
  var Switch2 = ({ id, label, checked, onChange, className }) => (0, import_jsx_runtime73.jsx)(Switch, { id, checked, onChange: (_, data2) => onChange(data2.checked), className, label });

  // ../../packages/aihappey-theme-fluent/dist/primitives/TextArea.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var TextArea = ({ rows, value, onChange, style, readOnly, className }) => (0, import_jsx_runtime74.jsx)(Textarea, { rows, value, disabled: readOnly, onChange: onChange ? (_, data2) => onChange(data2.value) : void 0, style, className });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Select.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var React188 = __toESM(require_react());
  var Select2 = ({ value, onChange, disabled, children: children2, style, "aria-label": ariaLabel, ...rest }) => {
    const options = React188.Children.toArray(children2).filter(React188.isValidElement).map((child) => ({
      value: child.props.value,
      label: child.props.children
    }));
    return (0, import_jsx_runtime75.jsx)(Dropdown, { value: options.find((o) => o.value === value)?.label ?? "", selectedOptions: [value], onOptionSelect: (_, data2) => {
      if (data2.optionValue)
        onChange(data2.optionValue);
    }, disabled, style, "aria-label": ariaLabel, ...rest, children: options.map((opt) => (0, import_jsx_runtime75.jsx)(Option, { value: opt.value, children: opt.label }, opt.value)) });
  };

  // ../../packages/aihappey-theme-fluent/dist/primitives/Drawer.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  var sizeMap = {
    small: "small",
    medium: "medium",
    large: "large",
    full: "full"
  };
  var Drawer2 = ({
    open,
    onClose,
    position: position4 = "end",
    size: size3 = "small",
    title,
    backdrop = true,
    // OverlayDrawer always has backdrop, ignore param
    children: children2
  }) => (0, import_jsx_runtime76.jsxs)(InlineDrawer, {
    open,
    // onOpenChange={(_, data) => !data.open && onClose()}
    position: position4 === "top" ? "end" : position4,
    size: sizeMap[size3],
    children: [title && (0, import_jsx_runtime76.jsx)(DrawerHeader, { children: (0, import_jsx_runtime76.jsx)(DrawerHeaderTitle, { children: title }) }), (0, import_jsx_runtime76.jsx)(DrawerBody, { children: children2 })]
  });

  // ../../packages/aihappey-theme-fluent/dist/primitives/Image.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  var Image2 = ({ src, ...rest }) => (0, import_jsx_runtime77.jsx)(Image, { src, ...rest });

  // ../../packages/aihappey-theme-fluent/dist/fluentTheme.js
  var fluentTheme = {
    Button: Button2,
    Input: Input2,
    Card: Card2,
    Select: Select2,
    Alert: Alert2,
    Spinner: Spinner2,
    Image: Image2,
    Chat: Chat2,
    Modal,
    Tabs,
    Tab: Tab3,
    Badge: Badge2,
    Table: Table2,
    CloseButton,
    Switch: Switch2,
    TextArea,
    Drawer: Drawer2
  };

  // ../../node_modules/usehooks-ts/dist/index.js
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var import_react78 = __toESM(require_react(), 1);
  var import_lodash = __toESM(require_lodash(), 1);
  var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? import_react78.useLayoutEffect : import_react78.useEffect;
  function useEventListener(eventName, handler, element4, options) {
    const savedHandler = (0, import_react78.useRef)(handler);
    useIsomorphicLayoutEffect3(() => {
      savedHandler.current = handler;
    }, [handler]);
    (0, import_react78.useEffect)(() => {
      const targetElement = (element4 == null ? void 0 : element4.current) ?? window;
      if (!(targetElement && targetElement.addEventListener))
        return;
      const listener = (event) => {
        savedHandler.current(event);
      };
      targetElement.addEventListener(eventName, listener, options);
      return () => {
        targetElement.removeEventListener(eventName, listener, options);
      };
    }, [eventName, element4, options]);
  }
  function useEventCallback3(fn) {
    const ref = (0, import_react78.useRef)(() => {
      throw new Error("Cannot call an event handler while rendering.");
    });
    useIsomorphicLayoutEffect3(() => {
      ref.current = fn;
    }, [fn]);
    return (0, import_react78.useCallback)((...args) => {
      var _a17;
      return (_a17 = ref.current) == null ? void 0 : _a17.call(ref, ...args);
    }, [ref]);
  }
  var IS_SERVER = typeof window === "undefined";
  function useLocalStorage(key, initialValue, options = {}) {
    const { initializeWithValue = true } = options;
    const serializer2 = (0, import_react78.useCallback)(
      (value) => {
        if (options.serializer) {
          return options.serializer(value);
        }
        return JSON.stringify(value);
      },
      [options]
    );
    const deserializer2 = (0, import_react78.useCallback)(
      (value) => {
        if (options.deserializer) {
          return options.deserializer(value);
        }
        if (value === "undefined") {
          return void 0;
        }
        const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;
        let parsed;
        try {
          parsed = JSON.parse(value);
        } catch (error) {
          console.error("Error parsing JSON:", error);
          return defaultValue;
        }
        return parsed;
      },
      [options, initialValue]
    );
    const readValue = (0, import_react78.useCallback)(() => {
      const initialValueToUse = initialValue instanceof Function ? initialValue() : initialValue;
      if (IS_SERVER) {
        return initialValueToUse;
      }
      try {
        const raw = window.localStorage.getItem(key);
        return raw ? deserializer2(raw) : initialValueToUse;
      } catch (error) {
        console.warn(`Error reading localStorage key \u201C${key}\u201D:`, error);
        return initialValueToUse;
      }
    }, [initialValue, key, deserializer2]);
    const [storedValue, setStoredValue] = (0, import_react78.useState)(() => {
      if (initializeWithValue) {
        return readValue();
      }
      return initialValue instanceof Function ? initialValue() : initialValue;
    });
    const setValue = useEventCallback3((value) => {
      if (IS_SERVER) {
        console.warn(
          `Tried setting localStorage key \u201C${key}\u201D even though environment is not a client`
        );
      }
      try {
        const newValue = value instanceof Function ? value(readValue()) : value;
        window.localStorage.setItem(key, serializer2(newValue));
        setStoredValue(newValue);
        window.dispatchEvent(new StorageEvent("local-storage", { key }));
      } catch (error) {
        console.warn(`Error setting localStorage key \u201C${key}\u201D:`, error);
      }
    });
    const removeValue = useEventCallback3(() => {
      if (IS_SERVER) {
        console.warn(
          `Tried removing localStorage key \u201C${key}\u201D even though environment is not a client`
        );
      }
      const defaultValue = initialValue instanceof Function ? initialValue() : initialValue;
      window.localStorage.removeItem(key);
      setStoredValue(defaultValue);
      window.dispatchEvent(new StorageEvent("local-storage", { key }));
    });
    (0, import_react78.useEffect)(() => {
      setStoredValue(readValue());
    }, [key]);
    const handleStorageChange = (0, import_react78.useCallback)(
      (event) => {
        if (event.key && event.key !== key) {
          return;
        }
        setStoredValue(readValue());
      },
      [key, readValue]
    );
    useEventListener("storage", handleStorageChange);
    useEventListener("local-storage", handleStorageChange);
    return [storedValue, setValue, removeValue];
  }
  var IS_SERVER2 = typeof window === "undefined";
  function useMediaQuery(query, {
    defaultValue = false,
    initializeWithValue = true
  } = {}) {
    const getMatches = (query2) => {
      if (IS_SERVER2) {
        return defaultValue;
      }
      return window.matchMedia(query2).matches;
    };
    const [matches, setMatches] = (0, import_react78.useState)(() => {
      if (initializeWithValue) {
        return getMatches(query);
      }
      return defaultValue;
    });
    function handleChange() {
      setMatches(getMatches(query));
    }
    useIsomorphicLayoutEffect3(() => {
      const matchMedia = window.matchMedia(query);
      handleChange();
      if (matchMedia.addListener) {
        matchMedia.addListener(handleChange);
      } else {
        matchMedia.addEventListener("change", handleChange);
      }
      return () => {
        if (matchMedia.removeListener) {
          matchMedia.removeListener(handleChange);
        } else {
          matchMedia.removeEventListener("change", handleChange);
        }
      };
    }, [query]);
    return matches;
  }
  var COLOR_SCHEME_QUERY = "(prefers-color-scheme: dark)";
  var LOCAL_STORAGE_KEY = "usehooks-ts-dark-mode";
  function useDarkMode(options = {}) {
    const {
      defaultValue,
      localStorageKey = LOCAL_STORAGE_KEY,
      initializeWithValue = true
    } = options;
    const isDarkOS = useMediaQuery(COLOR_SCHEME_QUERY, {
      initializeWithValue,
      defaultValue
    });
    const [isDarkMode, setDarkMode] = useLocalStorage(
      localStorageKey,
      defaultValue ?? isDarkOS ?? false,
      { initializeWithValue }
    );
    useIsomorphicLayoutEffect3(() => {
      if (isDarkOS !== isDarkMode) {
        setDarkMode(isDarkOS);
      }
    }, [isDarkOS]);
    return {
      isDarkMode,
      toggle: () => {
        setDarkMode((prev2) => !prev2);
      },
      enable: () => {
        setDarkMode(true);
      },
      disable: () => {
        setDarkMode(false);
      },
      set: (value) => {
        setDarkMode(value);
      }
    };
  }

  // ../../packages/aihappey-theme-fluent/dist/ThemeProvider.js
  var ThemeProvider2 = ({ children: children2 }) => {
    const { isDarkMode } = useDarkMode();
    return (0, import_jsx_runtime78.jsx)(ThemeContext.Provider, { value: fluentTheme, children: (0, import_jsx_runtime78.jsx)(FluentProvider, { theme: isDarkMode ? webDarkTheme : webLightTheme, children: children2 }) });
  };

  // src/msalConfig.ts
  init_define_DEFAULT_MCP_SERVER_LIST_URLS();
  init_define_MSAL_SCOPES();
  var msalConfig = {
    auth: {
      clientId: "3103139a-fc1c-483c-b66d-e2b177ca1fa3",
      authority: "https://login.microsoftonline.com/653b45ef-ba50-42b5-8576-1be3b5f03b6a",
      redirectUri: "/"
    },
    cache: {
      cacheLocation: "localStorage"
    }
  };
  var loginRequest = {
    scopes: define_MSAL_SCOPES_default
  };

  // src/App.tsx
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  var App = () => /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ThemeProvider2, { children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
    CoreRoot,
    {
      initialLists: define_DEFAULT_MCP_SERVER_LIST_URLS_default,
      chatConfig: {
        api: "http://localhost:3010/api/chat",
        modelsApi: "http://localhost:3010/models",
        samplingApi: "http://localhost:3010/sampling"
      },
      authConfig: {
        msal: {
          clientId: msalConfig.auth.clientId,
          authority: msalConfig.auth.authority,
          redirectUri: msalConfig.auth.redirectUri,
          scopes: loginRequest.scopes
        }
      }
    }
  ) });
  var App_default = App;

  // src/main.tsx
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  var router = createBrowserRouter([
    {
      path: "/oauth-callback",
      element: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(OAuthCallbackPage_default, {})
    },
    {
      path: "/*",
      element: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(App_default, {})
    }
  ]);
  var container = document.getElementById("root");
  if (container) {
    const root5 = (0, import_client2.createRoot)(container);
    root5.render(/* @__PURE__ */ (0, import_jsx_runtime80.jsx)(RouterProvider, { router }));
  }
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

react-is/cjs/react-is.production.min.js:
  (** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/development/chunk-DQRVZFIR.mjs:
react-router/dist/development/index.mjs:
  (**
   * react-router v7.6.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@azure/msal-common/dist/utils/Constants.mjs:
@azure/msal-common/dist/error/AuthErrorCodes.mjs:
@azure/msal-common/dist/error/AuthError.mjs:
@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs:
@azure/msal-common/dist/error/ClientAuthError.mjs:
@azure/msal-common/dist/crypto/ICrypto.mjs:
@azure/msal-common/dist/logger/Logger.mjs:
@azure/msal-common/dist/packageMetadata.mjs:
@azure/msal-common/dist/authority/AuthorityOptions.mjs:
@azure/msal-common/dist/account/AuthToken.mjs:
@azure/msal-common/dist/utils/TimeUtils.mjs:
@azure/msal-common/dist/cache/utils/CacheHelpers.mjs:
@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs:
@azure/msal-common/dist/error/ClientConfigurationError.mjs:
@azure/msal-common/dist/utils/StringUtils.mjs:
@azure/msal-common/dist/request/ScopeSet.mjs:
@azure/msal-common/dist/account/ClientInfo.mjs:
@azure/msal-common/dist/account/AccountInfo.mjs:
@azure/msal-common/dist/authority/AuthorityType.mjs:
@azure/msal-common/dist/account/TokenClaims.mjs:
@azure/msal-common/dist/authority/ProtocolMode.mjs:
@azure/msal-common/dist/cache/entities/AccountEntity.mjs:
@azure/msal-common/dist/utils/UrlUtils.mjs:
@azure/msal-common/dist/url/UrlString.mjs:
@azure/msal-common/dist/authority/AuthorityMetadata.mjs:
@azure/msal-common/dist/error/CacheErrorCodes.mjs:
@azure/msal-common/dist/error/CacheError.mjs:
@azure/msal-common/dist/cache/CacheManager.mjs:
@azure/msal-common/dist/config/ClientConfiguration.mjs:
@azure/msal-common/dist/account/CcsCredential.mjs:
@azure/msal-common/dist/constants/AADServerParamKeys.mjs:
@azure/msal-common/dist/request/RequestParameterBuilder.mjs:
@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs:
@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs:
@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs:
@azure/msal-common/dist/utils/FunctionWrappers.mjs:
@azure/msal-common/dist/authority/RegionDiscovery.mjs:
@azure/msal-common/dist/authority/Authority.mjs:
@azure/msal-common/dist/authority/AuthorityFactory.mjs:
@azure/msal-common/dist/error/ServerError.mjs:
@azure/msal-common/dist/network/RequestThumbprint.mjs:
@azure/msal-common/dist/network/ThrottlingUtils.mjs:
@azure/msal-common/dist/error/NetworkError.mjs:
@azure/msal-common/dist/client/BaseClient.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs:
@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs:
@azure/msal-common/dist/utils/ProtocolUtils.mjs:
@azure/msal-common/dist/crypto/PopTokenGenerator.mjs:
@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs:
@azure/msal-common/dist/response/ResponseHandler.mjs:
@azure/msal-common/dist/request/RequestValidator.mjs:
@azure/msal-common/dist/utils/ClientAssertionUtils.mjs:
@azure/msal-common/dist/client/AuthorizationCodeClient.mjs:
@azure/msal-common/dist/client/RefreshTokenClient.mjs:
@azure/msal-common/dist/client/SilentFlowClient.mjs:
@azure/msal-common/dist/network/INetworkModule.mjs:
@azure/msal-common/dist/protocol/Authorize.mjs:
@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs:
@azure/msal-common/dist/error/JoseHeaderErrorCodes.mjs:
@azure/msal-common/dist/error/JoseHeaderError.mjs:
@azure/msal-common/dist/crypto/JoseHeader.mjs:
@azure/msal-common/dist/telemetry/performance/StubPerformanceClient.mjs:
@azure/msal-common/dist/index-browser.mjs:
  (*! @azure/msal-common v15.6.0 2025-05-06 *)

@azure/msal-browser/dist/error/BrowserAuthErrorCodes.mjs:
@azure/msal-browser/dist/error/BrowserAuthError.mjs:
@azure/msal-browser/dist/utils/BrowserConstants.mjs:
@azure/msal-browser/dist/encode/Base64Encode.mjs:
@azure/msal-browser/dist/encode/Base64Decode.mjs:
@azure/msal-browser/dist/crypto/BrowserCrypto.mjs:
@azure/msal-browser/dist/error/BrowserConfigurationAuthErrorCodes.mjs:
@azure/msal-browser/dist/error/BrowserConfigurationAuthError.mjs:
@azure/msal-browser/dist/utils/BrowserUtils.mjs:
@azure/msal-browser/dist/navigation/NavigationClient.mjs:
@azure/msal-browser/dist/network/FetchClient.mjs:
@azure/msal-browser/dist/config/Configuration.mjs:
@azure/msal-browser/dist/packageMetadata.mjs:
@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs:
@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs:
@azure/msal-browser/dist/cache/DatabaseStorage.mjs:
@azure/msal-browser/dist/cache/MemoryStorage.mjs:
@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs:
@azure/msal-browser/dist/crypto/CryptoOps.mjs:
@azure/msal-browser/dist/cache/CookieStorage.mjs:
@azure/msal-browser/dist/cache/CacheHelpers.mjs:
@azure/msal-browser/dist/cache/LocalStorage.mjs:
@azure/msal-browser/dist/cache/SessionStorage.mjs:
@azure/msal-browser/dist/event/EventType.mjs:
@azure/msal-browser/dist/cache/BrowserCacheManager.mjs:
@azure/msal-browser/dist/cache/AccountManager.mjs:
@azure/msal-browser/dist/event/EventHandler.mjs:
@azure/msal-browser/dist/interaction_client/BaseInteractionClient.mjs:
@azure/msal-browser/dist/request/RequestHelpers.mjs:
@azure/msal-browser/dist/interaction_client/StandardInteractionClient.mjs:
@azure/msal-browser/dist/error/NativeAuthErrorCodes.mjs:
@azure/msal-browser/dist/broker/nativeBroker/NativeStatusCodes.mjs:
@azure/msal-browser/dist/error/NativeAuthError.mjs:
@azure/msal-browser/dist/broker/nativeBroker/NativeMessageHandler.mjs:
@azure/msal-browser/dist/utils/BrowserProtocolUtils.mjs:
@azure/msal-browser/dist/response/ResponseHandler.mjs:
@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs:
@azure/msal-browser/dist/interaction_client/SilentCacheClient.mjs:
@azure/msal-browser/dist/interaction_client/NativeInteractionClient.mjs:
@azure/msal-browser/dist/protocol/Authorize.mjs:
@azure/msal-browser/dist/crypto/PkceGenerator.mjs:
@azure/msal-browser/dist/interaction_client/PopupClient.mjs:
@azure/msal-browser/dist/interaction_client/RedirectClient.mjs:
@azure/msal-browser/dist/interaction_handler/SilentHandler.mjs:
@azure/msal-browser/dist/interaction_client/SilentIframeClient.mjs:
@azure/msal-browser/dist/interaction_client/SilentRefreshClient.mjs:
@azure/msal-browser/dist/cache/TokenCache.mjs:
@azure/msal-browser/dist/interaction_client/HybridSpaAuthorizationCodeClient.mjs:
@azure/msal-browser/dist/interaction_client/SilentAuthCodeClient.mjs:
@azure/msal-browser/dist/utils/MsalFrameStatsUtils.mjs:
@azure/msal-browser/dist/controllers/StandardController.mjs:
@azure/msal-browser/dist/controllers/ControllerFactory.mjs:
@azure/msal-browser/dist/app/PublicClientApplication.mjs:
@azure/msal-browser/dist/app/IPublicClientApplication.mjs:
@azure/msal-browser/dist/event/EventMessage.mjs:
@azure/msal-browser/dist/index.mjs:
  (*! @azure/msal-browser v4.12.0 2025-05-06 *)

@azure/msal-react/dist/MsalContext.js:
@azure/msal-react/dist/utils/utilities.js:
@azure/msal-react/dist/packageMetadata.js:
@azure/msal-react/dist/MsalProvider.js:
@azure/msal-react/dist/hooks/useMsal.js:
@azure/msal-react/dist/hooks/useIsAuthenticated.js:
@azure/msal-react/dist/components/AuthenticatedTemplate.js:
@azure/msal-react/dist/components/UnauthenticatedTemplate.js:
@azure/msal-react/dist/hooks/useAccount.js:
@azure/msal-react/dist/error/ReactAuthError.js:
@azure/msal-react/dist/hooks/useMsalAuthentication.js:
@azure/msal-react/dist/components/MsalAuthenticationTemplate.js:
@azure/msal-react/dist/components/withMsal.js:
@azure/msal-react/dist/index.js:
  (*! @azure/msal-react v3.0.12 2025-05-06 *)

keyborg/dist/esm/index.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=bundle.js.map
